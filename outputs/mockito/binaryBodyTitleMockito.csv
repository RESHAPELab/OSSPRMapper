pr;DB;Interpreter;Logging;Thread;Data Structure;DevOps;i18n;Logic;Microservices;ML;Test;Search;IO;UI;Parser;Security;Cloud;Big Data;App;GIS;Util;NLP;APM;Network;Title;Body;prIssue;issue;issueTitle;issueBody;issueComments;issueTitleLink;issueBodyLink;issueCommentsLink;isPR;isTrain;commitMessage;Comments
2;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;pull request: load default plugins dynamically;to be able to include mockito source in the android open source project  i d like to be able to build a subset of mockito which doesn t rely on cglib. this removes the compile-time dependency on the default mockmaker implementation  which naturally includes references to cglib.;;0;`predicate` missing;j@ in `comgooglecombase`: the interface `predicate`&nbspexists in googlecollections but is missing in guava however it is at least used in guava charmatcher`is the idea to keep the interface in collections for further developmentand have guava in a somewhat incomplete state until integration of theformer or was it just forgotten to copy it?regardsjochen kupperschmidt; as soon as we can finish the long-promised release 10 of the google collections library which i desperately hope will happen next month then the entire contents of that project will be moved into this project so that the arbitrary dividing lines will be erased--- ;;;;0;1;;
2;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;pull request: load default plugins dynamically;to be able to include mockito source in the android open source project  i d like to be able to build a subset of mockito which doesn t rely on cglib. this removes the compile-time dependency on the default mockmaker implementation  which naturally includes references to cglib.;;0;pull request: load default plugins dynamically;to be able to include mockito source in the android open source project id like to be able to build a subset of mockito which doesnt rely on cglib this removes the compile-time dependency on the default mockmaker implementation which naturally includes references to cglib;hey ianthe pull request makes sense for me - i will merge itcan you tell me a little bit what does it mean when mockito is included in the android open source project? is it a classic fork of the sources and afterwards android guys would maintain the sources in android osp whereas our team would keep maintaining sources at github?cheers and thanks a lot for the pull request! ||;;;;1;1;load default plugins dynamically;
2;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;pull request: load default plugins dynamically;to be able to include mockito source in the android open source project  i d like to be able to build a subset of mockito which doesn t rely on cglib. this removes the compile-time dependency on the default mockmaker implementation  which naturally includes references to cglib.;;0;add byte backed tuple and block implementations;the code only supportes  with columns  and has some hacks to get width information into the operators but it does generally show the direction;looks good enough ||;;;;1;1;add byte backed blocks and tuplesadd slice code from level dbtuples and blocks only support  with data;
2;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;pull request: load default plugins dynamically;to be able to include mockito source in the android open source project  i d like to be able to build a subset of mockito which doesn t rely on cglib. this removes the compile-time dependency on the default mockmaker implementation  which naturally includes references to cglib.;;0;language adaptors;includes groovy and jruby;;;;;1;1;javadoc generation;
3;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;pull request: remove class mockable test from classimposterizer;to be able to include mockito source in the android open source project  we need to be able to build a subset of mockito which doesn t rely on cglib. this second part rearranges the code related to checking whether a class can be mocked. i ve moved the logic to mockutil  where it could later be moved to the mockmaker where it really belongs.  my apologies - i can t see how to get github to make a pull request just with my second change  so this seems to include both of my changes.;;0;javadoc bug (typo) in comgooglecommonioresources; <b>what steps will reproduce the problem?</b>1 open  read the class documentation3 note that ""note that even those these methods use url parameters"" does not make any sense because those should be though<b>what version of the product are you using? on what operating system?</b>svn trunk as of 2009-09-17"; ;;;;0;1;;
3;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;pull request: remove class mockable test from classimposterizer;to be able to include mockito source in the android open source project  we need to be able to build a subset of mockito which doesn t rely on cglib. this second part rearranges the code related to checking whether a class can be mocked. i ve moved the logic to mockutil  where it could later be moved to the mockmaker where it really belongs.  my apologies - i can t see how to get github to make a pull request just with my second change  so this seems to include both of my changes.;;0;pull request: remove class mockable test from classimposterizer;to be able to include mockito source in the android open source project we need to be able to build a subset of mockito which doesnt rely on cglib this second part rearranges the code related to checking whether a class can be mocked ive moved the logic to mockutil where it could later be moved to the mockmaker where it really belongsmy apologies - i cant see how to get github to make a pull request just with my second change so this seems to include both of my changes;this change is fine too it only applies to the internal design may i know whats the motivation? is it because you want to easily exclude the classimposterizer when forking sources to aop?cheers & thanks again for the pull request! ||;;;;1;1;remove class mockable test from classimposterizerclassimposterizer is not otherwise used when a custom mockmaker is used thischange avoids calling to classimposterizer from the api portions of mockitowhich are used with any mockmaker;
3;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;pull request: remove class mockable test from classimposterizer;to be able to include mockito source in the android open source project  we need to be able to build a subset of mockito which doesn t rely on cglib. this second part rearranges the code related to checking whether a class can be mocked. i ve moved the logic to mockutil  where it could later be moved to the mockmaker where it really belongs.  my apologies - i can t see how to get github to make a pull request just with my second change  so this seems to include both of my changes.;;0;add basic uncompressedcolumninput;;im not sure why this is needed at all given you can create an uncompressedvalueblock if you have a slice ||;;;;0;1;;
3;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;pull request: remove class mockable test from classimposterizer;to be able to include mockito source in the android open source project  we need to be able to build a subset of mockito which doesn t rely on cglib. this second part rearranges the code related to checking whether a class can be mocked. i ve moved the logic to mockutil  where it could later be moved to the mockmaker where it really belongs.  my apologies - i can t see how to get github to make a pull request just with my second change  so this seems to include both of my changes.;;0;clojure adaptor;;;;;;1;1;clojureadaptorvery basic support that allows clojure/java interop using the fn function rather than clojure code needing to use proxy/reify and implement full java interfaces;
5;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;mock serialization/deserialization across classloader/jvm;this pull request will enable mocks to be serialized in a certain way  that will allow them to be serialized and especially deserialized outside the classloader the mock was created.  at the moment it s enabled automatically when using  withsettings().serializable() .  it still require to have mockito on the classpath of the jvm classloader where it is deserialized.;;0;merge google collections into this project; merge google collections into here after it goes 10; ;;;;0;1;;
5;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;mock serialization/deserialization across classloader/jvm;this pull request will enable mocks to be serialized in a certain way  that will allow them to be serialized and especially deserialized outside the classloader the mock was created.  at the moment it s enabled automatically when using  withsettings().serializable() .  it still require to have mockito on the classpath of the jvm classloader where it is deserialized.;;0;mock serialization/deserialization across classloader/jvm;this pull request will enable mocks to be serialized in a certain way that will allow them to be serialized and especially deserialized outside the classloader the mock was createdat the moment its enabled automatically when using `withsettings()serializable()`it still require to have mockito on the classpath of the jvm classloader where it is deserialized;;;;;1;1;fixing the message of the exceptions;
5;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;mock serialization/deserialization across classloader/jvm;this pull request will enable mocks to be serialized in a certain way  that will allow them to be serialized and especially deserialized outside the classloader the mock was created.  at the moment it s enabled automatically when using  withsettings().serializable() .  it still require to have mockito on the classpath of the jvm classloader where it is deserialized.;;0;add tuple builder;;;;;;1;1;introduce tuple builder;
5;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;mock serialization/deserialization across classloader/jvm;this pull request will enable mocks to be serialized in a certain way  that will allow them to be serialized and especially deserialized outside the classloader the mock was created.  at the moment it s enabled automatically when using  withsettings().serializable() .  it still require to have mockito on the classpath of the jvm classloader where it is deserialized.;;0;support multiple class types for language adaptors;;;;;;1;1;support multiple class types for language adaptors;
7;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;i have implemented 2 features requested in ticket #841.;the user can now specify an arbitrary number of file-link columns in te  entry table columns  preferences tab  to be added to the main table. the user can any file types specified in the list of external file types. the extra columns work exactly like the original file-link column.  for each file-link column whenever there are multiple files  the letter  m  is displayed at the bottom right corner of the icon.       committer: noravanq   on branch master  changes to be committed:    (use  git reset head <file>  to unstage)      modified:   src/main/java/net/sf/jabref/guiglobals.java modified:   src/main/java/net/sf/jabref/jabrefpreferences.java modified:   src/main/java/net/sf/jabref/tablecolumnstab.java modified:   src/main/java/net/sf/jabref/gui/maintableformat.java modified:   src/main/java/net/sf/jabref/gui/maintableselectionlistener.java modified:   src/main/java/net/sf/jabref/gui/preventdraggingjtableheader.java;;0;provide abilty to put null into immutable map; why immutablemap check value for null?what should i do if i want to put null value?may by it would be reasonable to introduce:immutablemapallownullvalues()&ltall nice methods of immutablemap>or do not check value for null; ;;;;0;1;;
7;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;i have implemented 2 features requested in ticket #841.;the user can now specify an arbitrary number of file-link columns in te  entry table columns  preferences tab  to be added to the main table. the user can any file types specified in the list of external file types. the extra columns work exactly like the original file-link column.  for each file-link column whenever there are multiple files  the letter  m  is displayed at the bottom right corner of the icon.       committer: noravanq   on branch master  changes to be committed:    (use  git reset head <file>  to unstage)      modified:   src/main/java/net/sf/jabref/guiglobals.java modified:   src/main/java/net/sf/jabref/jabrefpreferences.java modified:   src/main/java/net/sf/jabref/tablecolumnstab.java modified:   src/main/java/net/sf/jabref/gui/maintableformat.java modified:   src/main/java/net/sf/jabref/gui/maintableselectionlistener.java modified:   src/main/java/net/sf/jabref/gui/preventdraggingjtableheader.java;;0;refactoring: remove unused import;hiclassimposterizer is no longer used in returnsmocks this patch allows us in the android open source project to build returnsmocks without building classimposterizer (which ultimately depends on cglib-and-asm which we cant use)thanksian;;;;;1;1;remove unused import;
7;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;i have implemented 2 features requested in ticket #841.;the user can now specify an arbitrary number of file-link columns in te  entry table columns  preferences tab  to be added to the main table. the user can any file types specified in the list of external file types. the extra columns work exactly like the original file-link column.  for each file-link column whenever there are multiple files  the letter  m  is displayed at the bottom right corner of the icon.       committer: noravanq   on branch master  changes to be committed:    (use  git reset head <file>  to unstage)      modified:   src/main/java/net/sf/jabref/guiglobals.java modified:   src/main/java/net/sf/jabref/jabrefpreferences.java modified:   src/main/java/net/sf/jabref/tablecolumnstab.java modified:   src/main/java/net/sf/jabref/gui/maintableformat.java modified:   src/main/java/net/sf/jabref/gui/maintableselectionlistener.java modified:   src/main/java/net/sf/jabref/gui/preventdraggingjtableheader.java;;0;remove redundant field;;;;;;1;1;remove redundant field;
7;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;i have implemented 2 features requested in ticket #841.;the user can now specify an arbitrary number of file-link columns in te  entry table columns  preferences tab  to be added to the main table. the user can any file types specified in the list of external file types. the extra columns work exactly like the original file-link column.  for each file-link column whenever there are multiple files  the letter  m  is displayed at the bottom right corner of the icon.       committer: noravanq   on branch master  changes to be committed:    (use  git reset head <file>  to unstage)      modified:   src/main/java/net/sf/jabref/guiglobals.java modified:   src/main/java/net/sf/jabref/jabrefpreferences.java modified:   src/main/java/net/sf/jabref/tablecolumnstab.java modified:   src/main/java/net/sf/jabref/gui/maintableformat.java modified:   src/main/java/net/sf/jabref/gui/maintableselectionlistener.java modified:   src/main/java/net/sf/jabref/gui/preventdraggingjtableheader.java;;0;observable: abstract or final;"there is discussion about whether observable should be a ""final class"" and only be usable via observablecreate(func) or whether we should leave it as abstractdiscuss and decide ";i vote not finalif it were final then it would be impossible to extend observable to add operators and still interoperate with other code that uses observable || agreed || we have decided to not make it finalbut we also have changed it from being abstract to a normal concrete classthe subscribe implementation is passed in via a protected constructor or using observablecreate(func1) ||;;;;0;1;;
10;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;try to fix some obvious bugs about  groups;hi all  i just upgraded to 2.10 and i found some bugs immediately. 1. in the right-click-menu there is no  move-to-group  but 2  remove from group  instead. 2. i like the new add/remove/move panel  but the scrolling is not working  which is a big problem. because i have lots of groups which cannot even fit into the full screen height after expansion. 3. no way to expand or collapse all nodes  i tried the dev version  all problems still exist. here is my fixation.  cheers   w.l.;;0;"new ""mockingdetailsgetinvocations"" method for inspecting what happened with the mock";a simple implementation for [issue 178]( the mockingdetails api to expose a getinvocations() method this uses the invocation container from the mockutil object to return a collection of invocations (which is in the orgmockitoinvocation package) this enables users to debug and see invocations on a given mock and use the debugger (or code) to see arguments passed the target method etc;looks good thanks for the pull request || happy to help ill look for something else to fix next :)on wed nov 13 2013 at 2:52 am brice dutheil notifications@githubcomwrote:> looks good thanks for the pull request> > —> reply to this email directly or view it on github  || heyim just reviewing closed pr before the release im thinking that it might be better to return invocationonmock type instead of invocation by the getinvocations() the main reason is that invocation interface is more for devs who extend mockito and this api contains some methods that change the state of the mock and his behavior so the users may potentially hurt themselves by using those methodsmy question is do you need the getinvocations() to return invocation objects or invocationonmock should be enough? || im in a project and we wanted to use the `invocation` to see if the mock was already stubbed and if it was matching another `invocationonmock` still im not sure if well pursue that way for other reasonsanyway i believe you are right it feels like it is kind of internal stuff maybe we could create a public api to expose some of these details maybe even the real mocked type (avoiding to check ourselves if its a superclass or interfaces) ? || if theres a use case for using invocation (and apparently it is) letsuse it perhaps we could elevate some of the methods to theinvocationonmock type (eg all the sensible getters avoid exposing thesetters) maybe maybe we should just give the invocation to the world andsee what happensthanks for the feedbackon mon jan 20 2014 at 6:38 pm brice dutheil notifications@githubcomwrote:> im in a project and we wanted to use the invocation to see if the mock> was already stubbed and if it was matching another invocationonmock> still im not sure if well pursue that way for other reasons> > anyway i believe you are right it feels like it is kind of internal> stuff maybe we could create a public api to expose some of these details> maybe event the real mocked type (avoiding to check ourselves if its a> superclass or interfaces) ?> > —> reply to this email directly or view it on github ## szczepan faberprincipal engineer@gradle founder@mockito ||;;;;1;1;changes for issue 178 change to defaultmockingdetail and a simple test;
10;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;try to fix some obvious bugs about  groups;hi all  i just upgraded to 2.10 and i found some bugs immediately. 1. in the right-click-menu there is no  move-to-group  but 2  remove from group  instead. 2. i like the new add/remove/move panel  but the scrolling is not working  which is a big problem. because i have lots of groups which cannot even fit into the full screen height after expansion. 3. no way to expand or collapse all nodes  i tried the dev version  all problems still exist. here is my fixation.  cheers   w.l.;;0;first cut of dictionary encoder (serde);summary:the surrounding api is still a little rough and can probably be abstracted some more but the core functionality should be completely thereit also includes a simple packed long serde to help with the encoding;i think this code would be a lot simpler if you started the dictionary index at 0 instead of -1  this should be fine since we would not use dictionary encoding on a shard column with more than 2 billion unique entries  actually i would expect that a column shard would not have 2 billion rows in it ||;;;;1;1;first cut of a dictionary-based serdesummary:the surrounding api is still a little rough and can probably be abstracted some more but the core functionality should be completely there;
10;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;try to fix some obvious bugs about  groups;hi all  i just upgraded to 2.10 and i found some bugs immediately. 1. in the right-click-menu there is no  move-to-group  but 2  remove from group  instead. 2. i like the new add/remove/move panel  but the scrolling is not working  which is a big problem. because i have lots of groups which cannot even fit into the full screen height after expansion. 3. no way to expand or collapse all nodes  i tried the dev version  all problems still exist. here is my fixation.  cheers   w.l.;;0;documentation: observables/observer;;;;;;0;1;;
14;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;deprecated timeout().never()  in line with timeout().atmost();timeout().atmost() is deprecated due to issue 235:   these exact same arguments apply to never()  both verification modes are extremely likely to create assertions that immediately pass  and do not test what they re intended to test. this patch therefore deprecates never() similarly.  fairly shortly i m also planning on implementing verify(mock  during(x).[])  as a counterpart to timeout which always waits the full time  as discussed in issue 347:  this should allow for the kind of assertion behaviour that timeout().never() implies.  (also some minor whitespace tidy up and spelling corrections);;0;creating immutable sorted sets from already-ordered data; occasionally you have a list of elements which you already know to be insorted order the canonical example is the results from a sql query with anorder by clauseyou know the data to be sorted yet you have no way to offer the nicetiesof the sortedset/navigableset apis to your callers in order to construct atreeset/etc you must re-engineer the appropriate comparator that can beused to sort the data -- but the data is already sorted!i believe the way out of this is a method setsimmutablepresortedset(list)&nbspthis method would copy the elements out of the list assuming thatwhatever order they come out in is the order you want  it would not demanda comparator from you (although if you can provide one perhaps it shouldaccept it as this could speed up some of the operations  and if you dontprovide one what should the sets comparator() return?  should it return acomparatorsgivenorder()?)this idea is not fully-formed but its a shame to see methods forced touse list to model data which is often known to be dup-free and is orderednot indexed; i just added immutablesortedsetwithexplicitorder() methods to googles internal code base it will probably be in a future guava release--- ;;;;0;1;;
14;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;deprecated timeout().never()  in line with timeout().atmost();timeout().atmost() is deprecated due to issue 235:   these exact same arguments apply to never()  both verification modes are extremely likely to create assertions that immediately pass  and do not test what they re intended to test. this patch therefore deprecates never() similarly.  fairly shortly i m also planning on implementing verify(mock  during(x).[])  as a counterpart to timeout which always waits the full time  as discussed in issue 347:  this should allow for the kind of assertion behaviour that timeout().never() implies.  (also some minor whitespace tidy up and spelling corrections);;0;deprecated timeout()never() in line with timeout()atmost();timeout()atmost() is deprecated due to issue 235:  exact same arguments apply to never() both verification modes are extremely likely to create assertions that immediately pass and do not test what theyre intended to test this patch therefore deprecates never() similarlyfairly shortly im also planning on implementing verify(mock during(x)) as a counterpart to timeout which always waits the full time as discussed in issue 347:  this should allow for the kind of assertion behaviour that timeout()never() implies(also some minor whitespace tidy up and spelling corrections);updated to rename the reporter method ill rebase the other 2 onto this in a sec ||;;;;1;1;changed most() + timeout() warning reporter name to include never() toopreviously it was used by never() but the actual method name didnt match up;
14;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;deprecated timeout().never()  in line with timeout().atmost();timeout().atmost() is deprecated due to issue 235:   these exact same arguments apply to never()  both verification modes are extremely likely to create assertions that immediately pass  and do not test what they re intended to test. this patch therefore deprecates never() similarly.  fairly shortly i m also planning on implementing verify(mock  during(x).[])  as a counterpart to timeout which always waits the full time  as discussed in issue 347:  this should allow for the kind of assertion behaviour that timeout().never() implies.  (also some minor whitespace tidy up and spelling corrections);;0;new range implementation;; applied review comments and ;;;;0;1;;
14;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;deprecated timeout().never()  in line with timeout().atmost();timeout().atmost() is deprecated due to issue 235:   these exact same arguments apply to never()  both verification modes are extremely likely to create assertions that immediately pass  and do not test what they re intended to test. this patch therefore deprecates never() similarly.  fairly shortly i m also planning on implementing verify(mock  during(x).[])  as a counterpart to timeout which always waits the full time  as discussed in issue 347:  this should allow for the kind of assertion behaviour that timeout().never() implies.  (also some minor whitespace tidy up and spelling corrections);;0;operator: throttle;http://msdnmicrosoftcom/en-us/library/hh229298(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229400(vvs103)aspx;;;;;0;1;;
15;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make (un)abbreviating journal titles also work on the journaltitle field;i ve (i) added the toggle button to the  journaltitle  field editor and (ii) made the abbreviate/unabbreviate actions change both the  journal  and  journaltitle  fields. the latter might be a bit simple-minded --  should the field to consider depend on whether biblatex mode is actually turned on?;;0;listscharactersof(charsequence) returning list<character>; this is easy to implement (though requires some tricks that are not totallyobvious in order to get it just right) and im pretty sure it would come inhandy from time to time; ;;;;0;1;;
15;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make (un)abbreviating journal titles also work on the journaltitle field;i ve (i) added the toggle button to the  journaltitle  field editor and (ii) made the abbreviate/unabbreviate actions change both the  journal  and  journaltitle  fields. the latter might be a bit simple-minded --  should the field to consider depend on whether biblatex mode is actually turned on?;;0;verification with timout measures time more more accurately;the previous timeout implementation doesnt measure time correctly: it only counts time spent intentionally sleeping thus losing time on anything that happens when not sleeping (both the actual verification time and time spent in other threads during verification) and gaining time if any interruptedexceptions occurtypically this means that timeout()s actually run for a longer than theyre intended to the  test demonstrates this well previous the timeout was set to exactly the minimum possible time the sleeps in the code alone couldve taken ignoring all processing time and this test consistently passed after the changes it now fails (as it probably should)this patch fixes that by just measuring the time directly ive also fixed some variables names that were slightly annoying and that now-failing test has a 500ms buffer before it times out;ive updated this and rebased its now got some more javadoc and some timeout test improvements (dropping the magic number and more explicitly handling potential test overhead to eliminate timeout test races and some other similar test improvements i noticed along the way) as you mentioned at  ||;;;;1;1;minor tidyup & improvement of timeout() tests;
15;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make (un)abbreviating journal titles also work on the journaltitle field;i ve (i) added the toggle button to the  journaltitle  field editor and (ii) made the abbreviate/unabbreviate actions change both the  journal  and  journaltitle  fields. the latter might be a bit simple-minded --  should the field to consider depend on whether biblatex mode is actually turned on?;;0;get rid of empty blocks;filter methods now return optional<> instead operators never produce an empty block;;;;;1;1;get rid of empty blocksfilter methods now return optional<> instead operators never produce an empty block;
15;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make (un)abbreviating journal titles also work on the journaltitle field;i ve (i) added the toggle button to the  journaltitle  field editor and (ii) made the abbreviate/unabbreviate actions change both the  journal  and  journaltitle  fields. the latter might be a bit simple-minded --  should the field to consider depend on whether biblatex mode is actually turned on?;;0;operator: publish and publishlast;http://msdnmicrosoftcom/en-us/library/hh229126(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211622(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229147(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229797(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh228989(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211697(vvs103)aspx;good intro here:  || thanks for linking that article very helpful || still missing `publishlast` || this can be closed now as #407 included publishlast ||;;;;0;1;;
21;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;improved behavior of equalswithdelta with regards to null handling;added check to the equalswithdelta matcher   if the actual and expected objects are the same.;;0;filler for non-existent issue;21;;;;;0;1;;
21;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;improved behavior of equalswithdelta with regards to null handling;added check to the equalswithdelta matcher   if the actual and expected objects are the same.;;0;improved behavior of equalswithdelta with regards to null handling;added check to the equalswithdelta matcher  if the actual and expected objects are the same;   if for some reasons you do not want this commit just say and ill improve or close it (its ok) || sorry i didnt have the time to review it the pr is ok thanks for the interest ||;;;;1;1;added check to the equalswithdelta matcher  if the actual and expected objects are the same;
21;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;improved behavior of equalswithdelta with regards to null handling;added check to the equalswithdelta matcher   if the actual and expected objects are the same.;;0;handle importing long millis encoded as floats;;;;;;1;1;;
21;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;improved behavior of equalswithdelta with regards to null handling;added check to the equalswithdelta matcher   if the actual and expected objects are the same.;;0;operator: all;http://msdnmicrosoftcom/en-us/library/hh229537(vvs103)aspx;;;;;0;1;;
22;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;extended the  unknown entry type  error message;i had problems locating which entry had this unknown entry type and hence extended the error message to also include the bibtex key.;;0;filler for non-existent issue;22;;;;;0;1;;
22;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;extended the  unknown entry type  error message;i had problems locating which entry had this unknown entry type and hence extended the error message to also include the bibtex key.;;0;improved the javadoc example of custom answer implementation;so a developer can just copy and paste code from javadocs snippet to have the expected result;  ;;;;1;1;answer javadocs correctionso a developer can just copy and paste code from javadocs snippet to have the expected result;
22;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;extended the  unknown entry type  error message;i had problems locating which entry had this unknown entry type and hence extended the error message to also include the bibtex key.;;0;use guava objectstostringhelper;;;;;;1;1;use guava objectstostringhelper;
22;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;extended the  unknown entry type  error message;i had problems locating which entry had this unknown entry type and hence extended the error message to also include the bibtex key.;;0;operator: amb;http://msdnmicrosoftcom/en-us/library/hh229115(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229733(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211783(vvs103)aspx;;;;;0;1;;
24;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;extend biblatex: support for alias fields;- added support for aliased fields. for example  the content in the  journaltitle  field is also shown in the  journal  table. - added cleanup option to convert to the new biblatex format - modified the required/optional fields for biblatex entries to reflect the above changes (the  year  field is no longer required);;0;filler for non-existent issue;24;;;;;0;1;;
24;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;extend biblatex: support for alias fields;- added support for aliased fields. for example  the content in the  journaltitle  field is also shown in the  journal  table. - added cleanup option to convert to the new biblatex format - modified the required/optional fields for biblatex entries to reflect the above changes (the  year  field is no longer required);;0;avoided classloader issue when testing in eclipse plugins environment;;;;;;1;1;issue 453 : introduced a simple classloader builder for loading some classes in isolation also explained why we need different classpaths for this testthis last part could be abbreviate if we can load our test classes in memory;
24;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;extend biblatex: support for alias fields;- added support for aliased fields. for example  the content in the  journaltitle  field is also shown in the  journal  table. - added cleanup option to convert to the new biblatex format - modified the required/optional fields for biblatex entries to reflect the above changes (the  year  field is no longer required);;0;implement cursor and blockstream;;;;;;1;1;implement cursor and blockstream;
24;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;extend biblatex: support for alias fields;- added support for aliased fields. for example  the content in the  journaltitle  field is also shown in the  journal  table. - added cleanup option to convert to the new biblatex format - modified the required/optional fields for biblatex entries to reflect the above changes (the  year  field is no longer required);;0;operator: any;http://msdnmicrosoftcom/en-us/library/hh229905(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211993(vvs103)aspx;i think this issue can be closed ||;;;;0;1;;
29;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed bug #1240. 1-char strings working correctly.;fixed bug #1240  about an error thrown when trying to add a string with length of one character.;;0;filler for non-existent issue;29;;;;;0;1;;
29;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed bug #1240. 1-char strings working correctly.;fixed bug #1240  about an error thrown when trying to add a string with length of one character.;;0;"smarter constructor injection by choosing ""biggest"" constructor instead of the default one";see  additional condition to sorting of constructors by checking amount of mockable constructor arguments;  ;;;;1;1;issue 421: added additional condition to sorting of constructors by checking mockable arguments;
29;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed bug #1240. 1-char strings working correctly.;fixed bug #1240  about an error thrown when trying to add a string with length of one character.;;0;remove old groupby and aggregation code;;minor comments but overall ;;;;1;1;remove old groupby and aggregation code;
29;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed bug #1240. 1-char strings working correctly.;fixed bug #1240  about an error thrown when trying to add a string with length of one character.;;0;operator: combinelatest;http://msdnmicrosoftcom/en-us/library/hh211991(vvs103)aspx;"whats the status on this operator? - there is some code but the tests look a bit different from what i would expect this operator to doshouldnt``` java            w1observeronnext(""1a"")            w1observeroncompleted()            w2observeronnext(""2a"")            w2observeronnext(""2b"")            w2observeroncompleted()            w3observeronnext(""3a"")            w3observeronnext(""3b"")            w3observeronnext(""3c"")            w3observeronnext(""3d"")            w3observeroncompleted()```generate ""1a2b3a"" then ""1a2b3b"" then ""1a2b3c"" then ""1a2b3d""? because it starts with the latest values of `w1` and `w2` as soon as `w3` fires its first string? - to me this currently looks a bit like a mixture between `zip` and `combinelatest` but maybe im understanding the semantics of `combinelatest` wrongthe current code seems to still ""wait"" for an `onnext` from each combined observable before firing its own `onnext`? id love to try and fix that if you can confirm that i understand `combinelatest` correctly || as im reading through this im using the following to research the expected behavior: like iobservable<t>zip iobservable<t>combinelatest com­bines ‘pairs’ of val­ues from the two observ­able col­lec­tions but unlike zip when a new value becomes avail­able on one col­lec­tion it does not wait till a new value to be avail­able on the other col­lec­tion instead it takes what­ever the lat­est value is from the other col­lec­tion (pro­vided there is one):the test case appears to be as follows:```xonnext(1)yonnext(""a"")xonnext(2)xonnext(3)yonnext(""b"")xonnext(4)```this should result in:```a1a2a3b3b4```on each `onnext` from whatever sequence sends it the combination will be emitted using whatever the latest value isextrapolating that into a unit test i get something like this:``` java        @test        public void testcombinelatestdifferentlengthobservablesequenceswithinterleaving1() {            observer<string> w  mock(observerclass)            testobservable x  new testobservable()            testobservable y  new testobservable()            observable<string> combinelatestw  observablecreate(combinelatest(y x getconcat2stringscombinelatestfunction()))            combinelatestwsubscribe(w)            /* simulate sending data */            xobserveronnext(""1"")            yobserveronnext(""a"")            xobserveronnext(""2"")            xobserveronnext(""3"")            yobserveronnext(""b"")            xobserveronnext(""4"")            xobserveroncompleted()            yobserveroncompleted()            /* we should have been called 5 times on the observer */            inorder inorder  inorder(w)            inorderverify(w)onnext(""a1"")            inorderverify(w)onnext(""a2"")            inorderverify(w)onnext(""a3"")            inorderverify(w)onnext(""b3"")            inorderverify(w)onnext(""b4"")            inorderverify(w times(1))oncompleted()        }```this test fails with current codeso yes the current implementation is wrong - and its crazy complicatedill take a look at your pull request for this fix (hopefully tomorrow though i have a lot of meetings so )thank you @jmhofer  || i agree your test should work with my pull request as ive added a similar test also i simplified the code a bit but i wasnt sure how thoroughly i could/should rework it so i kept the basic structure (i guess the complexity mostly comes from the zip operator it seems to have been copied from originally)the one thing im still unsure of is when the combined stream should complete that first of your links above says: ""the combine latest processing will come to end either when one of the stream will complete or throw exception"" - however i dont really see a reason why it should complete before all streams are complete - i havent found any other specification yet for cross-checking this || you can change the implementation to whatever makes sense as i obviously misunderstood the behavior when i implemented this long ago and stole the base functionality from `zip` which starts it from the wrong place altogether since it shouldnt do queuing and thus doesnt need a lot (or any?) of the synchronization the zip requiresyour last question is a good one if an `onerror` is received at any time the whole thing should finish and propagate the errorfor the `oncompleted` question im not sure  the c# code will provide the definitive answer ill try to review that (no time right now) unless you can beat me to it or find a better answer somewhere else way would be a rxnet or rxjs test case if you have access to either of those or someone who does || the c# code looks very much like they complete only when all streams are complete (when there are no errors) - thats good then the pull request code should already handle that correctly || great then ill proceed with the review and merge i appreciate your willingness to dive into this one and deal with that gnarly code || so if i understand correctly synchrononous (blocking) sequences make `combinelatest` behavior rather odd such as this where only the last value of the first sequence will ever show up in the combined values:``` java            observable<string> w  observablecreate(combinelatest(observabletoobservable(""one"" ""two"") observabletoobservable(2 3 4) combinelatestfunction))            wsubscribe(aobserver)            verify(aobserver times(1))onnext(""two2"")            verify(aobserver times(1))onnext(""two3"")            verify(aobserver times(1))onnext(""two4"")``` || yes i think so - i came to that conclusion too ""latest"" doesnt really make much sense in the synchronous case || i updated my pull request: i had previously forgotten to adapt the comments also i cleaned up the code a bit and tried to fix synchronization (its hard as always) || i have merged pull request  to resolve this issue || ";;;;0;1;;
30;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;deep stub style mocks can be serialized;see https://code.google.com/p/mockito/issues/detail?id=399;;0;quickselect?; if it is desired we could provide an implementation of the quickselectalgorithm&nbsp&nbsppublic static &ltc extends comparable> list&ltc> quickselect(&nbsp&nbsp&nbsp&nbsplist&ltc> list int count) {}&nbsp&nbsppublic static &ltt> list&ltt> quickselect(&nbsp&nbsp&nbsp&nbsplist&ltt> list comparator<? super t> comparator int count) {}i have some code written but not tested debugged etc  i would onlybother to finish it up if people actually want itmore on quickselect: http://enwikipediaorg/wiki/quick_select; what youre looking for is called the ""kth order statistic""  within google we found that we did not have as much use for that functionality as for what we ended up doing  you can still file a separate feature request || ";;;;0;1;;
30;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;deep stub style mocks can be serialized;see https://code.google.com/p/mockito/issues/detail?id=399;;0;deep stub style mocks can be serialized;see https://codegooglecom/p/mockito/issues/detail?id399;"   thread safety added - i was thinking about some atomicreferences but that wasnt an option since the types of those references wouldnt be serializable so i went just for simple method synchronization as for the generics part - thanks for the usecases it seems clearer now as for the purpose of the fix || reviewed by brice still need to work on generic support serialization || hey marcin ive worked on the serialization of deep stubs with generic support and i decided this was too much for now i believe this could be added later on so for the moment i choose that deep stubs answer will now fallback to the previous mechanism when serializing you can grep the commits with `issue 399` for more details thanks for helping me on this one anyway :) || sure no problem :) || ";;;;1;1;added synchronization on instantiation of transient fields to guard thread safety;
30;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;deep stub style mocks can be serialized;see https://code.google.com/p/mockito/issues/detail?id=399;;0;add peeknextvalueposition to cursor and other minor changes;also added tests some docs to the cursor interface and implemented some missing methods in rle cursor; ill submit a new pull request once ive updated the tests as requested ||;;;;0;1;;
30;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;deep stub style mocks can be serialized;see https://code.google.com/p/mockito/issues/detail?id=399;;0;operator: concat;http://msdnmicrosoftcom/en-us/library/hh212124(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229289(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211916(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh212146(vvs103)aspx;it seems like this operator has been already implemented  || yes youre correct ||;;;;0;1;;
32;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed the behavior of compareto method of the mock objects;see   fix compareto behaviour the same objects;;0;upgrade to java 6; we will upgrade to requiring java 6 but will create a java 5-compatiblebranch and will include both forms in our releasebased on the changes listed in have some work to doapi - - adopt navigablefoo in place of sortedfoo throughout the api- add forwardingnavigablefoo forwardingdeque- add factory methods for the new implementations to lists/sets/mapsimpl -- add @﻿override to methods newly eligible for it- adopt the new abstractmapsimple(immutable)entry classes in place of our  custom code wherever possibleprobably other stuff im not thinking of; ;;;;0;1;;
32;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed the behavior of compareto method of the mock objects;see   fix compareto behaviour the same objects;;0; the behavior of compareto method of the mock objects;see  compareto behaviour the same objects;   thanks merged ) ||;;;;1;1;467] rename testsintroduce snake case instead of camel case for tests names in shouldmockscomparetobeconsistentwithequalstest class;
32;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed the behavior of compareto method of the mock objects;see   fix compareto behaviour the same objects;;0;simplify group by and aggregation by adding nextvalueequals;;minor comments but ;;;;1;1;changes based on feedback for #32;
32;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed the behavior of compareto method of the mock objects;see   fix compareto behaviour the same objects;;0;operator: count;http://msdnmicrosoftcom/en-us/library/hh229470(vvs103)aspx;;;;;0;1;;
36;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactoring: inner implementations of filter and comparator should be static;;;0;filler for non-existent issue;36;;;;;0;1;;
36;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactoring: inner implementations of filter and comparator should be static;;;0;refactoring: inner implementations of filter and comparator should be static;;  ;;;;1;1;make verifiableinvocationsfinderremoveignoredforverification private;
36;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactoring: inner implementations of filter and comparator should be static;;;0;rewrite columnprocessor and data import;;;;;;1;1;rewrite columnprocessor and data import;
36;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactoring: inner implementations of filter and comparator should be static;;;0;operator: delay;http://msdnmicrosoftcom/en-us/library/hh229677(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229810(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229250(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229280(vvs103)aspx;"once we have this operator we can implement [time flies like an arrow]( :-) || pretty :-) ill see what i can do || @benjchristensen what about implementing delay as combination of ""interval"" and ""first"" operations? || @lexer i dont think that can get us the needed functionality here is the discussion:  || delay is  ";;;;0;1;;
37;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;refactoring: avoid static keyword in inner interface definition;inner interfaces are implicitly static;;0;filler for non-existent issue;37;;;;;0;1;;
37;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;refactoring: avoid static keyword in inner interface definition;inner interfaces are implicitly static;;0;refactoring: avoid static keyword in inner interface definition;inner interfaces are implicitly static;  ;;;;1;1;remove redundant static keywordinner interfaces are implicitly static;
37;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;refactoring: avoid static keyword in inner interface definition;inner interfaces are implicitly static;;0;simplify cursors;;;;;;1;1;update datascan2 to new cursor interface;
37;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;refactoring: avoid static keyword in inner interface definition;inner interfaces are implicitly static;;0;operator: dematerialize;http://msdnmicrosoftcom/en-us/library/hh229047(vvs103)aspx;;;;;0;1;;
38;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;new  then  method for bdd-style interaction testing;new feature in bddmockito for bdd then part of the test which allows mock behavior verification by using  mockito#verify(object) . for example we have classes person and bike:      java bike bike = new bike()  person person = mock(person.class)       and the following interaction      java person.ride(bike)  person.ride(bike)       current (non bdd) behavior verification would go like:      java verify(person  times(2)).ride(bike)       this feature introduces the following way of verification:      java then(person).should(times(2)).ride(bike);;0;filler for non-existent issue;38;;;;;0;1;;
38;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;new  then  method for bdd-style interaction testing;new feature in bddmockito for bdd then part of the test which allows mock behavior verification by using  mockito#verify(object) . for example we have classes person and bike:      java bike bike = new bike()  person person = mock(person.class)       and the following interaction      java person.ride(bike)  person.ride(bike)       current (non bdd) behavior verification would go like:      java verify(person  times(2)).ride(bike)       this feature introduces the following way of verification:      java then(person).should(times(2)).ride(bike);;0;"new ""then"" method for bdd-style interaction testing";new feature in bddmockito for bdd then part of the test which allows mock behavior verification by using `mockito#verify(object)`for example we have classes person and bike:``` javabike bike  new bike()person person  mock(personclass)```and the following interaction``` javapersonride(bike)personride(bike)```current (non bdd) behavior verification would go like:``` javaverify(person times(2))ride(bike)```this feature introduces the following way of verification:``` javathen(person)should(times(2))ride(bike)```;"   when is the next release? :)on tue mar 18 2014 at 8:17 pm brice dutheil notifications@githubcomwrote:> merged #38  > ## > > reply to this email directly or view it on github  || some work is still needed regarding jdk8 but it may be easier than expected unless the community has missed somethingalso release scripts need to be enhanced and extended to the test-ng supportplus many stuff i may have forgotby the way could you give your feedback on this pr #9 im not yet sure how to integrate this feature tia || hey ive been playing around a bit with your feature i agree with you `then(person)verify(times(2))ride(bike)` doesnt read wellim no more inclined to add the verify alias but if you want to keep it what do you think of writing it this way with a no-op `then()` for exemple : ``` javathen()verify(person times(2))ride(bike)``` || > by the way could you give your feedback on this pr #9 im not yet sure how to integrate this feature tiaive just seen it is related to an accepted issue on the projects site on google code ill take a look into it when i get some time> im no more inclined to add the verify alias but if you want to keep it what do you think of writing it this way with a no-op then() for exemple : im also in favor of removing it || the thing is the jsr 305 is now part of the jdk8 that could be interesting to bring at some point support for that || sorry i didnt have any time to look at the pr ill try to take a look at it next week || > by the way could you give your feedback on this pr #9 im not yet sure how to integrate this feature tiaive looked at the pull request and im not sure i understand what the problem is is the main issue backwards compatibility and redesign of invocation or integration process itself?ps it seems this issue should be discussed somewhere maybe best on the mockito google group? || the comment on the pr is for that please share your opinion or question there too :)thx for taking the time to take a look at it by the way :) || when you get some free time please take a look at  im trying to gather some feedback from junit guys but none were given  hey can you share the link on the mailing list so people can discuss there :)also i will post the link on twitteranyway from just looking at the readme page i find the api quite elegant || i will thanks for feedback! :) || hey guysdid you consider this:then(person times(2))ride(bike)then(person)ride(bike) || i find the original case more readable so i must say im against it is there any concrete case where it doesnt read well? || i agree with lovro i find the original idea more readable || for example: then(task)should()completed()then(mock)method() is more consistent with the original apii really like your idea though i think it reads very nicely || yes that could work with aliases like``` javashouldbe()validated()has()performed()has(times(2))performed()``` || > i really like your idea though i think it reads very nicelythanksthere is one more problematic case: timeout()maybe more aliases should be introduced? || hey guysi thought about this and im tempted to remove this new method from the api i really like how it looks but on the other hand i dont want mockito api to grow in tactical aliases that solve mini use cases there is a room for this kind of aliases but id rather mockito api to be simple and opinionated perhaps there should be a separate library called mockito-bdd? also its pretty easy to add such aliases to any codebase simpler api like ""then(task)completed()"" would be ok for me because its truly an alias - it has exactly the same signature but the method name is different hence it does not complicate the api however it seems that you prefer more fluency - this could be different library that depends on mockito-core and has bunch of bdd aliaseslovro i really like your coding and id love to get more contributions from you! || btw thoughts? i can always be convinced :) || > lovro i really like your coding and id love to get more contributions from you!thanks!i must say that i still stand by my original pull request and its design> for example: then(task)should()completed()i think that only listener methods can be problematic (oncompletion) with current implementation normal methods usually dont go in past tense || but abandoning the should part and leaving only then wouldnt be bad for me either i just hope this gets released some time soon :) || i will release really soon i wanted to close down this api change actually before the release :)i totally respect your pov regarding should() methodoptions we have (ive conveniently removed options that dont work for me ):1 back out the feature from master possibly include more bdd aliases somewhere else2 change the feature to then(task)dostuff() if we do that we will reserve the then word/method and the original option wont be possible any more (even in a separate library)id say we do 1) but i will concede to your votes lovro/brice?thanks again for your input! || heyi thought about this and lets release it in the original shape eg as it is now in the codebase :)do you mind improving the impl a little bit?1 can you add info about this new feature from the mockito main class?2 it would be better if then was an interface and the implementing class not-public (protected or package-protected is fine)ill probably hide this feature from the codebase for the next release however once you get above items done submit pr well merge it and it should get _automatically_ released it will be nice test for the continuous deployment implementation :) || ah nevermind lets just have it in the coming release do you mind doing the 1-2 items in a different pr? :)thanks! || hey sorry for responding this late> do you mind doing the 1-2 items in a different pr? sure what needs to be done? :) || id love a pr with:1 new feature highlighted on the main mockito class (add an item to the   bottom of the list for example: ""(new) fluent bdd alias for verification"")2 deprecate then class introduce then interface (you can create a new   package orgmockitobdd) that the then class can implement for now3 extra credit: also deprecate other concrete classes that leak from the   top level bddmockito4 javadoc for deprecate class includes a deprecation reason5 ensure new api that you have introduced contains @since informationabove is pretty tactical but i hope it gives you a picture about do weapproach api design and evolution this can be very useful for you becauseyoure planning more prs right? :dthanks again for your contribution!on wednesday october 1 2014 lovro pandžić notifications@githubcomwrote:> hey sorry for responding this late> > do you mind doing the 1-2 items in a different pr?> > sure what needs to be done? :)> > —> reply to this email directly or view it on github>  szczepan fabercore dev@gradle founder@mockito || ok i have a few comments:2 deprecation is not really needed if i introduce an interface for then in bddmockito (and move/rename implementation) no client would be affected because the current then class is a final class with all fields non visible hence all imports/usages would be valid after this change but the more important question to me: what is the goal of this interface? is it expected of clients to provide more implementations because that seems highly unlikely to me and just increases complexity unnecessary?general direction is to deprecate the bddmockito class? || heythanks for following up!the general direction is not let concrete public classes leak to the apieg use interfaces for the api where possible bddmockito is cool letsnot deprecate it )possibly the deprecation is not needed i guess users do not instantiatethis class by hand in their tests :) i was playing safe here - for regularuse the deprecation is not needed however sometimes users find verycreative ways of using the api (which is good!) and the deprecation wouldensure backwards compatibilityif you want me to make the call i say deprecate it (its a good trainingfor evolving the api in backwards compatible way too) if you believe thedeprecation is not needed and you are happy to make that call just changeit without deprecationcheers!on fri oct 3 2014 at 11:59 pm lovro pandžić notifications@githubcomwrote:> ok i have a few comments:> 2 deprecation is not really needed if i introduce an interface for then> in bddmockito (and move/rename implementation) no client would be affected> because the current then class is a final class with all fields non visible> hence all imports/usages would be valid after this change but the more> important question to me: what is the goal of this interface? is it> expected of clients to provide more implementations because that seems> highly unlikely to me and just increases complexity unnecessary?> > general direction is to deprecate the bddmockito class?> > —> reply to this email directly or view it on github>  szczepan fabercore dev@gradle founder@mockito || i thought it had a private constructor but i see it has a public one my mistake so the deprecation is in order ill make a pr as soon as i get some free time on my hands :) || cool no rush ) || ";;;;1;1;- added documentation to mockito;
38;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;new  then  method for bdd-style interaction testing;new feature in bddmockito for bdd then part of the test which allows mock behavior verification by using  mockito#verify(object) . for example we have classes person and bike:      java bike bike = new bike()  person person = mock(person.class)       and the following interaction      java person.ride(bike)  person.ride(bike)       current (non bdd) behavior verification would go like:      java verify(person  times(2)).ride(bike)       this feature introduces the following way of verification:      java then(person).should(times(2)).ride(bike);;0;cursor redesign;;;;;;1;1;changes for review #38;
38;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;new  then  method for bdd-style interaction testing;new feature in bddmockito for bdd then part of the test which allows mock behavior verification by using  mockito#verify(object) . for example we have classes person and bike:      java bike bike = new bike()  person person = mock(person.class)       and the following interaction      java person.ride(bike)  person.ride(bike)       current (non bdd) behavior verification would go like:      java verify(person  times(2)).ride(bike)       this feature introduces the following way of verification:      java then(person).should(times(2)).ride(bike);;0;operator: distinct;http://msdnmicrosoftcom/en-us/library/hh229764(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211630(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh244310(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229050(vvs103)aspx;;;;;0;1;;
39;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;allow calling real implementation of jdk8 extension methods;see also the google code ticket:   enable calling real implementation on extensions method from jdk8 additionally change add validation checking whether callrealmethod is invoked on abstract methods. in fact resolving issue could be achieved by removing this validation because when someone do next thing: 1: when(someinteface.abstractmethod()).thancallrealmethod()  2: someinteface.abstractmethod() exception will be throwned on second line informing that there were attempt to invoke abstract method;;0;filler for non-existent issue;39;;;;;0;1;;
39;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;allow calling real implementation of jdk8 extension methods;see also the google code ticket:   enable calling real implementation on extensions method from jdk8 additionally change add validation checking whether callrealmethod is invoked on abstract methods. in fact resolving issue could be achieved by removing this validation because when someone do next thing: 1: when(someinteface.abstractmethod()).thancallrealmethod()  2: someinteface.abstractmethod() exception will be throwned on second line informing that there were attempt to invoke abstract method;;0;allow calling real implementation of jdk8 extension methods;see also the google code ticket:  calling real implementation on extensions method from jdk8additionally change add validation checking whether callrealmethod is invoked on abstract methodsin fact resolving issue could be achieved by removing this validation because when someone do next thing  when(someintefaceabstractmethod())thancallrealmethod()2: someintefaceabstractmethod()exception will be throwned on second line informing that there were attempt to invoke abstract method;"   i think we need different project in mockito with different java version where we can test mockito features against different jdki dont know if its possible in travis to have different jdks at the same time || form what ive checked it looks good let me some more time to see if theres some weird thing as well )thanks for this work it muck simpler than to rewrite an `isdefault` checkfor readers reference :  || by the way for the reader hers an interesting paper on defender methods :  || another interesting pdf one could read too its from the jvm langage summit 2013 :  ||  is possilbe to test project on multiple jdks (  but in order to test special features of jdk8 i advice to create seperate branch which will hold tests for that features ie: branch jdk8 will hold tests checking whether jdk8 features work correctly and it will be tested only on jdk8 (extension methods will not compile on jdk7) on the other hand master branch will be tested against jdk7 and jdk8 and difference in code will be only on tests level thanks to it we will not have 2 main lines of development but we will tests compatibility on 2 different jdks what do you think about it? it is just suggestion maybe you have better idea? || yeah i know about that feature which is nice really but it doesnt fit the goal i would like which would be to compile mockito and make sure its still compatible with jdk5 for example and the binaries would be tested in different test environment for that i fear i would need separate projectsstill your approach is interesting but im a bit concerned about the _branch synchronization_ im thinking about something else i need to ask gradle expert though  would it be possible to toggle a subproject on jdk version? || i do not know how it looks like from travis perspective but on github seperate branch is sufficient do you agree? in seperate branch you can configure gradle properties travis build definition as well as other things what is more it will be easier to merge prs into two branches in the same project(project as github definition) || yeah we could still try that || fyi im working on the jdk8 branch || if you need any help just let me know || hi what is the status of this feature? the release note 1100 (2014-09-25 22:25 utc) says ""allow calling real implementation of jdk8 extension methods"" but actually it is not possible see for instance:  my own tests it is indeed not possible to call real implementation of default methods  || ";;;;1;1;456] enable calling real method at extensions from jdk8;
39;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;allow calling real implementation of jdk8 extension methods;see also the google code ticket:   enable calling real implementation on extensions method from jdk8 additionally change add validation checking whether callrealmethod is invoked on abstract methods. in fact resolving issue could be achieved by removing this validation because when someone do next thing: 1: when(someinteface.abstractmethod()).thancallrealmethod()  2: someinteface.abstractmethod() exception will be throwned on second line informing that there were attempt to invoke abstract method;;0;add query testing framework;;great start! check out the comments and then merge it ||;;;;1;1;add query testing framework;
39;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;allow calling real implementation of jdk8 extension methods;see also the google code ticket:   enable calling real implementation on extensions method from jdk8 additionally change add validation checking whether callrealmethod is invoked on abstract methods. in fact resolving issue could be achieved by removing this validation because when someone do next thing: 1: when(someinteface.abstractmethod()).thancallrealmethod()  2: someinteface.abstractmethod() exception will be throwned on second line informing that there were attempt to invoke abstract method;;0;operator: distinctuntilchanged;http://msdnmicrosoftcom/en-us/library/hh229494(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229776(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229508(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229533(vvs103)aspx;;;;;0;1;;
41;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;new  getargumentat  method for convenient implementation of custom answers;the problem is when i need to use answers  i quite often need to cast these arguments. i propose two methods in invocationonmock  so we can get two arguments of method typesafely  so this piece of code       java @suppresswarnings( unchecked )   doanswer(new answer() {       public object answer(invocationonmock invocation) {           object args = invocation.getarguments()            int count  = (int)args[1]           //do something       }})   .when(mock).somemethod()       will be better:      java   doanswer(new answer() {       public object answer(invocationonmock invocation) {            int count  = invocation.getargumentat(1  int.class)           //do something       }})   .when(mock).somemethod();;0;filler for non-existent issue;41;;;;;0;1;;
41;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;new  getargumentat  method for convenient implementation of custom answers;the problem is when i need to use answers  i quite often need to cast these arguments. i propose two methods in invocationonmock  so we can get two arguments of method typesafely  so this piece of code       java @suppresswarnings( unchecked )   doanswer(new answer() {       public object answer(invocationonmock invocation) {           object args = invocation.getarguments()            int count  = (int)args[1]           //do something       }})   .when(mock).somemethod()       will be better:      java   doanswer(new answer() {       public object answer(invocationonmock invocation) {            int count  = invocation.getargumentat(1  int.class)           //do something       }})   .when(mock).somemethod();;0;"new ""getargumentat"" method for convenient implementation of custom answers";"the problem is when i need to use answers i quite often need to cast these argumentsi propose two methods in invocationonmock so we can get two arguments of method typesafely so this piece of code``` java@suppresswarnings(""unchecked"")  doanswer(new answer() {      public object answer(invocationonmock invocation) {          object args  invocationgetarguments()          int count   (int)args[1]         //do something      }})  when(mock)somemethod()```will be better:``` java  doanswer(new answer() {      public object answer(invocationonmock invocation) {           int count   invocationgetargumentat(1 intclass)         //do something      }})  when(mock)somemethod()```";im basically ok but i dont want the `getfirstargument` in `invocationonmock` otherwise the contract will grow too much without real benefit  || i had removed getfirstargument from pull request || great thx :) ||;;;;1;1;add casted generic methods for getting arguments from invocationonmock;
41;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;new  getargumentat  method for convenient implementation of custom answers;the problem is when i need to use answers  i quite often need to cast these arguments. i propose two methods in invocationonmock  so we can get two arguments of method typesafely  so this piece of code       java @suppresswarnings( unchecked )   doanswer(new answer() {       public object answer(invocationonmock invocation) {           object args = invocation.getarguments()            int count  = (int)args[1]           //do something       }})   .when(mock).somemethod()       will be better:      java   doanswer(new answer() {       public object answer(invocationonmock invocation) {            int count  = invocation.getargumentat(1  int.class)           //do something       }})   .when(mock).somemethod();;0;add double data type;;;;;;1;1;use sizeof constants instead of literal numbers;
41;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;new  getargumentat  method for convenient implementation of custom answers;the problem is when i need to use answers  i quite often need to cast these arguments. i propose two methods in invocationonmock  so we can get two arguments of method typesafely  so this piece of code       java @suppresswarnings( unchecked )   doanswer(new answer() {       public object answer(invocationonmock invocation) {           object args = invocation.getarguments()            int count  = (int)args[1]           //do something       }})   .when(mock).somemethod()       will be better:      java   doanswer(new answer() {       public object answer(invocationonmock invocation) {            int count  = invocation.getargumentat(1  int.class)           //do something       }})   .when(mock).somemethod();;0;operator: elementat and elementatordefault;http://msdnmicrosoftcom/en-us/library/hh229725(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229845(vvs103)aspx;i think this issue can be closed ||;;;;0;1;;
44;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add entry under the  view  menu to hide the toolbar;in addition  i would suggest to hide the toolbar by default.;;0;filler for non-existent issue;44;;;;;0;1;;
44;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add entry under the  view  menu to hide the toolbar;in addition  i would suggest to hide the toolbar by default.;;0;refactoring: removed then-verify;removed verify alias in bddmockito;perfect thx ||;;;;1;1;- removed then-verify;
44;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add entry under the  view  menu to hide the toolbar;in addition  i would suggest to hide the toolbar by default.;;0;reorganize code;move all block related code to blocks with sub package for each encoding typemove cvs import code to inject packagemove benchmark code to a benchmark package in tests;;;;;1;1;reorganize codemove all block related code to blocks with sub package for each encoding typemove cvs import code to inject packagemove benchmark code to a benchmark package in tests;
44;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add entry under the  view  menu to hide the toolbar;in addition  i would suggest to hide the toolbar by default.;;0;operator: first and firstordefault;http://msdnmicrosoftcom/en-us/library/hh229177(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229739(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229320(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229759(vvs103)aspx;;;;;0;1;;
47;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;added the ability to reorder the panels in the side pane.;side pane panels now feature an up arrow button and a down arrow button immediately to the left of the close button. these buttons allow panes to be swapped with the pane above or below them  respectively.  whenever the panes are reordered  the current position of each visible pane is recorded in the application preferences  so the user s custom ordering can be preserved when jabref is next run.;;0;filler for non-existent issue;47;;;;;0;1;;
47;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;added the ability to reorder the panels in the side pane.;side pane panels now feature an up arrow button and a down arrow button immediately to the left of the close button. these buttons allow panes to be swapped with the pane above or below them  respectively.  whenever the panes are reordered  the current position of each visible pane is recorded in the application preferences  so the user s custom ordering can be preserved when jabref is next run.;;0;issue484 fix;this fixes the issue when comparing 2 identical objects which throw an exception in their equals method;  ;;;;1;1; issue 484by adding an additonal clause to the areequal methodto take care of the trivial case;
47;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;added the ability to reorder the panels in the side pane.;side pane panels now feature an up arrow button and a down arrow button immediately to the left of the close button. these buttons allow panes to be swapped with the pane above or below them  respectively.  whenever the panes are reordered  the current position of each visible pane is recorded in the application preferences  so the user s custom ordering can be preserved when jabref is next run.;;0;reorder typeinfotype enum so ordinals back to orginal value;current serialized format for tupleinfo (incorrectly) writes the enum oridnal;;;;;1;1;;
47;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;added the ability to reorder the panels in the side pane.;side pane panels now feature an up arrow button and a down arrow button immediately to the left of the close button. these buttons allow panes to be swapped with the pane above or below them  respectively.  whenever the panes are reordered  the current position of each visible pane is recorded in the application preferences  so the user s custom ordering can be preserved when jabref is next run.;;0;operator: fromevent;http://msdnmicrosoftcom/en-us/library/hh244301(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211795(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229271(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229241(vvs103)aspx;"i think these are for net events java doesnt have its ""events"" on a single base neither the interfaces nor the add/remove functionality || closing as this doesnt particularly apply we are instead doing this type of work in contrib-modules such as for android and swing || ";;;;0;1;;
56;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix double-click opening of files on mac;moving the registration of apple events ensures that double-clicking on a file to open it works even if jabref is not yet running.;;0;mapsasmap(set function) -> map or mapstomap(iterable function) -> immutablemap ( or both); this method would create a new hash map then iterate over keys: applyfunction to get value add new entry to the mapmap&ltk v> fromfunction(set&ltk> keys function&ltk v> function);  `` ;;;;0;1;;
56;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix double-click opening of files on mac;moving the registration of apple events ensures that double-clicking on a file to open it works even if jabref is not yet running.;;0; wrong javadoc for additionalanswers; wrong javadoc for additionalanswers;;;;;1;1; javadoc for additionalanswers;
56;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix double-click opening of files on mac;moving the registration of apple events ensures that double-clicking on a file to open it works even if jabref is not yet running.;;0;add isvalid method cursor;;;;;;1;1;add isvalid method cursor;
56;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix double-click opening of files on mac;moving the registration of apple events ensures that double-clicking on a file to open it works even if jabref is not yet running.;;0;operator: join;http://msdnmicrosoftcom/en-us/library/hh229750(vvs103)aspx;;;;;0;1;;
59;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactoring: added casts to supress varargs warnings;;;0;filler for non-existent issue;59;;;;;0;1;;
59;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactoring: added casts to supress varargs warnings;;;0;refactoring: added casts to supress varargs warnings;;  ;;;;1;1;added casts to supress varargs warnings;
59;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactoring: added casts to supress varargs warnings;;;0;bind serdes to main + tuplestreamwriter;the main goal of this is to bind the serdes to main to allow conversion of the data files along the way added tuplestreamwriter paradigm which we can extend in the future to make data ingestion more efficient right now each column is extracted one at a time (same as before);" if you forget the _raw on the type you get an unfriendly exception message:```exception in thread ""main"" javautilnosuchelementexception    at comgooglecommonbaseabstractiteratornext(abstractiteratorjava:75)    at comfacebookprestomain$convertcsvrun(mainjava:118)    at comfacebookprestomain$basecommandcall(mainjava:61)    at comfacebookprestomain$basecommandcall(mainjava:54)    at comfacebookprestomainmain(mainjava:51)``` || ";;;;1;1;rebase on head;
59;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactoring: added casts to supress varargs warnings;;;0;operator: latest;http://msdnmicrosoftcom/en-us/library/hh212115(vvs103)aspx;"is `latest` same as `next` #66? i read  and  in rxnet but i cant find the difference || i believe latest can return a value from the past but falls back the next value if one hasnt been received yet || > i believe latest can return a value from the past but falls back the next value if one hasnt been received yet@abersnaze  do you mean if the next value hasnt arrived the latest will return the old cached value?but there are the following codes in the trymovenext method of latest``` c#            public override bool trymovenext(out tsource current)            {                var kind  default(notificationkind)                var value  default(tsource)                var error  default(exception)#if !no_cds                _semaphorewait()#else                _semaphorewaitone()#endif```so when `trymovenext` is called it will block the thread and wait for the incoming valuei tried the following codes in rxnext:``` c#            iobservable<int> ob                     observablecreate<int>(o >                    {                        consolewriteline(""subscribed: before onnext"")                        oonnext(1)                        threadsleep(2000)                        oonnext(2)                        consolewriteline(""subscribed: after onnext"")                        ooncompleted()                        return disposableempty                    }                    )            var iter  obsubscribeon(schedulernewthread)latest()getenumerator()            consolewriteline(""before movenext"")            while (itermovenext())            {                consolewriteline(""find a value"")                consolewriteline(""got "" + itercurrent)            }            consolewriteline(""after movenext"")```the output is:<pre>before movenextsubscribed: before onnextfind a valuegot 1subscribed: after onnextfind a valuegot 2after movenext</pre> || i did some tests on rxnet about `latest` and `next`i draw two marble diagrams to summary the differences between `latest` and `next`- latest![latest]( `latest` the `next` of `iterator` will check if there is a cached value if so returns the cached value and deleted the cached value if there is not a cached value it will blocks until the next value is emitted from the observable and returns it- next![next]( `next` the `next` method of `iterator` always blocks until the next value is emitted from the observable and returns itplease let me know if you find any mistake || so `next` will return every value emitted by source whereas `latest` only those which were observed just before the `hasnext()` call and only once?looking at `operationnext` i find it strange to have the `waiting` atomic boolean in l132 checked in l147 and set in l162 it appears if there is no one is using `takenext()` the onnext skips an onnext-notification l152 quotes some race condition which i dont really see as the observer ignores onerror and oncompleted and the materialized source should be race-free anyway || sorry that the next diagram is not clear here is a more clear diagram:![next1]( for the `next` operator items will be ignored if they are emitted between two `next` calls || however as the `iterator` has two methods: `hasnext` and `next` its more complicated check the document here:  and the discussion here:  || @zsxwing are you going to implement this? in addition ive looked at the operationmostrecent and if i understand it correctly it shares a single subscription to the source observable ie if i try to iterate the same source twice it wont work the second time:``` javablockingobservable<long> source  observableinterval(100 timeunitmilliseconds)take(10)toblockingobservable()iterable<long> it  sourcemostrecent(-1l)for (long l : it) {   systemoutprintln(l)   threadsleep(50)}systemoutprintln(""----------------------------------------"")for (long l : it) {    systemoutprintln(l)    threadsleep(50)}```same goes for `operationnextnext`i can fix both mostrecent and next and take latest || youre right the `subscribe` action should be created in the `iterator` rather than the `iterable` as im busy at other work now it would be appreciated if you can fix this issue and the `latest` operator || im on it   ";;;;0;1;;
63;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improve nointeractionswanted report to include the name of the mock;this is useful feedback when using multiple mocks in verifynomoreinteractions().;;0;filler for non-existent issue;63;;;;;0;1;;
63;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improve nointeractionswanted report to include the name of the mock;this is useful feedback when using multiple mocks in verifynomoreinteractions().;;0;improve nointeractionswanted report to include the name of the mock;this is useful feedback when using multiple mocks in verifynomoreinteractions();hey thanks for the pr could you add a unit test ? theres probably already something that test the location you can place it there ||    thanks for the pr can you describe a use case where it is useful? i thought that we write the mock name when invocations are printed || sure it helps where you provide several mocks to verifynomoreinteractions:``` javapublic class mockitotest {    @mock    private runnable a b    @before    public void setup() {        initmocks(this)    }    @test    public void test() {        brun()        verifynomoreinteractions(a b)    }}```without the patch:```failed tests:   mockitotesttest:23 no interactions wanted here:-> at compushtechnologydiffusionqueuesconflationmockitotesttest(mockitotestjava:23)but found this interaction:-> at compushtechnologydiffusionqueuesconflationmockitotesttest(mockitotestjava:22)actually above is the only interaction with this mock```with the patch:```failed tests:   mockitotesttest:23 no interactions wanted here:-> at compushtechnologydiffusionqueuesconflationmockitotesttest(mockitotestjava:23)but found this interaction:-> at compushtechnologydiffusionqueuesconflationmockitotesttest(mockitotestjava:22)for mockbactually above is the only interaction with this mock``` || reading the message i think it would read better this way : ```failed tests:   mockitotesttest:23 no interactions wanted here:-> at compushtechnologydiffusionqueuesconflationmockitotesttest(mockitotestjava:23)but found this interaction on mock b:-> at compushtechnologydiffusionqueuesconflationmockitotesttest(mockitotestjava:22)actually above is the only interaction with this mock```also could you squash those commits in a single one so both production and test are in single commit ) || i agree - the message is better your way ||;;;;1;1;improve nointeractionswanted report to include the name of the mock;
63;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improve nointeractionswanted report to include the name of the mock;this is useful feedback when using multiple mocks in verifynomoreinteractions().;;0;add rangeboundedcursor to support main data conversions;- added rangeboundedcursor + tuplestreamchunker- update uncompressedserde with some position information- this should run now:  pv data/000000_0gz | gzcat | head -10001 |  target/presto-01-snapshot-standalonejar convert csv -o data/foo -d \u0001 -t long_raw -t string_raw -t string_raw -t fmillis_raw -t fmillis_raw -t string_raw -t string_raw;;;;;1;1;updates to rangeboundedcursor + tests and main cleanup;
63;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improve nointeractionswanted report to include the name of the mock;this is useful feedback when using multiple mocks in verifynomoreinteractions().;;0;operator: min and minby;http://msdnmicrosoftcom/en-us/library/hh229286(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh228994(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229117(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229224(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229230(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229859(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229084(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh212002(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh244289(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh228951(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229715(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229095(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh228970(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229505(vvs103)aspx;;;;;0;1;;
65;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace usages of preferences by string through constants;i checked all the usage of strings for getting or setting preferences and replaced them by a the usage of a constant  if one existed. this gives some more static checking and consistency throughout the project. changes are limited to  src/main/java .   again this changes nothing functionwise  but only improves code quality.;;0;filler for non-existent issue;65;;;;;0;1;;
65;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace usages of preferences by string through constants;i checked all the usage of strings for getting or setting preferences and replaced them by a the usage of a constant  if one existed. this gives some more static checking and consistency throughout the project. changes are limited to  src/main/java .   again this changes nothing functionwise  but only improves code quality.;;0;refactoring: cleanup ignores and fix 15 compatibility;this branch contains a few cleanups i had to do after importing mockito:- there are a few more ignores required for eclipse - as mockito is configured for 15 source compatibility it should adhere to it therefore i removed the @override annotation where it would cause compile errors on 15;im ok for this pr however generally speaking for mockito i wonder if we should forget java 5 / 6 (maybe even 7) compatibility and just move over for the next mockito version ||;;;;1;1;remove @override annotation for implementing interface methodsmockito is configured with 15 source/target compatibility (according tobuildgradle) in java 5 its illegal to specify the @overrideannotation on method implementations based on interface this changeremoves those in order to have the mockito compile on 15 withoutcompilation errorssigned-off-by: gunnar wagenknecht <gunnar@wagenknechtorg>;
65;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace usages of preferences by string through constants;i checked all the usage of strings for getting or setting preferences and replaced them by a the usage of a constant  if one existed. this gives some more static checking and consistency throughout the project. changes are limited to  src/main/java .   again this changes nothing functionwise  but only improves code quality.;;0;early benchmark framework;- benchmarks will need to extend abstractbenchmark class- this version hardcodes dropping data as csv and jmeter output files- jmeter *jtl files can be picked up by jenkins performance plugin for build perf history- csv files will be used to submit data with post processing command to odsall of the benchmarks can be run with:mvn clean install exec:java;open to suggestions on this i still need to convert the existing benchmarks into this format and we need to define a dataset that will be used (will need to be uploaded to build server) || this should be good to go now i added a workaround for getting in the benchmark tpch jar file via system property until intellij can fix their stuff || ;;;;1;1;address review comments in pull #65;
65;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace usages of preferences by string through constants;i checked all the usage of strings for getting or setting preferences and replaced them by a the usage of a constant  if one existed. this gives some more static checking and consistency throughout the project. changes are limited to  src/main/java .   again this changes nothing functionwise  but only improves code quality.;;0;operator: multicast;http://msdnmicrosoftcom/en-us/library/hh211894(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229708(vvs103)aspx;good intro here:  || is this fully implemented or do we need more work beyond what was merged? ||;;;;0;1;;
68;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added custom failure message to mockito.verify. issue 482;issue 482: passing custom failure message to mockito.verify;;0;filler for non-existent issue;68;;;;;0;1;;
68;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added custom failure message to mockito.verify. issue 482;issue 482: passing custom failure message to mockito.verify;;0;added custom failure message to mockitoverify issue 482;issue 482: passing custom failure message to mockitoverify;"   @bric3 any chance that this will make it into the next build? || also it may be worth to reflect this addition to `bddmockito`before merging could you squash commits ? || ok thanks for the updates :)api may be tweaked in final 200 also  note that a `descriptable` interface may be extracted from this work itll help when we refactor hamcrest away from mockito || oh and thanks for the pr as well || thanks on jun 12 2015 1:42 pm ""brice dutheil"" notifications@githubcom wrote:> oh and thanks for the pr as well> > —> reply to this email directly or view it on github>  || ";;;;1;1;482: added custom failure message to mockitoverify;
68;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added custom failure message to mockito.verify. issue 482;issue 482: passing custom failure message to mockito.verify;;0;add basic support for distributed tuple streams;;;;;;1;1;address feedback from review #68;
68;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added custom failure message to mockito.verify. issue 482;issue 482: passing custom failure message to mockito.verify;;0;operator: range;http://msdnmicrosoftcom/en-us/library/hh229460(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211896(vvs103)aspx;the first ( is implemented in  second is waiting on schedulers || leaving open for the schedulers implementation ||;;;;0;1;;
87;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed delegatingmethod.equals() so that it s easier to extend mockito by custom verification modes;currently if you create a delegatingmethod and compare it to itself using .equals() it will show as not equal because the .equals() method expects a java.lang.reflect.method (without explicitly stating such).  this has a knock on effect on the evaluation of invocationimpl.equals() which at runtime may be using a delegatingmethod in its .equals().  i have changed .equals() and .hashcode() in delegatingmethod to a more appropriate implementation  which can handle both the case where the input object is a delegatingmethod and where it is a java.lang.reflect.method.  i ran up against this issue when creating a custom verificationmode which used invocationimpl.equals() to check that the appropriate invocation was made.  my comparison failed even though i was comparing two references to the same invocationimpl instance.;;0;filler for non-existent issue;87;;;;;0;1;;
87;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed delegatingmethod.equals() so that it s easier to extend mockito by custom verification modes;currently if you create a delegatingmethod and compare it to itself using .equals() it will show as not equal because the .equals() method expects a java.lang.reflect.method (without explicitly stating such).  this has a knock on effect on the evaluation of invocationimpl.equals() which at runtime may be using a delegatingmethod in its .equals().  i have changed .equals() and .hashcode() in delegatingmethod to a more appropriate implementation  which can handle both the case where the input object is a delegatingmethod and where it is a java.lang.reflect.method.  i ran up against this issue when creating a custom verificationmode which used invocationimpl.equals() to check that the appropriate invocation was made.  my comparison failed even though i was comparing two references to the same invocationimpl instance.;;0; delegatingmethodequals() so that its easier to extend mockito by custom verification modes;currently if you create a delegatingmethod and compare it to itself using equals() it will show as not equal because the equals() method expects a javalangreflectmethod (without explicitly stating such)  this has a knock on effect on the evaluation of invocationimplequals() which at runtime may be using a delegatingmethod in its equals()i have changed equals() and hashcode() in delegatingmethod to a more appropriate implementation which can handle both the case where the input object is a delegatingmethod and where it is a javalangreflectmethodi ran up against this issue when creating a custom verificationmode which used invocationimplequals() to check that the appropriate invocation was made  my comparison failed even though i was comparing two references to the same invocationimpl instance;"hi szczepanthanks for the reply ill simplify the methods now - do i open a new pull request or somehow edit this one?  sorry - im new to github and git!i havent used a custom verificationmode in anger yet im actually writing a tutorial on mockito and wanted to show one as an example  the one i wrote would verify that an invocation was the first invocation on a mock and i had a lot of hair pulling when the equals() of my chunk and all invocations didnt evaluate to true even though it was the same object!regardshugh || verificationmode is not a public api devs are welcome to use it and tell us about the use cases :)it does have strict backwards-compatibility constraints other words we can change it without notice however we do plan to publicize this api if only there were more days in a week :)update this pr or create a new one whatever is simpler for youthanks again! || not sure why this failed to build - the tests are passing locallythanks for the info about verificationmode - ill stick a health warning in the tutorial for that section! || the build failed due to a flaky test dont worry about it || updated again i was a bit trigger happy with the commit! hopefully thats it! :) || oh right im merging it lets see if continuous deployment actually works :) || fyi: your change is already released:  || thats pretty cool! thanks for letting me know!on 26 sep 2014 17:41 ""szczepan faber"" notifications@githubcom wrote:> fyi: your change is already released:>  > —> reply to this email directly or view it on github>  || ";;;;1;1;removing redundant null check from delegatingmethodequals();
87;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed delegatingmethod.equals() so that it s easier to extend mockito by custom verification modes;currently if you create a delegatingmethod and compare it to itself using .equals() it will show as not equal because the .equals() method expects a java.lang.reflect.method (without explicitly stating such).  this has a knock on effect on the evaluation of invocationimpl.equals() which at runtime may be using a delegatingmethod in its .equals().  i have changed .equals() and .hashcode() in delegatingmethod to a more appropriate implementation  which can handle both the case where the input object is a delegatingmethod and where it is a java.lang.reflect.method.  i ran up against this issue when creating a custom verificationmode which used invocationimpl.equals() to check that the appropriate invocation was made.  my comparison failed even though i was comparing two references to the same invocationimpl instance.;;0;dont import partition name as column;;;;;;1;1;dont import partition name as column;
87;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed delegatingmethod.equals() so that it s easier to extend mockito by custom verification modes;currently if you create a delegatingmethod and compare it to itself using .equals() it will show as not equal because the .equals() method expects a java.lang.reflect.method (without explicitly stating such).  this has a knock on effect on the evaluation of invocationimpl.equals() which at runtime may be using a delegatingmethod in its .equals().  i have changed .equals() and .hashcode() in delegatingmethod to a more appropriate implementation  which can handle both the case where the input object is a delegatingmethod and where it is a java.lang.reflect.method.  i ran up against this issue when creating a custom verificationmode which used invocationimpl.equals() to check that the appropriate invocation was made.  my comparison failed even though i was comparing two references to the same invocationimpl instance.;;0;operator: takewhile;http://msdnmicrosoftcom/en-us/library/hh244231(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229131(vvs103)aspx;;;;;0;1;;
103;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixes issue #99 : returns_deep_stubs automatically tries to create serializable mocks;see issue #99   what it does is propagating the serializing mode of the parent  upon each mock creation when deep stubbing.  before each mock created where made serializable by default. which is not an issue when the types have a default no arg constructor  but may become problematic when the type didn t have one  mockito would report an error explaining that it couldn t mock this type.;;0;filler for non-existent issue;103;;;;;0;1;;
103;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixes issue #99 : returns_deep_stubs automatically tries to create serializable mocks;see issue #99   what it does is propagating the serializing mode of the parent  upon each mock creation when deep stubbing.  before each mock created where made serializable by default. which is not an issue when the types have a default no arg constructor  but may become problematic when the type didn t have one  mockito would report an error explaining that it couldn t mock this type.;;0;fix perf regression;;;;;;1;1;dont insert final projection if final output matches underlying operators outputfix perf regression from 7cf6562f81b887c708add96711137ee3c1ee0395;
103;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixes issue #99 : returns_deep_stubs automatically tries to create serializable mocks;see issue #99   what it does is propagating the serializing mode of the parent  upon each mock creation when deep stubbing.  before each mock created where made serializable by default. which is not an issue when the types have a default no arg constructor  but may become problematic when the type didn t have one  mockito would report an error explaining that it couldn t mock this type.;;0;add more arities to zip operator;we have up to t3 now it should have at least up to t9;included in  via commit  ||;;;;0;1;;
103;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixes issue #99 : returns_deep_stubs automatically tries to create serializable mocks;see issue #99   what it does is propagating the serializing mode of the parent  upon each mock creation when deep stubbing.  before each mock created where made serializable by default. which is not an issue when the types have a default no arg constructor  but may become problematic when the type didn t have one  mockito would report an error explaining that it couldn t mock this type.;;99.0;fixes issue #99 : returns_deep_stubs automatically tries to create serializable mocks;see issue #99 what it does is propagating the serializing mode of the parent upon each mock creation when deep stubbingbefore each mock created where made serializable by default which is not an issue when the types have a default no arg constructor but may become problematic when the type didnt have one mockito would report an error explaining that it couldnt mock this type;awesome :)thanks brice for fixing the problem new version is already out   btw the release notes automation is based on the titles of the tickets in github: the better the title the better the release notes:  || ok ah yeah it makes sense i may be able to update it on the phone ||;returns_deep_stubs automatically tries to create serializable mocks;"i am just migrating from mockito 195 to 1105the following code runs fine with version 195 but breaks now:``` java  @test  public void test() {    tobemocked mock  mock(tobemockedclass returns_deep_stubs)    assertthat(mockgetsomething())isnotnull()  }  public static class tobemocked {    notserializablereturnvalue field1    public tobemocked(notserializablereturnvalue field1) {      thisfield1  field1    }    public notserializablereturnvalue getsomething() {      return field1    }  }  public static class notserializablereturnvalue {    string field1  """"    public notserializablereturnvalue(string field1) {      thisfield1  field1    }    public string getsomething2() {      return field1    }  }```orgmockitoexceptionsbasemockitoexception: you are using the setting withsettings()serializable() however the type you are trying to mock notserializablereturnvaluedo not implement serializable and do not have a no-arg constructor";heyperhaps mockito is too aggressive with this validation the thing is that this code could break if you stub some of those methods @bric3 thoughts?thanks for reporting! can you update your code and add serializable / default constructor? || i just experienced the same issue when i wanted to test our custom dsl api on my current project i believe there was some issue sometime ago before we moved to github about serialization it may relate to deep stubs ||  right?i dont really understand this validation - if i have no interest in my code being serializable nor serializing a mock/stub why do i have to make it so (and add default constructors allowing partially constructed objects) just to use deep stubs? shouldnt i have to opt-in if i need/want my deep stubs to be serializable or am i missing something? || @szczepiq hi for one occurence i was able to implement a default constructor for another occurence it did not feel sensible to add a default constructor i changed this and mocked all used method calls manually for me its ok now btw: thank you very much for sharing and caring for mockito! || for some reason the deep stub code was enabling _children_ stubs to be always serializable which doesnt make sense in the plane i crafted a fix ~~ill push it asap~~ || it should be  in 1108 || excellent thanks @bric3 ! let me take this chance to add that mockito is an excellent piece of software and a near-perfect mocking library imo - all of your efforts are highly appreciated :) i was at a workshop with michael feathers recently and was asking him whether he planned to update his book working effectively with legacy code to reflect the invent of modern (non-strict!) mocking frameworks such as mockito as in my opinion they have revolutionized dependency-breaking and bringing legacy code under test no luck but maybe someone should write a new updated such book :) || hey1108 was released to bintray/jcenter for some reason maven central syncdidnt work :(what do you think needs to be fixed so that mockito is perfect? :)on fri oct 10 2014 at 5:33 am chad notifications@githubcom wrote:> excellent thanks @bric3  ! let me take this> chance to add that mockito is an excellent piece of software and a> near-perfect mocking library imo - all of your efforts are highly> appreciated :) i was at a workshop with michael feathers recently and was> asking him whether he planned to update his book working effectively with> legacy code to reflect the invent of modern (non-strict!) mocking> frameworks such as mockito as in my opinion they have revolutionized> dependency-breaking and bringing legacy code under test no luck but maybe> someone should write a new updated such book :)> > ## > > reply to this email directly or view it on github>  szczepan fabercore dev@gradle founder@mockito ||;1;0;fixes issue #99 deep stubs where automatically marked as serializablewith this commit children mocks will use the serialization mode their parent;
113;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;improved exception handling of additionalanswers#delegatesto;when using the additionalanswers#delegatesto method  exceptions thrown by the delegate are wrapped in invocationtargetexception due to invocation via method. instead  the original exception from the delegate should be propagated to the caller.;;0;caution about ambiguity in overloaded varargs methods; given a class:class foo implements iterable&ltfoo>then:iterable&ltfoo> i  listsnewlinkedlist(new foo())is ambiguous and easily introduces bugs; java 8 introduces some new weirdness with the varargs listsnewarraylist() if you call listsnewarraylist(null) then javac7 would resolve the varargs method javac8 reports an error  reference to newarraylist is ambiguous&nbsp&nbsp&nbsp&nbsplistsnewarraylist(null)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp^&nbsp&nbspboth method &lte#1>newarraylist(iterable<? extends e#1>) in lists and method &lte#2>newarraylist(iterator<? extends e#2>) in lists match&nbsp&nbspwhere e#1e#2 are type-variables:&nbsp&nbsp&nbsp&nbspe#1 extends object declared in method &lte#1>newarraylist(iterable<? extends e#1>)&nbsp&nbsp&nbsp&nbspe#2 extends object declared in method &lte#2>newarraylist(iterator<? extends e#2>) || weve gotten away without any specific warnings about this for 10 years and the javadoc for varargs `listsnewarraylist` already warns people away from it so im just going to close this ||;;;;0;1;;
113;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;improved exception handling of additionalanswers#delegatesto;when using the additionalanswers#delegatesto method  exceptions thrown by the delegate are wrapped in invocationtargetexception due to invocation via method. instead  the original exception from the delegate should be propagated to the caller.;;0;improved exception handling of additionalanswers#delegatesto;when using the additionalanswers#delegatesto method exceptions thrown by the delegate are wrapped in invocationtargetexception due to invocation via methodinstead the original exception from the delegate should be propagated to the caller;i have updated the commit message (hopefully this is correct?) || yeah the commit message is good just putting # of the ticket links it to the issue )btw its released:  ||;;;;1;1;propagate exceptions from additionalanswers#delegatestoissue #113;
113;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;improved exception handling of additionalanswers#delegatesto;when using the additionalanswers#delegatesto method  exceptions thrown by the delegate are wrapped in invocationtargetexception due to invocation via method. instead  the original exception from the delegate should be propagated to the caller.;;0;update to spi package and fix imports;;;;;;1;1;fix imports to use correct classes;
113;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;improved exception handling of additionalanswers#delegatesto;when using the additionalanswers#delegatesto method  exceptions thrown by the delegate are wrapped in invocationtargetexception due to invocation via method. instead  the original exception from the delegate should be propagated to the caller.;;0;concat;;;;;;1;1;update comment in observable for concat;
142;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;128 : deep stubbing with generic responses in the call chain is not working;;;0;missing multimapmaker / expand functionality for mapmaker; currently i use mapmaker to create short-lived caches within a hibernatesession like ```       public static map<sessionlist<person>> personcache  new```mapmaker()weakkeys()makemap()the whole point of multimaps are to get rid of constructs like the one above if possible a makemultimap() method should create a mutable multimap withthe given features or alternatively a new multimapmaker() class thatmimics the mapmaker such a builder should have identical semanticssee also //stackoverflowcom/questions/737060/create-weak-multimap-with-google-collections; we dont feel this is an area we will be looking into in the foreseeable future--- ;;;;0;1;;
142;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;128 : deep stubbing with generic responses in the call chain is not working;;;0;join logical planning and other fixes;;;;;;1;1;graphviz printer for distributed plans;
142;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;128 : deep stubbing with generic responses in the call chain is not working;;;0;rxjava errorhandler plugin; error handler plugin plugin system;;;;;1;1;rxjavaerrorhandler plugin error handler plugin plugin system;
142;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;128 : deep stubbing with generic responses in the call chain is not working;;;128.0;128 : deep stubbing with generic responses in the call chain is not working;;"also i kind of like the original unit test in #128 i propose you include it in this pr it could be name like : `orgmockitousagebugsdeepstubsdeepstubfailingwhengenricnestedasrawtypetest` if you can amend the change ill merge the pr || done - not sure its exactly what you were asking for but i dont see other option at the moment || the final diff looks good to me !could you squash the 6 commits in a single one (in the same branch / pr) ? better for the history ) || btw you should be able to do that this way : ``` bashgit reset --soft head~6git commit --message""fixes issue #128 for deep stubs with mixed raw generics type" || i was off for few days - i see szczepan did the job so theres noting left for me :)btw happy new year!cheers || ";deep stubbing with generic responses in the call chain is not working;"deep stubbing will throw an exception if multiple generics occur in the call chain for instance consider having a mock `mymock1` that provides a function that returns a generic `t` if `t` also has a function that returns a generic an exception with the message ""raw extraction not supported for : null"" will be thrownas an example the following test will throw an exception:``` javapublic class mockitogenericsdeepstubtest {    @test    public void discoverdeepmockingofgenerics() {        myclass1 mymock1  mock(myclass1class returns_deep_stubs)        when(mymock1getnested()getnested()returnsomething())thenreturn(""hello world"")    }    public static interface myclass1 <mc2 extends myclass2> {        public mc2 getnested()    }    public static interface myclass2<mc3 extends myclass3> {        public mc3 getnested()    }    public static interface myclass3 {        public string returnsomething()    }}```you can make this test run if you step into the class `returnsdeepstubs` and change the method `withsettingsusing` to return `mocksettings` with `returnsdeepstubs` instead of `returnsdeepstubsserializationfallback` as default answer:``` javaprivate mocksettings withsettingsusing(genericmetadatasupport returntypegenericmetadata mockcreationsettings parentmocksettings) {    mocksettings mocksettings  returntypegenericmetadatahasrawextrainterfaces() ?            withsettings()extrainterfaces(returntypegenericmetadatarawextrainterfaces())            : withsettings()    return propagateserializationsettings(mocksettings parentmocksettings)            defaultanswer(this)}```however this breaks other tests and featuresi think the issue is that further generics are not possible to be mocked  returnsdeepstubsserializationfallback` since the `genericmetadatasupport` is ""closed"" at this pointthanks and kind regardstobias";;1;0;removed unnecessary imports;
144;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;enum answers implements now answer<object>;the enum type answers implements now the answer interface. this allows us to use the enum values in  mockito.mock(class answer) . this is handy when you have to test legacy code with powermockito and want to use both  @mock  and  mockito.mock(..) .      java @mock(answers=returns_deep_stubs)  classa a  classb b   public void setup(){   b= mock(classb mockito.returns_deep_stubs)   //<< static import is not possible here  but with this pull request we can use returns_deep_stubs we used in @mock. };;0;forwarding collections are easy to misuse; i had written this on an internal discussion 3 weeks ago-----8<------i believe it will be an extremely common mistake when using forwardingcollections to- override add() but forget to override addall()- override iterator() but forget to override toarray() toarray()  tostring() hashcode()etcits very easy to forget the fact that these collections forward everymethod call straight over to the delegate indiscriminately  the minimumsolution to this problem is1 more javadoc warning about this on the class and individual methods2 make collections2 methods public that users can use when they want the   standard self-use patterns instead of straight delegation   or   2-prime: have protected final methods directly in the forwardingcollection   classes for this with names like  undelegatedaddall()??  hard to name   &nbspthen users would do this      @override public boolean add(e element) {     // custom stuff   }   @override public void addall(collection<? extends e> elements) {     undelegatedaddall(elements)   }and the javadoc (mentioned in #﻿1) could refer to theseif we do that -- and i think i like the idea a lot -- we should sweepthrough our own subclasses to see where these could be used----->8------and then the following just appeared independently on our public mailing list:-----8<------it seems difficult to know how to use forwardinglist  how can youtell which methods you need to override  it looks like the code justdelegates in all situations which requires you to know how thedelegate is implemented in knowing what to override  would it bebetter to only delegate a few methods and be able to say in the apithat ""all reads go through the forwardinglist#get() and all inserts gothrough the forwardinglist#add()""  then you could easily know youonly had to override one or two methods and wouldnt have to trackdown the details of the backing listi guess in my situation the only methods that would use the delegatewould be add() and get(:int)with the general fowardingcollection i suppose you dont have a get()method but there should be a way to minimize the encapsulation breakpoints of the delegatei would have a hard time telling someone they should use theseclasses  they are filled with peril and can be easily messed upthere should at least be a disclaimer in the documentation that ""usingthese classes isnt as easy as you think"" and highlight some of thebreak points because i can see a lot of people having a heck of a timewith very tricky bugsi understand that they can be used effectively by but i worry theymake things seem too simple for and entice those that are lessvigilant----->8------"; ;;;;0;1;;
144;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;enum answers implements now answer<object>;the enum type answers implements now the answer interface. this allows us to use the enum values in  mockito.mock(class answer) . this is handy when you have to test legacy code with powermockito and want to use both  @mock  and  mockito.mock(..) .      java @mock(answers=returns_deep_stubs)  classa a  classb b   public void setup(){   b= mock(classb mockito.returns_deep_stubs)   //<< static import is not possible here  but with this pull request we can use returns_deep_stubs we used in @mock. };;0;enum answers implements now answer<object>;the enum type answers implements now the answer interface this allows us to use the enum values in `mockitomock(classanswer)` this is handy when you have to test legacy code with powermockito and want to use both `@mock` and `mockitomock()```` java@mock(answersreturns_deep_stubs) classa aclassb bpublic void setup(){  b mock(classbmockitoreturns_deep_stubs)   //<< static import is not possible here but with this pull request we can use returns_deep_stubs we used in @mock}```;good idea i like italso the ide changed too much whitespaces to see the relevant change || [![coverage status]( decreased (-002%) when pulling   thanks for the change ||;;;;1;1;add a javadoc note to indicate that this method will be removed in afuture release;
144;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;enum answers implements now answer<object>;the enum type answers implements now the answer interface. this allows us to use the enum values in  mockito.mock(class answer) . this is handy when you have to test legacy code with powermockito and want to use both  @mock  and  mockito.mock(..) .      java @mock(answers=returns_deep_stubs)  classa a  classb b   public void setup(){   b= mock(classb mockito.returns_deep_stubs)   //<< static import is not possible here  but with this pull request we can use returns_deep_stubs we used in @mock. };;0;refactor columnprinter into outputprocessor;;good to go ||;;;;1;1;refactor columnprinter into outputprocessor;
144;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;enum answers implements now answer<object>;the enum type answers implements now the answer interface. this allows us to use the enum values in  mockito.mock(class answer) . this is handy when you have to test legacy code with powermockito and want to use both  @mock  and  mockito.mock(..) .      java @mock(answers=returns_deep_stubs)  classa a  classb b   public void setup(){   b= mock(classb mockito.returns_deep_stubs)   //<< static import is not possible here  but with this pull request we can use returns_deep_stubs we used in @mock. };;0;used mockitos inorder to verify ordering instead of hand-written stub;;nice change ||;;;;1;1;used mockitos inorder to verify ordering instead of hand-written stub;
176;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make propertyandsetterinjection field sorting consistent;#155 is caused by calling  collections.sort  with a comparator that isn t always transitive  as in the case where sorting by name and sorting by type hierarchy imply different orders.  for example  with fields of type  [iterable  integer  number]   it gives  iterable == integer  and  iterable == number   but also an inconsistent  integer < number .  i m not sure it s possible to sort consistently with a stateless  comparator   so this change switches to a  sortsupertypeslast  method that first sorts by name and then shuffles any subclasses to after their superclasses. it s slower  but should be deterministic. the existing tests are preserved by leaving behind a dummy  comparator  that uses the new sort method. new tests make sure that the sorted ordering doesn t depend on the original order.  155.;;0;filler for non-existent issue;176;;;;;0;1;;
176;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make propertyandsetterinjection field sorting consistent;#155 is caused by calling  collections.sort  with a comparator that isn t always transitive  as in the case where sorting by name and sorting by type hierarchy imply different orders.  for example  with fields of type  [iterable  integer  number]   it gives  iterable == integer  and  iterable == number   but also an inconsistent  integer < number .  i m not sure it s possible to sort consistently with a stateless  comparator   so this change switches to a  sortsupertypeslast  method that first sorts by name and then shuffles any subclasses to after their superclasses. it s slower  but should be deterministic. the existing tests are preserved by leaving behind a dummy  comparator  that uses the new sort method. new tests make sure that the sorted ordering doesn t depend on the original order.  155.;;0;fix bug when partition key does not appear in predicate;;;;;;1;1;fix bug when partition key does not appear in predicate;
176;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make propertyandsetterinjection field sorting consistent;#155 is caused by calling  collections.sort  with a comparator that isn t always transitive  as in the case where sorting by name and sorting by type hierarchy imply different orders.  for example  with fields of type  [iterable  integer  number]   it gives  iterable == integer  and  iterable == number   but also an inconsistent  integer < number .  i m not sure it s possible to sort consistently with a stateless  comparator   so this change switches to a  sortsupertypeslast  method that first sorts by name and then shuffles any subclasses to after their superclasses. it s slower  but should be deterministic. the existing tests are preserved by leaving behind a dummy  comparator  that uses the new sort method. new tests make sure that the sorted ordering doesn t depend on the original order.  155.;;0;implemented groupby;for issue #51;#14  this is a difficult one with java as maintaining `groupedobservable` will require manual effort every time a new static is added and it will be very easy for it to drift away from observable in short im not a fan of relying on static method overridesim going to sit on this a bit while i think about and talk to others on this i want to better understand the groupby operator too so need to play with it || i used ide to delegate methods to underlying observable looks like it has generated statics methods as well let me remove them || ah so that wasnt intended   || in c# version `observable` is an interface and `groupedobservable` can simply extend it since in java version `observable` is a class i decided to make `groupedobservable` to be a proxy for `observable` || #17 yes your approach makes sensethe reason for the class rather than interface is because java doesnt have extension methods like c# does - otherwise wed also have observable be an interface (originally inside netflix we had observable as an interface and all implementations in abstractobservable  but everything has to work with abstractobservable  it was very awkward so we did away with it)i need to spend a few more minutes to understand this operator :-) || take a look at a different approach i took for `groupedobservable` in pull request  and let me know if you think that works okay || completed in  ||;;;;1;1;removed static methods delegations;
176;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make propertyandsetterinjection field sorting consistent;#155 is caused by calling  collections.sort  with a comparator that isn t always transitive  as in the case where sorting by name and sorting by type hierarchy imply different orders.  for example  with fields of type  [iterable  integer  number]   it gives  iterable == integer  and  iterable == number   but also an inconsistent  integer < number .  i m not sure it s possible to sort consistently with a stateless  comparator   so this change switches to a  sortsupertypeslast  method that first sorts by name and then shuffles any subclasses to after their superclasses. it s slower  but should be deterministic. the existing tests are preserved by leaving behind a dummy  comparator  that uses the new sort method. new tests make sure that the sorted ordering doesn t depend on the original order.  155.;;155.0;make propertyandsetterinjection field sorting consistent;#155 is caused by calling `collectionssort` with a comparator that isnt always transitive as in the case where sorting by name and sorting by type hierarchy imply different ordersfor example with fields of type `[iterable integer number]` it gives `iterable  integer` and `iterable  number` but also an inconsistent `integer < number`im not sure its possible to sort consistently with a stateless `comparator` so this change switches to a `sortsupertypeslast` method that first sorts by name and then shuffles any subclasses to after their superclasses its slower but should be deterministic the existing tests are preserved by leaving behind a dummy `comparator` that uses the new sort method new tests make sure that the sorted ordering doesnt depend on the original order155;"wow nice pr thanks for diving in the problem !so i agree on the idea but ive mixed feelings on having a custom sort therealso i agree speed is not the real issue here anyway id prefer the algorithm to be deterministic || finally i like the comment in the commit messages though it would be better if the last 2 commit were amended properly :) || overall its really nice work   i you think its possible to rewrite with a comparator and rewrite a clean history ill merge _asap_ :) || thanks ive rebased to clean up historyusing `comparator` is trickier id really prefer to do that and i spent some time thinking about what state could be calculated to allow pairwise comparison however this is essentially a topological sort and i cant think of a way to do this short of using a custom sort and then preparing a `comparator` that checks indexes in that versionactually checking now thats exactly the fallback suggested in [this stackoverflow answer]( the only way i see that it would be possible to do using a comparator would be to first do a topological sort and then using the indexes of the objects in this sorting as keys when implementing the comparatorid be happy to add any more tests or change the style to increase confidence that its a safe implementation || mmmmh ok it would definitely be better to have the comparator but that seems a bit complex as you said so i propose 2 things then :1 without comparator it would be better to externalize the sorting in some class instead of a method could be used like       ``` java   sorted  new orgmockitointernalutilreflectiontopologysorter()sort()   ```2 thanks for the amend i propose that the proper commits starts `155` like you did in one of the previous commits github can track identify the keyword and the issue referencesorry to be nitpicky but as soon as the pr is merged there will be an automated release :)also tests are finethanks for the feedback and the interesting links :) ||   thanks for the modifications @josephw perfect pr :) || by the way do you have any remarks on the contributing guide (missing info style guideline git stuff etc) || its great that youve got a contribution guide i think a couple of the things i missed are mentioned by it but i might over-emphasise:>  at least one commit message in the pr contains ""fixes #id""and suggest a template commit message> clean commit historyyou could make the history rewriting explicit here something like we prefer a clean commit history rebased and squashed if necessary so that each commit clearly changes one things and there are no extraneous fix-ups?thanks for the feedback -- everything else seemed specific enough that a review was the only way to pick it up || @josephw ok thanks for the feedback too || ";internal comparator violates its general contract;log from my test run  comparison method violates its general contract!    at javautiltimsortmergehi(timsortjava:868)    at javautiltimsortmergeat(timsortjava:485)    at javautiltimsortmergeforcecollapse(timsortjava:426)    at javautiltimsortsort(timsortjava:223)    at javautiltimsortsort(timsortjava:173)    at javautilarrayssort(arraysjava:659)    at javautilcollectionssort(collectionsjava:217)    at orgmockitointernalconfigurationinjectionpropertyandsetterinjectionorderedinstancefieldsfrom(propertyandsetterinjectionjava:125)    at orgmockitointernalconfigurationinjectionpropertyandsetterinjectioninjectmockcandidates(propertyandsetterinjectionjava:100)    at orgmockitointernalconfigurationinjectionpropertyandsetterinjectionprocessinjection(propertyandsetterinjectionjava:77)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyprocess(mockinjectionstrategyjava:68)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyrelayprocesstonextstrategy(mockinjectionstrategyjava:89)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyprocess(mockinjectionstrategyjava:71)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyrelayprocesstonextstrategy(mockinjectionstrategyjava:89)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyprocess(mockinjectionstrategyjava:71)    at orgmockitointernalconfigurationinjectionmockinjection$ongoingmockinjectionapply(mockinjectionjava:92)    at orgmockitointernalconfigurationdefaultinjectionengineinjectmocksonfields(defaultinjectionenginejava:20)    at orgmockitointernalconfigurationinjectingannotationengineinjectmocks(injectingannotationenginejava:100)    at orgmockitointernalconfigurationinjectingannotationengineprocessinjectmocks(injectingannotationenginejava:62)    at orgmockitointernalconfigurationinjectingannotationengineprocess(injectingannotationenginejava:56)    at orgmockitomockitoannotationsinitmocks(mockitoannotationsjava:108);it occures when bean under test has many fields (declaredfieldssize  44) ||;1;0;move the sorting into its own separate utility classcreate supertypeslastsortertest to hold the sorting implementation adjustthe tests accordingly and use it in propertyandsetterinjection;
201;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;200 : argumentcaptor.forclass is more friendly with generic types;we modify the signature of  argumentcaptor.fromclass(class<t>)  to better express the type relationship between the argument and the return type.  there is no change to the behavior of the method.  this change is to allow expressions such as:      java argumentcaptor<consumer<string>> captor = argumentcaptor.fromclass(consumer.class)      to type check  which is desirable as a convenience to users of  argumentcaptor .  we also add two tests to document this extension to the api  both of which fail to compile without this change to  argumentcaptor.fromclass .  these tests are unusual in that they make no assertions  this is justified because the change which they test is a change to the formal  or compile-time  properties of  argumentcaptor   not its behavior.;;0;filler for non-existent issue;201;;;;;0;1;;
201;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;200 : argumentcaptor.forclass is more friendly with generic types;we modify the signature of  argumentcaptor.fromclass(class<t>)  to better express the type relationship between the argument and the return type.  there is no change to the behavior of the method.  this change is to allow expressions such as:      java argumentcaptor<consumer<string>> captor = argumentcaptor.fromclass(consumer.class)      to type check  which is desirable as a convenience to users of  argumentcaptor .  we also add two tests to document this extension to the api  both of which fail to compile without this change to  argumentcaptor.fromclass .  these tests are unusual in that they make no assertions  this is justified because the change which they test is a change to the formal  or compile-time  properties of  argumentcaptor   not its behavior.;;0;make benchmark and console launcher respect maven java version;;;;;;1;1;make benchmark and console launcher respect maven java version;
201;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;200 : argumentcaptor.forclass is more friendly with generic types;we modify the signature of  argumentcaptor.fromclass(class<t>)  to better express the type relationship between the argument and the return type.  there is no change to the behavior of the method.  this change is to allow expressions such as:      java argumentcaptor<consumer<string>> captor = argumentcaptor.fromclass(consumer.class)      to type check  which is desirable as a convenience to users of  argumentcaptor .  we also add two tests to document this extension to the api  both of which fail to compile without this change to  argumentcaptor.fromclass .  these tests are unusual in that they make no assertions  this is justified because the change which they test is a change to the formal  or compile-time  properties of  argumentcaptor   not its behavior.;;0;synchronize observer on operationmerge;fix for merge serialization bug reported in  is necessary because by definition merge is subscribing to multiple sequences in parallel and is supposed to serialize them into a single observable;"#41  the fix looks goodhowever the test case does not catch the original problemfirst the test case tests an ""observablecreate(merge(o1o2)"" ( the create wraps an atomicobservablesubscription which defeats the purpose of checking whether operationmerge is chronologically well behaved itself this should be ""new observable(merge(o1o2) false)"" (where false  istrusted) or ""observablemerge(o1o2)"" this occurs in most of the test cases for operationmergeby changing the test case to properly test operationmerge the test still didnt fail on the original wrong implementationi dont have a test case that shows the original problem without resorting to threads with  sleep delays to orchestrate an interleaving || the test case in this commit forces concurrent onnext invocations and demonstrates how the changed code no longer allows concurrent onnext callswhen you say ""interleaving"" perhaps youre not referring to concurrent execution but instead how merge does not sequentially concatenate sequences? if thats what you mean then `merge` is the wrong operator and you need the `concat` operator heres the rxnet doc for concat:  this operator is available in rxjavanote that `concat` is described as:```an observable sequence that contains the elements of the first sequence followed by those of the second the sequence```whereas `merge` is:```the observable sequence that merges the elements of the observable sequences```the `merge` operator subscribes to all sequences concurrently and emits them into a single serialized sequence the `concat` operator subscribes to each sequence once at a time and thus ""merges"" them sequentiallyas for the comments about  `atomicobservablesubscription` - that is not the thing that is synchronizing it is the `synchronizedobserver` that wraps the observer to synchronize onnext calls to ensure they are serialized - ie no concurrent execution of onnextthe istrusted piece has nothing to do with concurrent execution - the `atomicobservablesubscription` is just ensuring that onnext/oncompleted/onerror obeys the contract - it does not synchronize anything and thus has nothing to do with concurrent executing interleaving etc am i missing something that causes you to say ""which defeats the purpose of checking whether operationmerge is chronologically well behaved itself""?thus with merge you can have these sequences:``` a1 a2 a3 b1 b2 b3```if the two are asynchronously and concurrently executing then they will both begin emitting immediately but onnext will not concurrently execute (which was the bug this fixes)you can then end up with this:``` a1 b1 b2 a2 b3 a3```but no longer end up with this with concurrent onnext calls like this which were possible before this commit:``` a1 b1   b3 a3        b2      a2```if youre trying to get output like this:```a1 a2 a3 b1 b2 b3```then you want the `concat` operator instead of `merge` || you are right i am confusing atomicobservablesubscription with synchronizedobserver which indeed refer to two completely different things sorry for thati do not mean the concat operation with interleaving i meant the interleaving of the calls to onnext and countdown in the test casewhen i revert the change on line  and run the test case the test case doesnt fail:```mfex@mfex:~/programming/rx-ben$ git log | head -n4commit effc08d548518df5a54c916e1b50daadb8bf4228author: ben christensen <benjchristensen@netflixcom>date:   tue mar 19 16 50 2013 -0700mfex@mfex:~/programming/rx-ben$ /gradlew rxjava-core rxjava-core:cleanbuild successfultotal time: 8355 secsmfex@mfex:~/programming/rx-ben$ /gradlew rxjava-core rxjava-core  some input files use unchecked or unsafe operationsnote: recompile with -xlint:unchecked for details:rxjava-core:processresources up-to-date:rxjava-core rxjava-core  some input files use unchecked or unsafe operationsnote: recompile with -xlint:unchecked for details:rxjava-core:processtestresources up-to-date:rxjava-core rxjava-core:testbuild successfultotal time: 19126 secsedit out the bug fixmfex@mfex:~/programming/rx-ben$ git diffdiff --git a/rxjava-core/src/main/java/rx/operators/operationmergejava b/rxjavaindex 1e6e6e76ad7a51 100644--- a/rxjava-core/src/main/java/rx/operators/operationmergejava+++ b/rxjava-core/src/main/java/rx/operators/operationmergejava@@ -1327 +1328 @@ public final class operationmerge {             /**              * subscribe to the parent observable to get to the children observ              */-            sequencessubscribe(new parentobserver(synchronizedobserver))+            //            sequencessubscribe(new parentobserver(synchronizedob+            sequencessubscribe(new parentobserver(actualobserver))             /* return our subscription to allow unsubscribing */             return oursubscriptionmfex@mfex:~/programming/rx-ben$ /gradlew rxjava-core rxjava-core:cleanbuild successfultotal time: 8131 secsmfex@mfex:~/programming/rx-ben$ /gradlew rxjava-core rxjava-core  some input files use unchecked or unsafe operationsnote: recompile with -xlint:unchecked for details:rxjava-core:processresources up-to-date:rxjava-core rxjava-core  some input files use unchecked or unsafe operationsnote: recompile with -xlint:unchecked for details:rxjava-core:processtestresources up-to-date:rxjava-core rxjava-core:testbuild successfultotal time: 19567 secsmfex@mfex:~/programming/rx-ben$``` || thats rather odd as i see the unit test doing what i expect:with this code:``` javasequencessubscribe(new parentobserver(actualobserver))```i get the failure:```rxoperatorsoperationmerge$unittest > testsynchronizationofmultiplesequences failed    javalangassertionerror at operationmergejava:445146 tests completed 1 failed:rxjava-core:test failed```with this code:``` javasequencessubscribe(new parentobserver(synchronizedobserver))```the unit test passes```build successfultotal time: 49234 secs```the `testsynchronizationofmultiplesequences` unit test is running 2 async observables that each spawn a thread i use a countdownlatch in the `testasynchronousobservable` instances to allow the unit test to wait for each to hit the point where they are calling `onnext`i then use the `endlatch` inside the `onnext` to cause the async observables to block inside the onnext call and increment the `concurrentcounter` atomicintegerif onnext is not synchronized then both threads will block on `endlatch` and `concurrentcounter` will be 2 if onnext is synchronized then only one of the threads can enter so `concurrentcounter` will be 1once i perform the assertion the `endlatch` is released to allow the callback threads to complete execution of `onnext`does this unit test correctly test the bug you originally were reporting about concurrent execution of onnext or is there something else that i am missing?---i just committed a few tweaks to improve the codeon line 136 it is now:``` java            sequencessubscribe(new parentobserver(synchronizedobserver))```if i change this to the following the unit test breaks for me:``` java            sequencessubscribe(new parentobserver(actualobserver))``` || #43 just to re-iterate: i think the fix is good this is now about the test case included in the fix> with this code:> > ```> sequencessubscribe(new parentobserver(actualobserver))> ```> > i get the failure:> > ```>  rxoperatorsoperationmerge$unittest > testsynchronizationofmultiplesequences failed>     javalangassertionerror at operationmergejava:445> 146 tests completed 1 failed> :rxjava-core:test failed> ```i dont always see failed sometimes the test does succeed```git clone  rx-200-false-positivecd rx-200-false-positivegit checkout issue-200-merge-synchronizationgit log | head -n7echo ""remove fix from code""sed -i s/synchronizedobserver<t>\ synchronizedobserver/\/\/test-remove/g rxjava-core/src/main/java/rx/operators/operationmergejavased -i s/sequencessubscribe(new\ parentobserver(synchronizedobserver))/sequencessubscribe(new parentobserver(actualobserver))/g rxjava-core/src/main/java/rx/operators/operationmergejavagit diff --exit-codeecho ""running tests""for i in {1100} do /gradlew cleantest rxjava-core:test -dtestsingle**operationmerge** done > test_run_resultstxtecho ""saw success out of 100:""echo `grep -c ""build successful"" test_run_resultstxt`echo ""saw fail out of 100: ""echo `grep -c ""build failed"" test_run_resultstxt````output:```initialized empty git repository in /home/mfex/programming/rx-200-false-positive/rx-200-false-positive/git/switched to a new branch issue-200-merge-synchronizationcommit fb555df3376301595f6596861662c654d77209d2author: ben christensen <benjchristensen@netflixcom>date:   wed mar 20 15 44 2013 -0700    synchronization of merge operator (fixes)    - return atomicsubscription not mergesubscription which i was accidentally still returningdiff --git a/rxjava-core/src/main/java/rx/operators/operationmergejava b/rxjava-core/src/main/java/rx/operators/operationmergejavaindex eeb1e96ded2383 100644--- a/rxjava-core/src/main/java/rx/operators/operationmergejava+++ b/rxjava-core/src/main/java/rx/operators/operationmergejava@@ -12812 +12812 @@ public final class operationmerge {              * bug report:               */             atomicobservablesubscription subscription  new atomicobservablesubscription(oursubscription)-            synchronizedobserver<t> synchronizedobserver  new synchronizedobserver<t>(actualobserver subscription)+            //test-remove  new synchronizedobserver<t>(actualobserver subscription)             /**              * subscribe to the parent observable to get to the children observables              */-            sequencessubscribe(new parentobserver(synchronizedobserver))+            sequencessubscribe(new parentobserver(actualobserver))             /* return our subscription to allow unsubscribing */             return subscriptionrunning testssaw success out of 100:98saw fail out of 100: 2```the test succeeding while it shouldnt doesnt happen always therefore i think that the test doesnt account for this possible interleaving of the different threads executing:| testrunner | o1 testasynchronousobservable | o2 testasynchronousobservable || --- | --- | --- || msubscribe  | - | - || - | onnextbeingsentcountdown() | - || - | observeronnext(""hello"") | - || o1onnextbeingsentawait() | - | - || - | - | onnextbeingsentcountdown() || o2onnextbeingsentawait() | - | - || assertequals(1 concurrentcounterget()) | - | - || - | - | observeronnext(""hello"") || endlatchcountdown() | - | - || - | observeroncompleted() | - || - | - | observeroncompleted() | || > ```> saw success out of 100:> 98> saw fail out of 100: > 2> ```this was on an ubuntu machineon a mac book i needed more samples for this result:```saw success out of 1000:3saw fail out of 1000: 997```something to consider when trying to reproduce the results i dont have detailed specs of the test machines available at the moment || hmm not sure yet whats wrong the test case but obviously it is not deterministic thank you for the detailed testing - ill explore what i can doif you can offer a better unit test that is deterministic (not reliant on threadsleep) for this ill gladly accept it || im holding off committing until i understand the non-determinism and can fix it  unless you would prefer i just commit the fix and worry about the unit test later || the merge operation is also used to implement mapmany ( which is even more important to get right i havent looked into the impact of the proposed fix of merge on mapmany || that should work as expected since mapmany is just a composition of `merge` and `map` it is definitely via `mapmany` that `merge` gets used most often in my experience || #70 looks good || i see in the code how the non-deterministic behavior could occur im not quite sure of a way to solve it other than using threadsleep to hopefully give each thread time to complete the `onnext` calli cant use another countdownlatch for after the call - as we want it in the middle of onnext i cant use it inside onnext as the whole point of this test is that one of them should be blocked on the synchronized onnext call thus i have no idea how to know if a thread has actually invoked but is blocked on a method  other than a thread dumpi cant replicate the non-deterministic behavior on my machine so @thegeez could you see if the fix i just committed helps on your machine?im going to proceed with the merge instead of waiting as i want to get this fix in since its passing unit tests (and manual review by both you and me) and if its still non-deterministic on your machine or elsewhere we can continue to figure out a better way to do this test || the fix in  indeed removes the false positives i saw previously for the test case || great thank you for confirming || ";;;;1;1;trying to fix non-deterministic test- not sure of a way other than putting threadsleep in here to give time after each countdownlatch triggers for the process scheduler to execute the next line of each threadsee  for more information;
201;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;200 : argumentcaptor.forclass is more friendly with generic types;we modify the signature of  argumentcaptor.fromclass(class<t>)  to better express the type relationship between the argument and the return type.  there is no change to the behavior of the method.  this change is to allow expressions such as:      java argumentcaptor<consumer<string>> captor = argumentcaptor.fromclass(consumer.class)      to type check  which is desirable as a convenience to users of  argumentcaptor .  we also add two tests to document this extension to the api  both of which fail to compile without this change to  argumentcaptor.fromclass .  these tests are unusual in that they make no assertions  this is justified because the change which they test is a change to the formal  or compile-time  properties of  argumentcaptor   not its behavior.;;200.0;200 : argumentcaptorforclass is more friendly with generic types;we modify the signature of `argumentcaptorfromclass(class<t>)` to better express the type relationship between the argument and the return type  there is no change to the behavior of the method  this change is to allow expressions such as:``` javaargumentcaptor<consumer<string>> captor  argumentcaptorfromclass(consumerclass)```to type check which is desirable as a convenience to users of `argumentcaptor`we also add two tests to document this extension to the api both of which fail to compile without this change to `argumentcaptorfromclass`  these tests are unusual in that they make no assertions this is justified because the change which they test is a change to the formal or compile-time properties of `argumentcaptor` not its behavior;almost perfect pr :)maybe the contributing guide is missing something here but the exemple `#id` should have been expended to the real gh issue number actually the commit message should be something like :```200 : tweak generic signature of argumentcaptorfromclass```ill merge it asap :)thanks for the pr by the way ! || i updated the contributing guide with an exemple :)if youre unsure how to rename the commit :``` bashgit commit --amendgit push --force``` || the travis build is broken in some way your code is fine thanks for the change :) ||;argumentcaptorfromclasss return type should match a parameterized type;`argumentcaptorfromclass`s return type should match a parameterized type  ie the expression `argumentcaptorfromclass(class<s>)` should be of type `argumentcaptor<u>` where `s` is a subtype of `u`   for example:```argumentcaptor<consumer<string>> captor  argumentcaptorfromclass(consumerclass)```does not type check (ie it is a compile time error) it should type check the reasons that it is desirable for `argumentcaptorfromclass` to allow expressions such as the example above to type check are:1) `argumentcaptorfromclass` is intended to be a convenience method to allow the user to construct an argumentcaptor without casting the returned valuecurrently the user can devise a workaround such as: ```argumentcaptor<? extends consumer<string>> captor  argumentcaptorfromclass(consumerclass)```this workaround is inconvenient and so contrary to `argumentcaptorfromclass` being a convenience method2) it is inconsistent with `@captor` which can be applied to a field with a paramterized type  ie```@captor argumentcaptor<consumer<string>> captor ```type checks;pr #201 ||;1;0;200 : tweak generic signature of argumentcaptorfromclasswe modify the signature of argumentcaptorfromclass(class<t>) to better express the type relationship between the argument and the return type  there is no change to the behaviour of the method  this change is to allow expressions such as:argumentcaptor<consumer<string>> captor  argumentcaptorfromclass(consumerclass)to type check which is desirable as a convenience to users of argumentcaptorwe also add two tests to document this extension to the api both of which fail to compile without this change to argumentcaptorfromclass  these tests are unusual in that they make no assertions this is justified because the change which they test is a change to the formal or compile-time properties of argumentcaptor not its behaviour;
202;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;better protection against incompatible returned value of default answer  and get safely mock name;fixes issue #187  the value returned by the default answer is now validated to make sure there won t be a  classcastexception  if the default value is incompatible with return type.  reporter now fetch in safer way the mock name  in case the default answer is incorrectly implemented. this avoid a  classcastexception  when reporting a verification issue.;;0;filler for non-existent issue;202;;;;;0;1;;
202;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;better protection against incompatible returned value of default answer  and get safely mock name;fixes issue #187  the value returned by the default answer is now validated to make sure there won t be a  classcastexception  if the default value is incompatible with return type.  reporter now fetch in safer way the mock name  in case the default answer is incorrectly implemented. this avoid a  classcastexception  when reporting a verification issue.;;0;upgrade to airlift 068-snapshot;fix server tests on machines with 32 processors;;;;;1;1;upgrade to airlift 068-snapshot;
202;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;better protection against incompatible returned value of default answer  and get safely mock name;fixes issue #187  the value returned by the default answer is now validated to make sure there won t be a  classcastexception  if the default value is incompatible with return type.  reporter now fetch in safer way the mock name  in case the default answer is incorrectly implemented. this avoid a  classcastexception  when reporting a verification issue.;;0;behavior of concat(observable<observable<t>>);"i have a question about the behavior of concat when given an observable of observables  currently it seems to materialize its input into a list then concat the list this runs counter to my expectation which would be that new observables could be produced while the concat is underway  in other words (a) elements from the first observable<t> should be rendered by concat() even if the observable<observable<t>> is blocked and (b) the concat()ed observable should not start pulling elements from the next observable<t> (or call oncompleted) until the current observable<t> calls oncompletedi have written a failing unit test which illustrates the behavior i was expecting: question then is (1) does this match the behavior of net (2) if so is this a design decision youre comfortable emulating and (3) if so does this match everyone elses intuition given the current documentation (which is silent on this issue)?if the answer to any of the above is ""no"" im happy to provide a patch  ";"the observable of observable in concat was something i put in last minutefor completeness  it was not the desired implementation  i meant toupdate that code but never got around to it  if you have patch pleasesend it  i probably will take a look at this weekend again    thanks forbringing this upon wed mar 20 2013 at 8:01 am abliss notifications@githubcom wrote:> i have a question about the behavior of concat when given an observable of> observables currently it seems to materialize its input into a list then> concat the list this runs counter to my expectation which would be that> new observables could be produced while the concat is underway in other> words (a) elements from the first observable should be rendered by> concat() even if the observable<observable<t>> is blocked and (b) the> concat()ed observable should not start pulling elements from the next> observable (or call oncompleted) until the current observable<t> calls> oncompleted> > i have written a failing unit test which illustrates the behavior i was> expecting:>  > my question then is (1) does this match the behavior of net (2) if so> is this a design decision youre comfortable emulating and (3) if so does> this match everyone elses intuition given the current documentation (which> is silent on this issue)?> > if the answer to any of the above is ""no"" im happy to provide a patch> > —> reply to this email directly or view it on github  || ";;;;0;1;;
202;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;better protection against incompatible returned value of default answer  and get safely mock name;fixes issue #187  the value returned by the default answer is now validated to make sure there won t be a  classcastexception  if the default value is incompatible with return type.  reporter now fetch in safer way the mock name  in case the default answer is incorrectly implemented. this avoid a  classcastexception  when reporting a verification issue.;;187.0;better protection against incompatible returned value of default answer and get safely mock name;fixes issue #187the value returned by the default answer is now validated to make sure there wont be a `classcastexception` if the default value is incompatible with return typereporter now fetch in safer way the mock name in case the default answer is incorrectly implemented this avoid a `classcastexception` when reporting a verification issue;build is ok but fail on travis ||;javalangclasscastexception: javalangclass cannot be cast to javalangstring;exception throws on verifyzerointeractions when using mock with default answerchecked on versions 1105-205all ok on 195;"hido you have a junit test so that we could reproducealso please see the [contributing guide]( || ``` javapublic class mockitotest extends mockito {    public interface testmock {        public boolean m1()    }    @test    public void test() {        testmock test  mock(testmockclass new answer() {            @override public object answer(invocationonmock invocation) throws throwable {                return false            }        })        testm1()        verifyzerointeractions(test)    }}``` || hi sorry for the late replythanks for the testcase indeed we missed something therefor reference the stacktrace is :```javalangclasscastexception: javalangboolean cannot be cast to javalangstring    at orgmockitousagebugsclasscastexonverifyzerointeractionstest$testmock$$enhancerbymockitowithcglib$$91d883c5tostring(<generated>)    at javalangstringvalueof(stringjava:2847)    at javalangstringbuilderappend(stringbuilderjava:128)    at orgmockitoexceptionsreporternomoreinteractionswanted(reporterjava:420)    at orgmockitointernalverificationnomoreinteractionsverify(nomoreinteractionsjava:24)    at orgmockitointernalmockitocoreverifynomoreinteractions(mockitocorejava:113)    at orgmockitomockitoverifyzerointeractions(mockitojava:1674)    at orgmockitousagebugsclasscastexonverifyzerointeractionstesttest(classcastexonverifyzerointeractionstestjava:23)``` || actually the usage report was improved to include the mock name however in this usage the default answer always returns `false` so when the string message is generated theres a cce because the default answer returns a `boolean`on your side the workaround is to return valid values for these `object` inherited methodson mockito side there should be two possible thing to do:- get the name safely without invoking `tostring`- validate more aggressively answers result || hello ive one doubt can we do casting for mocking objects? when i tried to do that i got ""javalangclasscastexception"" || ";1;0;ensure the default answer actually returns a compatible result related to #187;
207;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;197 : blocks ability to use negative value for timeout() and after() method.;it should  #197.   if user uses mockito.after() or mockito.timeout() with negative values  then friendly reminder exception with details will be thrown.;;0;filler for non-existent issue;207;;;;;0;1;;
207;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;197 : blocks ability to use negative value for timeout() and after() method.;it should  #197.   if user uses mockito.after() or mockito.timeout() with negative values  then friendly reminder exception with details will be thrown.;;0;flat hash aggregation;;;;;;1;1;add documentation null checks and minor cleanup for review #207;
207;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;197 : blocks ability to use negative value for timeout() and after() method.;it should  #197.   if user uses mockito.after() or mockito.timeout() with negative values  then friendly reminder exception with details will be thrown.;;0;implemented combinelatest semantics;at least if i understand them correctlythis is an attempt at resolving #29;#49  #52 #53 looks good || this looks good and fixes the behavior thank you @jmhofer for first finding this issue and then tackling the solution as i imagine it wasnt fun code to dig intothe only thing i would want to look at changing (and it originates from my original code that you were modifying) is try to move away from blocking/synchronization towards non-blocking/atomics if possible to reduce contention while still retaining the atomicity required for the contract but that is an optimization that may or may not warrant the effort and certainly does not need to hold up accepting this code as is to fix the fundamental problem ||;;;;1;1;whoops generics not allowed in @see javadoc;
207;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;197 : blocks ability to use negative value for timeout() and after() method.;it should  #197.   if user uses mockito.after() or mockito.timeout() with negative values  then friendly reminder exception with details will be thrown.;;197.0;197 : blocks ability to use negative value for timeout() and after() method;it should  #197 if user uses mockitoafter() or mockitotimeout() with negative values then friendly reminder exception with details will be thrown;first commit fixes the issue second one is a little bit of refactoring: (mostly reducing visibility and increasing encapsulation)197 : refactoring: - removed unused field from verificationovertimeimpl and also from constructors signature- improved encapsulation by removing 3 getters from verificationovertimeimpl- reduced visibility of few constructors in timeout and after classes   || nice pull request thank you !if comments are addressed ill merge right away ! || about timeouttest please look at it the whole point of this test is to pass timer object and do mocking/verifications on it if i use public constructor for this test i will not to able to pass timer objectthis is why constructor with this signature timeout(long pollingperiodmillis verificationmode delegate timer timer) was introduced by author in first place should i really touch it?btw there in so such thing like aftertest || oh yeah i see fair point just ignore what i said on thatignore the `aftertest` too i was a bit off this morning thanks for the feedback :) ||;mockitoafter() method accepts negative timeperiods and subsequent verifications always pass;eg```runnable runnable  mockitomock(runnableclass)mockitoverify(runnable mockitonever())run() // passes as expectedmockitoverify(runnable mockitoafter(1000)never())run() // passes as expectedmockitoverify(runnable mockitoafter(-1000)atleastonce())run() // passes incorrectly```;well spotted thx || i can try to fix that but need to know what exactly is the issue here:should negative values in after method be forbidden and trigger exception to be thrown? or maybe negatives are allowed here (negative value means - immediately pretty much it should behave like after(0) )? || i would vote for an illegalargumentexception being thrown || the same is happening for _timeout_ method:eg ```       someclazz mock  mockitomock(someclazzclass)       mockitoverify(mock timeout(-100))somemethod() //passes which is incorrect```if method was invoked then it passes but this negative timeout is at least confusing:```        someclazz mock  mockitomock(someclazzclass)        mocksomemethod()        mockitoverify(mock timeout(-100))somemethod() //passes``` ||;1;0;197 : timeout class constructors grouped together;
211;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;argumentcaptor no longer working for varargs;188 . these commits should  with capturing varargs.;;0;filler for non-existent issue;211;;;;;0;1;;
211;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;argumentcaptor no longer working for varargs;188 . these commits should  with capturing varargs.;;0;query gc;;other than that potential concurrency issue it ;;;;1;1;cancel abandonded queries;
211;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;argumentcaptor no longer working for varargs;188 . these commits should  with capturing varargs.;;0;remove use of jsr 305 and dependency on comgooglecodefindbugs;fixes  library and annotations were being used for trivial reasons so removing the usage so we dont have the dependency;#54  i just cloned version 0151 and the build process complains about the missing dependencyartifact comgooglecodefindbugs 139@jar not foundi thought this dependency was removed || maybe its another instance of this:  || yes it is thank you very much samuel ||;;;;1;1;remove use of jsr 305 and dependency on comgooglecodefindbugs library and annotations were being used for trivial reasons so removing the usage so we dont have the dependency;
211;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;argumentcaptor no longer working for varargs;188 . these commits should  with capturing varargs.;;188.0;argumentcaptor no longer working for varargs;188  these commits should  with capturing varargs;hi thanks for the pri will take a look at it soon and probably merge it in the mean time git history is fine except the merge commit can you get rid of it ?otherwise ill have to cherry-pick relevant commits || i will try to do rebase and then do force push hope it will work take a lookhm i see merge conflicts probably due your activity today :) || commit looks good but indeed theres some conflict to narrow down ill take a look later thanks for the rebase ) || now it should work || thanks ) ||;argumentcaptor no longer working for varargs;i ran into the issue described here: http://stackoverflowcom/questions/27303562/why-does-upgrading-mockito-from-1-9-5-to-1-10-8-break-this-captor;hi sorry for the late replyi reproduced the issue not sure when i will be able to fix though ||  by #211  ||;1;0;188 :  typo in capturesargumentsfrominvocation refactor of invocationmatcher;
215;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;adding an advanced data structure for title/word in the casechangers …;…implementation.  @koppor this is what i ment. what do you think?;;0;filler for non-existent issue;215;;;;;0;1;;
215;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;adding an advanced data structure for title/word in the casechangers …;…implementation.  @koppor this is what i ment. what do you think?;;0;improves injectmocks behavior when injectee has multiple fields of the same type;fix to @injectmocks which injected incorrectly when multiple fieldsof the same type could be injected into but only supplying 1 mockthis makes sure that whenever there are multiple type candidatesit will hold off injecting if it finds a different field which has the correct matching name;will  described in #205 ||;;;;1;1;205fix to @injectmocks which injected incorrectly when multiple fieldsof the same type could be injected into but only supplying 1 mockthis makes sure that whenever there are multiple type candidatesit will hold off injecting if it finds a different field which has the correct matching name;
215;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;adding an advanced data structure for title/word in the casechangers …;…implementation.  @koppor this is what i ment. what do you think?;;0;pass list of columns to importclient;;;;;;1;1;pass list of columns to importclient;
215;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;adding an advanced data structure for title/word in the casechangers …;…implementation.  @koppor this is what i ment. what do you think?;;0;manual merge of pull request #212;manual merge of  with small reorganization of 1 file/package;#63 ;;;;1;1;small reorganization of code for operationtake and trustedobservabletester- removed rxtesting package (if thats going to exist that means its bleeding into something that should live in /src/test and beyond what works well for inner class testing)- made trustedobservabletester part of rxoperation package and an inner unittest class so it doesnt become part of the public api;
221;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;212 : add shouldhavezerointeractions as bdd version of verifyzerointeractions;follow-up to #212;;0;filler for non-existent issue;221;;;;;0;1;;
221;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;212 : add shouldhavezerointeractions as bdd version of verifyzerointeractions;follow-up to #212;;0;change to recordcursor and pass column ids instead of names to hive client api;;;;;;1;1;pass correct column id to hive clientit was passing the column ordinal in the projected output instead of the underlying column id;
221;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;212 : add shouldhavezerointeractions as bdd version of verifyzerointeractions;follow-up to #212;;0;error handling improvements - user provided observers/functions;improve error handling as per discussion in issue  is by no means exhaustive in the search for places needing this protection but gets the most obvious ones entering via `subscribe` and `foreach`the intention is to protect against exceptions being thrown and ensure onnext/onerror/oncompleted contract compliance;"#68  #69 ive incorporated the change to restrict ""internal"" identification to rxoperatorsmerging as this seems to be a good step forward  further changes can always come in via another pull request || ";;;;1;1;"restrict identification of ""internal"" operators to only the rxoperators package- based on discussion at  dont wrap at atomicobserver again- anything outside of rxoperators will be wrapped";
221;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;212 : add shouldhavezerointeractions as bdd version of verifyzerointeractions;follow-up to #212;;212.0;212 : add shouldhavezerointeractions as bdd version of verifyzerointeractions;follow-up to #212;thanks @mkordas  ||;add bdd version of verifyzerointeractions();"right now my tests look like:``` javathen(file)should()moveto(directory)then(log)should()warn(""moved file""))verifyzerointeractions(otherfile)```would be great to have bdd replacement for `verifyzerointeractions()` then the test would be even nicer:``` javathen(file)should()moveto(directory)then(log)should()warn(""moved file""))then(otherfile)shouldhavezerointeractions()```";ok are you ready for a pr ? || @bric3 please see #221 ||;1;0;212 : add shouldhavezerointeractions as bdd version of verifyzerointeractions;
222;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;203 : introduce bdd inorder verification;follow-up to #203.;;0;filler for non-existent issue;222;;;;;0;1;;
222;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;203 : introduce bdd inorder verification;follow-up to #203.;;0;remove querystate from querycreatedevent;;;;;;1;1;remove state from querycreatedevent;
222;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;203 : introduce bdd inorder verification;follow-up to #203.;;0;pull issue 43 merge;manual merge of https://githubcom/netflix/rxjava/pull/196;#73  this finished  ||;;;;1;1;merge branch issue43 of  into pull-issue-43-mergeconflicts:	rxjava-core/src/main/java/rx/observablejava;
222;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;203 : introduce bdd inorder verification;follow-up to #203.;;203.0;203 : introduce bdd inorder verification;follow-up to #203;;introduce bdd inorder verification;"follow-up to the [discussion]( is great but right now it doesnt support inorder verification here is my proposition:##### initialization and invocations:``` javalist firstmock  mock(listclass)list secondmock  mock(listclass)firstmockadd(""was called first"")secondmockadd(""was called second"")secondmockadd(""was called second"")inorder inorder  inorder(firstmock secondmock)```##### current non-bdd solution:``` javainorderverify(firstmock)add(""was called first"")inorderverify(secondmock)add(""was called second"")```##### proposition 1:``` javainorderthen(firstmock)should()add(""was called first"")inorderthen(secondmock)should(times(2))add(""was called second"")```##### proposition 2:``` javathen(firstmock)should(inorder)add(""was called first"")then(secondmock)should(inorder times(2))add(""was called second"")```im open to other propositions what do you think? i can proceed with pr as soon as we will agree on api";it seems like a nice idea lets introduce ordered bdd id favor proposition 2 it reads better imhosince we are in a beta phase we can try and see if the api works with this proposition also it should probably be easier to implement || also sorry for this late reply || @bric3 ive implemented the second proposition i also like it more and implementation was really easy - please see #222 ||;1;0;203 : introduce bdd inorder verification;
223;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;206]  related to windows path;problem was caused by file separator. replacing hardcoded char  /  by file.seperatorchar solves issue. in the same file there is second occurence of this character but it is used with getresource(path) method -  in such case  /  is only acceptable separator.;;0;filler for non-existent issue;223;;;;;0;1;;
223;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;206]  related to windows path;problem was caused by file separator. replacing hardcoded char  /  by file.seperatorchar solves issue. in the same file there is second occurence of this character but it is used with getresource(path) method -  in such case  /  is only acceptable separator.;;0;make catalog schema and user configurable in client;;;;;;1;1;make catalog schema and user configurable in client;
223;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;206]  related to windows path;problem was caused by file separator. replacing hardcoded char  /  by file.seperatorchar solves issue. in the same file there is second occurence of this character but it is used with getresource(path) method -  in such case  /  is only acceptable separator.;;0;concat merge;1 update javadoc on subscribe() blocking if observables are running on the same thread2 add test case with infinity observable3 add test case to unsubscribe() with all observables running in different thread (non-blocking);#75  is this all good to go now @billyy and @abliss ? are you both happy with its conformance to the net implementation and the various use cases we discussed on previous pull requests? || this   ||;;;;1;1;1  update javadoc on subscribe() blocking if observables are running on the same thread2  add test case with infinity observable3  add test case to unsubscribe() with all observables running in different thread (non-blocking);
223;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;206]  related to windows path;problem was caused by file separator. replacing hardcoded char  /  by file.seperatorchar solves issue. in the same file there is second occurence of this character but it is used with getresource(path) method -  in such case  /  is only acceptable separator.;;206.0;206]  related to windows path;problem was caused by file separator replacing hardcoded char / by fileseperatorchar solves issue in the same file there is second occurence of this character but it is used with getresource(path) method -  in such case / is only acceptable separator;do i need to do something special in order to build with java 8? it looks like problem with default method - i create branch from master || dont worry about that error ill push the fix at some point todaythanks for fixing the windows test issue :) ||;nojunitdependenciestest is failing on windows machine;i found nojunitdependenciestest unit test is the only unit test that fails when you run the build on windows machine (i have also ubuntu and it is fine for some reason on unix platform)root cause: caused by: javalangnoclassdeffounderror: org\mockito\internal\invocation\invocationmarker (wrong name: org/mockito/internal/invocation/invocationmarker)full stacktrace  org\mockito\internal\invocation\invocationmarker has some dependency to junit    at orgmockitointegrationnojunitdependenciestestcheckdependency(nojunitdependenciestestjava:36)    at orgmockitointegrationnojunitdependenciestestpure_mockito_should_not_depend_junit(nojunitdependenciestestjava:28)    at sunreflectnativemethodaccessorimplinvoke0(native method)    at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:57)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javalangreflectmethodinvoke(methodjava:601)    at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:45)    at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:15)    at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:42)    at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:20)    at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:263)    at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:68)    at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:47)    at orgjunitrunnersparentrunner$3run(parentrunnerjava:231)    at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:60)    at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:229)    at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:50)    at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:222)    at orgjunitrunnersparentrunnerrun(parentrunnerjava:300)    at orggradleapiinternaltaskstestingjunitjunittestclassexecuterruntestclass(junittestclassexecuterjava:86)    at orggradleapiinternaltaskstestingjunitjunittestclassexecuterexecute(junittestclassexecuterjava:49)    at orggradleapiinternaltaskstestingjunitjunittestclassprocessorprocesstestclass(junittestclassprocessorjava:69)    at orggradleapiinternaltaskstestingsuitetestclassprocessorprocesstestclass(suitetestclassprocessorjava:48)    at sunreflectgeneratedmethodaccessor37invoke(unknown source)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javalangreflectmethodinvoke(methodjava:601)    at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:35)    at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:24)    at orggradlemessagingdispatchcontextclassloaderdispatchdispatch(contextclassloaderdispatchjava:32)    at orggradlemessagingdispatchproxydispatchadapter$dispatchinginvocationhandlerinvoke(proxydispatchadapterjava:93)    at comsunproxy$proxy2processtestclass(unknown source)    at orggradleapiinternaltaskstestingworkertestworkerprocesstestclass(testworkerjava:105)    at sunreflectgeneratedmethodaccessor36invoke(unknown source)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javalangreflectmethodinvoke(methodjava:601)    at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:35)    at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:24)    at orggradlemessagingremoteinternalhubmessagehub$handlerrun(messagehubjava:360)    at orggradleinternalconcurrentdefaultexecutorfactory$stoppableexecutorimpl$1run(defaultexecutorfactoryjava:64)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1145)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:615)    at javalangthreadrun(threadjava:722)caused by: javalangnoclassdeffounderror: org\mockito\internal\invocation\invocationmarker (wrong name: org/mockito/internal/invocation/invocationmarker)    at javalangclassloaderdefineclass1(native method)    at javalangclassloaderdefineclass(classloaderjava:791)    at javasecuritysecureclassloaderdefineclass(secureclassloaderjava:142)    at javaneturlclassloaderdefineclass(urlclassloaderjava:449)    at javaneturlclassloaderaccess$100(urlclassloaderjava:71)    at javaneturlclassloader$1run(urlclassloaderjava:361)    at javaneturlclassloader$1run(urlclassloaderjava:355)    at javasecurityaccesscontrollerdoprivileged(native method)    at javaneturlclassloaderfindclass(urlclassloaderjava:354)    at orgmockitoutilclassloaders$localexcludingurlclassloaderfindclass(classloadersjava:156)    at javalangclassloaderloadclass(classloaderjava:423)    at javalangclassloaderloadclass(classloaderjava:356)    at javalangclassforname0(native method)    at javalangclassforname(classjava:266)    at orgmockitointegrationnojunitdependenciestestcheckdependency(nojunitdependenciestestjava:34)     41 more;hithanks for reporting i dont own a windows box so i dont know if i will fix this one asapthis has probably something to do with the path thats the only thing that come to me at that time || i reproduced problem and found solution - in a sec i will create pr ||;1;0;206]  related to windows path;
229;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removes non-compact rank symbols in favor of compact rank;why? - because it is ugly :taxi:  - keep consistent icon width - removes 140 lines of code  five icons  one preference check box;;0;immutablecollectionaslist(); immutablesortedset holds items in a predicatble order in an array so can quickly provide its items by indexso its a good idea to implement list&lte> in immutablesortedset&lte>the usage is to provide iss as a list in legacy open api currently i have to copy sets items to a list each time when i asked items by open api or to hold two collections of items - one in iss to use them iternally and one in il - to return them by open api calls; ;;;;0;1;;
229;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removes non-compact rank symbols in favor of compact rank;why? - because it is ugly :taxi:  - keep consistent icon width - removes 140 lines of code  five icons  one preference check box;;0;add disabled tests for order by that highlight broken semantics;;;;;;1;1;add disabled tests for order by that highlight broken semantics;
229;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removes non-compact rank symbols in favor of compact rank;why? - because it is ugly :taxi:  - keep consistent icon width - removes 140 lines of code  five icons  one preference check box;;19.0;trying to extend the scheduler interface according to the comments at;ive tried to extend the `scheduler` interface according to the discussion at issue #19 if i understand this correctly most of it can be done via the `abstractscheduler`i hope this helps please have a look;"#85  awesome looks like it doesnt break a `scheduler` interface i thought about two examples``` java        final scheduler scheduler  schedulerscurrentthread()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(0 new func2<scheduler integer subscription>() {                    @override                    public subscription call(scheduler scheduler integer i) {                        if (i > 42) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(i)                        return schedulerschedule(i + 1 this)                    }                })            }        })        obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln(""completed"")            }            @override            public void onerror(exception e) {                systemoutprintln(""error"")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })```and``` java        final scheduler scheduler  schedulersthreadpoolforcomputation()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(new booleansubscription() new func2<scheduler booleansubscription subscription>() {                    @override                    public subscription call(scheduler scheduler booleansubscription cancel) {                        if (cancelisunsubscribed()) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(42)                        try {                            threadsleep(1000)                        } catch (interruptedexception e) {                            eprintstacktrace()                        }                        schedulerschedule(cancel this)                        return cancel                    }                })            }        })        subscription subscribe  obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln(""completed"")            }            @override            public void onerror(exception e) {                systemoutprintln(""error"")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })        threadsleep(10000)        subscribeunsubscribe()        systemoutprintln(""unsubscribe"")        threadsleep(10000)```and they worked well for me || im wondering if the `scheduler` interface really needs all of these overloads?rx has 3 primary methods (the rest are extension methods that look like they do transformations) the 2 key ones are:``` java<t> subscription schedule(t state func2<scheduler t subscription> action)<t> subscription schedule(t state func2<scheduler t subscription> action long duetime timeunit unit)```we dont have one with an explicit time to run only relative at this time || it appears the overloads all make sense  but again net is able to use extension methods to make the design much more elegant where only the main 3 are part of the interface and the rest come along for the rideit means we end up with a scheduler/abstractscheduler interface/abstract pairing to make this workshould we just make scheduler an abstract? im very tempted to do so because of the following problems:- adding methods to scheduler will be breaking changes requiring major version increments- people implementing schedulers will basically always have to also extend abstractscheduler or copy/paste all of those method overloadsor should be remove all but the main 3 methods from scheduler and put all the overloads as utility functions on the schedulers class instead?the precedent for using abstract (or concrete) classes instead of interfaces (which net then augments with extension methods) is already done - observable is a concrete class instead of interface for this very reasonall plugins  as abstracts instead of interfaces for this reason as wellthoughts? || while reviewing and playing with this i considered some changes id like to propose i have submitted another pull request ( that builds on top of your work @jmhofer and includes the unit tests from @mairbek i would appreciate your thoughts on it and whether they are beneficial changes or just pedantic || merged manually via  || ";rx schedulers;implementation of rx schedulers (  probably to go into the rxconcurrency package (https://githubcom/netflix/rxjava/tree/master/rxjava-core/src/main/java/rx/concurrency);"interesting quote from that page""if you do not use the overload which takes a scheduler as an argument rx will pick a default scheduler by using the principle of least concurrency  this means that the scheduler which introduces the least amount of concurrency that satisfies the needs of the operator is chosen  for example for operators returning an observable with a finite and small number of messages rx calls immediate  for operators returning a potentially large or infinite number of messages currentthread is called for operators which use timers threadpool is used"" || how would an operator know how many messages it is going to have? only the origin observable could know that - a given operator along the chain wont know so how does this get accomplished? || i guess this would mean that things like ""toobservable(1 2 3 4)"" are a known thing and can be done immediately without a thread but merging 4 unknown sequences cant be knownobviously when timers are used a thread of some kind is needed (javautiltimer or another implementation like this:  the majority of cases though where the ""cost"" of the observable sequence is unknown i dont know that i like automatically spawning them off on threads it has worked well for the netflix api to leave that choice to the origin of the observable (to be synchronous or asynchronous one thread or many etc)the introduction of schedulers makes perfect sense when an app is dealing with data structures their own synchronous io operations or cpu bound computations but it becomes awkward when consuming from a 3rd party api exposing observables who can and will make their own choice about being synchronous or asynchronousin fact thats been a huge part of the draw to rx is that the api doesnt need to change when the backend implementations moves between synchronous and asynchronous for whatever reason it may choose to do soif the observable is already asynchronous it would be inefficient to spin up another thread that in turn blocks on an async callother than documentation on the api calls that return observables is there a better way to handle that scenario?i can imagine a scenario where some apps (such as the netflix api) may want to disable any use of schedulers so the origin retains control since rx has allowed us to decouple the writing of business logic from the decisions of concurrencybefore flaming me  i do like schedulers its very powerful and we will definitely get them added i just have some questions about balancing that power (and inevitable inefficiencies of making poor scheduler choices) with the elegant simplicity of rx observables without them where concurrency is not a thought - everything is just asynchronousim interested in all of your perspectives so please chime in || the docs say ""least amount of concurrency"" which i interpreted to mean that if the amount of work is unknown that it would it default to immediate  we could still manipulate the defaults and probably ignore schedulers passed in through a strategy || yes i think a strategy pattern will be needed to accomplish the netflix api use case || some thoughts while working on the design of this:- the scheduler interface should be capable of supporting different sources of concurrency such as executors threads actors eventloops- we should be capable of supporting rxjava-contrib modules with new types of schedulers such as for akka/scala actors- we need the ability (via plugins probably) of a system to override or prevent usage of schedulers where they want for example if a system doesnt want client code starting threads they should be able to intercept and ignore or throw unsupportedoperationexception || sections 69 through 612 of the rx design guidelines pdf ( should be read by anyone involved in schedulers design and implementation || theres also [this video]( explaining the motivation behind introducing schedulers in rx || good video  thanks for the link || first round of schedulers implementation committed via pull request  contribued by @mairbekit implements observeon ( and subscribeon ( || open questions:### 1) scheduler timewere not using the schedulernow value anywhere should we be? or is that only for the virtual scheduler used for testing?### 2) use of subscribeon vs schedulerschedulerim trying to understand how operator overloads should use schedulerhere is a potential implementation:  and another  have not yet found c# source code or documentation that clarifies thisi have also had feedback (that i agree with) that it this is clearer:``` javamerge(o1 o2)subscribeon(scheduler)```than this``` javamerge(o1 o2 scheduler)```so is there anything different between this? ### 3) multiple schedulers in sequenceim trying to understand how a sequence should work when multiple `subscribeon` operators are applied at different steps of a sequence and it is unclear to me  how the unit test below should behavecan someone with an rxnet environment setup implement a test similar to this from java and tell me the output?``` java@test    public void testmixedschedulers() throws interruptedexception {        final string mainthreadname  threadcurrentthread()getname()        observable<string> o  observable<string> create(new func1<observer<string> subscription>() {            @override            public subscription call(observer<string> observer) {                systemoutprintln(""origin observable is running on: "" + threadcurrentthread()getname())                assertfalse(threadcurrentthread()getname()equals(mainthreadname))                asserttrue(""actually: "" + threadcurrentthread()getname() threadcurrentthread()getname()startswith(""rxiothreadpool""))                observeronnext(""one"")                observeronnext(""two"")                observeronnext(""three"")                observeroncompleted()                return subscriptionsempty()            }        })subscribeon(schedulersthreadpoolforio()) // subscribe to the source on the io thread pool        // now merge on the cpu threadpool        o  observable<string> merge(o observable<string> from(""four"" ""five""))                subscribeon(schedulersthreadpoolforcomputation())                map(new func1<string string>() {                    @override                    public string call(string v) {                        // opportunity to see what thread the merge is running on                        systemoutprintln(""merge is running on: "" + threadcurrentthread()getname())                        return v                    }                })        final countdownlatch latch  new countdownlatch(1)        final atomicreference<runtimeexception> onerror  new atomicreference<runtimeexception>()        // subscribe on a new thread        osubscribe(new observer<string>() {            @override            public void oncompleted() {                systemoutprintln(""> received oncompleted"")                latchcountdown()            }            @override            public void onerror(exception e) {                systemoutprintln(""> received onerror: "" + egetmessage())                onerrorset((runtimeexception) e)                latchcountdown()            }            @override            public void onnext(string v) {                systemoutprintln(""> final subscribe is running on: "" + threadcurrentthread()getname())                systemoutprintln(""> onnext: "" + v)            }        } schedulersnewthread())        // wait for the above to finish or blow up if its blocked        latchawait(5 timeunitseconds)    }```of course rxnet doesnt have the io and cpu thread pools  those are just helper methods to executors which would be 2 separate threadpools for different work types so youll need to adjust that || concerning 1) i guess it will come in handy when implementing #90 (or clock-like observables in general) at least if i understand this correctly im currently figuring out how working with the schedulers feels by playing around with an implementation for #74 which also requires a ""clock"" though it doesnt seem to require the current time) || i received the following feedback that will require a breaking change to the scheduler interface:---> it is essential to be able to access the scheduler inside the action to recursively schedule yourself just having a func1<subscription is not very useful since there is no opportunity to return the subscription before the function terminates``` c#interface ischeduler{schedule<tstate>(tstate s func<ischeduler tstate idisposable> a)                         schedule<tstate>(tstate s datetimeoffset d func<ischeduler tstate idisposable> a)               schedule<tstate>(tstate s timespan t func<ischeduler tstate idisposable> a)}```> you want to be able to write something like this``` c#void main(){     var repeat  observablecreate<int>(observer >     {         while(true) observeronnext(42)         return () > {}     })     //var dispose  repeatsubscribe(consolewriteline)     var dispose  observableextoobservable(newthreadschedulerdefault)                  select(_ > 42)                  subscribe(x > consolewriteline(x))     consolereadline()     disposedispose()     consolewriteline(""bye"")}static class observableex{     public static iobservable<unit> toobservable(this ischeduler scheduler)     {    return observablecreate<unit>(observer >         {              return schedulerscheduleasync(async (_scheduler token) >              {                  while(!tokeniscancellationrequested)                  {                     observeronnext(unitdefault)                       await _schedulersleep(timespanfromseconds(2))                   }              })         })     }}``` || here is another use case:``` c#var scheduler  taskpoolschedulerdefaultvar xs  observablegenerate     ( 0      i>true      i>i+1      i>i      i>timespanfromseconds(1)      scheduler     )var ys  observablecreate<int>(observer >{     return schedulerscheduleasync(async (_scheduler cancel) >     {         await _scheduleryield()         for(var i  0 !canceliscancellationrequested i++)         {              observeronnext(i)              await _schedulersleep(timespanfromseconds(1))         }     })})//var dispose  ystimestamp()subscribe(x > consolewriteline(xtostring()))var dispose  ystimestamp()dumplive()subscribe()consolereadline()disposedispose()consolewriteline(""disposed"")consolereadline()``` || note that im unavailable to work on this until the 15th anyone else who wants to jump in and determine the changes needed based on this feedback please do  || here is some simple code i was playing with to prove out the use of `subscribeon` from an ""observable api"" and it appears to be working as we want and from what i can tell it is conforming to the rx contract and not injecting concurrency where it shouldntanyone find faults in this?``` groovyimport rx*import rxconcurrencyschedulers/* * ******** producer code ********  * this is the ""observable api"" */observable<video> getvideos() {    return observablecreate({        observer ->        threadsleep(200) // simulate network traffic        // 10 videos are fetched in a batch and emitted        observeronnext(new video(1))        observeronnext(new video(2))        observeronnext(new video(3))        observeronnext(new video(4))        observeronnext(new video(5))        observeronnext(new video(6))        observeronnext(new video(7))        observeronnext(new video(8))        observeronnext(new video(9))        observeronnext(new video(10))        observeroncompleted()    })}class video {    final int id    public video(int id) {        thisid  id    }    observable<rating> getrating() {        return observablecreate({            observer ->            threadsleep(200) // simulate network traffic            observeronnext(new rating(id))            observeroncompleted()        })subscribeon(schedulersthreadpoolforio())    }    observable<bookmark> getbookmark() {        return observablecreate({            observer ->            threadsleep(200) // simulate network traffic            observeronnext(new bookmark(id))            observeroncompleted()        })subscribeon(schedulersnewthread())    }}class rating {    final string value    public rating(int id) {        thisvalue  ""ratingfor_"" + id    }}class bookmark {    final string value    public bookmark(int id) {        thisvalue  ""bookmarkfor_"" + id    }}/* * ******** consumer code ******** * this is a client consuming the ""observable api"" */long start  systemcurrenttimemillis()getvideos()mapmany({    video video ->    // fetch and transform bookmark    observable ob  videogetbookmark()map({b ->         return ""transformed-"" + bvalue    })    // fetch ratings and zip together with bookmark    return observablezip(ob videogetrating() {b r -> return [bvalue rvalue]})    map({ tuple ->        // combine all metadata for a single video        return [""id"" : videoid ""bookmark"" : tuple[0] ""rating"": tuple[1]]    })})foreach({    videomap ->    systemoutprintln(""video: "" + videomap[""id""] + ""   bookmark: "" + videomap[""bookmark""] + ""   rating: "" + videomap[""rating""] + "" thread: "" + threadcurrentthread())})long end  systemcurrenttimemillis()systemoutprintln(""time: "" + (end-start))```output is:```video: 5   bookmark: transformed-bookmarkfor_5   rating: ratingfor_5 thread: thread[rxiothreadpool-55main]video: 9   bookmark: transformed-bookmarkfor_9   rating: ratingfor_9 thread: thread[rxiothreadpool-95main]video: 10   bookmark: transformed-bookmarkfor_10   rating: ratingfor_10 thread: thread[rxiothreadpool-105main]video: 2   bookmark: transformed-bookmarkfor_2   rating: ratingfor_2 thread: thread[rxiothreadpool-25main]video: 4   bookmark: transformed-bookmarkfor_4   rating: ratingfor_4 thread: thread[rxiothreadpool-45main]video: 8   bookmark: transformed-bookmarkfor_8   rating: ratingfor_8 thread: thread[rxiothreadpool-85main]video: 6   bookmark: transformed-bookmarkfor_6   rating: ratingfor_6 thread: thread[rxiothreadpool-65main]video: 3   bookmark: transformed-bookmarkfor_3   rating: ratingfor_3 thread: thread[rxiothreadpool-35main]video: 7   bookmark: transformed-bookmarkfor_7   rating: ratingfor_7 thread: thread[rxiothreadpool-75main]video: 1   bookmark: transformed-bookmarkfor_1   rating: ratingfor_1 thread: thread[rxiothreadpool-15main]time: 659``` || @benjchristensen im left wondering if or how question 3) from your comment ( was addressed or whether this is still an open question?in our app we havent quite figured out yet which layer should be responsible for scheduling an observable if we schedule on the service layer--which would make sense when trying to make client code oblivious as to whether code runs concurrently or not--then what does that mean for reusability of observables? would say service a be able to take an observable from service b which has already been scheduled by b transform and re-schedule it?with the pre-08 schedulers this is not possible since subscribeon/observeon will wrap as many times as you call these methods || i think the javadocs havent been updated yet:  there any documentation / examples around what the state parameter is used for? looking at the existing schedulers i only ever see it being passed through so i wonder what this accomplishes? || heres an example (by @mairbek) using state:  || i forgot to upload the new javadocs  will do so once im at my laptop sorry about that  || @mttkay i found wifi  uploaded javadocs for 080also the example from @mairbek was incorporated into unit tests here:  || i believe were pretty comfortable with the `schedulers` implementation and interface as of 011/012 so closing this out || ";1;0;trying to extend the scheduler interface according to the comments at#19;
229;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removes non-compact rank symbols in favor of compact rank;why? - because it is ugly :taxi:  - keep consistent icon width - removes 140 lines of code  five icons  one preference check box;;228.0;228:  a verify() call example in @captor javadoc;;thanks for the fix :) ||;@captor javadoc contains a wrong call example;in the javadoc of `@captor`:```verify(mockdostuff(captorcapture()))```which is incorrect;cool thanks :) ||;1;0;228:  a verify() call example in @captor javadoc;
234;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cannot instantiate type with public method of a public parent class having a non public types in signature;this should 233  (awaiting delivery of bytebuddy fix   thanks @raphw;;0;filler for non-existent issue;234;;;;;0;1;;
234;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cannot instantiate type with public method of a public parent class having a non public types in signature;this should 233  (awaiting delivery of bytebuddy fix   thanks @raphw;;0;fix bug when optimizing expression containing function calls;; ;;;;0;1;;
234;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cannot instantiate type with public method of a public parent class having a non public types in signature;this should 233  (awaiting delivery of bytebuddy fix   thanks @raphw;;233.0;cannot instantiate type with public method of a public parent class having a non public types in signature;this should 233(awaiting delivery of bytebuddy fix  @raphw;actually  in bytebuddy 0610 in commit  ||;mockito 2014 fails to mock jetty httpclient;this fails:<pre>     import orgeclipsejettyclient       mock( 9210v20150310)with mockito 202-beta i can mock that class without a problem stacktrace:<pre>javalangillegalaccesserror: tried to access class orgeclipsejettyutilcomponentcontainerlifecycle$managed from class orgeclipsejettyclient    at orgeclipsejettyclient source)    at sunreflectgeneratedserializationconstructoraccessor2newinstance(unknown source)    at javalangreflectconstructornewinstance(constructorjava:408)    at orgobjenesisinstantiatorsunsunreflectionfactoryinstantiatornewinstance(sunreflectionfactoryinstantiatorjava:45)    at orgobjenesisobjenesisbasenewinstance(objenesisbasejava:73)    at orgmockitointernalcreationinstanceobjenesisinstantiatornewinstance(objenesisinstantiatorjava:14)    at orgmockitointernalcreationbytebuddybytebuddymockmakercreatemock(bytebuddymockmakerjava:27)    at orgmockitointernalutilmockutilcreatemock(mockutiljava:33)    at orgmockitointernalmockitocoremock(mockitocorejava:59)    at orgmockitomockitomock(mockitojava:1392)    at orgmockitomockitomock(mockitojava:1270)</pre>;is this an osgi package ? || also a general principle when mocking is _to not mock types you dont own_ theres several reasons for that see that [wiki page]( the issue is probably true but i cannot reproduce locally do you have additional informations like jetty version jvm version (openjdk hotspot j9 ) ? || yeah i know about that rule this is from a really tiny method and i just want to check that it invokes the start method oracle jdk8_11 jetty 9210 || the `managed` inner class is package-private:  class should never be accessible from `orgeclipsejettyclient or any mock which both live in another package i assume that you have a version clash on your class path creating a mock can trigger lazy class path resolutions that are not even triggered in your production code via the class introspection that is required to create the mock  || ok but the  class can be instantiated just fine by calling its constructorclient  new  || also the managed enum is only used inside containerlifecycle  || i now see what the problem is byte buddy overrides the public method `containerlifecycle::addbean(object o managed managed)` in order to allow mocking the method call for this the mock references the `managed` class which is however package-privatewhile this is a rather poorly designed api as the method should itself be package-private as it cannot be used outside of the package byte buddy should be smart enough to figure this out it is a small fix i have it ready some time this week thanks for reporting! || thanks i agree that the package structure and api design of jetty is a bit strange || @raphw thanks for the investigation || @christophsturm thanks for the feddback too note mockito 200 is still in beta phase || sure! we will just continue to use 202-beta for now which works great || you can use a more recent beta `208-beta` the last version before switching to bytebuddy || byte buddy 069 is released which should fix the issue sorry for the hick-up (in jcenter currently synchronizing to maven central) || no problem you were blazingly fast ! ||;1;0;233 : cannot instantiate type with public method of a public parent class having a non public types in signaturereformated a bit the generator for improved readability;
234;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cannot instantiate type with public method of a public parent class having a non public types in signature;this should 233  (awaiting delivery of bytebuddy fix   thanks @raphw;;233.0;scheduledobserver ordering;fixing issue #233blocking solution for now thinking about non-blocking alternatives;#90 #91 #92] [rxjava-pull-requests #93  this looks like an elegant solution @mairbek i cant quite figure out if theres a chance for a race condition on the counter but am merging it for now since i cant prove one way or another and this is way better than what we haveim manually merging via  since i added some unit tests || im not sure if this is a really working solution as well looks too simpleneed to think about use cases to break this code || thanks id appreciate that as i havent had time to think through those || okay this seems to be workingassuming that underlying observable implemented correctly this means that onnext oncompleted and onerror events will be called sequentially the solution itself is inspired by the way a currentthreadscheduler works except that it relies on concurrent primitives instead of threadlocali can see 4 cases:1 enqueue when queue was empty counter is set to 1 and queue processing is started since counter is atomic two processes cannot start2 enqueue when queue is not empty counter is set to 1 queue processing is already going on queue processing cannot stop since counter is atomic3 dequeue when queue has more than one element this would recursively schedule queue processing4 dequeue when queue has one item when item is processed counter would be set to 0 queue processing stopped next enqueue will schedule out new queue processing @benjchristensen what do you think?  ||;scheduledobserver doesnt guaranty ordering;"`scheduledobserver` should be reimplemented the way that it guaranties ordering of the eventsright now this test prints values in different ordering ``` java    @test    public void testtoiteratorobserveon() {        observable<string> obs  observablefrom(""one"" ""two"" ""three"" ""four"")        iterable<string> it  obsobserveon(schedulersthreadpoolforcomputation())toiterable()        for (string s : it) {            systemoutprintln(s)        }    }```";"this is used as a pass-thru for `observeon` to a `scheduler` so why does this need to ensure ordering? that should be up to the scheduler implementation should it not?for example if i need to ensure ordering then i probably dont sent it to a thread-pool but send it to a single thread (such as the ui thread)if i choose to send something to a thread-pool for execution on multiple threads why should i expect the events to all be processed and returned in order when i am specifically injecting concurrencyi cant find anything in the rx design guidelines that dictates that order should be retained and its not at all guaranteed by all operators (for example `merge` definitely does not retain order whereas `concat` does) || quote from the  _42 assume observer instances are called in a serialized fashion_> consumers of observables can safely assume that messages arrive in a serialized fashion> >    var count  0>    xssubscribe(v >>    {>    count++>    consolewriteline(""onnext has been called {0} times"" count) >    })> > in this sample no locking or interlocking is required to read and write to count as only one call to onnext can be in-flight at any timeif ordering is not guarantied we might observe `oncomplete` event before `onnext` in this case operators like `toiterator` doesnt work correctly || but i dont read that to mean ordered we must ensure the contract of onnext|oncompleted|onerror but i dont see how we need to or should ensure that execution of onnext events arrive in the same order once theyve been thrown off on a thread-pool and multiple threadsdo you think otherwise? || you can take a look at an observer wrapper we used in production in our internal version before open-sourcing that allows concurrent onnext executions but ensures the oncompleted/onerror contract:  were more lenient in our internal version about allowing concurrent execution of onnext since we forced everything to be functional and without state (which i still actually prefer and think onnext should be allowed to be concurrent) but when we open sourced i removed this since it is against the contract of official rx and do not allow concurrent onnext executionhowever it shows the principle of how onnext calls could interleave (be out of order) but still be serialized while ensuring oncompleted/onerror occur only at the end after all onnext calls are completed || thinking about this more  the ordering still isnt the part that concerns me (though maybe it should) but the real issue here is that each onnext/oncompleted/onerror could be triggered on a separate threadwe need to not only ensure only one of those is running at a time but then we ensure visibility/memory consistency this means we are basically forced into wrapping this in `synchronizedobserver` so only a single onnext/oncompleted/onerror call is happening at any given time correct?without that i cant see `observeon` complying with the rx contract || i thought if `onnext` calls are sequential it makes sense to make them sequencial in the order they have appeared ive tried to implement non-blocking algorithm to make it work #234 || > we need to not only ensure only one of those is running at a time but then we ensure visibility/memory consistency this means we are basically forced into wrapping this in synchronizedobserver so only a single onnext/oncompleted/onerror call is happening at any given time correct?using only `synchronizedobserver` itself wouldnt be helpful since it doesnt guaranty the ordering of the events `oncompleted` could be called before `onnext`it is a good question whether memory consistency/visibility should be responsibility of the library or of the observer || it would guarantee ordering if the synchronization happens before putting the event on to the scheduler since they would enter and leave the scheduler in the same order they hit the synchronizedobserverit should only be permitted to schedule one event at a time it cant schedule more than one at a time because then you can no longer prevent them from running concurrently || i believe this was  in  and  || ";1;0;fixing unittest;
235;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;clean ups;purpose was to replace more defaultformbuilders  but ended up cleaning up minor issues and removed quite a bit of disabled code from ieeexplorefetcher (bibtex fetching and multi-page search results)  which has not been working for years  and added support for a few more publication types that ieee xplore has added.;;0;filler for non-existent issue;235;;;;;0;1;;
235;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;clean ups;purpose was to replace more defaultformbuilders  but ended up cleaning up minor issues and removed quite a bit of disabled code from ieeexplorefetcher (bibtex fetching and multi-page search results)  which has not been working for years  and added support for a few more publication types that ieee xplore has added.;;0;implement in list;;;;;;1;1;implement in list;
235;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;clean ups;purpose was to replace more defaultformbuilders  but ended up cleaning up minor issues and removed quite a bit of disabled code from ieeexplorefetcher (bibtex fetching and multi-page search results)  which has not been working for years  and added support for a few more publication types that ieee xplore has added.;;0;schedulers interface (merging and adding to pull request 229);merging and adding to pull request  from @jmhofer which adds functionality discussed in the scheduler issue  done in  added the following methods to `scheduler`:- `subscription schedule(t state func2<scheduler t subscription> action long delaytime timeunit unit)`- `subscription schedule(t state func2<scheduler t subscription> action)`these are in fact the primary methods from rxnet ( and the others are just helper overloadsit seems beneficial to use these 2 methods for actual implementation logic while all other methods are just decorating and forwarding from abstractscheduler to these methodsi propose these changes on top of pull request  to achieve thisi also added unit tests that @mairbek created ( unit tests are passing … but we dont yet have enough unit test coverage so i wont be surprised if bugs are found;#94  @jmhofer @mairbek (and any others of course) i have added various inline comments and questions about the scheduler code and would appreciate your thoughts (even if its stating agreement but especially if you disagree) to determine if our approaches to these various things are correctthank you both for your involvement in this so far and continuing to do so! || @mairbek and @jmhofer i think this pull request is ready to merge though im not yet ready to release id like to leave some more time to review consider and fix thingsagree? disagree? || #96 +1 from me to merging but not releasing yet ||;;;;1;1;implement scheduler method with duetime- added method: schedule(t state func2<scheduler t subscription> action date duetime);
235;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;clean ups;purpose was to replace more defaultformbuilders  but ended up cleaning up minor issues and removed quite a bit of disabled code from ieeexplorefetcher (bibtex fetching and multi-page search results)  which has not been working for years  and added support for a few more publication types that ieee xplore has added.;;220.0;220 constructor invoking methods raise npe;in some recent version of mockito `@spy` annotation will use the constructor rather than objenesis that mean that constructor carry actual work but since the interceptor set after instantiation this raised an npe with bytebuddy it wasnt an issue with cglib but it probably didnt event intercept such calls (unconfirmed at this point)this pr aims to fix that by calling real code if interceptor is not set which can only happen if `constructorinstanciator` is usedthanks to @raphw for his tip on this regard as well : https://githubcom/raphw/byte-buddy/issues/32#issuecomment-113269844;i just saw that you chose to invoke the real method instead of returning a default value that might cause problems when the invoked method expects some state then again if the constructor is called the constructor might always receive correct input values?i added another interceptor to make the field receival a bit more convenient and runtime efficient and if you wanted to aupress the calls from the constructor (might be unsuitable for spies) i think i also found a better alternative for thati just send you a pull request on monday || yes for constructors that made sense (when spy is instantiated with constructor) though i agree with you other than this scenario it shouldnt be authorized i didnt yet wrap entirely my head around this yetim not yet sure how to ensure a bit more safety there ||;208-beta -> 209-beta unable to initialize @spy annotated field;no test failures when using 208-beta but when incrementing to 209-beta the following error occurs:```orgmockitoexceptionsbasemockitoexception: unable to initialize @spy annotated field monitortaskschedulerunable to create mock instance of type monitortaskscheduler    at netprojectdashmonitormonitortaskscheduler$mockitomock$1184625981getexecutorservice(unknown source)    at netprojectdashmonitormonitortaskscheduler<init>(monitortaskschedulerjava:39)    at netprojectdashmonitormonitortaskscheduler$mockitomock$1184625981<init>(unknown source)    at sunreflectnativeconstructoraccessorimplnewinstance0(native method)    at sunreflectnativeconstructoraccessorimplnewinstance(nativeconstructoraccessorimpljava:62)    at sunreflectdelegatingconstructoraccessorimplnewinstance(delegatingconstructoraccessorimpljava:45)    at javalangreflectconstructornewinstance(constructorjava:422)    at orgmockitointernalcreationinstanceconstructorinstantiatorinvokeconstructor(constructorinstantiatorjava:42)    at orgmockitointernalcreationinstanceconstructorinstantiatornoargconstructor(constructorinstantiatorjava:66)    at orgmockitointernalcreationinstanceconstructorinstantiatornewinstance(constructorinstantiatorjava:17)    at orgmockitointernalcreationbytebuddybytebuddymockmakercreatemock(bytebuddymockmakerjava:27)    at orgmockitointernalutilmockutilcreatemock(mockutiljava:33)    at orgmockitointernalmockitocoremock(mockitocorejava:59)    at orgmockitomockitomock(mockitojava:1284)    at orgmockitointernalconfigurationspyannotationenginenewspyinstance(spyannotationenginejava:117)    at orgmockitointernalconfigurationspyannotationengineprocess(spyannotationenginejava:67)    at orgmockitointernalconfigurationinjectingannotationengineprocessindependentannotations(injectingannotationenginejava:73)    at orgmockitointernalconfigurationinjectingannotationengineprocess(injectingannotationenginejava:55)    at orgmockitomockitoannotationsinitmocks(mockitoannotationsjava:108)    at netprojectdashmonitormonitortaskschedulertestsetup(monitortaskschedulertestjava:38)```relevant code (monitortaskschedulertestjava)``` java@spymonitortaskscheduler monitortaskscheduler@beforepublic void setup(){    mockitoannotationsinitmocks(this)}```relevant code (monitortaskschedulerjava)``` javapublic class monitortaskscheduler{    public monitortaskscheduler()    {        thisfuturetotaskmap  new concurrenthashmap<>()    }}```;"can you try with 2011-beta ? || same problem with 2011-beta (in fact i started with that version and then decremented one by one till the problem was gone) || if i had to make a (somewhat) educated guess i would say it is most likely related to 3b445aa057ada4e64b096634b011eab399f03f56 || its not really that commit it probably have to do with the change from cglib to bytebuddy i cannot reproduce locally can you craft a reproducible test ? || monitortaskschedulerjava: ``` javapublic class monitortaskscheduler{    private final map<scheduledfuture<?> monitortask> futuretotaskmap    private final scheduledexecutorservice executor    public monitortaskscheduler()    {        futuretotaskmap  new concurrenthashmap<>()        executor  (scheduledexecutorservice) getexecutorservice()    }    @visiblefortesting    executorservice getexecutorservice()    {        return new monitortaskexecutor(this)    }}```monitortaskschedulertestjava:``` java@spymonitortaskscheduler monitortaskscheduler@beforepublic void setup(){    mockitoannotationsinitmocks(this)    doreturn(new synchronousexecutor())when(monitortaskscheduler)getexecutorservice()}@testpublic void test(){    monitortaskschedulerschedule(() -> { systemoutprintln(""task"") })}public class synchronousexecutor extends abstractexecutorservice{    private volatile boolean shutdown    public void shutdown()    {        shutdown  true    }    public list<runnable> shutdownnow()    {        return null    }    public boolean isshutdown()    {        return shutdown    }    public boolean isterminated()    {        return shutdown    }    public boolean awaittermination(long time timeunit unit) throws interruptedexception    {        return true    }    public void execute(runnable runnable)    {        runnablerun()    }}``` || ive identified an issue but the given code is incomplete and i dont get the same stacktrace so it may be another issueheres mine : ``` javapublic class construcotrinvokingmethodshouldworktest {    @spy hasconstructorinvokingmethod hasconstructorinvokingmethod    @test    public void should_be_able_to_create_spy() throws exception {        mockitoannotationsinitmocks(this)    }    private static class hasconstructorinvokingmethod {        public hasconstructorinvokingmethod() {            somemethod()        }        void somemethod() { }    }}```in the meantime two workaround sticks to an older version or modify the code so it doesnt call methods in the constructor which may indicate the design is wrong in oop (builders or factory to the rescue) || actually there maybe a better workaround using the `mockitospy()` factory method``` javaclass monitortaskschedulertest {// @spymonitortaskscheduler monitortaskscheduler  spy(new minitortaskscheduler())```this even works with `@injectmocks` || sorry for not providing a complete examplewas trying to copy and paste stuff from difference sources for simplification purposes glad you were at least able to identify an issue out of it i will take your suggestions and do what i can  youre welcome thanks for testing betas ) || 2d036ec  my original issue indeed! thanks so much great work || ";1;0;220 : invokes real method when using constructor instanciator;
238;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moves responsibility of istypemockable to mockmaker;mock makers may have different capabilities. historically cglib and mockito were deeply related  later mockmaker was created to allow android developers to use dexmaker to create mocks. but logic that decided if a type could be mocked still reside in the mockito base  while it should be the responsibility of the mockmaker.  also for example one could create his own mockmaker that forbid to mock type if some annotation is present.;;0;filler for non-existent issue;238;;;;;0;1;;
238;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moves responsibility of istypemockable to mockmaker;mock makers may have different capabilities. historically cglib and mockito were deeply related  later mockmaker was created to allow android developers to use dexmaker to create mocks. but logic that decided if a type could be mocked still reside in the mockito base  while it should be the responsibility of the mockmaker.  also for example one could create his own mockmaker that forbid to mock type if some annotation is present.;;0;moves responsibility of istypemockable to mockmaker;mock makers may have different capabilities historically cglib and mockito were deeply related later mockmaker was created to allow android developers to use dexmaker to create mocks but logic that decided if a type could be mocked still reside in the mockito base while it should be the responsibility of the mockmakeralso for example one could create his own mockmaker that forbid to mock type if some annotation is present;perfect thanks!ive added the incompatibility label so that we can generate migration guide automatically || ok im still polishing this one a bit ||;;;;1;1;improves this test behavior when run inside idea;
238;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moves responsibility of istypemockable to mockmaker;mock makers may have different capabilities. historically cglib and mockito were deeply related  later mockmaker was created to allow android developers to use dexmaker to create mocks. but logic that decided if a type could be mocked still reside in the mockito base  while it should be the responsibility of the mockmaker.  also for example one could create his own mockmaker that forbid to mock type if some annotation is present.;;0;implement case statement;;;;;;1;1;implement case statement;
238;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moves responsibility of istypemockable to mockmaker;mock makers may have different capabilities. historically cglib and mockito were deeply related  later mockmaker was created to allow android developers to use dexmaker to create mocks. but logic that decided if a type could be mocked still reside in the mockito base  while it should be the responsibility of the mockmaker.  also for example one could create his own mockmaker that forbid to mock type if some annotation is present.;;0;scheduledobserver/observeon - manual merge of pull 234;manual merge of  with some unit test tweaks and additions;#99  this pull request resolved outstanding issues reported for schedulers  released in version 070 ||;;;;1;1;observeon and subscribeon concurrency unit tests- these are very rudimentary and may have a determinism problem due to the threadsleep;
239;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;remove edit preamble and edit strings from toolbar. it is still avail…;…able under the bibtex menu.;;0;filler for non-existent issue;239;;;;;0;1;;
239;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;remove edit preamble and edit strings from toolbar. it is still avail…;…able under the bibtex menu.;;0;rework stubbing api with consecutive vararg to avoid jdk7+ warnings;"the motivation behind this rework is that developers using jdk7+ see compiler warnings on some varargs methodswhile these warning are false alarms users may not feel the same way these compiler warnings cannot be entirely avoided  annotations like `@safevarargs` dont work on interfaces and `@suppresswarning({""unchecked"" ""varargs""})` have a limited impact on user code**as these annotations have limited impact and most people use a single argument anyway i propose to to introduce api that takes a single argument while an overload can takes more arguments**if we dont do that ie if we keep the same api with compiler warnings it may encourages users to add `@suppresswarning({""unchecked"" ""varargs""})` in their test code thus potentially hiding bugs in their code base";  ;;;;1;1;adds more bdd will(answer);
239;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;remove edit preamble and edit strings from toolbar. it is still avail…;…able under the bibtex menu.;;0;implement cast;;;;;;1;1;implement cast;
239;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;remove edit preamble and edit strings from toolbar. it is still avail…;…able under the bibtex menu.;;0;currentthreadscheduler delayed execution fix;added unit tests for the delayed execution for `currentthreadscheduler`re-implemented queueing in order to make those tests pass;#100  thanks for improving this ||;;;;1;1;merge branch master into sched-priorityqueueconflicts:	rxjava-core/src/main/java/rx/concurrency/sleepingactionjava;
240;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fixes coverage reports;test coverage reports have been broken with gradle without satisfying explanation  for quite some time. this pull request hopes to fix things;;0;filler for non-existent issue;240;;;;;0;1;;
240;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fixes coverage reports;test coverage reports have been broken with gradle without satisfying explanation  for quite some time. this pull request hopes to fix things;;0;fixes coverage reports;test coverage reports have been broken with gradle without satisfying explanation for quite some time this pull request hopes to fix things;this can close #164 as well ||;;;;1;1;fixes coverage reports;
240;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fixes coverage reports;test coverage reports have been broken with gradle without satisfying explanation  for quite some time. this pull request hopes to fix things;;0;count column;;;;;;0;1;;
240;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fixes coverage reports;test coverage reports have been broken with gradle without satisfying explanation  for quite some time. this pull request hopes to fix things;;0;update testscheduler to match merged scheduler changes;- i accidentally merged this code before fixing it to match the changes to abstractscheduler/scheduler;#101 ;;;;1;1;update testscheduler to match merged scheduler changes- i accidentally merged this code before fixing it to match the changes to abstractscheduler/scheduler;
252;0;1;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;251] migrate fest assert code to assertj;251;;0;nullpointerexception in mapmaker; i ran code attached and got the following exception while monitoring it under jvisualvm (jdk160_14 google-collections:10-rc2)28092009 21 34 comgooglecommonbaseinternalfinalizer cleanupsevere: error cleaning up after referencejavalangreflectinvocationtargetexception&nbsp&nbsp&nbsp&nbspat sunreflectgeneratedmethodaccessor47invoke(unknown source)&nbsp&nbsp&nbsp&nbspat sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:25)&nbsp&nbsp&nbsp&nbspat javalangreflectmethodinvoke(methodjava:597)&nbsp&nbsp&nbsp&nbspat comgooglecommonbaseinternalfinalizercleanup(finalizerjava:154)&nbsp&nbsp&nbsp&nbspat comgooglecommonbaseinternalfinalizerrun(finalizerjava:127)caused by: javalangnullpointerexception&nbsp&nbsp&nbsp&nbspat comgooglecommoncollectmapmaker$softentryfinalizereferent(mapmakerjava:954)&nbsp&nbsp&nbsp&nbsp 5 more; mapmaker has been basically rewritten since this was reported please reopen if it (or something similar) is still occurring :-)--- ;;;;0;1;;
252;0;1;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;251] migrate fest assert code to assertj;251;;0;fix some analyzer bugs;; ;;;;0;1;;
252;0;1;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;251] migrate fest assert code to assertj;251;;0;observabletofuture;;#111 ;;;;1;1;observabletofuture;
252;0;1;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;251] migrate fest assert code to assertj;251;;251.0;251] migrate fest assert code to assertj;251;  ;unit tests improvements: migrate from legacy fest assert code to assertj;triggered by #250;;1;0;251] migrate fest assert code to assertj251;
261;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;260: typo in documentation;very minor typo in documentation:   there s an extra  at  (@) in the documentation.  before it reads:  annotating the junit test class with a @runwith(@mockitojunitrunner.class)   after it reads:  annotating the junit test class with a @runwith(mockitojunitrunner.class)   (https://cloud.ent.com/assets/338917/8634099/6c7f5264-27b8-11e5-93d9-98b725c9f749.png);;0;filler for non-existent issue;261;;;;;0;1;;
261;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;260: typo in documentation;very minor typo in documentation:   there s an extra  at  (@) in the documentation.  before it reads:  annotating the junit test class with a @runwith(@mockitojunitrunner.class)   after it reads:  annotating the junit test class with a @runwith(mockitojunitrunner.class)   (https://cloud.ent.com/assets/338917/8634099/6c7f5264-27b8-11e5-93d9-98b725c9f749.png);;0;npe when handling ctrl-c;exception in thread ""sigint handler"" javalangnullpointerexception    at comfacebookprestoserver    at comfacebookprestoserver    at comfacebookprestocliquerycancelleafstage(queryjava:102)    at comfacebookprestocliquery$1handle(queryjava:47)```"; ||;;;;0;1;;
261;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;260: typo in documentation;very minor typo in documentation:   there s an extra  at  (@) in the documentation.  before it reads:  annotating the junit test class with a @runwith(@mockitojunitrunner.class)   after it reads:  annotating the junit test class with a @runwith(mockitojunitrunner.class)   (https://cloud.ent.com/assets/338917/8634099/6c7f5264-27b8-11e5-93d9-98b725c9f749.png);;0;multicast: `observablepublish()`;a very little api addition: publishing observables without requiring a `subject` see #65 (and http://northhorizonnet/2011/sharing-in-rx/);i happened to implement this last night as well as `replay` and `cache` in  || #132  oh haha funny then this pull request is superfluous || could you take a quick look at the other pull request to confirm correctness of the 3 operators? i added a unit test for each of them as well || as far as i can see this thanks @jmhofer  ||;;;;0;1;;
261;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;260: typo in documentation;very minor typo in documentation:   there s an extra  at  (@) in the documentation.  before it reads:  annotating the junit test class with a @runwith(@mockitojunitrunner.class)   after it reads:  annotating the junit test class with a @runwith(mockitojunitrunner.class)   (https://cloud.ent.com/assets/338917/8634099/6c7f5264-27b8-11e5-93d9-98b725c9f749.png);;260.0;260: typo in documentation;"very minor typo in documentation:  an extra ""at"" (@) in the documentationbefore it reads:""annotating the junit test class with a @runwith(@mockitojunitrunnerclass)""after it reads:""annotating the junit test class with a @runwith(mockitojunitrunnerclass)""(https://cloudentcom/assets/338917/8634099/6c7f5264-27b8-11e5-93d9-98b725c9f749png)";   merging **#261**   cool thanks for the fix :) ||;typo in documentation;"very minor thing theres an extra ""at"" (@) in the documentationif you go to http://sitemockitoorg/mockito/docs/current/org/mockito/mockitohtml#33(https://cloudentcom/assets/338917/8634099/6c7f5264-27b8-11e5-93d9-98b725c9f749png)";;1;0;"260: typo in documentationtheres an extra ""at"" (@) in the documentationbefore it reads:""annotating the junit test class with a @runwith(@mockitojunitrunnerclass)""after it reads:""annotating the junit test class with a @runwith(mockitojunitrunnerclass)""";
264;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove unused menus for import/export;found some dead code in jabrefframe which has been used to generate submenus for custom imports/exports.   would be glad if someone checks whether this is okay.;;0;filler for non-existent issue;264;;;;;0;1;;
264;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove unused menus for import/export;found some dead code in jabrefframe which has been used to generate submenus for custom imports/exports.   would be glad if someone checks whether this is okay.;;0;fix typo in docs missing breaklines; 32 and 33 show inline because they are missing a breakline(https://cloudentcom/assets/338917/8639441/43dba808-28a8-11e5-8e9e-5bfc9dcc92bbpng);  ;;;;1;1;fix typo in docs missing breaklines;
264;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove unused menus for import/export;found some dead code in jabrefframe which has been used to generate submenus for custom imports/exports.   would be glad if someone checks whether this is okay.;;0;count column should return 0 if all values are null;;;;;;1;1;count column should return 0 if all values are null;
264;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove unused menus for import/export;found some dead code in jabrefframe which has been used to generate submenus for custom imports/exports.   would be glad if someone checks whether this is okay.;;0;merge behaviorsubject from pull 256;manual merge of  additionally removes synchronizedobserver usage from subject implementations- we dont need to add synchronization as the subjects can trust their source observables to comply with the rx contract- this optimization follows rx design guidelines 68 avoid serializing operatorsthis was discussed at https://githubcom/netflix/rxjava/pull/256;;;;;1;1;removing synchronizedobserver usage from subject implementations- we dont need to add synchronization as the subjects can trust their source observables to comply with the rx contract- this optimization follows rx design guidelines 68 avoid serializing operatorsthis was discussed at https://githubcom/netflix/rxjava/pull/256;
270;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;issue #268: added support for generic arrays as return types.;solves  by explicitly checking for return types that represent a generic array and by resolving for the array s component type.;;0;filler for non-existent issue;270;;;;;0;1;;
270;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;issue #268: added support for generic arrays as return types.;solves  by explicitly checking for return types that represent a generic array and by resolving for the array s component type.;;0;allow null stageinfos when computing global stats;;;;;;1;1;allow null stageinfos when computing global stats;
270;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;issue #268: added support for generic arrays as return types.;solves  by explicitly checking for return types that represent a generic array and by resolving for the array s component type.;;0;blocking behaviour in rxjava;"firstly - thanks for a great library :)i am in the process of getting rxjava to play nicely with vertx  you dont know vertx its (very roughly) a polyglot reactor implementation for the jvm i guess you can think of it superficially as a ""nodejs for the jvm""vertx provides 100% asynchronous apis for our users and everything is executed on an event loop - the exact same thread is always used for any piece of user codevertx (like nodejs) apis generally take the form of:void dosomething(someparam handler handler)where handler is a callback handler that gets executed asynchronously on the event loop when the result is availablethe idea with the rxjava module i am developing for vertx is we can wrap these vertx apis so instead of taking handlers they instead return observablethis means they become composable with rxjava and we can get rid of ""callback hell""since everything is executed on the event loop in vertx its essential that the rxjava api is 100% non-blockingmost things do indeed seem to be non-blocking but i hit a snag with the concat operation where the subscribe seems unfortunately to be blocking egobservable<message<string>> concatenated  observableconcat(obs1 obs2 obs3)concatenatedsubscribe(action) // this blocks!!unfortunately this will cause vertx to hang since the thread that blocks is the same thread that the events will be delivered on so they will never arrive :(looking at the code in operationconcatjava i can see that a countdownlatch is being usedi cant see a good reason why any of the main operations in rxjava (including concat) cant be implemented in a 100% non blocking way and this would be essential for vertx to use themdo you have any plans to refactor concat to work in a non blocking way? we would love to use rxjava in vertx and i think vertx would be a good vehicle to push rxjava to an even bigger audience :)thanks in advance[also i noticed that last() is also blocking which makes it unusable in vertx (or any non blocking system) again i cant see a reason why it has to be]";"in rxnet all blocking operators are deprecated so perhaps we should not have last in rxjava however if you really want the last value of a stream you ultimately need to block somewhere (your main program cannot terminate before seeing it) you may also see some operators blocking when you use their default schedulers (where the assumption is that in the typical case they perform ""a small amount of work"" which is debatable)in addition to providing “await” support for observable sequences we’ve also added async variants of a number of operators first of all we’ve deprecated blocking operations in favor of asynchronous ones those include:first[ordefault]asynclast[ordefault]asyncsingle[ordefault]asyncforeachasyncon may 14 2013 at 5:03 am tim fox notifications@githubcom wrote:> firstly - thanks for a great library :)> > i am in the process of getting rxjava to play nicely with vertx  > if you dont know vertx its (very roughly) a polyglot reactor implementation for the jvm i guess you can think of it superficially as a ""nodejs for the jvm""> > vertx provides 100% asynchronous apis for our users and everything is executed on an event loop - the exact same thread is always used for any piece of user code> > vertx (like nodejs) apis generally take the form of:> > void dosomething(someparam handler handler)> > where handler is a callback handler that gets executed asynchronously on the event loop when the result is available> > the idea with the rxjava module i am developing for vertx is we can wrap these vertx apis so instead of taking handlers they instead return observable> > this means they become composable with rxjava and we can get rid of ""callback hell""> > since everything is executed on the event loop in vertx its essentially that the rxjava is 100% non-blocking> > most things do indeed seem to be non-blocking but i hit a snag with the concat operation where the subscribe seems unfortunately to be blocking eg> > observable> concatenated  observableconcat(obs1 obs2 obs3)> concatenatedsubscribe(action) // this blocks!!> > unfortunately this will cause vertx to hang since the thread that blocks is the same thread that the events will be delivered on so they will never arrive :(> > looking at the code in operationconcatjava i can see that a countdownlatch is being used> > i cant see a good reason why any of the main operations in rxjava (including concat) cant be implemented in a 100% non blocking way and this would be essential for vertx to use them> > do you have any plans to refactor concat to work in a non blocking way? we would love to use rxjava in vertx and i think vertx would be a good vehicle to push rxjava to an even bigger audience :)> > thanks in advance> > [also i noticed that last() is also blocking which makes it unusable in vertx (or any non blocking system) again i cant see a reason why it has to be]> > —> reply to this email directly or view it on github || thanksim not to bothered about last() its really the blocking nature of the concat operator which is the main problemon 14/05/13 16:12 headinthebox wrote:> in rxnet all blocking operators are deprecated so perhaps we should not have last in rxjava however if you really want the last value of a stream you ultimately need to block somewhere (your main program cannot terminate before seeing it)> you may also see some operators blocking when you use their default schedulers (where the assumption is that in the typical case they perform ""a small amount of work"" which is debatable)> > in addition to providing “await” support for observable sequences we’ve also added async variants of a number of operators first of all we’ve deprecated blocking operations in favor of asynchronous ones those include:> > first[ordefault]async> last[ordefault]async> single[ordefault]async> foreachasync> > on may 14 2013 at 5:03 am tim fox notifications@githubcom wrote:> > > firstly - thanks for a great library :)> > > > i am in the process of getting rxjava to play nicely with vertx  > > > if you dont know vertx its (very roughly) a polyglot reactor implementation for the jvm i guess you can think of it superficially as a ""nodejs for the jvm""> > > > vertx provides 100% asynchronous apis for our users and everything is executed on an event loop - the exact same thread is always used for any piece of user code> > > > vertx (like nodejs) apis generally take the form of:> > > > void dosomething(someparam handler handler)> > > > where handler is a callback handler that gets executed asynchronously on the event loop when the result is available> > > > the idea with the rxjava module i am developing for vertx is we can wrap these vertx apis so instead of taking handlers they instead return observable> > > > this means they become composable with rxjava and we can get rid of ""callback hell""> > > > since everything is executed on the event loop in vertx its essentially that the rxjava is 100% non-blocking> > > > most things do indeed seem to be non-blocking but i hit a snag with the concat operation where the subscribe seems unfortunately to be blocking eg> > > > observable> concatenated  observableconcat(obs1 obs2 obs3)> > concatenatedsubscribe(action) // this blocks!!> > > > unfortunately this will cause vertx to hang since the thread that blocks is the same thread that the events will be delivered on so they will never arrive :(> > > > looking at the code in operationconcatjava i can see that a countdownlatch is being used> > > > i cant see a good reason why any of the main operations in rxjava (including concat) cant be implemented in a 100% non blocking way and this would be essential for vertx to use them> > > > do you have any plans to refactor concat to work in a non blocking way? we would love to use rxjava in vertx and i think vertx would be a good vehicle to push rxjava to an even bigger audience :)> > > > thanks in advance> > > > [also i noticed that last() is also blocking which makes it unusable in vertx (or any non blocking system) again i cant see a reason why it has to be]> > > > —> > reply to this email directly or view it on github> > > > ---> > > > reply to this email directly or view it on github:> >  || hi tim great to hear from you vertx is what i tell everyone they should use when they talk about nodejs and id be happy to work with you to resolve any issues preventing adoption of rx inside vertx as i feel they are a perfect fit for each other (its unfortunate to see promises become the standard in many other libraries and frameworks when rx observable/observer can handle the promise use cases plus sequences event notifications infinite streams scheduling etc while still retaining a simple mental model)> the idea with the rxjava module i am developing for vertx is we can wrap these vertx apis so instead of taking handlers they instead return observablethis sounds perfect and exactly what i would like to see when using the vertx apis> most things do indeed seem to be non-blocking but i hit a snag with the concat operation where the subscribe seems unfortunately to be blockingthe blocking nature of `concat` is a bug as it is supposed to be non-blocking i or someone else can get on fixing thatas for the blocking operators id really like to remove them from `observable` and perhaps put them in a `blockingobservable` where people can use them if they wantfor example:``` javablockingobservablefrom(normalobservable)single()```when we started with rxjava internally we didnt have any blocking operators as the whole point of this library for us was non-blocking composition of asynchronous observables they have been contributed since becoming open-source and ive been allowing them in so far since that is how rxnet does it and weve been trying to conform to rxnet as closely as possible (but ive been wanting to find a way to separate them that still maintains the spirit of that principle)@headinthebox thanks erik for getting involved (for anyone who does not know who erik meijer is he is the inventor of rx and was behind the original implementation at microsoft)erik due to your statement would you be comfortable with me pulling all of the blocking operators into a separate `blockingobservable` that people can use if they want? the benefit to me is that they are still there for people consciously choosing to use them (so they dont lose that functionality) but they would not be part of the main `observable` behavior and thus not confuse people and cause people to accidentally block (such as the difference between `last` and `takelast`)i would like to do this soon as part of version 09 and get the breaking changes out of the way before major systems get too far integrated (example: at netflix ive been struggling with how to prevent use of blocking operators in a graceful way in our api layer) i have reserved the right to do breaking changes for things such as this until we hit 10 (which is still a bit out) to ensure we get the long-term design correct i think this deserves the change as im not happy with where weve ended up mixing blocking and non-blocking operators || hi benthanks for the replyglad to hear that the blocking nature of concat is not intended +1 on the idea to move all the blocking stuff out i think it would be cleaner to keep it nice and 100% non blocking || @purplefox once we get these issues resolved (both have pull requests for review right now) is there anything else preventing adoption? || now that 090 is released can you confirm whether this issue is resolved or not?  || thanks ben i will take it for a spin asap :) || closing out as i believe this is resolved if anything is blocking in 09 or later (other than in `blockingobservable`) then please file another issue or re-open this one || ";;;;0;1;;
270;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;issue #268: added support for generic arrays as return types.;solves  by explicitly checking for return types that represent a generic array and by resolving for the array s component type.;;268.0;issue #268: added support for generic arrays as return types;solves  by explicitly checking for return types that represent a generic array and by resolving for the arrays component type;  ;return_deep_stubs and toarray(t) stops working with versions > 195;with version 195 the following test works without a problem:```  @test  public void toarraytypeddoesnotwork() throws exception {    container container  mock(containerclass returns_deep_stubs)    containergetinnercontainer()gettheproblem()toarray(new string{})  }  class container {    private innercontainer innercontainer    public innercontainer getinnercontainer() {      return innercontainer    }  }  class innercontainer {    private set<string> theproblem    public set<string> gettheproblem() {      return theproblem    }  }```with version 1100 and beyond (including 2026-beta) the following exception gets thrown```orgmockitoexceptionsbasemockitoexception: ouch it shouldnt happen type sunreflectgenericsreflectiveobjectsgenericarraytypeimpl on method : public abstract <t> t javautilsettoarray(t) is not supported : t    at eulindenbaumtoarrayproblemtesttoarraytypeddoesnotwork(bookingwebservicetestjava:102)    at sunreflectnativemethodaccessorimplinvoke0(native method)    at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)    at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)    at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)    at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)    at orgjunitinternalrunnersstatementsrunbeforesevaluate(runbeforesjava:26)    at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)    at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)    at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)    at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)    at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)    at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)    at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)    at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)    at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)    at orgjunitrunnerjunitcorerun(junitcorejava:137)    at comintellijjunit4junit4ideatestrunnerstartrunnerwithargs(junit4ideatestrunnerjava:78)    at comintellijrtexecutionjunitjunitstarterpreparestreamsandstart(junitstarterjava:212)    at comintellijrtexecutionjunitjunitstartermain(junitstarterjava:68)    at sunreflectnativemethodaccessorimplinvoke0(native method)    at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)    at comintellijrtexecutionapplicationappmainmain(appmainjava:140)```using```    container container  mock(containerclass returns_mocks)```instead of```    container container  mock(containerclass returns_deep_stubs)```works;i looked at the code and it seems like there is no specific handler for generic arrays the strange thing is that there never was onedid you maybe run with a different java version in the process? until java 7 non-generic arrays were also represented by instances of `genericarraytype` when returned from the generic reflection methods since java 7 generic arrays with a non-generic component type are properly resolved as `class` instancesnevertheless this needs a fix in mockito as i understand it i just sent a pull request || the test code is executed using oracle java 8 (18040-b25) on osxi updated mockito from 195 to 1100 in the process of updating from java7 to java8 || you are right the change came with java 8  with my pull request || @raphw nice catch and thanks for the patch :)@scameronde thanks for reporting :) || by the way @raphw as you may be one of the only person around mockito that can give thorough feedback on the generic support class in mockito do you see how to improve it ? || well as i am currently dealing with generic types a lot i can only tell that it is quite complex to beginn with but i am deep in the matter these days i will look at the implementation some time and see if i can improve it for now it looks save apart from the fact that you were missing generic type arrays || yes it was developed on java 7 and missed that anyway thanks again || you got to love the open source community thank you a lot for the fast response and the fix ||;1;0;issue #268: added support for generic arrays as return types;
280;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removes option to disable renaming in filechooser dialogs.;why? - i think this is annoying as one would expect this to work.   i can also live with the option that this is always active  but giving the user the option to choose is not good in my opinion.;;0;filler for non-existent issue;280;;;;;0;1;;
280;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removes option to disable renaming in filechooser dialogs.;why? - i think this is annoying as one would expect this to work.   i can also live with the option that this is always active  but giving the user the option to choose is not good in my opinion.;;0;add per-node avg stats to console in debug mode;;;;;;1;1;add per-node avg stats to console in debug mode;
280;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removes option to disable renaming in filechooser dialogs.;why? - i think this is annoying as one would expect this to work.   i can also live with the option that this is always active  but giving the user the option to choose is not good in my opinion.;;0;diagrams and some new javadoc content for observable subclasses;some marble or marblish diagrams and a bit of new documentation for theblockingobservable and connectableobservable subclasses;#152 ;;;;1;1;diagrams and some new docs for observable subclassessome marble or marblish diagrams and a bit of new documentation for theblockingobservable and connectableobservable subclasses;
280;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removes option to disable renaming in filechooser dialogs.;why? - i think this is annoying as one would expect this to work.   i can also live with the option that this is always active  but giving the user the option to choose is not good in my opinion.;;243.0;reintroduce null check on mockutilismock();will 243 - null check on mockutilismock() was incorrectly removed after successive refactoring this pr reintroduces null check;  ;mockutilismock() no longer checks null;in version 195 mockutilismock() is defined as:```return instance ! null && ismockitomock(instance)```in v11019 and head the `instance ! null` check is gonethis method is called by mockscanner when injecting mock instances on fields where field values can be nullis this a bug? or its up to mockmakergethandler() to check for null?if its a bug i can fix it but then well need to wait for v20 before upgrading mockito for the companys code base if its up to the mock maker then i guess we need to fix googles dexmakermockmaker to add a line of `if (mock  null) return null`;"thanks for reporting this one ! || bytebuddymockmakergethandler(object mock) method checks for null using instanceof operator`if (!(mock instanceof mockaccess)) {    return null}`i presume it is not a bug  || > i presume it is not a bugnope || how about we document the change in the behavior javadoc ok?on sun jul 19 2015 at 11:28 pm brice dutheil notifications@githubcomwrote:> i presume it is not a bug> > nope> > —> reply to this email directly or view it on github>  szczepan faberfounder mockitoorg core dev gradleorgtweets as @szczepiq blogs at blogmockitoorg || `mockutil` is an internal class i dont think we have to document that one but i believe we should fix the code there || the public api (or spi) is mockmakergethandler(object mock)the current javadoc doesnt mention whether null could be passed in although in v195 it was guaranteed that nulls wont be passed inif v11019 drops that guarantee androids [dexmakermockmaker]( is broken because it doesnt make the effort to check for nulli personally think its pointless for mockito to ever call mockmakergethandler(null) because nothing but null would seem reasonable to be returned anyway so why risk the npe?but if this change in the implicit contract needs to happen the document change is at mockmakergethandler() something like ""null could be passed in and implementations should return null in that case"" would be clear enough || yes agreed with @fluentfuture  || while working on #277 i  the null-check in the mockscanner (as tests were failing if you would remove this check) the check can be [found here]( || ";1;0;#243 reintroduce null check on mockutilismock();
286;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed a number of warnings;got rid of a number of warnings: - <> - static methods - commented empty blocks - general clean up;;0;filler for non-existent issue;286;;;;;0;1;;
286;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed a number of warnings;got rid of a number of warnings: - <> - static methods - commented empty blocks - general clean up;;0;add new api method to reset invocations of a mock while maintaining all existing stubbing;add new api method to reset invocations of a mock while maintaining all existing stubbing---**edit by mockito team** : 183;  ;;;;1;1;add new api method to clear invocations of a mock while maintaining all existing stubbing;
286;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed a number of warnings;got rid of a number of warnings: - <> - static methods - commented empty blocks - general clean up;;0;dont use snapshot for airlift;;"please make the commit message as descriptive as the pull request title :) || ""upgrade to airlift 068"" || ";;;;1;1;use latest released airlift version (068) instead of a snapshot;
286;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed a number of warnings;got rid of a number of warnings: - <> - static methods - commented empty blocks - general clean up;;0;scan operator with and without initial value behave wildly different intended?;"im quite new to this rx stuff so forgive me if there something simple im missing herei was trying to use scan and found that it did not behave as i expected this code illustrates how:``` javapublic class scanissue{    public static void main(string args) throws interruptedexception    {        publishsubject<integer> source   publishsubjectcreate()        func2<integer integer integer> accumulator  new func2<integer integer integer>()        {            @override            public integer call(integer a integer b)            {                return a + b            }        }        observable<integer> scan  observablescan(source accumulator)//        observable<integer> scan  observablescan(source 0 accumulator)        print(""a"" scan)        print(""b"" scan)        print(""c"" scan)//        print(""d"" scan)//        print(""e"" scan)        threadsleep(1000)        sourceonnext(1)        threadsleep(1000)        sourceonnext(1)    }    private static <t> void print(final string prefix observable<t> source)    {        sourcesubscribe(new action1<t>()        {            @override            public void call(t s)            {                systemoutprintln(prefix + "": "" + s)            }        })    }}```i would expect it to output nothing on the first `onnext` and this on the second:```a: 2b: 2c: 2```where i dont care about the order of ab & cbut instead it outputs this on the first one:```b: 1b: 2b: 3```and this on the second:```b: 4b: 5b: 6```_b_ can be any of a b and c but always the same all 6 times- if i switch to the one with initial value it works as i expect- the more subscriptions i add the worse it gets- the type of source does not seem to matter (tried with a hand rolled one)";the first value is always passed through as the first `onnext` if no initial value is given then the first source `onnext` is passed through and then fed as the initial value along with the next `onnext`so for this one:``` javasourcescan(0 accumulator)```we see `0` come through first and then be accumulated with `1` and `2`:```onnext > a: 0func> a: 0 b: 1onnext > a: 1func> a: 1 b: 2onnext > a: 3```in this one:``` javaobservable<integer> scan  sourcescan(accumulator)```its now actually only passing in 2 values (1 and 2) instead of 0 as initial then 1 and 2 so we get:```onnext > a: 1func> a: 1 b: 2onnext > a: 3```the first value is still passed directly through and then the next accumulatedif i change the observable to emit 0 1 2 it looks the same as when setting initialvalue to 0``` java        sourceonnext(0)        sourceonnext(1)        sourceonnext(2)``` now emits this:```onnext > a: 0func> a: 0 b: 1onnext > a: 1func> a: 1 b: 2onnext > a: 3```javadocs:  an observable that applies a function of your choosing to the first item emitted by a source observable then feeds the result of that function along with the second item emitted by an observable into the same function and so on until all items have been emitted by the source observable emitting the result of each of these iterations```![scan]( ||;;;;0;1;;
287;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;doaj search;search for directory of open access journals. quite functional  but the remaining things should (probably) be done -  ~~help page~~ -  decide on where the bibjsonconverter class should be positioned (input?) -  more fields? ~~issn?~~ -  ~~better/more error checking~~ -  ~~handle search results with more than 100 entries properly~~ -  ~~fill empty methods in doajfetcher~~ -  ~~update status bar~~ -  add test for bibjsonconverter -  ~~enable stopping search~~  implements what is discussed in #208;;0;filler for non-existent issue;287;;;;;0;1;;
287;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;doaj search;search for directory of open access journals. quite functional  but the remaining things should (probably) be done -  ~~help page~~ -  decide on where the bibjsonconverter class should be positioned (input?) -  more fields? ~~issn?~~ -  ~~better/more error checking~~ -  ~~handle search results with more than 100 entries properly~~ -  ~~fill empty methods in doajfetcher~~ -  ~~update status bar~~ -  add test for bibjsonconverter -  ~~enable stopping search~~  implements what is discussed in #208;;0;add a very basic help/hint system;which may or may not resemble certain classic help systems;;;;;0;1;;
287;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;doaj search;search for directory of open access journals. quite functional  but the remaining things should (probably) be done -  ~~help page~~ -  decide on where the bibjsonconverter class should be positioned (input?) -  more fields? ~~issn?~~ -  ~~better/more error checking~~ -  ~~handle search results with more than 100 entries properly~~ -  ~~fill empty methods in doajfetcher~~ -  ~~update status bar~~ -  add test for bibjsonconverter -  ~~enable stopping search~~  implements what is discussed in #208;;0;error handling and validation;refactoring related to arg validation and error handling throw if no onerror handler specified subscribe argument validation;#158 ;;;;1;1;"throw if no onerror handler specified per rx design guidelines 52: ""when calling the subscribe method that only has an onnext argument the onerror behavior will be to rethrow the exception on the thread that the message comes out from the observable sequence the oncompleted behavior in this case is to do nothing""a new onerrornotimplementedexception was created so it is explicit as to where the exception is coming from and why";
287;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;doaj search;search for directory of open access journals. quite functional  but the remaining things should (probably) be done -  ~~help page~~ -  decide on where the bibjsonconverter class should be positioned (input?) -  more fields? ~~issn?~~ -  ~~better/more error checking~~ -  ~~handle search results with more than 100 entries properly~~ -  ~~fill empty methods in doajfetcher~~ -  ~~update status bar~~ -  add test for bibjsonconverter -  ~~enable stopping search~~  implements what is discussed in #208;;124.0;implement verificationcollector which can collect multiple verifications;it will report in the end the result of multiple statements 124;  ;concise way to collect multiple verify failures ideally with junitcollector or  derivative;if you are using more than one verify statement as test post-conditions it would be nice to be able to collect each failure and continue with the remaining verify statements or asserts that follow  junit provides the errorcollector @rule to facilitate this kid of thing but the current [errorcollector api]( requires either- a matcher<t> and a value to compare- or a callable<object>the mockito verify statements only return void however since they depend on throwing exceptions  i have not thought of an ideal non-disruptive way to use junits errorcollector to aggregate multiple mockito verify failure;as a possible example of the way to handle it maybe it could be modeled after the same way that assertj added deferred composite assertion handling through [their own junit @rule]( ||;1;0;implement verificationcollector which can collect multiple verificationsit will report in the end the result of multiple statements 124;
288;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add optional answer to support mocked builders;when googling the mocking of builders  a lot of people said it was not possible with mockito to support them in a clean way.  returns_deeps_stubs  does allow cascading  but can become quite fast very cumbersome. the added  returns_self  will try to return itself by looking at the method  returntype  and compare this with the class of the mock.;;0;position based access of linkedlistmultimap; hii am using your collection linkedlistmultimap for storing duplicatekey-value pairs and maintain the insertion order it performs well for keybased access compared to a pure linkedlist based implementation i havewritten but position based operations are not allowed directly i am doingeverything with entries() view (it is causing performance overhead comparedto pure linkedlist) is it possible i can do positional access similar to alinkedlist in this collection using a workaround? or get a listiteratorwhich can traverse backward from the end in entries() view? please let meknow thanks in advanceregardsram; i think this must have been addressed at some point in the intervening years because linkedlistmultimapentries() and linkedlistmultimapvalues() _do_ return a list--- ;;;;0;1;;
288;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add optional answer to support mocked builders;when googling the mocking of builders  a lot of people said it was not possible with mockito to support them in a clean way.  returns_deeps_stubs  does allow cascading  but can become quite fast very cumbersome. the added  returns_self  will try to return itself by looking at the method  returntype  and compare this with the class of the mock.;;0;add optional answer to support mocked builders;when googling the mocking of builders a lot of people said it was not possible with mockito to support them in a clean way `returns_deeps_stubs` does allow cascading but can become quite fast very cumbersomethe added `returns_self` will try to return itself by looking at the method `returntype` and compare this with the class of the mock;  ;;;;1;1;add optional answer to support mocked builders;
288;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add optional answer to support mocked builders;when googling the mocking of builders  a lot of people said it was not possible with mockito to support them in a clean way.  returns_deeps_stubs  does allow cascading  but can become quite fast very cumbersome. the added  returns_self  will try to return itself by looking at the method  returntype  and compare this with the class of the mock.;;0;add show functions;;;;;;1;1;add show functions;
288;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add optional answer to support mocked builders;when googling the mocking of builders  a lot of people said it was not possible with mockito to support them in a clean way.  returns_deeps_stubs  does allow cascading  but can become quite fast very cumbersome. the added  returns_self  will try to return itself by looking at the method  returntype  and compare this with the class of the mock.;;0;fix publishsubject non-deterministic behavior on concurrent modification;- changed to take snapshot of observersvalues() before iterating in onnext/onerror/oncompleted so that nested subscriptions that add to observers cant change the values() iteration- single-threaded nested subscriptions are now deterministic- multi-threaded subscriptions will no longer be allowed to race to get into an interating onnext/onerror/oncompleted loop they will always wait until the next- also improved terminal state behavior when subscribing to a publishsubject that has already received onerror/oncompletedhttps://githubcom/netflix/rxjava/issues/282;#159  #161;;;;1;1;synchronize terminalstate and subscription logic- remove the race condition that existed between a subscription coming in while onerror/oncompleted was being called;
293;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;remove validateserializable();245:  remove serializable validation.;;0;make immutableclasstoinstancemap serializable; please argue for this if you think its strictly needed for 10;  `` ;;;;0;1;;
293;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;remove validateserializable();245:  remove serializable validation.;;0;fix cancel for operators;;;;;;1;1;fix cancel for operators;
293;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;remove validateserializable();245:  remove serializable validation.;;0;expose scheduledsubscription on the public api;i understand it should be transparent for a client where an observable was scheduled however wed actually like to ensure that our service objects schedule operations on an appropriate scheduler (we use different schedulers for eg api requests and local storage i/o)this is not possible at the moment since there is no way to obtain information about this by inspecting the observable or the subscription since subscribeon effectively creates a new observable there is also no simple way to use mock objects other than to spy into the implementation using partial mocks which is not greati was wondering if it would make sense to change scheduledsubscription so thata) scheduledsubscription is a public top level classb) exposes a method getscheduler that returns the currently private scheduler instanceso that clients can test subscriptions in unit tests in the following way:subscription sub  serviceobjectperformjob()subscribe()assertthat(sub instanceof(scheduledsubscriptionclass))assertthat(sub ((scheduledsubscription) sub)getscheduler() equalto(expectedscheduler) );answered in  ||;;;;0;1;;
293;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;remove validateserializable();245:  remove serializable validation.;;245.0;remove validateserializable();245:remove serializable validation;  ;serializable check is too harsh;"hi apologies if this has been discussedwhile upgrading my companys mockito to 11019 i ran into a lot of this error:```orgmockitoexceptionsbasemockitoexception: you are using the setting withsettings()serializable() however the type you are trying to mock opportunityclientdo not implement serializable and do not have a no-arg constructorthis combination is requested otherwise you will get an javaioinvalidclassexception when the mock will be serialized```in summary there are two cases triggering this error1 the subjectundertest accepts an object foo and requires it to be serializable and yet foo doesnt implement serializable nor has a default constructor2 foo itself is serializable but the test calls `when(foocreatebar())thenreturn(bar)` which behind the scene puts the `bar` mock onto the state of foo which requires bar itself to be serializable in production bar isnt required to be serializablei feel case 1 is possibly reasonable (although its still kind of harsh ill get to it in a bit)case 2 should not require bar to be serializable as it does today in version 195 our tests worked around it by using `mock(barclass withsettings()serilizable()` but in version 11019 this workaround breaks if bar has no default constructorpossibly the [serializable proxy pattern]( could be used to solve this nicely by stashing the ""mock specifications"" into a proxy object that can later on deserialize itself back into a mock bar with the same number of when()thenreturn()now let me try to explain why i think even case 1 is too harshphilosophically i feel that its not mockitos job to ensure the mocked object works in real life its a mock object after all it isnt expected to meet all required specification of the real objectwhen in a test i say `@mock(serializabletrue) foo foo` im explicitly asking mockito to ""please pretend my object be serializable i dont want to worry about the real object in this test"" would the real object be serializable when i pass it into subjectundertest? well:1 there is nothing guaranteeing that production code passes foo to subjectundertest it could likely pass a cousin class realfoo2 that implements serializable just fine (or not but the test doesnt help me with that) it needs to be tested but imho not against a mock foo especially when mockitos when()thenreturn() syntax adds non-existent serializable requirement to the mock object2 given the proxy pattern that foo doesnt _look like_ a serializable class isnt a guarantee that it cant be so by throwing this error mockito enforces stricter constraint than whats technically necessaryi agree that checking basic serializable requirement in mockito can catch some bugs if case 2 can be  its likely that case 1 would not have triggered so many false positivesbut with all our workarounds already added because of case 2 and the fair number of our tests triggering this error the amount of work to fix all of them before we can upgrade mockito looks dauntingso i guess my question is: **can we do away with mockcreationvalidatorvalidateserializable() or make it an opt-in?**sorry for the long message";heres a real example the subject under test looks like this:```class subjectundertest implements serializable {  private final foofactory factory  subjectundertest(foofactory factory) {    thisfactory factory  }    foo foo  factorycreatefoo()  }```the testing framework actually tries to serialize subjectundertest so foofactory needs to be serializable toothe test using mockito looks like this:```foo foo  mock(fooclass)foofactory mockfactory  mock(foofactoryclass withsettings()serializable())when(mockfactorycreatefoo())thenreturn(foo)subjectundertest subject  new subjectundertest(mockfactory)```but when the framework serializes `subject` we get an exception because the line of `when(mockfactorycreatefoo())thenreturn(foo)` implicitly adds foo as part of `mockfactory` stateto work around the problem our tests had to make foo serializable too:```foo foo  mock(fooclass withsettings()serializable())```again production code doesnt need foo to be serializable and it may not have a default constructorthats status quonow with v11019 the above work-around breaks because foo doesnt implement serializable nor has a default constructorback to square one if i had the choice i would strongly discourage the code that mocks either foofactory or foo instead it should just be a plain old foofactory subclass that returns foo with java 8 the syntax would actually become more concise than the mockito syntax but i cant go back and fix so many teams code as it stands today this is the biggest issue blocking the upgradehopefully ive made a clear case || thanks for reportingim ok with removing the check or making it smarter it seems to be a legituse case brice?cheers!on fri jul 3 2015 at 2:50 pm ben yu notifications@githubcom wrote:> heres a real example the subject under test looks like this:> > class subjectundertest implements serializable {>   private final foofactory factory> >   subjectundertest(foofactory factory) {>     thisfactory factory>   }> >   >   foo foo  factorycreatefoo()>   > }> > the testing framework actually tries to serialize subjectundertest so> foofactory needs to be serializable too> > the test using mockito looks like this:> > foo foo  mock(fooclass)> foofactory mockfactory  mock(foofactoryclass withsettings()serializable())> when(mockfactorycreatefoo())thenreturn(foo)> subjectundertest subject  new subjectundertest(mockfactory)> > but when the framework serializes subject we get an exception because> the line of when(mockfactorycreatefoo())thenreturn(foo) implicitly adds> foo as part of mockfactory state> > to work around the problem our tests had to make foo serializable too:> > foo foo  mock(fooclass withsettings()serializable())> > > again production code doesnt need foo to be serializable and it may not> have a default constructor> > thats status quo> > now with v11019 the above work-around breaks because foo doesnt> implement serializable nor has a default constructor> > back to square one if i had the choice i would strongly discourage the> code that mocks either foofactory or foo instead it should just be a> plain old foofactory subclass that returns foo with java 8 the syntax> would actually become more concise than the mockito syntax> > but i cant go back and fix so many teams code as it stands today this> is the biggest issue blocking the upgrade> > hopefully ive made a clear case> > —> reply to this email directly or view it on github>  szczepan faberfounder mockitoorg core dev gradleorgtweets as @szczepiq blogs at blogmockitoorg || hi is this reasonable? i can send a pr to remove this check if its okay with you guys || lets remove the check unless brice objects )on fri sep 18 2015 at 9:08 pm ben yu notifications@githubcom wrote:> hi is this reasonable? i can send a pr to remove this check if its okay> with you guys> > —> reply to this email directly or view it on github>  szczepan faberfounder mockitoorg core dev gradleorgtweets as @szczepiq blogs at blogmockitoorg || @szczepiq @fluentfuture is this fix available in any of the mockito releases? || @vikkyrk since 2031-beta || thanks  ||;1;0;remove validateserializable();
294;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed deprecated returnvalues and all it s occurrences;these changes should  deal with  issue #273;;0;filler for non-existent issue;294;;;;;0;1;;
294;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed deprecated returnvalues and all it s occurrences;these changes should  deal with  issue #273;;0;removed deprecated returnvalues and all its occurrences;these changes should deal with issue #273;commits has been squashed ||   ;;;;1;1;issue #273: removed deprecated method from mockito class api removed deprecated method from imockitoconfiguration and its implementations and returnvalues itself;
294;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed deprecated returnvalues and all it s occurrences;these changes should  deal with  issue #273;;0;fix global stats computation and status display for completed stages;;;;;;1;1;;
294;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed deprecated returnvalues and all it s occurrences;these changes should  deal with  issue #273;;0;make scheduledsubscription public expose scheduler field;as proposed in issue #293this will make it easier to verify proper scheduling behavior of services implemented using rx;"#167  anyone else able to do a code review on this? || beside variable setting this class is only a few lines of code  i dont think it is worth exposing as it would require us to maintain the constructors etc which the private access currently doesnt  there could be more said for exposing a scheduler accessor on an interface  @mttkay you mind noting the specific use case here?  is it testing or validation at runtime?  || this was purely for testing we had a few occurrences of devs forgetting to schedule an observable on an appropriate scheduler and disk io was performed on the main application thread it would be good to catch these errors early by being able to write a unit test || that said how do you guys do it? just rely on developer diligence? were still trying to discover the ""right"" idioms/practices for us both in the context of android and rx in general || @mttkay we generally rely on developer diligence and them doing their own unit testing we have some light abstractions on top of rxjava that we use in our codebase that encourage the ""right way"" for how we use it (such as avoiding the use of schedulers in almost all cases)for the reasons @adriancole mentions id rather not make this class public as i consider it an implementation detail for the `onsubscribe` operatoralso since `subscription` is already the top-level interface there is nothing that would force people to use `scheduledsubscription` and thus it still wouldnt enable you to achieve the goal of asserting what scheduler is being usedit gets more complicated with composition as well as a `scheduledsubscription` could be inside another `subscription` so instanceof checks dont mean much when composition is usedi am not aware of a generally applicable solution to what youre looking for (asserting io only happens where it should) but its a great thing to pursue perhaps this could be a discussion over on the google groups (  || another thought  something ive considered but not yet pursued is the use of execution hooks ( for testing and smoke tests to perform assertions against each step of an rx composition you could assert each instance of a `subscription` or `observable` instance at each step of composition (helping get around the inheritance versus composition issue i stated above) not sure yet if it could achieve what youre trying to do but it might for example if in your code base you always want a certain type of `subscription` uses this could assert that || closing as i would prefer this stay an implementation detail and not part of the public api || @benjchristensen that link to the execution hooks is _very_ useful i wasnt aware of this thanks!not a big deal at all to not have this it seemed reasonable to me but i understand there might be better ways to accomplish this without escalating scheduledsubscription to the public api || ";;;;0;1;;
301;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed a number of false positive translation strings;cleaned up the code (basically move localization.lang to the  correct  places) for a number of files to reduce the amount of false positives when it comes to possibly obsolete keys. this also resulted in some other related clean-ups  such as removing translation requests for database names (try to translate  inspire ).;;0;filler for non-existent issue;301;;;;;0;1;;
301;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed a number of false positive translation strings;cleaned up the code (basically move localization.lang to the  correct  places) for a number of files to reduce the amount of false positives when it comes to possibly obsolete keys. this also resulted in some other related clean-ups  such as removing translation requests for database names (try to translate  inspire ).;;0;refactor some utilities and todo done;hey guys awesome framework +1 ive been looking at the code and i did some improvements also i did a todo but im not quite sure how to handle that null check it would be awesome if you could check it out @bric3 @szczepiq answersjava : private is not required classpathloaderjava: removed unnecessary importsscenarioprinterjava: changed the string concat into another appendmockhandlerfactoryjava: return statement changed to be inlinevalueprinterjava: todo done null check addededit releasenotesextension : made authtoken a final stringedit 2: some improvements to the threadtests :);  ;;;;1;1;refactor some utilities and todo donerefactor some utilities and todo donerefactor some utilities and todo donerefactor for boolean condition and null check improvedrefactor some utilities and todo donerefactor some utilities and todo donerefactor some utilities and todo donerefactor for boolean condition and null check improvednull check improveddefault value changed;
301;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed a number of false positive translation strings;cleaned up the code (basically move localization.lang to the  correct  places) for a number of files to reduce the amount of false positives when it comes to possibly obsolete keys. this also resulted in some other related clean-ups  such as removing translation requests for database names (try to translate  inspire ).;;0;allow query cancel during planning;;;;;;1;1;;
301;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed a number of false positive translation strings;cleaned up the code (basically move localization.lang to the  correct  places) for a number of files to reduce the amount of false positives when it comes to possibly obsolete keys. this also resulted in some other related clean-ups  such as removing translation requests for database names (try to translate  inspire ).;;0;implementation of flatmapdelayerror();there is already a documentation of mapmanydelayerror() but i cant find an implementation i would like to use mapmanydelayerror() in a project if there is no implementation yet i may contribute it;sounds like a good idea || renamed from `mapmanydelayerror` to `flatmapdelayerror` as we removed `mapmany` naming conventions || closing out due to inactivity if wanted please re-open ||;;;;0;1;;
306;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;eliminate direct dependency on objenesisinstantiator;updated instantiatorprovider to be a plug-in  to eliminate direct dependency on objenesisinstantiator. this allows mockito to be used by runtimes that don t execute bytecode  such as j2objc-translated code on ios.;;0;with/withoutmethods on immutable collections; something along the lines of:final immutablemap&ltintegerstring> map  immutablemapof(1 ""a"" 2 ""b"")immutablemap&ltintegerstring> resultresult  mapwith(3 ""c"") // { 1 : ""a"" 2 : ""b"" 3 : ""c"" }result  mapwith(3 ""foo"") // { 1 : ""a"" 2 : ""b"" 3 : ""foo"" }result  mapwithout(3) // { 1 : ""a"" 2 : ""b"" }and possibly bulk overloadsi understand the performance implications of using these but they would still be very useful currently i use:public static &ltkv> immutablemap&ltkv> with(&nbsp&nbspfinal immutablemap&ltkv> map final k key final v value) {&nbsp&nbsp&nbsp&nbspreturn immutablemap&ltkv>builder()&nbsp&nbsp&nbsp&nbsp&nbsp&nbspputall(mapsfilterkeys(map &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsppredicatesnot(predsis(key))))put(key value)build()}(predsis is what used to be predicatesissameas)but i would think that this can be done better if it were implemented in the collectionin the long run immutable collections would need a different implementation to be able to use these methods in moderately performance sensitive areas (the way clojures persistent data structures are implemented comes to mind and i would think scala has something similar though i am not sure)"; we dont wish to attempt to turn our collections into full-blown ""persistent data structures"" aka ""pure functional data structures"" there are lots of other languages and libraries that have this if its what you want--- ;;;;0;1;;
306;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;eliminate direct dependency on objenesisinstantiator;updated instantiatorprovider to be a plug-in  to eliminate direct dependency on objenesisinstantiator. this allows mockito to be used by runtimes that don t execute bytecode  such as j2objc-translated code on ios.;;0;eliminate direct dependency on objenesisinstantiator;updated instantiatorprovider to be a plug-in to eliminate direct dependency on objenesisinstantiator this allows mockito to be used by runtimes that dont execute bytecode such as j2objc-translated code on ios;  ;;;;1;1;updated instantiatorprovider to be a plug-in to eliminate direct dependency to objenesisinstantiator;
306;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;eliminate direct dependency on objenesisinstantiator;updated instantiatorprovider to be a plug-in  to eliminate direct dependency on objenesisinstantiator. this allows mockito to be used by runtimes that don t execute bytecode  such as j2objc-translated code on ios.;;0;add basic support for quoted identifiers;;;;;;1;1;;
306;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;eliminate direct dependency on objenesisinstantiator;updated instantiatorprovider to be a plug-in  to eliminate direct dependency on objenesisinstantiator. this allows mockito to be used by runtimes that don t execute bytecode  such as j2objc-translated code on ios.;;0;issue with onerrorresumenextfunction and async observable;"this may be a problem with mapobserver or onerrorresumexxx and is probably related to  the function returned by onerrorresumexxx returns an async observable then there is some unpredictable behavior with operators (eg map) that rely on the atomicobserver to generate a valid event streamive created a unittest below to demonstrate the problem ``` java@testpublic void testmaperror() {    observable<string> observable  observablefrom(""one""""error""""two""""three"")    observable<string> m  observablecreate(map(observable new func1<stringstring>() {        @override        public string call(string in) {            if (""error""equals(in))                throw new runtimeexception(""simulated error"")            return in        }    }))    // add error handler    mmonerrorresumenext(new func1<exceptionobservable<string>>() {        public observable<string> call(exception e) {            return createslowsequence(new string {""ii""""iii""})         }    })    msubscribe(stringobserver)    verify(stringobserver times(1))onnext(""one"")        // should be caught be onerrorresumenext    verify(stringobserver never())onerror(any(exceptionclass))    verify(stringobserver never())onnext(""error"")    verify(stringobserver never())onnext(""two"")    verify(stringobserver never())onnext(""three"")        // resume output    verify(stringobserver times(1))onnext(""ii"")    verify(stringobserver times(1))onnext(""iii"")    verify(stringobserver times(1))oncompleted()}private observable<string> createslowsequence(final string seq) {    return observablecreate(new func1<observer<string>subscription>() {        public subscription call(final observer<string> ob) {            new thread() {                /** delay for a given time */                public void waitfor(int ms) {                    try {                       threadsleep(ms)                    }                    catch (interruptedexception e) {                    }                }                /** slowly emit a sequence */                public void run() {                    for (int i0i<seqlengthi++) {                        waitfor(100)                        obonnext(seq[i])                    }                    oboncompleted()                }            }start()            return subscriptionsempty()        }    })}```there are two issues i see causing the problem so two potential fixes1 mapobserver continues to emit onnext/oncompleted even after it has emitted onerror this pushes the problem downstream2 onerrorresumenext continues to propogate onnext/oncompleted even after it has subscribed the observer(s) to the resume observable this means that if the resume observable is async onerrorresumenext will emit one/more onnext and potentially oncompleted from the source observable unless the resume observable completesit could also trigger multiple subscriptions if the mapobserver produced another onerror_a side note here is that the atomicobserver fixes this issue if the resume observable is sync (because it ignores the source observable events after the resume observable has completed) this effectively masks the problem in the onerrorresumenext unit-test perhaps the unit-tests should disable this behavior or detect it via a plugin?_";;;;;0;1;;
309;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove translation string  an error occurred while fetching from inspire source (%0):;i assume that the user knows in which context he his  therefore we can reuse the generic exception message to have less strings opened for translation.;;0;tweaks to the main mockito javadocs to aid readability;@szczepiq as discussed please review;  ;;;;1;1;tweaks to the main mockito javadocs to aid readability;
309;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove translation string  an error occurred while fetching from inspire source (%0):;i assume that the user knows in which context he his  therefore we can reuse the generic exception message to have less strings opened for translation.;;0;raise an error when distinct is used in aggregations;; ;;;;0;1;;
309;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove translation string  an error occurred while fetching from inspire source (%0):;i assume that the user knows in which context he his  therefore we can reuse the generic exception message to have less strings opened for translation.;;0;a little typo in a comment in the clojure examples;;#185 thanks @josephwilk  ||;;;;1;1;typos;
314;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add shouldhavenomoreinteractions() to bddmockito;replicates  verifynomoreinteractions  on the bdd api.  ---  **edit by mockito team** : 311;;0;consider memoizing results of filtering a lazily filtered iterable; consider this snippet:```return immutablesetcopyof(setsfilter(    unfilteredsetofthings    new predicate<thing>() {      @override      public boolean apply(thing thing) {        return thingisacceptable()      }    }))```q1:&nbsp&nbsphow many times is ""isacceptable"" invoked on each thing in the list of unfiltered things?q2:&nbsp&nbsphow many times would you think it should be invoked?for me a2 was 1 alas a1 disagreed!in short each thing has ""isacceptable"" invoked 3 times for this one copyof() operation  this happens each time size() is called on the filtered view of the unfitered set and then once while iteratingfiling to solicit opinions on whether this is ok behaviorthanks-fred"; ;;;;0;1;;
314;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add shouldhavenomoreinteractions() to bddmockito;replicates  verifynomoreinteractions  on the bdd api.  ---  **edit by mockito team** : 311;;0;add shouldhavenomoreinteractions() to bddmockito;replicates `verifynomoreinteractions` on the bdd api---**edit by mockito team** : 311;  ;;;;1;1;311: add shouldhavenomoreinteractions() to bddmockito;
314;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add shouldhavenomoreinteractions() to bddmockito;replicates  verifynomoreinteractions  on the bdd api.  ---  **edit by mockito team** : 311;;0;minor fixes;- bad import- released version;;;;;1;1;use released airlift version;
314;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add shouldhavenomoreinteractions() to bddmockito;replicates  verifynomoreinteractions  on the bdd api.  ---  **edit by mockito team** : 311;;0;map error handling;while reviewing pull request  i noticed that the behavior of map didnt seem right in how it continued emitting values and necessitated the changes to onerrorresumenext digging in it seems the onnext was manually doing error handling but in a non-comprehensive manner whereas now i am letting the `safeobserver` (previously called `atomicobserver`) handle it which does unsubscribes and ignores subsequent events if it doesnt unsubscribe correctlythis is also related to https://githubcom/netflix/rxjava/issues/216;#189 ;;;;1;1;better handling of map function errors- stop catching the error and passing to onerror and instead let the safeobserver handle it which will then prevent subsequent onnext calls and/or unsubscribe when a failure occurs- this also solves the onerrorresumenext issue  in  but those changes still seem valid so ill leave themrelated to  and https://githubcom/netflix/rxjava/pull/312;
317;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;modify stacktracefilter to not exclude  good  stack trace elements;currently stacktracefilter filters in this way (example from javadoc): [a+  b+  c-  d+  e+  f-  g+] -> [a+  b+  g+]  this patch makes it work: [a+  b+  c-  d+  e+  f-  g+] -> [a+  b+  d+  e+  g+]  not sure why it was implemented first time in this strange manner.  ---  **edit by mockito team** : 316;;0;listenablefutureadapter hard-codes executor; futurescompose cannot be used in google appengine as futures$listenablefutureadapter hard-codes its executor to a cached thread pool  please adjust this```private static class listenablefutureadapter<t> extends forwardingfuture<t>  implements listenablefuture<t> {private static final executor adapterexecutor     javautilconcurrentexecutorsnewcachedthreadpool() <--- this is the problem```;  `` ||;;;;0;1;;
317;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;modify stacktracefilter to not exclude  good  stack trace elements;currently stacktracefilter filters in this way (example from javadoc): [a+  b+  c-  d+  e+  f-  g+] -> [a+  b+  g+]  this patch makes it work: [a+  b+  c-  d+  e+  f-  g+] -> [a+  b+  d+  e+  g+]  not sure why it was implemented first time in this strange manner.  ---  **edit by mockito team** : 316;;0;"modify stacktracefilter to not exclude ""good"" stack trace elements";currently stacktracefilter filters in this way (example from javadoc):[a+ b+ c- d+ e+ f- g+] -> [a+ b+ g+]this patch makes it work:[a+ b+ c- d+ e+ f- g+] -> [a+ b+ d+ e+ g+]not sure why it was implemented first time in this strange manner---**edit by mockito team** : 316;"  ;;;;1;1;modify stacktracefilter to not exclude useful stack trace elements between filtered out elements;
317;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;modify stacktracefilter to not exclude  good  stack trace elements;currently stacktracefilter filters in this way (example from javadoc): [a+  b+  c-  d+  e+  f-  g+] -> [a+  b+  g+]  this patch makes it work: [a+  b+  c-  d+  e+  f-  g+] -> [a+  b+  d+  e+  g+]  not sure why it was implemented first time in this strange manner.  ---  **edit by mockito team** : 316;;0;exchange operator;;looks good i _think_ :) ||;;;;1;1;simplify page buffer;
317;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;modify stacktracefilter to not exclude  good  stack trace elements;currently stacktracefilter filters in this way (example from javadoc): [a+  b+  c-  d+  e+  f-  g+] -> [a+  b+  g+]  this patch makes it work: [a+  b+  c-  d+  e+  f-  g+] -> [a+  b+  d+  e+  g+]  not sure why it was implemented first time in this strange manner.  ---  **edit by mockito team** : 316;;0;androidschedulerjava;initial spike for androidschedulerjavabeen using this for quite some time but i dont like the concept using calling `observerobserveon(androidschedulergetinstance())` as it sort of puts android specific stuffs should rxjava support some concept of `schedulersmainscheduler()`? we can then set the default main schedulers using `schedulerssetmainscheduler(androidschedulergetinstance())` when app starts;#195 thanks @prabirshrestha for the submission support for android is something several people will be happy about gettingsince i dont work with android id like to pull @mustafasezgin into this conversation as hes using rxjava on android at soundcloud mustafa can you review contribute and/or answer questions?mustafa gave a presentation that hinted at the use of schedulers for android:  dont like the idea of global settings like schedulerssetmainscheduler as libraries would be stepping on each otheri think something such as the following is a good approach similar to the `schedulers` factory class in rx core:``` javaandroidschedulermain_scheduler or androidschedulermainscheduler()``` || `androidschedulermainscheduler()` definitely sounds better then `androidschedulergetinstance()`i named the method as `getinstance` so that the androidscheduler is similar to the swingscheduler which uses `getinstance()` i would also need help on writing the gradle build scripts(android sdk should also be installed in the ci server) || android dependencies should be in a repo such as maven central so that someone does not need to configure their environment correctly to build is this what it needs?  gradle file will be similar to this:  but you will add this dependency:```compile comandroidtools:sdk-common:2213```also add your module to this file:  example place this on the 2nd to last line before rxjava-swing:```rxjava-contrib:rxjava-android \``` || @benjchristensen happy to help out @mttkay (from the soundcloud android team) will also be valuable to the discussionwe use the first method outlined by @benjchristensen to set a the main thread scheduler on an observable the main thread scheduler is similar to the one submitted by @prabirshrestha with the second method being implemented using the `handlerpostdelayed()` method for consistency with the core package i think the static method approach for the scheduler is more suited in this instance@mttkay wrote some helpful components related to fragments which we were also looking to opensource maybe we should look to getting that out sooner @mttkay thoughts?also you should only need to add the main android sdk dependency  using the _provided_ maven scope || thanks @mustafasezgin for getting involved nice to know you and @mttkay work togetheryes we only need the sdk as a provided not compile dependency so like this in the buildgradle file:```provided comgoogleandroid 4114``` || awesome i was playing around with android and rxjava already too but i guess for me itll be a libgdx integration mostly || hey guys indeed we have been using a more complete scheduler for a while one that has an implementation for delayed messages toomy suggestion is to rename `androidscheduler` to `androidschedulers` (plural) since there may be more schedulers to be implemented for android down the road (like scheduling via asynctasks) so we should have:`androidschedulersmainthread()`im also missing tests and build integration with this pr it seems like its a wip maybe we should combine our efforts around this? || have a look at the above pr ive pulled the scheduler component out of our production app code and into rxjava-contribthe build should pass the scala adaptor seems to be causing trouble though? seems to neither build on the public ci nor on my local machine test execution time is slightly up due to the addition of robolectric which goes through a start-up procedure to initialize a fake android application environment for testing || closing in favor of #318 ||;;;;0;1;;
344;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;show correct location of unwanted interaction with mock when using mockitojunitrule;this pull request by @indy5858 and me changes the stacktrace filtering so that when using  mockitojunitrule  the correct location of an unwanted interaction with a mock.  before this commit the location on an unwanted interaction was not reported properly. instead of      no interactions wanted here: -> at <package>.<testclass>.<testmethod>(<testclass.java>:<linenumber>)      the assertion message said:      no interactions wanted here: -> at org.junit.runners.parentrunner.runleaf(parentrunner.java:325)      the issue with the current behaviour in master is that all stacktrace elements above an element containing  org.mockito.  are removed. as  org.mockito.internal.junit.junitrule  fullfills this condition and comes below the  payload  (i.e. test code and code under test) stack elements the interesting part of the stack is filtered. in case the pull request #317 (which we only found after hacking on this) is merged this pull becomes obsolete except for the two tests that are added: - checking that the  payload  stack elements aren t removed from the stack and - a test for removal of the byte buddy stack elements.;;0;immutablemapcopyof is slow because of its usage of #toarray; immutablemaps are unusable for me due to this performance issueimmutablemapcopyof has this line of code:&nbsp&nbsp&nbsp&nbspentry&ltk v> entries  mapentryset()toarray(new entry[0])since the entry array is too small to fit the entryset() abstractcollection#toarray delegates to the reflection api to create the array this is extremely slow in my profiling - copyof spends 95% of its time creating these arraysa fix is to create the initial array with the size of the map - this prevents the java library from using reflection:&nbsp&nbsp&nbsp&nbspentry&ltk v> entries  mapentryset()toarray(mapsize())before:&nbsp&nbsp&nbsp&nbsp144 ms    17 s    comgooglecommoncollect    immutablemap::copyof&nbsp&nbsp&nbsp&nbsp103 ms    16 s    javautil     abstractcollection::toarray&nbsp&nbsp&nbsp&nbsp16 s    16 s    javalang      class::getcomponenttype&nbsp&nbsp&nbsp&nbsp00 ns    660 ms    javalangreflect      array::newinstance&nbsp&nbsp&nbsp&nbsp660 ms    660 ms    javalangreflect       array::newarray&nbsp&nbsp&nbsp&nbsp00 ns    164 ms    comgooglecommoncollect     immutablemap::entryof&nbsp&nbsp&nbsp&nbsp164 ms    164 ms    comgooglecommoncollect      maps::immutableentrywith my fix:&nbsp&nbsp&nbsp&nbsp964 ms    1623 ms    comgooglecommoncollect    immutablemap::copyof&nbsp&nbsp&nbsp&nbsp339 ms    556 ms    javautil     abstractcollection::toarray&nbsp&nbsp&nbsp&nbsp00 ns    217 ms    javautil      hashmap$entryset::iterator&nbsp&nbsp&nbsp&nbsp103 ms    217 ms    javautil       hashmap::newentryiterator&nbsp&nbsp&nbsp&nbsp00 ns    114 ms    javautil        hashmap$entryiterator::&ltinit>&nbsp&nbsp&nbsp&nbsp114 ms    114 ms    javautil         hashmap$entryiterator::&ltinit>&nbsp&nbsp&nbsp&nbsp00 ns    103 ms    comgooglecommoncollect     regularimmutablemap::&ltinit>&nbsp&nbsp&nbsp&nbsp103 ms    103 ms    comgooglecommoncollect      hashing::choosetablesizeas a workaround i avoid using immutablemapcopyof and use unmodifiable hashmaps; ;;;;0;1;;
344;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;show correct location of unwanted interaction with mock when using mockitojunitrule;this pull request by @indy5858 and me changes the stacktrace filtering so that when using  mockitojunitrule  the correct location of an unwanted interaction with a mock.  before this commit the location on an unwanted interaction was not reported properly. instead of      no interactions wanted here: -> at <package>.<testclass>.<testmethod>(<testclass.java>:<linenumber>)      the assertion message said:      no interactions wanted here: -> at org.junit.runners.parentrunner.runleaf(parentrunner.java:325)      the issue with the current behaviour in master is that all stacktrace elements above an element containing  org.mockito.  are removed. as  org.mockito.internal.junit.junitrule  fullfills this condition and comes below the  payload  (i.e. test code and code under test) stack elements the interesting part of the stack is filtered. in case the pull request #317 (which we only found after hacking on this) is merged this pull becomes obsolete except for the two tests that are added: - checking that the  payload  stack elements aren t removed from the stack and - a test for removal of the byte buddy stack elements.;;0;show correct location of unwanted interaction with mock when using mockitojunitrule;"this pull request by @indy5858 and me changes the stacktrace filtering so that when using `mockitojunitrule` the correct location of an unwanted interaction with a mockbefore this commit the location on an unwanted interaction was notreported properly instead of```no interactions wanted here:-> at <package><testclass><testmethod>(<testclassjava>:<linenumber>)```the assertion message said:```no interactions wanted here:-> at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)```the issue with the current behaviour in master is that all stacktrace elements above an element containing ""orgmockito"" are removed as `orgmockitointernaljunitjunitrule` fullfills this condition and comes below the ""payload"" (ie test code and code under test) stack elements the interesting part of the stack is filteredin case the pull request #317 (which we only found after hacking on this) is merged this pull becomes obsolete except for the two tests that are added:- checking that the ""payload"" stack elements arent removed from the stack and- a test for removal of the byte buddy stack elements";  ;;;;1;1;add test for removal of bytebuddy stacktrace elements;
344;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;show correct location of unwanted interaction with mock when using mockitojunitrule;this pull request by @indy5858 and me changes the stacktrace filtering so that when using  mockitojunitrule  the correct location of an unwanted interaction with a mock.  before this commit the location on an unwanted interaction was not reported properly. instead of      no interactions wanted here: -> at <package>.<testclass>.<testmethod>(<testclass.java>:<linenumber>)      the assertion message said:      no interactions wanted here: -> at org.junit.runners.parentrunner.runleaf(parentrunner.java:325)      the issue with the current behaviour in master is that all stacktrace elements above an element containing  org.mockito.  are removed. as  org.mockito.internal.junit.junitrule  fullfills this condition and comes below the  payload  (i.e. test code and code under test) stack elements the interesting part of the stack is filtered. in case the pull request #317 (which we only found after hacking on this) is merged this pull becomes obsolete except for the two tests that are added: - checking that the  payload  stack elements aren t removed from the stack and - a test for removal of the byte buddy stack elements.;;0;update to airlift 069 and fix dependencies;;;;;;1;1;update to airlift 069 and fix dependencies;
344;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;show correct location of unwanted interaction with mock when using mockitojunitrule;this pull request by @indy5858 and me changes the stacktrace filtering so that when using  mockitojunitrule  the correct location of an unwanted interaction with a mock.  before this commit the location on an unwanted interaction was not reported properly. instead of      no interactions wanted here: -> at <package>.<testclass>.<testmethod>(<testclass.java>:<linenumber>)      the assertion message said:      no interactions wanted here: -> at org.junit.runners.parentrunner.runleaf(parentrunner.java:325)      the issue with the current behaviour in master is that all stacktrace elements above an element containing  org.mockito.  are removed. as  org.mockito.internal.junit.junitrule  fullfills this condition and comes below the  payload  (i.e. test code and code under test) stack elements the interesting part of the stack is filtered. in case the pull request #317 (which we only found after hacking on this) is merged this pull becomes obsolete except for the two tests that are added: - checking that the  payload  stack elements aren t removed from the stack and - a test for removal of the byte buddy stack elements.;;0;update clojure interop to support new onsubscribefunc with rx/fn;;#235;;;;1;1;update clojure interop to support new onsubscribefunc with rx/fn;
349;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;issue #345 : removes previously verified invocations when capturing argument is combined with after and atmost verifiers;solves #345 by removing already verified invocations before redundant capture of their arguments in atmost class.;;0;support javanetsocket in the closeables utility class; for whatever reason sun didnt add the closeable interface to socket when they introduced closeable in java 5  theyre fixing it in java 7 but in the meantime it would be nice to have socket specific methods on closeables in the guava libraries; ;;;;0;1;;
349;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;issue #345 : removes previously verified invocations when capturing argument is combined with after and atmost verifiers;solves #345 by removing already verified invocations before redundant capture of their arguments in atmost class.;;0;issue #345 : removes previously verified invocations when capturing argument is combined with after and atmost verifiers;solves #345 by removing already verified invocations before redundant capture of their arguments in atmost class;could you send me details of the failure? im not able to reproduce the problem || > process gradle test executor 1 finished with non-zero exit value 137its not your fault the gradle process was killed there could be a few reasons (like to large memory usage) the build should be rerun - @tarnowskijan you can force it by pushing (with  ;;;;1;1;#345 : fixes the issue by removing previously verified invocations before redundant capture of their arguments;
349;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;issue #345 : removes previously verified invocations when capturing argument is combined with after and atmost verifiers;solves #345 by removing already verified invocations before redundant capture of their arguments in atmost class.;;0;make plan fragment id a typed object;;;;;;1;1;make plan fragment id a typed object;
349;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;issue #345 : removes previously verified invocations when capturing argument is combined with after and atmost verifiers;solves #345 by removing already verified invocations before redundant capture of their arguments in atmost class.;;0;window operator;manual merge of  this pull request was submitted there were significant changes to the `create` operator and generics so i manually merged into master i have not actually reviewed for behavior but unit tests are passing and code structure looked goodthis is for issue https://githubcom/netflix/rxjava/issues/102?sourcec;@bcotton great pull request i like how you also worked on `buffer`now that ive merged this with master ill add some inline comments on the code with questions if another pull request is needed so you can take back control of the branch go right ahead and just cherry pick these 2 commits on to a new branch of your own || #239  this looks like a great addition of code and not a trival one so thank you @bcotton!i do not have the time to review it for thread-safety but nothing jumps out as obviously wrongthe unit tests appear to cover the use cases well and based on them the behavior looks correct i have not done a comparison with rxnet to determine if we have covered all cases if anyone else could do that id appreciate itonce weve got resolutions to the (1) generics and (2) func0 questions i posted above this appears good to merge unless anyone else can find issues || if possible id like to get the above items resolved today so i can merge this and release 012 by end of today (us time) || i know that im being kind of a pain in the butt here but theres also the question whether the various `chunk` and `window` classes are co-/contra- or invariant in their type parametersill go examine the code more closely now || i made the wi(n)dow maker typesafe - there are also some more raw types in `chunkedoperation` though || now i think im done with the important things the chunks look invariant to me at first sight i tried to get everything typesafe that wasnt already and again added a lot of wildcards - its all [here]( should i put up a pull request against your `window-merge` branch? || i just pulled them off your branch to this pull requestlooks like both of my questions/concerns are now addressedany last thoughts on placement of util classes? otherwise this looks ready to merge (if the build passes) || #240 thanks for the reviews @jmhofer@bcotton it looks like this pull request only has you as the author but not commiter due to the crazy merge i had to do if you want to take these commits and reapply them so you get the credit please do soill wait a few hours if you can do it otherwise ill proceed with this pull request || go ahead no need for glory :-) happy to help || thanks @bcotton  ill merge now and release 012 fairly soon || im confused these methods all are instance methods but they do not depend in any way on `this` so they could be made static however the better way would probably be to remove the argument called `source` and replace all occurences of `source`  this`am i missing something? || no youre not missing anything  we all did who reviewed this! so funny  an earlier review had the methods change from static to instance but apparently only the static keyword got removed ill go submit a fix and release 0121  too funny (and embarrassing) we all missed thisthanks for reporting it || oops embarrassing :-)  completely missed this too || just release 0121  making its way through sonatype now ||;;;;1;1;made the public window methods more generic via the basic (lol) super/extends fluff also simplified api by removing a few useless super definitions (theres no super of opening and closing);
373;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;extracted logic out of filehistory;separated filehistory into filehistorymenu which contains the menu functions and filehistory which contains the logic for the file history.;;0;cartesian product size calculation bug; at the risk of being voted for the grossest nitpicking of the year here is an example of setscartesianproduct silently producing the wrong size()i create some sets with sizes of 2 3 17 etc and make the cartesian product of those which thinks that its size is merely 858993458 and no overflow happened while the real size is 18446744074568545074 (ie does not fit in a long)the problem with that funny (but not unique) number is that the bits at indexes 32 to 63 are all zero in which case the current overflow check is not adequatei feel guilty for even mentioning this - obviously this ""bug"" has zero practical significance i was just looking at the source of cartesianproduct() and i was very curious thinking ""woah apparently kevin uses some fancy number theory"" but i couldnt figure why this works so i tried various numbers till i found a counterexamplesincerely sorry for wasting your time"; the fix (forbidding results with size >max_int) will be in r10--- ;;;;0;1;;
373;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;extracted logic out of filehistory;separated filehistory into filehistorymenu which contains the menu functions and filehistory which contains the logic for the file history.;;0;get rid of the tablehandle annotations;this turned out to be annoyingly complicatedwhen faced with the choice of adding yet another type to the tablehandle interface (hybridtablehandle) or fixing that piece (which in turn allows pulling out the tpch code) i chose to fix the code;;;;;0;1;;
373;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;extracted logic out of filehistory;separated filehistory into filehistorymenu which contains the menu functions and filehistory which contains the logic for the file history.;;0;a few warnings javadoc and one missing scheduler parameter;"this is just a quick fix for #368 according to @samuelgruetters commentsi also removed a few unnecessary `@suppresswarnings(""unchecked"")` and one unnecessary semicolon";#268  #270 thank you! ||;;;;1;1; all the javadoc build warnings;
373;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;extracted logic out of filehistory;separated filehistory into filehistorymenu which contains the menu functions and filehistory which contains the logic for the file history.;;365.0;365 simplify the invocationonmock-api to get a casted argument;this pull request 365 by introducing `t getargument(int)` and deprecating `t getargumentat(intclass<t>)` in type `invocationonmock` this improves the readabilty of custom answers this`string text  invocationgetargumentat(1stringclass)` can be replaced  string text  invocationgetargument(1)`;  ;simplify the invocationonmock-api to get a casted argument;"the 2nd argument of  `invocationonmockgetargumentat(intclass<t>)` can be removed cause it is not neccessaryintuitively on would write this to get a ""auto casted"" argument:`string text  invocationgetargumentat(1stringclass)`the type can be ommited without side effects (the implementation of invocationonmock discards it anyway)`string text  invocationgetargumentat(1null)`therefore mockito 20 should consider to simplify the api and ommit the `class`-argument here maybe it is also a good chance to simplify the method name too what about  `getargument(int index)` ?this is how the new api could look like:`string text  invocationgetargument(1)`";"i would like to mention that sometimes class argument can be usefulin my case i would like to catch object passed to mock and write to mongo databasethe code i would like to have is:```// test setupdoanswer(invocation -> mongotemplateinsert(invocationgetargument(0 personclass)))  when(mock)  mymethod(any())// test execution mockmymethod(new person(""joe"" ""doe""))```the reason of problem is that `mongotemplate` has 2 similar methods:```public <t> executableinsert<t> insert(class<t> domaintype) {) //(1)public void insert(object objecttosave) {) //(2)```afaiu when i setup `doanswer(invocation -> mongotemplateinsert(invocationgetargument(0))` type inference will choose method (1) and finally i get class cast exception `person` -> `class`unfortunately code `doanswer(invocation -> mongotemplateinsert((person)invocationgetargument(0))` does not compileto implement my test i have to define anonymous class `answer` so my code is long-winded - one-liner looks much better || ";1;0;365 introduced t getargument(int) and deprecated  t getargumentat(intclass<t>) in type invocationonmock;
376;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix typo in example in javadoc.;this is a trivial javadoc-only change  just fixing a typo.;;0;package srcs as a jar rather than a zip;zorzella@ the guava-r06zip has these files:guava-r06jarguava-src-r06zipthe second package the source one should instead beguava-r06-srcjarie it should be a jar rather than a zip and follow the usual naming convention for src jars (ie &ltwhatever-the-name-of-the-jar>-srcjar); says who or what?  can you explain why this could possibly matter?i have always thought zip files and jar files were exactly the same except that1 jar files might contain manifest information (im unaware of any such information wed provide in a source ""jar"")2 a zip file _might_ contain symbolic links or file permission information -- in essence its more of a ""real"" archive format -- while a jar file certainly wont3 a jar file has a strong connotation: that it is not just any zip file but specifically one that contains class files and resource files suitable for appearing in a classpath1 and 3 explain why i used zip and 2 doesnt help either way--- ;;;;0;1;;
376;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix typo in example in javadoc.;this is a trivial javadoc-only change  just fixing a typo.;;0;fix typo in example in javadoc;this is a trivial javadoc-only change just fixing a typo;  ;;;;1;1;fix typo in example in javadoc;
376;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix typo in example in javadoc.;this is a trivial javadoc-only change  just fixing a typo.;;0;fix requiring hadoop native libraries;;;;;;1;1;fix requiring hadoop native libraries;
376;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix typo in example in javadoc.;this is a trivial javadoc-only change  just fixing a typo.;;0;idiomatic scala adaptor;this is a first pull request for   the scala adaptor is still far from being finished (see todos in `language-adaptors/rxjava-scala/todomd`) but i think its in a state where it can be merged in so that people can try it out and give feedback;"#273  as far as testing is concerned: i mainly tested usability (in the file `language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/rxscalademoscala`) and not whether the operators behave correctly because thats already covered by the tests in rxjava nevertheless i also plan to add such tests in scala || does this break any existing usability with the implicits that have been in place?how does this new approach and those implicits interact or this is a complete replacement? ||  forgot to say  awesome work! thanks so much for your effort and submitting this! || its not a breaking change: the old `rximplicits` are still there and usable its even imaginable to use both approaches in the same project by importing one or the other in scala code if you have an `rxlangscalaobservable` you can always call `asjava` to get the underlying `rxobservable` and to code in languages other than scala `rxlangscalaobservable` appears as `rxobservable` thanks to scalas value classes || ditto! || since this is not breaking i will merge this and release 0131 so people can start trying it out || @samuelgruetter really nice work the value class approach lends itself very well to the jvm-centric approach and allows for easy consumption by all other jvm languages  i share your concern on the maintenance burden of keeping `rxobservable` and `rxlangscalaobservable` in sync  it seems like some sort of codegen approach may ease the burden - do have a sense if that would be a worthwhile endeavor? || @mattrjacobs the whole point of this scala adaptor is that someone manually looks at each method in the java observable and asks ""how should this be done in scala?"" there are more differences between java and scala than one might think and the goal of the adapter is to expose an api which looks as scala-idiomatic as possible some examples for these differences:``` scaladef ++[u >: t](that: observable[u]): observable[u] // instead of concatdef zip[u](that: observable[u]): observable[(t u)] // instance method instead of staticdef dematerialize[u](implicit evidence: t <:< notification[u]): observable[u] // ensures that it can only be called on observables of notificationsdef onerrorresumenext[u >: t](resumefunction: throwable > observable[u]): observable[u] // requires type parameter with lower bound to get covariance rightdef fold[r](initialvalue: r)(accumulator: (r t) > r): observable[r] // curried in scala collections so curry if also heredef sample(duration: duration): observable[t] // using duration instead of (long timepan timeunit duration)def drop(n: int): observable[t] // called skip in java but drop in scaladef zipwithindex: observable[(t int)] // theres only mapwithindex in java because java doesnt have tuplesdef toseq: observable[seq[t]] // corresponds to javas tolistdef switch[u](implicit evidence: observable[t] <:< observable[observable[u]]): observable[u] // ensures that it can only be called on observables of observablesdef apply(range: range): observable[int] // static from becomes apply use scala rangedef never: observable[nothing] // use bottom type```so i would definitely not go for a codegen approach however it might be cool to have a unit test in which we encode the information ""which java method corresponds to which scala method"" and using reflection we check if there is a scala method for each java method so if a method is added to the java observable but not to the scala observable this test would fail || ";;;;1;1;add license headers;
377;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;removed some random unused stuff;removed unused variables  methods  and classes that i happened to stumble upon.;;0;removeif() broken for randomaccess lists that dont support set(); <b>what steps will reproduce the problem?</b>&nbspfinal arraylist&ltinteger> crash  listsnewarraylist(1 2 3 4 5) &nbspiterablesremoveif(liststransform(crash intodouble()) even()) &nbspsystemoutprintln(crash)<b>what is the expected output? what do you see instead?</b>&nbspexpected result should be [135]&nbspinstead this exception is reported:javalangunsupportedoperationexception &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspat javautilabstractlistset(abstractlistjava:115) &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspat comgooglecommoncollectiterablesremoveiffromrandomaccesslist(iterables java: 167) &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspat comgooglecommoncollectiterablesremoveif(iterablesjava:152) &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp <b>what version of the product are you using? on what operating system?</b>&nbsp&nbspguava r05<b>please provide any additional information below</b>this have already been discussed here //groupsgooglecom/group/guava-discuss/browse_thread/thread/2d422600e7f87367/1e6c6a7b41c87aac#1e6c6a7b41c87aac; fine :) ty  ||;;;;0;1;;
377;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;removed some random unused stuff;removed unused variables  methods  and classes that i happened to stumble upon.;;0;remove duplication;simple documentation-only change;  ;;;;1;1;remove duplicationremove duplicate description of automatic @spy field initialization;
377;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;removed some random unused stuff;removed unused variables  methods  and classes that i happened to stumble upon.;;0;tweak exception handling;;;;;;1;1;tweak exception handling;
377;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;removed some random unused stuff;removed unused variables  methods  and classes that i happened to stumble upon.;;0;distinct operator;merging https://githubcom/netflix/rxjava/pull/375;#274 ;;;;1;1;merge branch distinct of git://githubcom/jmhofer/rxjava into distinct-mergeconflicts:	rxjava-core/src/main/java/rx/observablejava;
381;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;change default preferences: remote server is started;i think  the new default makes sense as jabref sometimes opens twice which is a bit annoying for me.  before resetting the preference every now and then  i had the remote server activated for a few months and it worked fine.;;0;objectstostringhelper() should accept class and string as parameter; lets say i have an interface an abstract class and multiple sub classive delegated the tostring method to the abstract class and would like it to show by default: myinterface{} for the moment if i have internal classes extending the abstract one i keep getting weird names like numbersi cant have the string to show whatever i would like it does with the tostringhelper method ive tried using the class and a string but both returns respectively ""class{}"" and ""string{}"" which is not really what i would expectso please add a way to make the following happen:objectstostringhelper(myinterfaceclass) --> ""myinterface{}""objectstostringhelper(""myinterface"") --> ""myinterface{}""i dont think this is really a problem and a pair of instanceof should make it work shouldnt it? or even a few additional method with respectively class and string as parameter are good idea no?"; thank you very much! || ";;;;0;1;;
381;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;change default preferences: remote server is started;i think  the new default makes sense as jabref sometimes opens twice which is a bit annoying for me.  before resetting the preference every now and then  i had the remote server activated for a few months and it worked fine.;;0;add integration tests for prism client;;;;;;1;1;add integration tests for prism client;
381;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;change default preferences: remote server is started;i think  the new default makes sense as jabref sometimes opens twice which is a bit annoying for me.  before resetting the preference every now and then  i had the remote server activated for a few months and it worked fine.;;312.0;312  added documentation in ongoingstubbingthenthrow();this 312  added documentation in ongoingstubbingthenthrow where new throwsexceptionclass() is used to create a new throwable using objenesis;  ;throwsexceptionclass is urealiable - exception doesnt containt stack trace;"the `throwsexceptionclass` is using `objenesishelpernewinstance` which happens to have different strategy of creating objects depending on the jvm used im using java hotspot vm on this machine created `throwable` is initalized with all nullsas a result calling `throwablefillinstacktrace()` has no effect and there is no chance the stack trace is ever filled you can easily observe this behaviour by this sample code:``` javathrowable t  (throwable) objenesishelpernewinstance(throwableclass)tfillinstacktrace()tprintstacktrace()```after a bit of struggling i ended up using `throwsexception` instead of `throwsexceptionclass`objenesis strategy to create instances is dependent on vm name (returned  systemgetproperty(""javavmname"")`) so there is no 100% guarantee that this behaviour is reproduced on your machine";ok thanks for the report can you make a pull request to document that behaviour for `throwsexceptionclass` || thanks @zbigniewtomczak for doing the research on this  i just added the documentation  its in pr #381 ||;1;0;312  added documentation in ongoingstubbingthenthrow() for issue;
381;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;change default preferences: remote server is started;i think  the new default makes sense as jabref sometimes opens twice which is a bit annoying for me.  before resetting the preference every now and then  i had the remote server activated for a few months and it worked fine.;;372.0;implemented `mapwithindex`;as requested by @samuelgruetter in #372;#278 (test failure again due to sporadic timing problems) || i just submitted an [issue]( for this || ;zip/map/select with index;im looking for a function corresponding to this rx c# function: we already have this in rxjava? im asking this because i want to implement the `zipwithindex` function in the scala adaptor;no we do not have that yet your naming convention will be what we need to use so we dont overload methods with functions of different arities as that causes issuesso `mapwithindex` and `zipwithindex` make sense || id be happy with `mapwithindex` and `zipwithindex` || i dont think we have the arity problem with `map` (`mapwithindex`) or do we? i think it should be specific to `zip` so we could name it `map` instead of `mapwithindex` if we wanted to but probably we should be consistent and still call it `mapwithindex` || i take that back i just experimented with this and noticed that at least clojure does indeed have a problem with that so `mapwithindex` it is ||;1;0;implemented mapwithindex;
382;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;correct package declaration of verificationwithdescriptiontest;allows project to compile without errors in eclipse  check list -  pr should be motivated  i.e. what does it fix  why  and if relevant how -  if possible / relevant include an example in the description  that could help all readers      including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history   intention is important please rebase your commit history so that each      commit is meaningful and help the people that will explore a change in 2 years -  read the [contributing guide]( -  mention  <issue number>  in the description _if relevant_ -  at least one commit should mention  fixes #<issue number>  _if relevant_;;0;mapmaker()weakkeys() causes thread leak in webapp; &nbsp&nbspcurrently i am using google-collections 10 if we call new mapmaker()weakkeys()makemap() to create a new map it will start a daemon thread to call finalizereferent method internally&nbsp&nbspthis works fine for any java standalone application however it can cause thread leak in a java ee application because the java ee container may not shutdown for deploy/undeploy an application so the daemon thread will remain in the container after we undeploy the application&nbsp&nbspcan mapmaker create a weak reference map with a flag to enable/disable backgroup thread? cheersdavid; ;;;;0;1;;
382;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;correct package declaration of verificationwithdescriptiontest;allows project to compile without errors in eclipse  check list -  pr should be motivated  i.e. what does it fix  why  and if relevant how -  if possible / relevant include an example in the description  that could help all readers      including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history   intention is important please rebase your commit history so that each      commit is meaningful and help the people that will explore a change in 2 years -  read the [contributing guide]( -  mention  <issue number>  in the description _if relevant_ -  at least one commit should mention  fixes #<issue number>  _if relevant_;;0;correct package declaration of verificationwithdescriptiontest;allows project to compile without errors in eclipsecheck list-  pr should be motivated ie what does it fix why and if relevant how-  if possible / relevant include an example in the description that could help all readers     including project members to get a better picture of the change-  avoid other runtime dependencies-  meaningful commit history  intention is important please rebase your commit history so that each     commit is meaningful and help the people that will explore a change in 2 years-  read the [contributing guide](  mention `<issue number>` in the description _if relevant_-  at least one commit should mention `fixes #<issue number>` _if relevant_;  ;;;;1;1;correct package declaration of verificationwithdescriptiontest;
382;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;correct package declaration of verificationwithdescriptiontest;allows project to compile without errors in eclipse  check list -  pr should be motivated  i.e. what does it fix  why  and if relevant how -  if possible / relevant include an example in the description  that could help all readers      including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history   intention is important please rebase your commit history so that each      commit is meaningful and help the people that will explore a change in 2 years -  read the [contributing guide]( -  mention  <issue number>  in the description _if relevant_ -  at least one commit should mention  fixes #<issue number>  _if relevant_;;0;update to swift-smc 02;;;;;;1;1;update to swift-smc 02;
382;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;correct package declaration of verificationwithdescriptiontest;allows project to compile without errors in eclipse  check list -  pr should be motivated  i.e. what does it fix  why  and if relevant how -  if possible / relevant include an example in the description  that could help all readers      including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history   intention is important please rebase your commit history so that each      commit is meaningful and help the people that will explore a change in 2 years -  read the [contributing guide]( -  mention  <issue number>  in the description _if relevant_ -  at least one commit should mention  fixes #<issue number>  _if relevant_;;0;removing deprecated rximplicits from rxjava-scala;now that @samuelgruetters work on a value class implementation of scala observable has been merged no need for the standalone `rximplicits`;#280  now that  is made public it looks like this can still be deleted || #289;;;;1;1;removing deprecated rximplicits from rxjava-scala;
386;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove deprecated code;fixes for #374 - more left though.;;0;simplifing job concurrency; some times run some process many time ( concurrently ) on diferent data could be really painfullwe could have some object that dispatches jobs in threads have fluent/simple utilizationthis object could provide methods to configure the dispatching like the number of concurrent threadsan exemple of this:list&ltstring> data  arraysaslist( ""abc""""def""""ghi""""jkl"" )```    concurrentjobdispatchercreate()        /* data to be provided to each job         we could have a lot of differents data providers         for collections for suppliers          or even the final developer could write          a own implementation of dataprovider interface         ( providing hashnextdata() and nextdata() methods )*/        withdataprovider( dataprovidersfrom( data ) )         /*            * number of simultaneous threads          * */        withconcurrencylevel( 5 )        /*        * code to be executed on the threads            */        withjob( new concurrentjob<string>() {        @override        public void run( string data ) {               systemoutprintln( data )                            }        } )        /*         * starts the dispatcher and block the caller threads         * ( could also have a executeinbackground() or only execute() )           */        executeandwait()```"; i agree that could be useful it also feels a bit out of scope with respect to guava but thanks for sharing!--- ;;;;0;1;;
386;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove deprecated code;fixes for #374 - more left though.;;0;add window functions;;looks good but @martint should review the planning code || other than those comments it  looks good ship it! ||;;;;1;1;address review comments for window functions;
386;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove deprecated code;fixes for #374 - more left though.;;0;android : how to manage screen rotation with observer;hi since i have discovered rx java i have replaced all my async  loaders by observers and observables thats very cool to easily get an error to the ui thread i have still a question as you know when the screen rotate the activity is killed and recreated i am wondering how should i do to resubscribe to the same observable launched before the rotation is there a pattern i have not think of? or is it a feature to come? i am very new to reactive programming and i perfectly realize i am using 1% of the power of rx java but can you help me to reach the 2%?thank you;"something else but related is there a way to stop an observable during its work? i noticed that when onerror is called the process is stopped is there a way to call the stop method from the main thread? || i dont have experience with android so cant help on this perhaps the rxjava google group would be a better place to ask? || hi @benjchristensen indeed it s not really an android issue it s a more general issue which may happen more often on androidthe point is that i am getting many ```javalangruntimeexception: error occurred when trying to propagate error to observeronerror```the reason is easy to understand the activity which is also the subscriber has been closed (because the screen rotate but we dont really care) before the observable catch an error and try to send it back to the subscriberbecause of the way safeobserver works it crash all the application``` java @override    public void onerror(throwable e) {        if (isfinishedcompareandset(false true)) {            try {                actualonerror(e)            } catch (throwable e2) {                if (e2 instanceof onerrornotimplementedexception) {                    /*** onerror isnt implemented so throw**  rx design guidelines 52** ""when calling the subscribe method that only has an onnext argument the onerror behavior will be* to rethrow the exception on the thread that the message comes out from the observable sequence* the oncompleted behavior in this case is to do nothing""*/                    throw (onerrornotimplementedexception) e2                } else {                    // if the onerror itself fails then pass to the plugin                    // see  for further discussion                    rxjavapluginsgetinstance()geterrorhandler()handleerror(e)                    rxjavapluginsgetinstance()geterrorhandler()handleerror(e2)                    // and throw exception despite that not being proper for rx                    //                     throw new runtimeexception(""error occurred when trying to propagate error to observeronerror"" new compositeexception(arraysaslist(e e2)))                }            }            // auto-unsubscribe            subscriptionunsubscribe()        }    }```so in a general is there a way to deal with an error reported after the subscriber unsubscribe and even disappears? || > so in a general is there a way to deal with an error reported after the subscriber unsubscribe and even disappears?the event is not relevant to the subscription at that point since the subscriber is gone> because of the way safeobserver works it crash all the applicationwhat about `safeobserver` would crash the application?> javalangruntimeexception: error occurred when trying to propagate error to observeronerrorthat error does not mean the `observer` is unsubscribed that means the `observer` is failing to handle the `onerror` event and thus there is no choice but to throwso why is the `observeronerror` failing when an exception is passed to it?> i think this happens because we can not disable handlerthreadscheduler when the activity stopsis the activity youre referring to an `observable` or an `observer`?if it is an `observable` then it should emit an `oncompleted` and be doneif is is an `observer` then it should unsubscribe from the `subscription` it received when it called `observablesubscribe` and it will give the `observable` a chance to shutdown and clean upthe `scheduler` does not have a `cancel` on it because what would that mean? scheduling is per task (the `schedule` methods) and when something is scheduled it returns a `subscription` thus the `subscription` is cancelled (`subscriptionunsubscribe`) not the entire `scheduler`if you can post a unit test demonstrating the issue that would help || sorry that i misunderstood this issue i deleted my comments || @benjchristensen thank you for your answer (-> questions :-) )it made me search in the right directioni think i know understand what was happeningon android ui stuff is realized in an activityif a user rotates the phone (say from portrait to landscape) the activity is killed a new one is then recreatedof course in the rotation you loose everything there are some techniques to keep variable values however but in general it has to be stored in a bundle object android boring stuffanyway in my first implementation i followed the blog post from @mttkay without really understanding how rx works inside so the activity class was implementing the observer interfaceit means that if the user rotate its phone you better have to call unsubscribe method or you will use a zombie  activity / observerunfortunately i look at the source code of rx and i understood that observable built outside rx are wrapped inside a safeobservable and that safeobservable will keep a hard reference to the observer preventing it to be nullified + garbage collectedin normal case it should not be an issue because unsubscribe should have been called right? but unfortunately in some cases i have still not found why unsubscribe method is not called (lots of corner case in my app)at the end of the story i get a call to onerror() because an exception has been released in the working thread inside the observable this method is the one from an observer which is also an activity and this observer/activity should have been destroyed -> doing stuff in a dead but not destroyed activity  crash the applicationbased on  the comment from @mttkay i have written a simple proxy observer to avoid this situation (miss the unsubscribe + observer has disappeared)``` javaimport javalangrefweakreferenceimport rxobserverpublic class androidproxyobserver {    public static <t> observer<t> secure(observer<t> obs){        return new proxyobserver<t>(obs)    }    private static class proxyobserver<t> implements observer<t>{        final private weakreference<observer<t>> mcallback        private proxyobserver(observer<t> obs){            mcallback  new weakreference<observer<t>>(obs)        }        @override        public void oncompleted() {            if(mcallbackget() ! null) {                mcallbackget()oncompleted()            }        }        @override        public void onerror(throwable throwable) {            if(mcallbackget() ! null) {                mcallbackget()onerror(throwable)            }        }        @override        public void onnext(t object) {            if(mcallbackget() ! null) {                mcallbackget()onnext(object)            }        }    }}```nothing complex just a weak reference so if the activity is destroyed there is no more hard reference to it to avoid cleaning / garbage collection the observer /activity will be killed at the device rotation and no more call to onerror() method is then possible because the weakreference wrapper will be emptymay be this code should be added to the android contrib folder i will wait comments from you or @mttkay or whoever would see anything interesting in this simple snippet may be i am missing something else!moreover i am trying to build a class to manage easily the device rotation (or any activity/observer destruction) in this gist :  i am waiting opinion from advanced rxjava user to see if it s useful / correct / has to be committedagain thank you for having help to build such tool i am very happy when using it!regards || i think you need to call `msubscriptionunsubscribe` before the activity is destroyed (eg call in `activityonstop` or `activityondestroy`) after that the new events in the scheduler will be dropped || @pommedeterresautee we use a similar approach ie using a `weakreference` however the class we use does some additional things to make it more sound when being used to update the ui we use an observer implementation which binds a fragment to a weak reference in every callback it first checks ifa) the reference is still set (thats what youre doing too)b) if the fragment is still attached (thats what youre not doing)if you dont do b) your app might still crash since `getactivity` returns null when the fragment is not attached if you dont use fragments (i hope you do!) then you should probably check for `isfinishing` and drop the message if thats truethat class i wanted to contribute back since it is production proven for a few months now and has proper unit tests and everythinghowever i actually like the idea of decoupling the two concerns ie i see it could be beneficial (although slightly more complex to use) to have a `weakobserver` (i think androidproxyobserver is probably not a good name since it doesnt convey any meaning) which could wrap a `fragmentobserver` or `activityobserver` which then do the above mentioned extra checks necessary when one wants to update the ui in `oncompleted`@benjchristensen do you think a `weakobserver` is something that should be part of the core module? it sounds more universally applicable than to just android its simply an observer which doesnt guarantee to deliver any of the messages (that might or might not be in violation with the design guidelines but we actually do require this behaviour on android to not leak resources) || @zsxwing of course i have such call in ondestroy method however i cant reproduce exactly what happens when the application crashes but in my observable (the one having issues) i am executing some shell commands  and in some cases for some reasons unsubscribe doesnt kill immediately the working thread most of the time it does but not always i have not studied how unsubscribe works inside and why / how it happens but the weak reference security avoid the effects of this behavior regards || @mttkay and @benjchristensen this post looks applicable || interesting thanks this paragraph applies to android in the same way it applied to the author:> there are some rare scenarios in gui and some other programming when the unsubscription moment is non-determined and using the strong subscription will cause memory and resources leaks so its not possible to explicitly control the unsubscription sometimesandroid may decide non-deterministically that its time to destroy a ""sleeping"" activity eg because the system runs out of memory i think weak references are an easy and straight forward way to deal with this the activity is either there or its not if its not drop the message as consuming it would crash the appits an interesting thought however to implement this on the `observable` level rather than in a decorating observer this for me falls into the general question that keeps bugging me: which parts of rx should be implemented as operators and which parts in observers in this case i found the observer to be the more natural place since the requested behaviour is purely specific to the subscriber side i dont really see how an operator that turns an observable sequence into a less ""reliable"" sequence is very useful outside this case which seems to be specific to guis || i also noticed that his implementation of a `weakobserver` auto-unsubscribes from the observable:  could be useful on android too || actually just talked to a co-worker about this and it might end up being quite powerful after all to implement these things as an operator (eg `operationtouserinterfaceevents`) this would reduce client side boiler plate even further by doing the following things:1 wrap both the subscription and the target observer in an inner observer that keeps weak references2 automatically schedule the observer on the android ui thread (since this is just boilerplate right now)3 automatically unsubscribe if the reference to the target observer is gonethis still doesnt encompass checking for `isattached` or `isfinishing` but perhaps that bit could remain in the observer thoughts? || @pommedeterresautee which scheduler do you use? does your `onnext` method run in the ui main thread or a non-ui thread? if it runs in a non-ui thread `onnext` has a change to run after `unsubscribe` for example this is a snippet of codes in `rxoperatorsscheduledobservereventloop` which try to invoke your `onnext` method ``` java            do {                notification<? extends t> notification  queuepoll()                // if we got a notification send it                if (notification ! null) {                    // if unsubscribed stop working                    if (parentsubscriptionisunsubscribed()) {                        return parentsubscription                    }                    // process notification                    switch (notificationgetkind()) {                    case onnext:                        underlyingonnext(notificationgetvalue())                        break                    case onerror:                        underlyingonerror(notificationgetthrowable())                        break                    case oncompleted:                        underlyingoncompleted()                        break                    default:                        throw new illegalstateexception(""unknown kind of notification "" + notification)                    }                }            } while (counterdecrementandget() > 0)```if this part of codes run in a non-ui thread it may be suspended at `switch` statement then the ui thread runs and invokes the `activityondestroy` method even if `unsubscribe` is called in the  `activityondestroy` method when the non-ui thread is back it still will call the `onnext` methodim not sure if this is the cause of your issue could you check it? || @mttkay```which parts of rx should be implemented as operators and which parts in observers?```all operators are implemented as observers with sprecial behavior by having them as operators it allows for composition when i use rx i generally try to have the final observer be as simple as possible often there the body the onnext empty || thanks @abersnaze that sounds sensible i will set some time aside this or next week to move this behaviour to an operator || @zsxwing in my application the observer is an activity and so the onnext() method is called on ui threadmy issue may be related to the fact that i was not checking isfinishing() method as reminded by @mttkay  may be in some cases the activity is being destroyed when onerror() is called before the unsubscribe inside the ondestroy callback is called making the application crash@mttkay i try use as few as possible fragment it introduces complexity in android application i use them when i need to have different ui regarding the size / orientation of the screen but i try to wrap separated task inside dedicated activities if possible to limit the lots of complex bugs affecting fragments however thats android stuff not related to rx may be not the place to discuss about thatregarding the question where to put stuff i like the idea to wrap as much as possible things inside a class hiding checks auto unsubscribing  code to the user of the libraryin particular on android most people will have the same needs regarding executing some async work no need to bother them more than the strict minimumhowever i dont get why isfinishing / isattached should be check in the observer by the lib user? if you have a weak ref to your observer in your operationtouserinterfaceevents class why not do the job there?regards || @pommedeterresautee as to your last question because the `observer` isnt necessarily a fragment or activity it could be an inner class of either so you cannot invoke these methods on the observer directly || @mttkay i think 90% of users will implement the observer interface in their activity/fragment directly as they do for loadermanagerloadercallbacks when implementing asynctaskloaderso it may be a good thing to manage both cases if observer is an instance of activity make all the boring work otherwise its up to the lib user to implement these checks in the observer || could you guys weigh in on this?  || is work still happening on this issue or shall we close it out? || imo it can be closed  || ";;;;0;1;;
386;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove deprecated code;fixes for #374 - more left though.;;374.0;remove deprecated code;fixes for #374 - more left though;  ;remove deprecated api from mockito 2;# this is a reminder to remove all deprecated apis from the upcoming mockito 2this issue blocks #123 [release mockito 20](123)relates to -  #273 [get rid of returnvalues](273);;1;0;delete class that was moved to internal;
389;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;lazily verify without calling collector.verify();as originally requested in #287: lazily verify all  mockito.verify()  calls inside junit test cases.;;0;internetdomainnamefrom fails with capital letter i in turkish locale; internetdomainnamefrom is using stringtolowercase without passing a locale when the domain contains a capital letter i this will convert it to a small letter dotless i if the default locale is turkish; ;;;;0;1;;
389;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;lazily verify without calling collector.verify();as originally requested in #287: lazily verify all  mockito.verify()  calls inside junit test cases.;;0;lazily verify without calling collectorverify();as originally requested in #287: lazily verify all `mockitoverify()` calls inside junit test cases;i have to say that the code based on java 8 would be so much cleaner this could deter all verbose wrapping and setters with using  ;;;;1;1;lazily verify without calling collectorverify();
389;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;lazily verify without calling collector.verify();as originally requested in #287: lazily verify all  mockito.verify()  calls inside junit test cases.;;0;move to airbase build;this requires  be applied and the appropriate snapshots pushed to central;;;;;1;1;move to airbase build;
389;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;lazily verify without calling collector.verify();as originally requested in #287: lazily verify all  mockito.verify()  calls inside junit test cases.;;0;scala adaptor improvements;includes groupby scala readme examples moving implicitfunctionconversions out of internal package multicast publish replay and methods for blockingobservablenote that the commit  modifies core by making the java `subject<t r>` used as contravariant in `t` and covariant in `r` which allows me to write scalas multicast without typecasting;#287] looks good to me unit test pass on my machine  ||;;;;1;1;add methods to blockingobservable;
404;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed some coverity and some eclipse warnings;;;0;build errors with ant target gwtcompile due to bad classpath; theres a mistake in the ant target for compiling the gwt support codepatch attached; ;;;;0;1;;
404;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed some coverity and some eclipse warnings;;;0;make constant final;;;;;;1;1;make constant final;
404;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed some coverity and some eclipse warnings;;;0;add fromchangeevents methods to swingobservable;for swing components which fire `changeevent`s i added a method `swingobservablefromchangeevents` similar to the other methods of `swingobservable` unfortunately there is no common base interface for all components which fire `changeevents`s so i created one myself: `changeeventsourcechangeeventcomponentwrapper`then each component which fires `changeevents`s needs its own overload in `swingobservable`an other approach would be to use reflection but then we loose typesafety;"#309] before merging this we should also try a solution with reflection and then decide which one is better || @jmhofer can you comment on this as well since you were involved in the first submission of rxjava-swing? || looks good to me - will all these overloads work with dynamic languages though?i wouldnt want to switch to reflection for this even if its a bit ugly doing all this by hand || i think we should at least try a solution with reflection because this would also work with custom components which have `addchangelistener` and `removechangelistener` methods with reflection we lose typesafety but c# also uses reflection when i call something like``` csobservablefromeventpattern<eventargs>(mytextfieldcomponent ""textchanged"")```see  || im always very sceptical when it comes to anything to do with reflection but i see your point if i understand you right you want to simulate a scala structural type here correct? this could very well be worth it || #318 for testing the negative maybe send a mock(observer) and then verify(obr times(1))onnext(sentevent) || this is a very long discussion  is this ready for final review and merge? || @abersnaze is this ready to merge? || ive added some more commits just to avoid duplicate work but imho this is not yet ready for merge || #340  is this waiting on peoples time or is there something fundamental still to decide upon? || last comment 20 days ago was that this is still not ready to merge so where is this going? || i think the current reflection-based approach is good but the unit tests need to be rewritten from scratch and it might also need some polishing i dont have time now but if no one does it until december i will do it then || closing  if any of you want to revive at some point please send another request || ";;;;0;1;;
404;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed some coverity and some eclipse warnings;;;374.0;374 removed deprecated classes and methods;374 removed deprecated classes and methods;"thanks for this pr and for fixing the formatting could you also squash all commits to a single one for better versioning?  @raphw i  the line ending issue is it okay to squash the commits once the review of all commits is fine? the removal of some deprecated classes and methods was more than simply removing it eg mockitojunitrule if my implementation is not okay it can easily be reverted  || @raphw do you know why the check ""codecov/changes"" fail? || @christianschwarz fixing issue and will report back shortly || @christianschwarz can you submit an empty commit for another rebuild i believe this issue was fixed within the last 6 days thank you || i do not currently have good internet access (vacation) please repush (forced) and see if it worksthanksfor the effort this will be merged eventually  || @raphw and @stevepeak thanks for your support ||   @raphw @szczepiq  @bric3 sorry for stressing you the people want mockito 2 & 3 (lambda) please comment and/or merge this pr its a little step in the right direction || ping || lgtm thanks for doing the chore work! || ";remove deprecated api from mockito 2;# this is a reminder to remove all deprecated apis from the upcoming mockito 2this issue blocks #123 [release mockito 20](123)relates to -  #273 [get rid of returnvalues](273);;1;0;374 removed deprecated types and methodsremoved deprecated deprecatedongoingstubbing and iongoingstubbingremoved deprecated method mockitostubvoid()removed deprecated annotation mockitoannotationsmockremoved @deprecated annotations of inner classes of bddmockito and madethem privateremoved deprecated methods verificationwithtimeoutnever() andverificationwithtimeoutatmost()removed deprecated class mockitojunitruleremoved deprecated enum answersremoved deprecated method invocationonmockgetargumentat(intclass)removed deprecated class returnselementsof compile error in extramatcherscorrected wrong package declaration in verificationwithdescriptiontest;
412;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixed #407 vararg method call on mock object fails;;;0;hide slf4j classes from plugins;;some minor stylistic comments looks good otherwise  || ;;;;0;1;;
412;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixed #407 vararg method call on mock object fails;;;0;bufferingobserver;we sometimes find that we want to hold on to items emitted by an observable before forwarding them to the final destination we therefore came up with a naive implementation of a `bufferingobserver` which acts as a decorator and can be thought of as a reactive array buffer it waits for `oncompleted` then flushes all items to a delegate observer one would then subclass `bufferingobserver` to provide extra behaviour before emitting the resultthis is different from `operationbuffer` or `operationtolist` in that we do not consider this part of the event stream and it might even cause side effects on eg ui components so we did not want this to be executed as part of an observable sequence we use it purely to orchestrate ui callbacks like checking a result set before emitting it to a different observer that then updates the ui in some way shape or formwe will probably have this in an upcoming pr for the android submodule but wanted to check if anyone thinks this might make sense to have in the core library?otherwise feel free to just close this;"im not sure i understand ""we did not want this to be executed as part of an observable sequence"" how is it executed then?  how does this compare to the `replaysubject`? or `tolist()mapmany({ list -> observablefrom(list) })`? || by that i mean its not supposed to be a transformation of the underlying observable but rather something that is specific to one of n observers on the listener side its used as a means to decorate one of potentially many ui observers in our case and observers deriving from it actually manipulate view objects (ie mutate state)in other words: i neither want the observable sequence to get collapsed into a list (since other observers might still operate on individual elements) nor do i want side effecting operations be executed as a transformation of the sequenceheres some dummy code showing how we use it:```connectableobservable observable  servicecall()publish()observablesubscribe(observer1) // consumes an item directlyobservablesubscribe(new custombufferingobserver(observer2))observableconnect()```the custom buffering observer would cache the results perform some other (ui related) task then emit the results i cant transform the sequence itself since otherwise observer1 would have to be rewritten to take a list of t instead of t which is not what i wantlet me know if that still doesnt make sense to you i might simply be missing something || the tolist mapmany combo can be localized to just one of the subscription calls```connectableobservable observable  servicecall()publish()observablesubscribe(observer1) // consumes an item directlyobservabletolist()mapmany({ list -> observablefrom(list) })subscribe(observer2)observableconnect()``` || im confused does line 3 actually do anything? the observable is transformed into 2 different observables that are not connectable observables anymore so the call to subscribe on line 3 will fire immediately instead of connecting the observer to the published stream? || the tolist mapmany combo is chained off the connected observable it can not bypass it  the tolist buffers all the items and the mapmany unwraps observable<list<t>> again back to an observable<t> so the following subscribe is in the wiser || interesting i shall try that instead-- ";;;;0;1;;
412;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixed #407 vararg method call on mock object fails;;;407.0; #407 vararg method call on mock object fails;;@andreyrmg can you add your test too? || oh yes of course! im sorry but only tomorrow ||   added test || +1 for adding unit tests!can you also add your `defaultanswerdemo` test case to the usage tests (package orgmockitousagestubbing)? name proposal: stubbingwithdelegatevarargstest || sorry for delay i added usage test case and squash commits into oneand there is need to extend from `testbase` for calling help method `orgmockitoutiltestbase#invocationof(javalangclass<?> javalangstring javalangobject)` || lgtm thanks for figuring this one out and adding an extensive test suite luckily an easy fix ||;vararg method call on mock object fails when used orgmockitoadditionalanswers#delegatesto;"i try to mock interface with varargs method and default implementation in final class and get this error:```javalangillegalargumentexception: wrong number of arguments    at sunreflectnativemethodaccessorimplinvoke0(native method)    at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javalangreflectmethodinvoke(methodjava:498)    at orgmockitointernalstubbingdefaultanswersforwardsinvocationsanswer(forwardsinvocationsjava:31)    at orgmockitointernalhandlermockhandlerimplhandle(mockhandlerimpljava:93)    at orgmockitointernalhandlernullresultguardianhandle(nullresultguardianjava:29)    at orgmockitointernalhandlerinvocationnotifierhandlerhandle(invocationnotifierhandlerjava:38)    at orgmockitointernalcreationmethodinterceptorfilterintercept(methodinterceptorfilterjava:51)```i run the following code:``` javapublic class defaultanswerdemo {    public interface foo {        void bar(string baz object args)    }    public static final class fooimpl implements foo {        @override        public void bar(string baz object args) {            systemoutprintln(""bar"")        }    }    @test    public void defaultanswertest() {        foo fooimpl  new fooimpl()        foo foo  mock(fooclass withsettings()                defaultanswer(delegatesto(fooimpl)))        foobar(""baz"" 12 ""45"" 678)    }}```this is happens because orgmockitointernalinvocationinvocationimpl by default expands varargs arguments to flat list and i have no idea how correctly fix this";"this is a bug in [forwardsinvocations]( as you already investigated the expanded varargs are passed to the delegatethe current implementation does this:```result  delegatemethodinvoke(delegatedobject arguments)```mockito look for method with the signature `stringintstringdouble` for the given arguments (""baz""12""45""678) but such a method doesnt existsto fix the issue the raw/unexpanded arguments must be used```object rawarguments  ((invocation)invocation)getrawarguments() result  delegatemethodinvoke(delegatedobject rawarguments)```now mockito looks for method signature `stringobject` which is the var args method you want note: it is safe to cast to `invocation` here cause answers always get a invocation-instance passed from `mockhandlerimpl` if i find some time i will send a pr with a fix or you or some one else start to fix it  || here is pr i thought about cast but may be better pull up method [orgmockitoinvocationinvocation#getrawarguments]( to interface [orgmockitoinvocationinvocationonmock]( || @andreyrmg pulling `getrawarguments()` up to `invocationonmock` would help in this narrow use case on the other side it bloat the public api and migth confuse clients that implement custom answers which method to choose `getarguments()` or `getrawarguments()`  wdyt? || yes i agree with you but i think this is already a bit confusing that method `getargument()` returns expanded varargs maybe we need two methods `getarguments()` and `getexpandedarguments()`? || adding new api or changing existing behaviour need to be discussed with the core-membersi agree with you `getarguments()` should return unaltered/not expanded arguments the current `getarguments()` implementation has also the problem that is cant distinguish an null-vararg argument / `varargmethod(new type{null})` from an null-varag array / `varargmethod((type)null)` || ";1;0; #407 vararg method call on mock object fails;
413;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed method name to verifynomoreinteractions;;;0;add a function<supplier<t> t> to suppliers; eg```private static class evalfunction<t> implements function<supplier<t> t> serializable {    private static final long serialversionuid  0l    public static final evalfunction instance  new evalfunction()    public t apply(@nullable supplier<t> o) {        checknotnull(o)        return oget()    }    @override    public string tostring() {        return ""eval""    }}@suppresswarnings({""unchecked""})public static <t> function<supplier<t> t> eval() {    return evalfunctioninstance}@suppresswarnings({""unchecked""})public static <t> function<supplier<t> t> eval(iterable<supplier<t>> tclass) {    return evalfunctioninstance}```"; ;;;;0;1;;
413;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed method name to verifynomoreinteractions;;;0; method name to verifynomoreinteractions;;  lgtm ;;;;1;1; method name to verifynomoreinteractions;
413;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed method name to verifynomoreinteractions;;;0;fix plugin class loader  getresources implementation;;;;;;1;1;fix plugin class loader getresources implementation;
413;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed method name to verifynomoreinteractions;;;85.0; the issues of takelast(items 0) and null values;"hithere are two issues about `takelast` #85 #140 the essential cause is `linkedblockingdeque`1 count  0   `takelast` in rxjava will throw an exception when count  0 as `linkedblockingdeque` rejects count < 0 however in c# takelast with 0 count is valid the following codes is ok in c# (no exception and do nothing):``` c#            var source  observablereturn(1)takelast(0)            sourcesubscribe(                x >                     consolewriteline(""subscriber got "" + x)            )            consolereadline()```1 null values   linkedblockingdeque requires the elements can not be null but an observable can emit a null valuei used `reentrantlock` and `linkedlist` to replace `linkedblockingdeque` please take a look thanks";#319  #321 merging as this seems correct  but i question whether we need any of this synchronization in here since this operator would never be multi-threaded it can count on the rx contract to have sequential onnext eventsthus i wonder if the performance hit of all this synchronization is a concern or necessary im favoring functionality and merging now  but something to consider for the future ||;operator: takelast;http://msdnmicrosoftcom/en-us/library/hh212114(vvs103)aspx;;1;0; the issue about null values;
419;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;bddmockito: rename willnothing to willdonothing;.. and keep the original signature as deprecated;;0;a way to get a function that looks up counts in a multiset; either: function&lte integer> multisetscountfunction (multiset<? extends e> multiset)or: map&lte integer> multisetsasmap(multiset<? extends e> multset) so that i can then run the resulting map through functionsformap() presumably the map view would return null if the count for an element was 0 which is a little odd but otherwise the size() of the map wouldnt make any sense so maybe the first one is better; if i were going to do it like that itd be multisetscopyhighestcountfirst(multiset)entryset()aslist()get(0)getcount() since youve got the cheap aslist() view  the issue of sorting the whole thing is why i didnt suggest that though || re: asmap i would recommend switching to atomiclongmap which is very similar to a multiset and does have an asmap viewre: countfunction see the explanation in louiss ""2014-10-01 at 09:35 pm"" comment || a lot of other ideas came up in this thread and if any of them are worth preserving please file them separately || ";;;;0;1;;
419;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;bddmockito: rename willnothing to willdonothing;.. and keep the original signature as deprecated;;0;bddmockito: rename willnothing to willdonothing;and keep the original signature as deprecated;it linguistically sounds better to mei wonder if we need regression tests to stay in place if original method will be removed one daybtw @alb-i986 travis failed but it looks like a flaky test could you trigger it once again (eg with `git commit --amend`) || > i wonder if we need regression tests to stay in place if original method will be removed one daylooks like there are no tests in place for `willnothing` probably because it is not doing much but just forwarding to `mockito#donothing` || whats the story with this?maybe you want me to first open an issue as per contributing guidelines?cheers || @alb-i986 thanks for the ping i think this is fine so lgtm the deprecated method can be removed in mockito 30 ||;;;;1;1;bddmockito: rename willnothing to willdonothingand keep the original signature as deprecated;
419;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;bddmockito: rename willnothing to willdonothing;.. and keep the original signature as deprecated;;0;more task info;;;;;;1;1;add nomoresplits declarations to task info;
419;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;bddmockito: rename willnothing to willdonothing;.. and keep the original signature as deprecated;;0;marble diagram improvements;many thanks @davidmgross for all these nice marble diagrams theyre awesome!here are some suggestions for improvements:-    interval: starts at 0 not at 1-    flatmap/mapmany: make clear that theres an underlying merge (currently it looks as if the items of observable `i+1` were only emitted once observable `i` has completed)-    where/filter: it might be nicer if the predicate was a shape-    scan: also show that if frequency of source observable is lower than sampling frequency elements are repeated-    zip: it looks like this operator can fetch elements from the future -)-    make the diagrams open source;"thanks for the feedback!  ill make the adjustments you suggestthe diagrams are already open-source: thoughtheyre in a proprietary format ( wed oct 2 2013 at 1:43 am samuelgruetter notifications@githubcomwrote:> many thanks @davidmgross  for all these> nice marble diagrams theyre awesome!> > here are some suggestions for improvements:> - interval: starts at 0 not at 1> - flatmap/mapmany: make clear that theres an underlying merge>   (currently it looks as if the items of observable i+1 were only>   emitted once observable i has completed)> - where/filter: it might be nicer if the predicate was a shape> - scan: also show that if frequency of source observable is lower than>   sampling frequency elements are repeated> - zip: it looks like this operator can fetch elements from the future>   -)> - make the diagrams open source> > —> reply to this email directly or view it on github  || could you clarify what you meant about ""scan"" and its sampling frequency? did you mean ""sample"" or one of the ""throttle""s?on fri oct 4 2013 at 11:33 am david gross davgross@netflixcom wrote:> thanks for the feedback!  ill make the adjustments you suggest> > the diagrams are already open-source:>  though> theyre in a proprietary format ( > on wed oct 2 2013 at 1:43 am samuelgruetter notifications@githubcomwrote:> > > many thanks @davidmgross  for all these> > nice marble diagrams theyre awesome!> > > > here are some suggestions for improvements:> > - interval: starts at 0 not at 1> > - flatmap/mapmany: make clear that theres an underlying merge> >   (currently it looks as if the items of observable i+1 were only> >   emitted once observable i has completed)> > - where/filter: it might be nicer if the predicate was a shape> > - scan: also show that if frequency of source observable is lower> >   than sampling frequency elements are repeated> > - zip: it looks like this operator can fetch elements from the future> >   -)> > - make the diagrams open source> > > > —> > reply to this email directly or view it on github >  || oh yes i meant ""sample"" not ""scan"" || thank you @davidmgross for fixing these in  || ";;;;0;1;;
424;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;inorder timeouts;*fixes issue    *updated code provided by  in pr #20  closes #20;;0;inputsupplierfor() and outputsupplierfor() methods; while working with plain vanilla java io apis and with guava at the same time i found myself defining the same two methods pretty often:```public static <w> outputsupplier<w> outputsupplierfor(final w writer) {    return new outputsupplier<w>() {        @override        public w getoutput() throws ioexception {            return writer        }    }}public static <r> inputsupplier<r> inputsupplierfor(final r reader) {    return new inputsupplier<r>() {        @override        public r getinput() throws ioexception {            return reader        }    }}```may be its better to put the somewhere in the library?; the problem with that is that suppliers can be reused but readers/writers cant its like the difference between iterable and iterator--- ;;;;0;1;;
424;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;inorder timeouts;*fixes issue    *updated code provided by  in pr #20  closes #20;;0;fixes;;;;;;1;1;make tests use bootstrap;
424;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;inorder timeouts;*fixes issue    *updated code provided by  in pr #20  closes #20;;20.0;inorder timeouts;*fixes issue   *updated code provided by  in pr #20closes #20;could you please add tests to make sure the code is correctly behaving?also you have some unrelated changes mostly imports reordering please remove those as well || i should have some time to work on the code changes this weekend || @timvdlippe there was already a test there i just removed the @ignore tag ill add one for the exception throwing behavior as well i also removed the import reordering my ide was trying to be super helpful! || @jazzepi sounds great! :+1: the codecov status has to pass before this can be merged after the current feedback has been processed i will take another look but i think so far it is looking good! || @jazzepi could you rebase this pr and commit your changes? i would like to merge this sooner rather than later ||   @timvdlippe i think it should all be in working ordering now ive been doing git force pushes to my branch no idea if thats the accepted style but github seems to be figuring out what im doing i just wish it were layering patchsets on like gerrit does@christianschwarz i really puzzled over what you were looking for and could not understand how i could improve the code in the way youre describing id prefer this changeset get merged and then make whatever style changes you wanted yourself || lgtm ;implemented support for inorder evaluation of timeout verificationmode; for [issue 292]( that while the provided wrapping mechanism is generic enough to support both timeout and after usage the current implementation of verificationwithtimeouttestjava prevents correct usage with after this is because it repeatedly verifies until the timeout has elapsed thus marking all invocations that may have matched in the meantime as verified this will of course exhaust correct invocations and more often than not fail on the verification before the ager time has elapsed;hi im basically ok with the pr however i have a few remarks :- i dont like the name `verificationwrapperinorderwrapper` i would prefer something more meaningful in the same way the existing `verificationwrapper` could be renamed as well if you have some proposition ill gladly hear them- also it might be interesting to refactor existing code to support `verificationinordermode` so the code dont have to check against `verificationwrapper` class || ill review it soon thanks for the pr! || this is a feature id like too whats the status of this? any plans to merge it or put it on the road map? || we want to merge it but so far there wasnt enough time sorry! || i could also use this feature!  @sirchia could you please rebase this pr on current master then i can take a look and review sorry for the extremely delayed response hopefully you are still interested in making this contribution up-to-dateif this pr is not updated within 2 weeks i will close it as stale || @timvdlippe i had actually done that for my own private usage a while back ive provided a  that rebases the original pr by @sirchia ||;1;0;inorder timeouts  *fixes issue   *updated code provided by  in pr #20;
424;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;inorder timeouts;*fixes issue    *updated code provided by  in pr #20  closes #20;;54.0;implemented the ignoreelements operator;hii implemented the `ignoreelements` operator #54 please take a look thanks;#333  can you rebase this with the changes to master so it can be cleanly merged again? with all the other changes this no longer cleanly mergesthank you @zsxwing for this and all the other pull requests i really appreciate your involvement in the project || i rebased the pull request now it should be able to merge to master directly || #336 #337 looks good ||;operator: ignoreelements;http://msdnmicrosoftcom/en-us/library/hh229242(vvs103)aspx;;1;0;implemented the ignoreelements operator;
427;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactored class reporter to a static utillity;426 for class reporter   this pr changes the way errors are created and thrown. all methods of the reporter are now static so they can be imported statically and return an exception instead of throwing it directly. this improves the readability and eliminates the use of hacks to satisfiy the compiler.  here is a sample:      public list<t> getlastvarargs() {         if (arguments.isempty()) {             reporter().noargumentvaluewascaptured()              return null          } else {             return arguments.getlast()          } }      the above code snipped can be rewritten to this:      public list<t> getlastvarargs() {         if (arguments.isempty()) {             throw noargumentvaluewascaptured()          }          return arguments.getlast()  };;0;make immutablesortedmultiset public; id very much like to have a sortedmultiset interface to generalize treemultiset perhaps offering submultiset headmultiset etc for the sake of java 5 compatibility its elementset() would have to be a sortedset but perhaps in the future we could add the logical analogs of the various navigableset implementationssubversion is the last major rcs that i havent used yet so im just going to hope im attaching my changes in a fashion that will be useful; marked as release 12 just so its in the list of issues--as-of-12--- ;;;;0;1;;
427;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactored class reporter to a static utillity;426 for class reporter   this pr changes the way errors are created and thrown. all methods of the reporter are now static so they can be imported statically and return an exception instead of throwing it directly. this improves the readability and eliminates the use of hacks to satisfiy the compiler.  here is a sample:      public list<t> getlastvarargs() {         if (arguments.isempty()) {             reporter().noargumentvaluewascaptured()              return null          } else {             return arguments.getlast()          } }      the above code snipped can be rewritten to this:      public list<t> getlastvarargs() {         if (arguments.isempty()) {             throw noargumentvaluewascaptured()          }          return arguments.getlast()  };;0;make hive view error message a constant;;;;;;1;1;make hive view error message a constant;
427;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactored class reporter to a static utillity;426 for class reporter   this pr changes the way errors are created and thrown. all methods of the reporter are now static so they can be imported statically and return an exception instead of throwing it directly. this improves the readability and eliminates the use of hacks to satisfiy the compiler.  here is a sample:      public list<t> getlastvarargs() {         if (arguments.isempty()) {             reporter().noargumentvaluewascaptured()              return null          } else {             return arguments.getlast()          } }      the above code snipped can be rewritten to this:      public list<t> getlastvarargs() {         if (arguments.isempty()) {             throw noargumentvaluewascaptured()          }          return arguments.getlast()  };;0;[rfc] initial implementation of operationobserveinforeground (android);in reference to the discussion in [0] and our work with rxjava on android here is an initial attempt at providing an rx operator which wraps the boilerplate required to observe sequences on android ui components like fragments and activities (although i should mention that i havent added support for the latter yet but focused on fragments from the support-v4 library)heres what i did:- provide an operator which accepts a specialized observer type that is able to expose a fragment reference this is essential for us to decide whether its safe to forward messages to that fragment and we can only ask the fragment itself to make that decision- schedule observer callbacks on the android ui thread by defaultthere is some discussions to be had around this i would really appreciate if everyone with and without android experience could weigh in specific questions i think need discussing:- i am terminating the sequence early if the caller does not subscribe using one of the specialized observer types i provide (`fragmentobserver` or `supportfragmentobserver` for native and back-compat fragments respectively) as mentioned above i must force the caller to give me a reference to the fragment since otherwise callbacks cannot be executed in a safe manner (safe wrt not calling back in case android decided to remove the fragment from the window this is a life-cycle event in android which cannot be intercepted other than asking the fragment whether its still attached or not) i realize this has a smell to it but i dont see another option- the specialized observer class keeps weak references to the source observer and the fragment (both can be the same object but then again could also not if eg you use inner classes as observers) in case the references got cleared messages will be dropped- naming: observeinforeground is the best i could come up with which doesnt mean much :-) feel free to submit better naming suggestionstodo:- implement native `fragmentobserver` in the same manner as `supportfragmentobserver` (the latter is what we need so i built that one first)- add `activityobserver` in the same manner- think about auto-unsubscribing from the source sequence in case the references got cleared[0] https://groupsgooglecom/forum/?fromgroups#!topic/rxjava/7o_njw36enw;"#339  i thought about this a lot today and i decided to get back to the proverbial drawing boardi have another idea for how to build this which circumvents the limitations i mentioned above and is overall less awkward i realized too late that i simply cannot rely on the observer to pass through android components like fragments since any chain and order of composition might result in the observer being wrapped perhaps multiple times giving me no access to the source observerclosing this one sorry for the noise will follow up with something better || lol just spent this morning to study your code :-) should have checked here first ! || yeah sorry about that i actually sat down in the evening the same day and i think solved all problems (tm) im about to integrate the new solution with our code base and i want to give it some time to mature in an internal betathe new solution i came up with does not use new observer types or interfaces at all its all self contained in the operator class it also doesnt use weakreferences at all at the cost of forcing the caller to unsubscribe in `ondestroy` events however i think this is a cleaner approach anyway since the wrapped sequence might have to be unsubscribed from anywayill probably hold off with a pr to the core project for now though this is all still experimental stuff if you want to follow progress on this fork  instead || hi i have just looked at your code here are just few thoughts i had i understand why you wanted to drop the weak reference but there is still the danger that a lib user forget to unsubscribe in the ondestroy method to mitigate this risk why not release an exception in the method which checks the state of the activity or of the fragment the exception would have a nice message like hey stupid programmer you have forgotten to unsubscribe in the ondestroy method of your fragment / activity of course in the onnext method the error will be catched by rx and forwarded to the onerror callback it s still better than nothing but may be there are ways to make the app crash not tested but does rx would catch the error if it s throwed on the main loop? something else i have several samsung devices and they have in common to put in log tons of system things which h makes the log difficult to read very boring you have added few things to put in log too if you think you really need log why not use a method to activate logs if needed? last thing i know you have a memento project for keeping variable across device rotation but dont you think this feature should be included in rx? i mean any async task implies the risk of being executed after the death of its activity so any rx stuff too its so common that i think anyone would need it why asking to the user to search for other lib or implement that part himself?  || is the finalizer guardian idiom useful to protect against when people forget to do it? it is not what should be relied upon (because finalizers are not trusted or fast) but helps when they forget and then can spit out a nasty exception/log telling people to start unsubscribing correctly || @benjchristensen this idiom is to guaranty the call of a finalizer block but here there is not such block however there is a method iscomponentvalid called before executing each observer event it seems to me to be a nice place to put code is there something i am missing?@mttkay as it s not possible to open issue in your fork may be it s a good idea to reopen this issue? || it could live within the new operator being considered such as in here:  that operator (observable) is ever garbage collected without having been unsubscribed the guardian could do the cleanup and trigger warnings nasty error messages etc || by cleanup you probably mean unsubscribing when the activity / fragment is destroyed? i was thinking to make the application crash (if possible) i deeply believe earlier it crashes better it is with the nice message the programmer will rapidly understand the reason if cleanup is automatically done and as j bloch writes in his book because we cant believe finalizer from being called when we need it the cleanup may be done one time and not the other moreover why let a dev do bad things like not calling the unsubscribe method if the activity fragment dies?second question i still dont get why we may need a finallizer block? (i am sorry if the question sounds stupid it s past midnight and i am a bit tired) are you thinking to put it in the iscomponentvalid method of this class  ? || there are a few points which bugs me in your solution:- you seem to assume that most people will use fragment or activity as an observable i think it is the opposite actually but im never using android ui components as direct observers im still experimenting however this can be easily added though as you proposed earlier with a specific interface for example- i see that you are using volatile for componentref and observerref maybe i misunderstand why youre using it but does that mean that you are planning to use your operator from a different thread? because im not sure that ""fragmentisadded()"" & ""!activityisfinishing()"" are thread-safe and thus they shouldnt be used from different threads this could lead to race-conditions and hard-to-reproduce bugs so maybe checking current scheduler/thread and raising an exception would be more appropriate than using volatile synchronization keyword- releasing refs only in onnext()/onerror() or oncompleted() doesnt give enough guarantees (eg if nothing is happening in the pipe for a long time) i know this a security but a security that doesnt ensure anything eventually i think like pommedeterresautee that an exception or something explicit wld be maybe better- assuming what i just said is rubbish and releasingref() would be a good thing why not calling unsubscribe() too?- isfinishing() is true in from onpause() if im not mistaken not sure people want to unsubscribe in onpause() (and resubscribe in onresume() everytime) iv thought about this only a little though this seems especially true to me with long network calls you dont want to just ignore the result but anyway i guess you can have a kind of headless service in-between that will keep the result so maybe this scenario is uselessi didnt have time to implement a solution yet but when i thought about this issue last time i thought the best idea would be to have a kind of central manager that you would initialize wh activity starts and finalize when activity stops and register any callback (eg an observer) in-between that must be released later but this requires still a few ""explicit"" calls from the user-sideit is even possible to detach an inner class callback (eg an observer defined as an inner class) and reattach it later to another activity later i already implemented this idea for an async task-like library that you can find there:  (disclaimer: work not finished yet and still on hold)sorry if im not clear this is a bit late :-)ps: by the way i mostly agree with you pommedeterresautee i prefer a quick violent and explicit exception or even crash when something is done wrong || @ratamovic regarding your first point at the subscription three things are provided an observable an observer and an activity or a fragment unlike the previous discussions in the new fork the observer has not to be implemented in an activity / fragment the android component is just provided to check if the observable should be unsubscribed or not regarding the thread issue activity and fragment are probably not thread safe but i dont think its an issue here isadded method and isfinishing will just read a  boolean value and not change a state so imo its safe also is finishing is true only if finish is called or if the activity is being destroyed according to the doc  unsubscribe in onpause || - actually while looking quickly at thecode i couldnt find the definition ""androidcomponent"" in the code this maybe why im getting confused but i still dont see how you handle an observer that communicates with the ui but is not ui itself- about threading: okay i didnt see the ""observeon(androidschedulersmainthread())"" yesteray my fault in that case be careful with successive access to ""componentref"": when doing ""if (componentref ! null && iscomponentvalid(componentref)) {"" you do successive calls to the volatile var componentref instead of reading it once in a local variable hence it can change (eg set to null) between the two conditions check and it is anyway inefficient or else i think you must guarantee unsubscribe is called from the ui thread or you have anyway a problem- in addition (not related to threading) i think you can break the condition so that you can call releasereferences() only once and not every time a new onnext() is called (ie ""if (x ! null) { if (isvalid()) {} else { release() }  })"")- about isfinishing() im a bit confused because i see that ""this is often used in onpause() to determine whether the activity is simply pausing or completely finishing"" which means it can be true in onpause() to me and that the operator can be true and release its reference in onpause() but i just got up too and maybe my thoughts not clear yet -) || androidcomponent is just generic stuff overridden by fragment or activity class the observer you provide may be an instance of a non static class in your activity or another class you provided ui objects in the constructor or anything i didnt thought about :-) then the observer provided is boxed in a new one to make the necessary checks regarding isfinishing when the activity is destroyed all the intermediate states are reached including on pause so sometimes on pause is called because the screen is off sometimes because the activity is being destroyed thats why isfinishing is useful there  || okay i see it now there are two params in observefromandroidcomponent() so this is generic indeed sorry i wasnt careful enoughi understand why isfinishing() is interesting here havent thought about this much yet but im feeling somewhat uncomfortable with it maybe because this may mean that an activity may stop receiving data in onpause() (only if activity will be destroyed of course) before any other activity got time to subscribe to the same source observable which means you may lose data indeed 2 activities can have their onstart()/onstop() calls overlap but not onresume()/onpause() if im not wrong not sure again if this is a real-life scenario though || guys this is excellent feedback one thing though: are we all clear that were not talking about the code in this pr (as i closed it?) ive reimplemented everything here:  sorry for the confusion to avoid further confusion i moved this discussion to a separate gh issue: || got here from googling ""observable android rotation"" i see that its over a year ago since someone posted so whats the current status? did rxandroid  exist at that point? where do i go to read more about how to implement  com in activities and fragments where the result is returned as an observable (using retrofit) and i want to be able to get the result even after a device rotation? (ref this illustration:  )  || rxandroid did not exist a year ago i suggest opening a new issue on the rxandroid project as this is an android specific item || there is no single authoritative solution for dealing with context loss inrxandroid but there are a number of idioms that have evolved and that iwant to collect into a recipe style wiki have a look at the open issuesi also used to have a sample activity which showed how to do it butsamples got lost after breaking out rxandroid i had less time lately towork on all this than i hoped for sorry for that || thanks for the heads up and sorry for cluttering this discussion ill be sure to follow the discussions over at rxandroid  || not a problem at all the split of projects definitely causes some confusion  || ";;;;0;1;;
427;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactored class reporter to a static utillity;426 for class reporter   this pr changes the way errors are created and thrown. all methods of the reporter are now static so they can be imported statically and return an exception instead of throwing it directly. this improves the readability and eliminates the use of hacks to satisfiy the compiler.  here is a sample:      public list<t> getlastvarargs() {         if (arguments.isempty()) {             reporter().noargumentvaluewascaptured()              return null          } else {             return arguments.getlast()          } }      the above code snipped can be rewritten to this:      public list<t> getlastvarargs() {         if (arguments.isempty()) {             throw noargumentvaluewascaptured()          }          return arguments.getlast()  };;426.0;refactored class reporter to a static utillity;426 for class reporter this pr changes the way errors are created and thrown all methods of the reporter are now static so they can be imported statically and return an exception instead of throwing it directly this improves the readability and eliminates the use of hacks to satisfiy the compilerhere is a sample:```public list<t> getlastvarargs() {        if (argumentsisempty()) {            reporter()noargumentvaluewascaptured()            return null        } else {            return argumentsgetlast()        }}```the above code snipped can be rewritten to this:```public list<t> getlastvarargs() {        if (argumentsisempty()) {            throw noargumentvaluewascaptured()        }         return argumentsgetlast()}```;;refactor instance based utility classes to static utility classes;the internal implementation of mockito contains numerous helper classed that serve as a container for useful methods by its nature these classes dont have a state currently some them are instance based in other word you need to create the utility class to call a helper method this not only pollutes the heap but also the code cause instance methods cant be imported statically here is an example:```javahelper helper  new helper()if (helperisinputvalid(input)){   }```vs static import of helperisinputvalid```javaif (isinputvalid(input)){   }```the aim of this ticket is to identify canidates that can be refactored to static utility classes if you like to refactoring and mockito feel free to send a pr and reference this issuerefactoring canidates:-  `accessibilitychanger`-  `beanpropertysetter`-  `conditionalstacktracefilter`-  `fieldcopier`-  `fieldreader`-  `genericmaster` should be integrate into `generictyperesolver`-  `junitfailurehacker` can be removed when the deprecated `verbosemockitojunitrunner` is removed-  `lenientcopytool`-  `matcherbinder`-  `mockitocore` should better be a singleton-  `mockcreationvalidator`- [ ] `removefirstline`-  #591 `argumentmatchingtool`-  #515 `allinvocationsfinder`-  #502 `argumentscomparator`-  #540 `arrayutils`-  #490 `atleastxnumberofinvocationschecker`-  #490 `atleastxnumberofinvocationsinorderchecker`- [ ] #912 `constructors`-  #427 `fieldsetter`-  #908 `friendlyexceptionmaker`-  #431 `handyreturnvalues` - [x] #432 `invocationmarker`- [x] #462 `invocationsfinder`- [x] #908 `junitdetecter`- [x] #490 `missinginvocationchecker`- [x] #490 `missinginvocationinorderchecker`- [x] #514 `mockutil`- [x] #503 `nongreedynumberofinvocationsinorderchecker`- [x] #907 `numberofinvocationsinorderchecker`- [x] #907 `numberofinvocationschecker`- [x] #547 `objectmethodsguru`- [x] #427 `reporter`- [x] #535 `supertypeslastsorter`- [x] #501 `testmethodfinder`- [x] #515 `verifiableinvocationsfinder`;"@raphw thanks for merging the pr that fast!  would you mind reopening this ticket? there are more classes that can be refactored that way i would like to extend the list || big :+1: for me btw but please keep the pull requests managable and as small as possible preferably refactoring 1 method at a time that way it is a lot easier to review || i agree there is nothing wrong with multiple prs the quick merge is a reaction to an easy overview (and being stuck at an ukrainian airport without access to the eurocup) || there are still two unit tests failing could you have a look @christianschwarz - i just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `reporter`i should have checked more thoroughly before merging hopefully you can fix the problem soon alternatively i will just rollback the one commit (the first one is good) and we can reapply the patch once you  the two unit tests thank you really this was great clean-up || i fixed the one test error i push it tonightps: i also fixed a bug in the stack trace cleaner not a biggy but please do not `@ignore` tests especially in big commits it is easy to miss that single annotation || @raphw which test(s) is/are failing? i will fix it asap! too bad that some test fail on a regulare base is it possible to ignore them in the ide only? || you can see the build output here:  advise you to run the tests with `/gradlew build` this should work || @timvdlippe know what you mean! the next prs include only one refactored class at a time || i have it all fixed on local but i did not have access to wifi without 22 blocked will commit soon || @raphw can you please reopen this issue  || sorry github automatically closes issues that reference a pr || @christianschwarz if a commit contains a comment like ""426"" the mentioned issue is automatically closed by github || @pascalschumacher good to know! i will leave it out for the upcoming prs  now that we are pulling in static methods i would like to propose a new (linter) rule to make it easier to read a file i would like that all methods invoked in the current class are referenced with `this` (and `super` for that matter) therefore if we see `thisverify` we know it is in the current class and the same object whereas `verify` references a static method in this class or an imported static method do you agree @mockito/developers ? || > i would like that all methods invoked in the current class are referenced with this (and super for that matter)to me it feels like unnecessary/duplicate code cause `this` is implicit adding `this` before every instance call would create a lot more text and would imho reduce readability eg:`thisdosometing(thiswithprivatemethod())` vs `dosomething(withprivatemethod())`> therefore if we see thisverify we know it is in the current class and the same object whereas verify references a static method in this class or an imported static methodan other option avoid ambiguity is to qualify static methods via its class name  this way you can also distinguish which verify() is called ( `mockitocoreverify()` / `mocktioverify()`)  which is not an easy task when a static import is used || im not coding too much in mockito atm (hopefully now after springone conference ill have more time) but i fully agree with @christianschwarz  imo the best solution is to: - omit `this` before method calls - if necessary provide the class for static method call || respectful -1i like when the class formally declares collaborators instead of calling out to static methods this makes it easy to reason about the code i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etc another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too proceduralthe benefits for converting to static utilities have minimal significance to me yet there is a downside i care about (eg maintainability of procedural code static methods that consume static methods that consume static methods)hence i down vote this sort of changes going down this path all stateless classes in mockito would become static utilities :)you can get +1s from other maintainers and have your changes merged - im not here to block your changes but to give honest feedback i see merit in arguments for static utilities they do not outweigh the cost in my opinion || im mitigated about this as well i understand well that mockito creates garbage but they are short lived and **most probably** wont go in the old generation especially in the test phase yet the faster the tests are the more developers will run them it **may** have impacts on big projects also design wise i dont like much static methods toohowever i dont totally agree with the above points : > i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etccoupling appears also in the import section  static methods are visible there and modern ide usually highlight this intellij even have a warning if import section is too big just as theres warning if theres too many fields this point should not be the reason to avoid static methods> maintainability of procedural code static methods that consume static methods that consume static methodshaving instance methods does not protect again procedural code---i believe theres middle ground there : - mockito project contains a lot of small utility stateless objects that are supporting mockito features these are usually collections tools reflection tools those could are good candidate for static methods objects like `fieldsetter` `fieldcopier` `lenientcopytool` could be nice candidate for static methods- mockito features could be backed by object instances objects like `mockitocore` `mockcreationvalidator` `argumentmatchingtool` are candidate to stay objects || exactly the middle ground described by brice is my motivation for merging most of the prs this is also the reason i have not yet merged the mockitocore pr for this exact reasonif an object is not a attribute or parameter but an internal creation and immediately dismissed i value a pure function more || thought: when we switch to java 8 we can use interfaces with defaultmethods the switch from static utility to interface is very easy now (justa couple of text replaces no method reference modifications)on fri 12 aug 2016 17:23 brice dutheil notifications@githubcom wrote:> im mitigated about this as well i understand well that mockito creates> garbage but they are short lived and _most probably_ wont go in the old> generation especially in the test phase yet the faster the tests are the> more developers will run them it _may_ have impacts on big projects> also design wise i dont like much static methods too> > however i dont totally agree with the above points :> > i dont need to read every line of code in the class to find out external> couplings realized via static methods i can see the couplings via fields> i can easily query how the field variable is used etc> > coupling appears also in the import section  static methods are visible> there and modern ide usually highlight this intellij even have a warning> if import section is too big just as theres warning if theres too many> fields this point should not be the reason to avoid static methods> > maintainability of procedural code static methods that consume static> methods that consume static methods> > ## having instance methods does not protect again procedural code> > i believe theres middle ground there :> >    -> >    mockito project contains a lot of small utility stateless objects that>    are supporting mockito features these are usually collections tools>    reflection tools those could are good candidate for static methods>    objects like fieldsetter fieldcopier lenientcopytool could be nice>    candidate for static methods>    -> >    mockito features could be backed by object instances objects like>    mockitocore mockcreationvalidator argumentmatchingtool are candidate>    to stay objects> > —> you are receiving this because you modified the open/close state> reply to this email directly view it on github>  or mute the thread>   || this feels like a misuse of the default methods || i think you mean static-methods in interfaces here? default-methods require an instance to be called onanyway i dont think that it is a good idea  it would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods imho a class with private constructor is the best construct to do this || > > thought: when we switch to java 8 we can use interfaces with default> > methods> > default-methods require an instance to be called oni was thinking exactly that default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface) || @christianschwarz what do you think to continue the work here with the middle ground described [here]( ? || i am attempting to refactor the matcherbinder class to a static utility class and am having trouble refactoring the following from mockhandlerimpltestjava: `handlermatchersbinder  new matchersbinder() {            public invocationmatcher bindmatchers(argumentmatcherstorage argumentmatcherstorage invocation invocation) {                throw new invaliduseofmatchersexception()            }} `how can i maintain the abstract class definition when i am not able to create an object of matcherbinder?any help is appreciated!  || lets close this ticket refactorings can be done as needed as we work with the code || ";1;0;refactored class reporter to a static utility class;
429;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix similar bug as #420 for the database properties dialog;a similar bug as #420 happened when the encoding was changed in the database properties dialog. this is now fixed in this pr.   sorry for introducing these bugs in the first place.;;0;predicate factory classes for comparable types; i would like to see the following factory methods in predicates:predicate&ltt> largerthan(t reference)predicate&ltt> largerthanorequal(t reference)predicate&ltt> smallerthan(t reference)predicate&ltt> smallerthanorequal(t reference)where &ltt extends comparable&ltt>> and all methods use compareto() internallysample usage:collections2filter(arraysaslist(1234) predicateslargerthan(2))> [3 4]patch with sample code is attached; ;;;;0;1;;
429;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix similar bug as #420 for the database properties dialog;a similar bug as #420 happened when the encoding was changed in the database properties dialog. this is now fixed in this pr.   sorry for introducing these bugs in the first place.;;0;added default answer for javautilstreamstream;i hope the description says it all :-)the new java 8 based code only uses reflection so the library still compiles and runs under older java versions;;;;;1;1;added a default answer for javautilstreamstream if the code is running under java 8 or higher;
429;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix similar bug as #420 for the database properties dialog;a similar bug as #420 happened when the encoding was changed in the database properties dialog. this is now fixed in this pr.   sorry for introducing these bugs in the first place.;;0;improve rendering for new pipelined execution style;; ;;;;0;1;;
429;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix similar bug as #420 for the database properties dialog;a similar bug as #420 happened when the encoding was changed in the database properties dialog. this is now fixed in this pr.   sorry for introducing these bugs in the first place.;;0;buffer() using timebasedchunks results in duplicates being sent onnext;"this seems to be isolated to the first chunk```    @test    public void testduplicate() throws exception {        final set<integer> unique  new hashset<integer>()        observablecreate(new onsubscribefunc<integer>() {            @override            public subscription onsubscribe(final observer<? super integer> t1) {                final future<?> t  executorsnewsinglethreadexecutor()submit(new runnable() {                    @override                    public void run() {                        int count  0                        for (int i  0 i < 11 i++) {                            t1onnext(count++)                            try {                                threadsleep(10)                            } catch (interruptedexception e) {                            }                        }                    }                })                return new subscription() {                    @override                    public void unsubscribe() {                        tcancel(true)                    }                }            }        })        buffer(100 100 timeunitmilliseconds)         subscribe(new action1<list<integer>>() {            @override            public void call(list<integer> t1) {                if (t1isempty())                     return                loginfo(t1tostring())                for (integer i : t1) {                    synchronized (unique) {                        if (uniquecontains(i)) {                            logerror(""duplicate for "" + i)                        }                        assertassertfalse(uniquecontains(i))                        uniqueadd(i)                    }                }            }        })        threadsleep(10000)    }```";"i think this is not a bug i suppose you want to do something like this:<pre>create a chunk --> sleep 100ms --> emit the chunk -> create a new chunk</pre>however as `emit the chunk` and `create a new chunk` may run in different threads their order is not determined so if you use `buffer(100 100 timeunitmilliseconds)` somethink like this may happen:<pre>create a chunk --> sleep 100ms --> create a new chunk -> emit the old chunk</pre>so before the old chunk is emited the old and new chunks will both receive any results after `create a new chunk`i think this is not a bug because `timebasedchunks` is a `overlappingchunks` which allows such indeterminacy || whats the status of this being a bug or not? @headinthebox can you confirm? || if i change `buffer(100 100 timeunitmilliseconds)` to `buffer(100 timeunitmilliseconds)` then i dont see overlaps when i run it many times with `100 100` i could agree that it is a valid race-condition but im also testing with `100 101` and seeing it and that doesnt make sense`buffer(100 101 timeunitmilliseconds)`with that i see this:```[0 1 2 3 4 5 6 7 8 9][9 10]duplicate for 9```that is not expected so i tend to agree that we have a bugthe second buffer starting at `101` should not have a value emitted during the first `100ms` || > if i change buffer(100 100 timeunitmilliseconds) to buffer(100 timeunitmilliseconds) then i dont see overlaps when i run it many times and if you change it to buffer(42 timeunitmicroseconds) then some items will be droppedsee also #756 > that is not expected so i tend to agree that we have a bug+1 || this bug should be resolved in the latest release || this test now passes:``` java    @test    public void testduplicate() throws exception {        final set<integer> unique  new hashset<integer>()        observablecreate(new onsubscribe<integer>() {            @override            public void call(final subscriber<? super integer> t1) {                final future<?> t  executorsnewsinglethreadexecutor()submit(new runnable() {                    @override                    public void run() {                        int count  0                        for (int i  0 i < 11 i++) {                            t1onnext(count++)                            try {                                threadsleep(10)                            } catch (interruptedexception e) {                            }                        }                    }                })                t1add(subscriptionsfrom(t))            }        })        buffer(100 100 timeunitmilliseconds)         subscribe(new action1<list<integer>>() {            @override            public void call(list<integer> t1) {                if (t1isempty())                     return                systemoutprintln(t1tostring())                for (integer i : t1) {                    synchronized (unique) {                        if (uniquecontains(i)) {                            systemoutprintln(""duplicate for "" + i)                        }                        assertassertfalse(uniquecontains(i))                        uniqueadd(i)                    }                }            }        })        threadsleep(10000)    }```it emits:```[0 1 2 3 4 5 6 7 8 9][10]``` || ";;;;0;1;;
431;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;426 dropped class handyreturnvalues;#426  while refactoring the class handyreturnvalues  towards a static utility class i notices that it is not required at all. therefore i decided to remove the type  handyreturnvalues .;;0;consider protected visibility for abstractexecutionthreadservices getservicename method; use case: using a different executor (an executorservice really) for an abstractexecutionthreadservice implementationthis (probably) implements a service pattern: it has startup() and shutdown() but a noop run() method plus custom service specific methods which return future instances these are returned by executorservicesubmit() executions which perform work on the services (in this case) newsinglethreadexecutor; this will be  in the next release--- ;;;;0;1;;
431;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;426 dropped class handyreturnvalues;#426  while refactoring the class handyreturnvalues  towards a static utility class i notices that it is not required at all. therefore i decided to remove the type  handyreturnvalues .;;0;upgrade versions;;;;;;1;1;upgrade to resolver 11;
431;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;426 dropped class handyreturnvalues;#426  while refactoring the class handyreturnvalues  towards a static utility class i notices that it is not required at all. therefore i decided to remove the type  handyreturnvalues .;;0;unsubscribing does not work when using subscribeon(schedulersnewthread());im having trouble unsubscribing whenever i use `observablesubscribeon(schedulersnewthread())` on android im using rxjava 0143 in my case my observer class does the following:``` javasubscription sub  myobjectgetdata()subscribeon(schedulersnewthread())    observeon(androidschedulersmainthread())    subscribe(this)```the `getdata()` method creates an observable and the onsubscribefunc generates some mock data using a new thread:``` javafinal booleansubscription subscription  new booleansubscription()thread t  new thread(new runnable() {    public void run() {        // generate data call onnext()        // check subscriptionisunsubscribed()        // sleep a bit repeat last two steps    }})tstart()return subscription```when i unsubscribe the (composite) subscription i got in the observer `isunsubscribed()` never returns true in the worker thread and `booleansubscriptionunsubscribe()` never gets called (breakpoint never triggered) i stepped through the `compositesubscriptionunsubscribe()` method and it seems that it doesnt even contain the `booleansubscription` anywhere in the `keyset`the interesting thing is that if i call `subscribeon(schedulersthreadpoolforcomputation())` or call it using `androidschedulersmainthread()` the unsubscription works correctly am i misusing the `schedulersnewthread()` method or does the newthreadscheduler have a bug?;"could you provide a unit test to reveal this issue? i tried similar codes but did not find the bug you described || ive observed similar behaviour using rxjava 0146 also on android when attempting to unsubscribe from a subscription created using `schedulersnewthread()scheduleperiodically()`the failure is fairly easy to reproduce in the context of the application although its inconsistent as often the subscriptions are successfully unsubscribed || this test demonstrates the problem basically the observable never receives unsubscribes even though the observer no longer receives notifications:```package testsimport orgjunittestimport rxobservableimport rxobserverimport rxsubscriptionimport rxconcurrencyschedulersimport rxutilfunctionsfunc1import javautilconcurrenttimeunitpublic class unsubscribetest {    @test    public void testunsubscribe() throws interruptedexception {        subscription sub  observableinterval(1 timeunitseconds)                map(new func1<long long>() {                    @override                    public long call(long along) {                        systemoutprintln(""generated "" + along)                        return along                    }                })                subscribeon(schedulersnewthread())                observeon(schedulerscurrentthread())                subscribe(new observer<long>() {                    @override                    public void oncompleted() {                    }                    @override                    public void onerror(throwable e) {                    }                    @override                    public void onnext(long args) {                        systemoutprintln(""received "" + args)                    }                })        threadsleep(3000)        systemoutprintln(""calling unsubscribe"")        subunsubscribe()        threadsleep(3000)    }}```output is:generated 0received 0generated 1received 1calling unsubscribegenerated 2generated 3generated 4generated 5if i change the subscribeon thread to schedulersthreadpoolforio() then the output is:generated 0received 0generated 1received 1calling unsubscribe || ill take a look || i think this is  in  someone confirm? || yes looks fixed to me || great ill release today or tomorrow || hello guys - im on 0151 and still see the issue on any scheduler you subscribeonissue is a little different - i go on getting called onnext on the observer even after unsubscribe() only difference is that oncomplete is not called || the test program above prints the values expected when run with the current master but the whole program just doesnt quit after that i see three rxnewthreadscheduler threads (2 core machine) all of them waiting for `threadpoolexecutorworkqueuetake()` these threads arent marked as daemon threads see newthreadscheduler l55edit: maybe they should be regular threads but the executor running them should be allowed to timeout its single core thread since newthreadscheduler will start a new pool anyway``` javaprivate static class eventloopscheduler extends scheduler {    private final executorservice executor    private eventloopscheduler() {        threadpoolexecutor e  (threadpoolexecutor)executorsnewfixedthreadpool(1 new threadfactory() {            @override            public thread newthread(runnable r) {                return new thread(r ""rxnewthreadscheduler-"" + countincrementandget())            }        })        esetkeepalivetime(1 timeunitseconds)        eallowcorethreadtimeout(true)        executor  e    }    }``` || ";;;;0;1;;
431;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;426 dropped class handyreturnvalues;#426  while refactoring the class handyreturnvalues  towards a static utility class i notices that it is not required at all. therefore i decided to remove the type  handyreturnvalues .;;426.0;426 dropped class handyreturnvalues;#426while refactoring the class`handyreturnvalues` towards a static utility class i notices that it is not required at all therefore i decided to remove the type `handyreturnvalues`;  lgtm but the formatting of quite some files is still incorrect some have a space too much others are indented too much please take a close look at the diff and make sure that formatting changes are reverted functionality is fine by me || @timvdlippe > lgtm but the formatting of quite some files is still incorrecthopefully  for now and ever ||;refactor instance based utility classes to static utility classes;the internal implementation of mockito contains numerous helper classed that serve as a container for useful methods by its nature these classes dont have a state currently some them are instance based in other word you need to create the utility class to call a helper method this not only pollutes the heap but also the code cause instance methods cant be imported statically here is an example:```javahelper helper  new helper()if (helperisinputvalid(input)){   }```vs static import of helperisinputvalid```javaif (isinputvalid(input)){   }```the aim of this ticket is to identify canidates that can be refactored to static utility classes if you like to refactoring and mockito feel free to send a pr and reference this issuerefactoring canidates:-  `accessibilitychanger`-  `beanpropertysetter`-  `conditionalstacktracefilter`-  `fieldcopier`-  `fieldreader`-  `genericmaster` should be integrate into `generictyperesolver`-  `junitfailurehacker` can be removed when the deprecated `verbosemockitojunitrunner` is removed-  `lenientcopytool`-  `matcherbinder`-  `mockitocore` should better be a singleton-  `mockcreationvalidator`- [ ] `removefirstline`-  #591 `argumentmatchingtool`-  #515 `allinvocationsfinder`-  #502 `argumentscomparator`-  #540 `arrayutils`-  #490 `atleastxnumberofinvocationschecker`-  #490 `atleastxnumberofinvocationsinorderchecker`- [ ] #912 `constructors`-  #427 `fieldsetter`-  #908 `friendlyexceptionmaker`-  #431 `handyreturnvalues` - [x] #432 `invocationmarker`- [x] #462 `invocationsfinder`- [x] #908 `junitdetecter`- [x] #490 `missinginvocationchecker`- [x] #490 `missinginvocationinorderchecker`- [x] #514 `mockutil`- [x] #503 `nongreedynumberofinvocationsinorderchecker`- [x] #907 `numberofinvocationsinorderchecker`- [x] #907 `numberofinvocationschecker`- [x] #547 `objectmethodsguru`- [x] #427 `reporter`- [x] #535 `supertypeslastsorter`- [x] #501 `testmethodfinder`- [x] #515 `verifiableinvocationsfinder`;"@raphw thanks for merging the pr that fast!  would you mind reopening this ticket? there are more classes that can be refactored that way i would like to extend the list || big :+1: for me btw but please keep the pull requests managable and as small as possible preferably refactoring 1 method at a time that way it is a lot easier to review || i agree there is nothing wrong with multiple prs the quick merge is a reaction to an easy overview (and being stuck at an ukrainian airport without access to the eurocup) || there are still two unit tests failing could you have a look @christianschwarz - i just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `reporter`i should have checked more thoroughly before merging hopefully you can fix the problem soon alternatively i will just rollback the one commit (the first one is good) and we can reapply the patch once you  the two unit tests thank you really this was great clean-up || i fixed the one test error i push it tonightps: i also fixed a bug in the stack trace cleaner not a biggy but please do not `@ignore` tests especially in big commits it is easy to miss that single annotation || @raphw which test(s) is/are failing? i will fix it asap! too bad that some test fail on a regulare base is it possible to ignore them in the ide only? || you can see the build output here:  advise you to run the tests with `/gradlew build` this should work || @timvdlippe know what you mean! the next prs include only one refactored class at a time || i have it all fixed on local but i did not have access to wifi without 22 blocked will commit soon || @raphw can you please reopen this issue  || sorry github automatically closes issues that reference a pr || @christianschwarz if a commit contains a comment like ""426"" the mentioned issue is automatically closed by github || @pascalschumacher good to know! i will leave it out for the upcoming prs  now that we are pulling in static methods i would like to propose a new (linter) rule to make it easier to read a file i would like that all methods invoked in the current class are referenced with `this` (and `super` for that matter) therefore if we see `thisverify` we know it is in the current class and the same object whereas `verify` references a static method in this class or an imported static method do you agree @mockito/developers ? || > i would like that all methods invoked in the current class are referenced with this (and super for that matter)to me it feels like unnecessary/duplicate code cause `this` is implicit adding `this` before every instance call would create a lot more text and would imho reduce readability eg:`thisdosometing(thiswithprivatemethod())` vs `dosomething(withprivatemethod())`> therefore if we see thisverify we know it is in the current class and the same object whereas verify references a static method in this class or an imported static methodan other option avoid ambiguity is to qualify static methods via its class name  this way you can also distinguish which verify() is called ( `mockitocoreverify()` / `mocktioverify()`)  which is not an easy task when a static import is used || im not coding too much in mockito atm (hopefully now after springone conference ill have more time) but i fully agree with @christianschwarz  imo the best solution is to: - omit `this` before method calls - if necessary provide the class for static method call || respectful -1i like when the class formally declares collaborators instead of calling out to static methods this makes it easy to reason about the code i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etc another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too proceduralthe benefits for converting to static utilities have minimal significance to me yet there is a downside i care about (eg maintainability of procedural code static methods that consume static methods that consume static methods)hence i down vote this sort of changes going down this path all stateless classes in mockito would become static utilities :)you can get +1s from other maintainers and have your changes merged - im not here to block your changes but to give honest feedback i see merit in arguments for static utilities they do not outweigh the cost in my opinion || im mitigated about this as well i understand well that mockito creates garbage but they are short lived and **most probably** wont go in the old generation especially in the test phase yet the faster the tests are the more developers will run them it **may** have impacts on big projects also design wise i dont like much static methods toohowever i dont totally agree with the above points : > i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etccoupling appears also in the import section  static methods are visible there and modern ide usually highlight this intellij even have a warning if import section is too big just as theres warning if theres too many fields this point should not be the reason to avoid static methods> maintainability of procedural code static methods that consume static methods that consume static methodshaving instance methods does not protect again procedural code---i believe theres middle ground there : - mockito project contains a lot of small utility stateless objects that are supporting mockito features these are usually collections tools reflection tools those could are good candidate for static methods objects like `fieldsetter` `fieldcopier` `lenientcopytool` could be nice candidate for static methods- mockito features could be backed by object instances objects like `mockitocore` `mockcreationvalidator` `argumentmatchingtool` are candidate to stay objects || exactly the middle ground described by brice is my motivation for merging most of the prs this is also the reason i have not yet merged the mockitocore pr for this exact reasonif an object is not a attribute or parameter but an internal creation and immediately dismissed i value a pure function more || thought: when we switch to java 8 we can use interfaces with defaultmethods the switch from static utility to interface is very easy now (justa couple of text replaces no method reference modifications)on fri 12 aug 2016 17:23 brice dutheil notifications@githubcom wrote:> im mitigated about this as well i understand well that mockito creates> garbage but they are short lived and _most probably_ wont go in the old> generation especially in the test phase yet the faster the tests are the> more developers will run them it _may_ have impacts on big projects> also design wise i dont like much static methods too> > however i dont totally agree with the above points :> > i dont need to read every line of code in the class to find out external> couplings realized via static methods i can see the couplings via fields> i can easily query how the field variable is used etc> > coupling appears also in the import section  static methods are visible> there and modern ide usually highlight this intellij even have a warning> if import section is too big just as theres warning if theres too many> fields this point should not be the reason to avoid static methods> > maintainability of procedural code static methods that consume static> methods that consume static methods> > ## having instance methods does not protect again procedural code> > i believe theres middle ground there :> >    -> >    mockito project contains a lot of small utility stateless objects that>    are supporting mockito features these are usually collections tools>    reflection tools those could are good candidate for static methods>    objects like fieldsetter fieldcopier lenientcopytool could be nice>    candidate for static methods>    -> >    mockito features could be backed by object instances objects like>    mockitocore mockcreationvalidator argumentmatchingtool are candidate>    to stay objects> > —> you are receiving this because you modified the open/close state> reply to this email directly view it on github>  or mute the thread>   || this feels like a misuse of the default methods || i think you mean static-methods in interfaces here? default-methods require an instance to be called onanyway i dont think that it is a good idea  it would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods imho a class with private constructor is the best construct to do this || > > thought: when we switch to java 8 we can use interfaces with default> > methods> > default-methods require an instance to be called oni was thinking exactly that default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface) || @christianschwarz what do you think to continue the work here with the middle ground described [here]( ? || i am attempting to refactor the matcherbinder class to a static utility class and am having trouble refactoring the following from mockhandlerimpltestjava: `handlermatchersbinder  new matchersbinder() {            public invocationmatcher bindmatchers(argumentmatcherstorage argumentmatcherstorage invocation invocation) {                throw new invaliduseofmatchersexception()            }} `how can i maintain the abstract class definition when i am not able to create an object of matcherbinder?any help is appreciated!  || lets close this ticket refactorings can be done as needed as we work with the code || ";1;0;removed handyreturnvalues;
432;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactors how the default encoding is stored in the preferences;;;0;iterablesconsumingiterable(iterable): special case or overload for priorityqueue; it would be nice if one could use consumingiterable to read and remove all elements from a priorityqueue in the queues orderofficially (according to the priorityqueue spec) the iterators ordering is arbitrary and removing every element is not a special case however in the three jres i tried it on it does in fact return the elements in orderrather than rely on this undocumented behaviour it would be safer to wrap the queue in a new iteratorbecause the returned iterator would not be equivalent to iteratorsconsumingiterator(iterator) (contrary to the current documentation of consumingiterable) an overload might be preferable to a run-time type check; ;;;;0;1;;
432;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactors how the default encoding is stored in the preferences;;;0;various fixes;;;;;;1;1;dont update done queries;
432;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactors how the default encoding is stored in the preferences;;;0; path to rxscalademoscala;;#343 i doubt that editing language-adaptors/rxjava-scala/readmemd could have caused this failure || another instance of  ||;;;;1;1; path to rxscalademoscala;
432;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactors how the default encoding is stored in the preferences;;;426.0;426 refactored invocationmarker to a static utility class;#426refactored `invocationmarker`to a static utility class;  there are some imports remaining on the `invocationmarker` which i think can be removed other than that  how to trigger a build without the commiting squashing forced push cycle? that failing tests suck! || not much faster but the fastest way i know of to trigger building of pull request is```git commit --amendgit push -f``` || lgtm ||;refactor instance based utility classes to static utility classes;the internal implementation of mockito contains numerous helper classed that serve as a container for useful methods by its nature these classes dont have a state currently some them are instance based in other word you need to create the utility class to call a helper method this not only pollutes the heap but also the code cause instance methods cant be imported statically here is an example:```javahelper helper  new helper()if (helperisinputvalid(input)){   }```vs static import of helperisinputvalid```javaif (isinputvalid(input)){   }```the aim of this ticket is to identify canidates that can be refactored to static utility classes if you like to refactoring and mockito feel free to send a pr and reference this issuerefactoring canidates:-  `accessibilitychanger`-  `beanpropertysetter`-  `conditionalstacktracefilter`-  `fieldcopier`-  `fieldreader`-  `genericmaster` should be integrate into `generictyperesolver`-  `junitfailurehacker` can be removed when the deprecated `verbosemockitojunitrunner` is removed-  `lenientcopytool`-  `matcherbinder`-  `mockitocore` should better be a singleton-  `mockcreationvalidator`- [ ] `removefirstline`-  #591 `argumentmatchingtool`-  #515 `allinvocationsfinder`-  #502 `argumentscomparator`-  #540 `arrayutils`-  #490 `atleastxnumberofinvocationschecker`-  #490 `atleastxnumberofinvocationsinorderchecker`- [ ] #912 `constructors`-  #427 `fieldsetter`-  #908 `friendlyexceptionmaker`-  #431 `handyreturnvalues` - [x] #432 `invocationmarker`- [x] #462 `invocationsfinder`- [x] #908 `junitdetecter`- [x] #490 `missinginvocationchecker`- [x] #490 `missinginvocationinorderchecker`- [x] #514 `mockutil`- [x] #503 `nongreedynumberofinvocationsinorderchecker`- [x] #907 `numberofinvocationsinorderchecker`- [x] #907 `numberofinvocationschecker`- [x] #547 `objectmethodsguru`- [x] #427 `reporter`- [x] #535 `supertypeslastsorter`- [x] #501 `testmethodfinder`- [x] #515 `verifiableinvocationsfinder`;"@raphw thanks for merging the pr that fast!  would you mind reopening this ticket? there are more classes that can be refactored that way i would like to extend the list || big :+1: for me btw but please keep the pull requests managable and as small as possible preferably refactoring 1 method at a time that way it is a lot easier to review || i agree there is nothing wrong with multiple prs the quick merge is a reaction to an easy overview (and being stuck at an ukrainian airport without access to the eurocup) || there are still two unit tests failing could you have a look @christianschwarz - i just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `reporter`i should have checked more thoroughly before merging hopefully you can fix the problem soon alternatively i will just rollback the one commit (the first one is good) and we can reapply the patch once you  the two unit tests thank you really this was great clean-up || i fixed the one test error i push it tonightps: i also fixed a bug in the stack trace cleaner not a biggy but please do not `@ignore` tests especially in big commits it is easy to miss that single annotation || @raphw which test(s) is/are failing? i will fix it asap! too bad that some test fail on a regulare base is it possible to ignore them in the ide only? || you can see the build output here:  advise you to run the tests with `/gradlew build` this should work || @timvdlippe know what you mean! the next prs include only one refactored class at a time || i have it all fixed on local but i did not have access to wifi without 22 blocked will commit soon || @raphw can you please reopen this issue  || sorry github automatically closes issues that reference a pr || @christianschwarz if a commit contains a comment like ""426"" the mentioned issue is automatically closed by github || @pascalschumacher good to know! i will leave it out for the upcoming prs  now that we are pulling in static methods i would like to propose a new (linter) rule to make it easier to read a file i would like that all methods invoked in the current class are referenced with `this` (and `super` for that matter) therefore if we see `thisverify` we know it is in the current class and the same object whereas `verify` references a static method in this class or an imported static method do you agree @mockito/developers ? || > i would like that all methods invoked in the current class are referenced with this (and super for that matter)to me it feels like unnecessary/duplicate code cause `this` is implicit adding `this` before every instance call would create a lot more text and would imho reduce readability eg:`thisdosometing(thiswithprivatemethod())` vs `dosomething(withprivatemethod())`> therefore if we see thisverify we know it is in the current class and the same object whereas verify references a static method in this class or an imported static methodan other option avoid ambiguity is to qualify static methods via its class name  this way you can also distinguish which verify() is called ( `mockitocoreverify()` / `mocktioverify()`)  which is not an easy task when a static import is used || im not coding too much in mockito atm (hopefully now after springone conference ill have more time) but i fully agree with @christianschwarz  imo the best solution is to: - omit `this` before method calls - if necessary provide the class for static method call || respectful -1i like when the class formally declares collaborators instead of calling out to static methods this makes it easy to reason about the code i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etc another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too proceduralthe benefits for converting to static utilities have minimal significance to me yet there is a downside i care about (eg maintainability of procedural code static methods that consume static methods that consume static methods)hence i down vote this sort of changes going down this path all stateless classes in mockito would become static utilities :)you can get +1s from other maintainers and have your changes merged - im not here to block your changes but to give honest feedback i see merit in arguments for static utilities they do not outweigh the cost in my opinion || im mitigated about this as well i understand well that mockito creates garbage but they are short lived and **most probably** wont go in the old generation especially in the test phase yet the faster the tests are the more developers will run them it **may** have impacts on big projects also design wise i dont like much static methods toohowever i dont totally agree with the above points : > i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etccoupling appears also in the import section  static methods are visible there and modern ide usually highlight this intellij even have a warning if import section is too big just as theres warning if theres too many fields this point should not be the reason to avoid static methods> maintainability of procedural code static methods that consume static methods that consume static methodshaving instance methods does not protect again procedural code---i believe theres middle ground there : - mockito project contains a lot of small utility stateless objects that are supporting mockito features these are usually collections tools reflection tools those could are good candidate for static methods objects like `fieldsetter` `fieldcopier` `lenientcopytool` could be nice candidate for static methods- mockito features could be backed by object instances objects like `mockitocore` `mockcreationvalidator` `argumentmatchingtool` are candidate to stay objects || exactly the middle ground described by brice is my motivation for merging most of the prs this is also the reason i have not yet merged the mockitocore pr for this exact reasonif an object is not a attribute or parameter but an internal creation and immediately dismissed i value a pure function more || thought: when we switch to java 8 we can use interfaces with defaultmethods the switch from static utility to interface is very easy now (justa couple of text replaces no method reference modifications)on fri 12 aug 2016 17:23 brice dutheil notifications@githubcom wrote:> im mitigated about this as well i understand well that mockito creates> garbage but they are short lived and _most probably_ wont go in the old> generation especially in the test phase yet the faster the tests are the> more developers will run them it _may_ have impacts on big projects> also design wise i dont like much static methods too> > however i dont totally agree with the above points :> > i dont need to read every line of code in the class to find out external> couplings realized via static methods i can see the couplings via fields> i can easily query how the field variable is used etc> > coupling appears also in the import section  static methods are visible> there and modern ide usually highlight this intellij even have a warning> if import section is too big just as theres warning if theres too many> fields this point should not be the reason to avoid static methods> > maintainability of procedural code static methods that consume static> methods that consume static methods> > ## having instance methods does not protect again procedural code> > i believe theres middle ground there :> >    -> >    mockito project contains a lot of small utility stateless objects that>    are supporting mockito features these are usually collections tools>    reflection tools those could are good candidate for static methods>    objects like fieldsetter fieldcopier lenientcopytool could be nice>    candidate for static methods>    -> >    mockito features could be backed by object instances objects like>    mockitocore mockcreationvalidator argumentmatchingtool are candidate>    to stay objects> > —> you are receiving this because you modified the open/close state> reply to this email directly view it on github>  or mute the thread>   || this feels like a misuse of the default methods || i think you mean static-methods in interfaces here? default-methods require an instance to be called onanyway i dont think that it is a good idea  it would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods imho a class with private constructor is the best construct to do this || > > thought: when we switch to java 8 we can use interfaces with default> > methods> > default-methods require an instance to be called oni was thinking exactly that default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface) || @christianschwarz what do you think to continue the work here with the middle ground described [here]( ? || i am attempting to refactor the matcherbinder class to a static utility class and am having trouble refactoring the following from mockhandlerimpltestjava: `handlermatchersbinder  new matchersbinder() {            public invocationmatcher bindmatchers(argumentmatcherstorage argumentmatcherstorage invocation invocation) {                throw new invaliduseofmatchersexception()            }} `how can i maintain the abstract class definition when i am not able to create an object of matcherbinder?any help is appreciated!  || lets close this ticket refactorings can be done as needed as we work with the code || ";1;0;426 refactored invocationmarker to a static utility class;
434;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;very tiny typo.;missing word in error message.;;0;suggestion: serializable function interface; ive had some problems where i wanted to define a function and have it be serializable this is the solution i came up with:/**&nbsp\* @﻿author bjørn soldal&nbsp\* @﻿created 28 sep 2010&nbsp*/public interface serializablefunction&ltf extends serializable t extends serializable> extends function&ltf t> serializable {}; ""but serializing an anonymous class is a very bad idea!  consider that simply rearranging your code a bit can render previously serialized objects suddenly unreadable as the name of your class is suddenly myouterclass$8 instead of myouterclass$7""i agree with this i guess a little context is needed to understand why i requested this i work predominantly with apache wicket these days and wicket serializes religiously it throws a hissy fit whenever it encounters something which is not serializable i figure other people will need this sort of interface too some time in the future but i recognize that perhaps it is a bit of an edge case and shouldnt go into guava after all thank you for your time :) || ";;;;0;1;;
434;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;very tiny typo.;missing word in error message.;;0;very tiny typo;missing word in error message;lgtm thanks for spotting! ||;;;;1;1;very tiny typo;
434;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;very tiny typo.;missing word in error message.;;0;expose async  state in exchange info;;;;;;1;1;expose async  state in exchange info;
434;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;very tiny typo.;missing word in error message.;;0;implemented serialsubscription and timeout operator;implemented timeout operator and serialsubscription upon which it is based;#345  merging this as it functions and is well written and well documented and will then look at whether modifications based on #446 make sense ||;;;;1;1; a couple of warnings and reverted change to imports;
436;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;clean up issues reported by intellij;some general issues reported by intellij. mostly concerning modifiers and unused imports.;;0;[idea] strings#tononnullstring(object); it would be handy to have a method in class strings which returns a non null  string for the passed parameter like """"+param without creating 2 new string instancesmore precise something like this->public static string tononnullstring(object obj){&nbsp&nbspreturn objnull?""null"":objtostring()}"; ogregoire is right stringvalueof(object) does what you want--- ;;;;0;1;;
436;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;clean up issues reported by intellij;some general issues reported by intellij. mostly concerning modifiers and unused imports.;;0;clean up issues reported by intellij;some general issues reported by intellij mostly concerning modifiers and unused imports;  did you upgrade to java 7? we are still compiling to java 5 even though byte buddy requires java 6 anyways || no i did not upgrade to java 7 why? || try with ressources and diamond operators are java 7 features  || oh i thought they were java 5 features why is travis not failing on that? :owill revert these changes then :( || i assume travis runs java 8 but compiles back to java 5 || the travis build uses java 7:  || sorry this is painful to ask for but could you rebase this? || will rebase this weekend when i have time || once mockito 2 is released i think we can focus on a pure java 8 release || @raphw rebased    ||;;;;1;1;clean up issues reported by intellij;
436;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;clean up issues reported by intellij;some general issues reported by intellij. mostly concerning modifiers and unused imports.;;0;simple sql execution and create materialized view;;other than those minor comments it ;;;;1;1;consolidate query state machine;
436;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;clean up issues reported by intellij;some general issues reported by intellij. mostly concerning modifiers and unused imports.;;0;reimplemented the reduce operator;hii reimplemented the reduce operator the improvements are as follow:- as i mentioned in #423 reduce should throw an exception when applying on an empty sequence without an initial value- now reduce does not need a takelast operator and should be more efficient;"#348  > now reduce does not need a takelast operator and should be more efficientwhat is the overhead of `takelast(1)` that limits its usage? (as a side-note i think `takelast(1)` could be special-cased and made far more efficient than `takelast(n)` since it doesnt need a queue just the last value)> as i mentioned in #423 reduce should throw an exception when applying on an empty sequence without an initial valuecan we not achieve this check without re-implementing the entire operator? this duplicates logic between `scan` and `reduce` for accumulation if we cant do it cleanly or efficiently then your implementation looks greatthe guiding principle for this decision is:![guideline-6 1]( || hi @benjchristensen i removed the synchronized however im still confused about concurrency in rxjava could you review my discussion in #417 and help me solve the problems?i also updated the unit testsfinally i reviewed the current operators and could not find a way to throw an exception when the observable is empty could you provide some suggestion? || #360 #361 [rxjava-pull-requests #362 > finally i reviewed the current operators and could not find a way to throw an exception when the observable is empty could you provide some suggestion?does this do what you need?``` javaflatmap( o -> {  if(good) {   return observablejust(goodvalue)  } else {   // if bad  return an error   return observableerror(new runtimeexception())  }})``` || sorry that i still have no idea about how to use `flatmap` to implement it if the observable is empty `flatmap` does nothing so how to throw an exception in such situation? || maybe it would be nice to have an `assertnonempty` operator since this could also be useful for other use cases what do you think? || materialize and dematerialize are good tool for implementing operators that have behavior based on onerror and oncompleted``` javax  from()hadvalue  falsexmaterialize()map({ n ->  if (nkind  notificationkindonnext) {    hadvalue  true  }  else if (nkind  notificationkindoncompleted && !hadvalue) {    return new notification(new exception())  }  return n})dematerialize()``` || thanks @abersnaze  it works@samuelgruetter  i added an private `assertnonempty` operator in the `observable` i think its not necessary to be `public`  || [rxjava-pull-requests #375]( failurelooks like theres a problem with this pull request || i just had this idea replace the takelast(1) with takelast(2) and use a second scan to figure out what to do at the end of the sequence``` java    public observable<t> reduce(func2<t t t> accumulator) {        func2<notification<t> notification<t> notification<t>> func  new func2<notification<t> notification<t> notification<t>>() {            @override            public notification<t> call(notification<t> value notification<t> end) {                if (endisonerror())                    return end                if (value  null)                    return new notification<t>(new unsupportedoperationexception(""can not apply on an empty sequence""))                return value            }        }        return create(operationscanscan(this accumulator))materialize()takelast(2)scan(null func)dematerialize()    }``` || sounds good but im not sure if its better that using one more `scan` to eliminate the `isempty` variable its better that eliminating variable but a little harder to understand || i updated this pr to use the new `last` operator #470 to implement `reduce` this can be merged now || [rxjava-pull-requests #397]( failurelooks like theres a problem with this pull request || it has been  in #474  || ";;;;0;1;;
441;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanups  warning removals  move and test.;some cleanups and warning removals. should get rid of six high impact coverity issues (i hope).;;0;use @nonnull for computationexception and subclass constructor argument;blair-ol@ are there any places where a computationexception is thrown that it does not have a null throwable argument?it would be nice to count on there always being an exception so how about adding @﻿nonnull to the constructor argument?; users are allowed to throw their own computationexceptions from their functions for any reason  if they do we wont re-wrap it in our own  of course they might not have a throwable to chain in some situations--- ;;;;0;1;;
441;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanups  warning removals  move and test.;some cleanups and warning removals. should get rid of six high impact coverity issues (i hope).;;0;delete ignored cglib related tests;;as far as i can tell cglib was completely replaced by byte-buddy ||   lgtm thanks for spotting! ||;;;;1;1;delete ignored cglib related tests;
441;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanups  warning removals  move and test.;some cleanups and warning removals. should get rid of six high impact coverity issues (i hope).;;0;make threadpool sizes configurable;- query manager executor pool- import partition chunk and shard pools;;;;;1;1;make threadpool sizes configurable- query manager executor pool- import partition chunk and shard pools;
441;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanups  warning removals  move and test.;some cleanups and warning removals. should get rid of six high impact coverity issues (i hope).;;417.0; the issue that take does not call onerror;i  one of the issues in #417: `systemoutprintln(observablefrom(1 2 3)take(1)map(f)toblockingobservable()single())` is never terminatedthis issues is because `take` does not handle the exception throwing from `onnext` correctly;#359;exception not properly propagated;"given``` javastatic func1<integer integer> f  new func1<integer integer>() {    public integer call(integer arg0) {        throw new runtimeexception(""the error in f"")    }}```when i run this:``` javapublic static void main(string args) {    systemoutprintln(""started"")    systemoutprintln(observablefrom(1)        map(f)toblockingobservable()single())    systemoutprintln(""done"")}```i get (as expected) this output:```startedexception in thread ""main"" javalangruntimeexception: the error in f    at rxjavahelloworld$2call(rxjavahelloworldjava:226)    at [blah blah]    at rxjavahelloworldmain(rxjavahelloworldjava:240)```however when i observe it on a different thread:``` javapublic static void main(string args) {    systemoutprintln(""started"")    systemoutprintln(observablefrom(1)observeon(schedulersthreadpoolforcomputation())        map(f)toblockingobservable()single())    systemoutprintln(""done"")}```then the output is this:```started```and the application does not terminatebut i would expect that no matter on what thread i observe errors are always propagated";"here the error occurs even without `observeon`:``` javasystemoutprintln(observablefrom(1 2 3)take(1)map(f)toblockingobservable()single())```this snippet also makes the app never terminatethis prevents me from implementing the [head]( operation in the scala adaptor and the original one with `observeon` prevents me from implementing a [nice constructor]( || > here the error occurs even without observeon:> > systemoutprintln(observablefrom(1 2 3)take(1)map(f)toblockingobservable()single())> this snippet also makes the app never terminatefor `take(1)` after the observer receives a value any later value or error will be ignored even if `onnext(the first value)` throws an exception the related codes:``` java            @override            public void onerror(throwable e) {                if (countergetandset(num) < num) {                    observeronerror(e)                }            }            @override            public void onnext(t args) {                final int count  counterincrementandget()                if (count < num) {                    observeronnext(args)                    if (count  num) {                        observeroncompleted()                    }                }                if (count > num) {                    // this will work if the sequence is asynchronous it will have no effect on a synchronous observable                    subscriptionunsubscribe()                }            }```for `take(1)` it will increment `count` at first even if `observeronnext(args)` throws an exception as `count  num` the exception is not propagated || > public static void main(string args) {>     systemoutprintln(""started"")>     systemoutprintln(observablefrom(1)observeon(schedulersthreadpoolforcomputation())>         map(f)toblockingobservable()single())>     systemoutprintln(""done"")> }this issue is because `rxoperatorsscheduledobservereventloop` does not handle the exception threw from the `onnext` method of a observer the related codes:``` java                    switch (notificationgetkind()) {                    case onnext:                        underlyingonnext(notificationgetvalue())                        break                    case onerror:                        underlyingonerror(notificationgetthrowable())                        break                    case oncompleted:                        underlyingoncompleted()                        break                    default:                        throw new illegalstateexception(""unknown kind of notification "" + notification)                    }``` || @benjchristensen i encountered one problem which i had never realized before when i tried to solve this issuefrom  the observables perspective it can guarantee that it calls `oncompleted` of an observer after all `onnext` calls however from the observers perspective if `onnext` and `oncompleted` run in different threads some weird thing may happenfor example an observable calls `onnext` in thread t1 after 5ms it calls `oncompleted` in thread t2 if t1 is suspended at once after it enters the `onnext` method at this moment none statement in `onnext` is executed so now the observer does not know its `onnext` has been invoked suppose t1 is suspended in 100ms and t2 is not be suspended so the observer will find that `oncompleted` is invoked first and after 95ms the `onnext` method is calledi really think such case is weird for the observer could you point out where i misunderstood?  || i read the article about concurrency in rx:  im still confused here are my problems:- should an observable call all onnext oncompleted and onerror in the same thread if no scheduler is involved?- whats the contract when an observable encounters a thread pool scheduler? || @benjchristensen one more question if an observer throws an exception in `onnext` does its `onerror` have to be called? if so there may be complicated to fix the issue in `rxoperatorsscheduledobservereventloop`for example in @samuelgruetter s example ``` javapublic static void main(string args) {    systemoutprintln(""started"")    systemoutprintln(observablefrom(1)observeon(schedulersthreadpoolforcomputation())        map(f)toblockingobservable()single())    systemoutprintln(""done"")}````eventloop` will receive two notifications: `onnext(1)` and `oncompleted` however as they are out of order `oncompleted` may arrive first so the observer will be notified `oncompleted` then when `onnext(1)` is called the observer will need to be notified `onerror` as `onnext` throws an exception in such situation the `oncompleted` and `onerror` will be both calledim trapped in heredue to `oncompleted` and `onerror` concurrency in rxjava is different from rxnet is there an wiki page about concurrency in rxjava? || you should read the ""rx design guidelines"" >  should an observable call all onnext oncompleted and onerror in the same thread if no scheduler is involved?there is nothing requiring it be the same thread necessarily but it is required that it being sequential and synchronized so the observer doesnt need to worry about memory visibility interleaving calls etcsee section 67 and 68 of the design guidelines> whats the contract when an observable encounters a thread pool scheduler?its the same a scheduler is for moving location and time but does not change the contract a single observable must still be serialized anything in rxjava doing differently is a bug and needs to be we iterated several times on `observeon` to get it to hopefully behave correctly so that each event it receives is put on an event loop and processed sequentially on whatever scheduler it is given || > eventloop will receive two notifications: onnext(1) and oncompleted however as they are out of order oncompleted may arrive firstif they are out-of-order then we still dont have `observeon` working correctly and its a bug || thanks for your help ""rx design guidelines"" is really helpful || now this issue should be fixed in pr #453 and #441 it can be closed || ";1;0; the issue that take does not call onerror when onnext throws any error;
442;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;enable some ignored tests of bridgemethodshitagaintest and detectingf…;…inalmethodstest  this worked locally  so let s see if this also works on the ci server.  304;;0;mapscapacity gives bad estimate (16) when expectedsize > 2^30; mapscapacity is used to give initial sizes to new hash maps and sets so that they can avoid expensive reallocations  however if the expected size is at least 2^30 then the computation overflows and it ends up returning 16; this and many other integer-overflow bugs  for our collections when size nears max_value--- ;;;;0;1;;
442;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;enable some ignored tests of bridgemethodshitagaintest and detectingf…;…inalmethodstest  this worked locally  so let s see if this also works on the ci server.  304;;0;update and cancel tasks in parallel;;other than the comments above ;;;;1;1;address review comments;
442;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;enable some ignored tests of bridgemethodshitagaintest and detectingf…;…inalmethodstest  this worked locally  so let s see if this also works on the ci server.  304;;0;how to execute two observables sequentially?;ive got to  request wrapped by observable```observable<t1> request1 observable<t2> request2```i want to execute them sequentially;"this will do it`observableconcat(request1 request2)` || yup concat is the one to use || i think concat actually dont work well for mehere is simplified problem:```observable<string> geocodeaddressrequest ```returns address required to create ride```observable<ride> createriderequest  apicreateride(address)  ```i need address from geocodeaddressrequest to create iti want to have observable<ride> geocodeaddresssthencreateriderequest || if they are dependent on each other then map/flatmap off the first into the second``` javageocodeaddressrequestflatmap( address -> {   return apicreateride(address)})``` || thanks! just realized same thing and you replied ) || we need to mark this as question || @benjchristensen @lexer @abersnaze concat is not well !```        observable<historyvideo> insert  historyvideodaoinsert(historyvideo)        observable<long> count  historyvideodaocount()        observableconcat(insert count)                observeon(androidschedulersmainthread())                subscribe(new action1<object>() {                    @override                    public void call(object o) {                    }                })```the example above have two observable when concat twothe action1 s param become objecti can not figure out who is historyvideo and who is longdoes rxjava have a solution to do that? || when you have such unrelated types java cant find any common ancestor other than `object` why do you want to mix types on a stream? || @akarnokd i just want to excute observals one after anotherbut i realize the style below is not so good```        historyvideodaoinsert(historyvideo)                observeon(androidschedulersmainthread())                subscribe(new action1<historyvideo>() {                    @override                    public void call(historyvideo historyvideo1) {                                                //do something handle historyvideo1                        //and next i want to excute another observable                        observable<long> count  historyvideodaocount()                        countobserveon(androidschedulersmainthread())                                subscribe(new action1<long>() {                                    @override                                    public void call(long along) {                                        // do something to handle along                                         }                                })                    }                })``` || `concat` is the right operator but due to limits of the java language you have to work with `object`s and use `instanceof` + cast to get back the right data type || @akarnokd thanks to you!i try `instanceof` and cast  it work fine to me!but i am confused is there a way not have to mix types? || i have a possibly silly but otherwise related questioni have a single that is subscribed like this:``` javapublic void dispatch(action action) {        reducerreduce(stategetvalue() action) // <-- is `single<state>`                doonsuccess(newstate -> stateaccept(newstate) // <-- write to behaviorrelay                subscribe()```however id like to be able to force serial execution for these singles but i dont know the next `single` at this time so i cannot `concat()` them before `subscribe()`how would i approach forcing a ""one-at-a-time"" execution and buffer the singles until this particular single is executed?ive been looking all over the net but i found [nothing of value]( imagine i might need to queue the singles and ""remove them from the queue"" as side-effect but then that needs to handle concurrency rx-style? i dunno------------------ ;;;;0;1;;
442;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;enable some ignored tests of bridgemethodshitagaintest and detectingf…;…inalmethodstest  this worked locally  so let s see if this also works on the ci server.  304;;304.0;enable some ignored tests of bridgemethodshitagaintest and detectingf…;…inalmethodstestthis worked locally so lets see if this also works on the ci server304;  thanks this has  issue #304 ! ||;problem verifying bridge methods;"hello i think there might be a bug in mockito when verifying bridge methodsthe bug is present both in version 2031-beta and in version 11019``` javaimport javaioserializableimport orgjunittestimport static orgmockitomockitomockimport static orgmockitomockitoverifypublic class mockitobridgetest {    @test    public void test() {        extended ext  mock(extendedclass)        exttest(""123"")        verify(ext)test(""123"") // passes        ((base<string>)ext)test(""456"")        verify(ext)test(""456"") // fails    }    public interface base<t extends serializable> {        int test(t value)    }    public interface extended extends base<string> {        @override        int test(string value)    }}```";"the problem here is the following: byte buddy does not intercept bridge methods but assumes that these methods should be dispatched _as they are_ therefore the actual method is still invoked which is then intercepted as a result the `method` instance that is bound to this interception is the actual method ie `test(string)` and not `test(serializable)` which was identified as the bridge the behavior of cglib is similarmockito on the other hand picks up the invoked method from the call site which is `test(serializable)` fpr the secod example therefore mockito claims that another method is invoked instead mockito would need to resolve the method to its actual target in order to validate that this method is a bridge for `test(string)`i am going to look into how this can be added to mockito this requires resolving parameterized tyes along the hierarchy in order to find out to what method the bridge is actually pointing to || since somebody else has this issue i found a workaround to make the test pass:``` java        ((base<string>)ext)test(""456"")        verify(ext)test(""456"") // fails        ((base<string>)verify(ext))test(""456"") // passes (workaround)``` || @bric3 would it be a feasible solution if i relied on byte buddy apis to resolve this? i implemented a rather elaborate algorithm that i have tried to port to mockito however its not as easy as i thought since the algorithm and related data structure are quite bound into the byte buddy apis i would of course add an interface that does not rely on byte buddy for querying this information but asking the library to do it would be the most straight-forward solution || @raphw that is possible maybe in the form of a _`plugin`_ that bytebuddy mockmaker implement maybe we would need a default implementation ie that does nothing || ";1;0;enable some ignored tests of bridgemethodshitagaintest and detectingfinalmethodstest;
444;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;add parameter elementtype to @mock;todo: add a regression test to also show how this functionality can be used. cc @smoyer64  438;;0;add new find with function interface to iterables and iterators; iterablesfind can return the same data type as the input iterables it would be nice if it takes a function in addition to prediates and allows the function to decide what data type to return the signature and a sample implementation is as follows:&nbsp&nbsp/**&nbsp&nbsp&nbsp&nbsp&nbsp\* in iterables&nbsp&nbsp&nbsp&nbsp&nbsp*/&nbsp&nbsp&nbsp&nbsppublic static &lti o> o find(iterable&lti> iterable&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspfunction<? super i o> function){&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn find(iterableiterator() function)//support to be iteratorsfind()&nbsp&nbsp&nbsp&nbsp}```/** * in iterator */public static <i o> o find(iterator<i> iterator function<? super i o> function){    while (iteratorhasnext()){        i input  iteratornext()        o output  functionapply(input)        if (output ! null) return output    }    return null}public static void main(string args){    list<string> numbers  arraysaslist(new string{""one"" ""two"" ""three""})    integer i  find(numbers new function<string integer>(){        @override public integer apply(@nullable string s){            if (""two""equals(s)) return 2            else return null        }    })    systemoutprintln(i)//return 2}```"; i agree with colin i think this is best addressed using the existing apis--- ;;;;0;1;;
444;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;add parameter elementtype to @mock;todo: add a regression test to also show how this functionality can be used. cc @smoyer64  438;;0;importer fixes;- fix node worker logic for imports- reduce size of buffered output streams to 64k;;;;;1;1;importer fixes- fix node worker logic for imports- reduce size of buffered output streams to 64k;
444;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;add parameter elementtype to @mock;todo: add a regression test to also show how this functionality can be used. cc @smoyer64  438;;0;how to create observable interval that waits until operation is executed?;i need to create observable interval that actually go to next interval only when async operation was finishedin net it is possible to achieve with timeinterval()  need delay between async calls;duplicate of issue #90  ||;;;;0;1;;
444;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;add parameter elementtype to @mock;todo: add a regression test to also show how this functionality can be used. cc @smoyer64  438;;438.0;add parameter elementtype to @mock;todo: add a regression test to also show how this functionality can be used cc @smoyer64438; ;add elementtypeparameter to @mock;parameterized tests are becoming more common - junit 5 explicitly allows parameters and the sample [mockitoextension]( currently includes an @injectmock to trigger the creation of a mock parameter  it would be so much cleaner to use @mock in both placesthis shouldnt be an issue for most legacy test systems since they dont allow test parameters (by default);"@smoyer64 i think that is a reasonable addition do you maybe have a sample junit test case that i can add to our test suite as regression test? || @timvdlippewill this change be going into mockito 1x or 2x (or both)? || @sbrannen mockito 20 we might be able to port back to mockito 1x but i would prefer not to is there an explicit requirement for this change to be included in 1x? || regarding a regression test this should do the job!``` javaimport static orgjunitassertasserttrueimport javalangreflectfieldimport javalangreflectmethodimport orgjunittestimport orgmockitomock/** * its actually sufficient if this class compiles the test methods * are therefore a bit superfluous * * @author sam brannen */public class mockannotationdeclarationtests {    @mock    string foo    void bar(@mock string baz) {    }    @test    public void mockannotationcanbedeclaredonfield() throws exception {        field field  getclass()getdeclaredfield(""foo"")        asserttrue(fieldisannotationpresent(mockclass))    }    @test    public void mockannotationcanbedeclaredonparameter() throws exception {        method method  getclass()getdeclaredmethod(""bar"" stringclass)        asserttrue(methodgetparameters()[0]isannotationpresent(mockclass))    }}```so feel free to use thatcheerssam || @timvdlippei dont suppose there is an explicit _requirement_ per se to have this support in 1x however i feel it could well benefit 1x users who also wish to use junit 5 furthermore i cannot foresee any possible negative side effects for 1x users: its 100% backwards compatible || i do not think we really have an infrastructure to still publish mockito 1 artifacts we did however not change much in 2 and 99% of all mockito code should run as expected after updating mainly we removed deprecated code that people had years to upgradei think adding this should be okay even though there is no scenario where mockito itself would process the annotation would adding an annotation to the junit plugin not be another altivertive? i wonder if that was a cleaner solution || > would adding an annotation to the junit plugin not be another altivertive? i wonder if that was a cleaner solutionintroducing a new annotation in mockitos official junit 5 support is of course technically possible -- thats what our proof-of-concept `mockitoextension` does today (ie we created an `@injectmock` annotation)but i dont think i would call that a _cleaner solution_ imho a single annotation from mockito would be the cleanest solution since it would result in the **element of least surprise** for users of mockitofwiw we have already hashed out the [exact same discussion for the spring framework]( with regard to springs `@autowired` annotation previously it was not allowed to be declared on a constructor or method parameter but we changed this for spring 43 || ok considering that junit and mockito is such a common combination lets just make it as easy as possible || sounds good!  wow  a lot of work got done while i was out celebrating fathers day  from a users perspective this all looks perfect  how often do you get everything you ask for?  i guess i have one final  question which since this issue is closed is more academic - where should an official production ready mockitoextension for junit 5 be hosted?  mockitojunit is obviously part of the mockito project and the mokitoextension will always rely on both mockito and junit 5maintaining the status quo would be fine but it might also make sense to create a junit5-extensions project for ""common combinations"" (using the wording above) where a combination of project maintainers could collaborate on code that is essentially the intersection of their projects?  external extensions and testengines are going to be documented in the junit 5 wiki per issue  and given the collaboration demonstrated by this thread maybe the whole question is mootin any case thanks for all the hard work thats gone into both projects! || @smoyer64 you got lucky we are working hard on releasing mockito 20   i am not sure what the stance is of the junit team regarding such extensions could you open an issue on junit5 to discuss where such extensions should be placed? || @timvdlippe the question has been posed to the junit 5 team in issue   @sbrannen is a member of that team so im guessing hes already seen the question )  and im just one of those pesky users (trying to help identify use cases and stress-test the new code)! || thanks a lot looking forward to their response || ";1;0;add parameter elementtype to @mock;
446;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make tests which test for timeouts with thread#sleep more lenient.;i took a look at the recently builds on travis ci and noticed a lot of failed builds. these failures where mostly unrelated to the actual changes  but caused by these strict timeout tests.  this pull request will not completely fix these random failures  but it should reduce their occurrences.   the ideal solution would be to completely remove usage of  thread#sleep  from the test  but i have no idea how to do this.;;0;iterablesconcat() improvement; i was looking at some code recently where there was something like an iterable&ltfoo> where foo implements iterable (ie informally a list of lists)  the code wanted to flatten these into a single foo instance  so i wanted a function like&nbsp&nbsp&ltt extends iterable<?>> t concat(supplier&ltt> supplier iterable&ltt> ts)which would construct a new t using the supplier consisting of the contents of all tsif you wanted to get super-tony-morris-style geeky you could further generalize this as a fold something like:&nbsp&nbsp&ltt u> u fold(function&ltpair&ltt u> u> fn u unit iterable&ltt> ts)which starts with a ""unit"" value and repeatedly applies fn to each element in ts yielding a new accumulated value at each step  the above concat could then be implemented this way oh uh i guess theres already an enhancement request filed for fold() -- issue 218 -- which amusingly was created by the dude whose code im looking at  fun times"; ;;;;0;1;;
446;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make tests which test for timeouts with thread#sleep more lenient.;i took a look at the recently builds on travis ci and noticed a lot of failed builds. these failures where mostly unrelated to the actual changes  but caused by these strict timeout tests.  this pull request will not completely fix these random failures  but it should reduce their occurrences.   the ideal solution would be to completely remove usage of  thread#sleep  from the test  but i have no idea how to do this.;;0;make tests which test for timeouts with thread#sleep more lenient;i took a look at the recently builds on travis ci and noticed a lot of failed builds these failures where mostly unrelated to the actual changes but caused by these strict timeout teststhis pull request will not completely fix these random failures but it should reduce their occurrences the ideal solution would be to completely remove usage of `thread#sleep` from the test but i have no idea how to do this;  relates to  issue #433 and pr #451 ||;;;;1;1;make tests which test for timeouts with thread#sleep more lenientthe actual sleep time depends on the scheduler and these tests cause a lot of false negatives on the ci server;
446;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make tests which test for timeouts with thread#sleep more lenient.;i took a look at the recently builds on travis ci and noticed a lot of failed builds. these failures where mostly unrelated to the actual changes  but caused by these strict timeout tests.  this pull request will not completely fix these random failures  but it should reduce their occurrences.   the ideal solution would be to completely remove usage of  thread#sleep  from the test  but i have no idea how to do this.;;0;idempotent task scheduling;;;;;;0;1;;
446;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make tests which test for timeouts with thread#sleep more lenient.;i took a look at the recently builds on travis ci and noticed a lot of failed builds. these failures where mostly unrelated to the actual changes  but caused by these strict timeout tests.  this pull request will not completely fix these random failures  but it should reduce their occurrences.   the ideal solution would be to completely remove usage of  thread#sleep  from the test  but i have no idea how to do this.;;0;implemented the timeout operator;hi i used `synchronizedobserver` to implement the `timeout` operator #91 it may be simpler than #434 considering datetimeoffset and timespan in c# have the same meaning rxjava only needs 4 overrides i have already implemented all of themplease take a look thanks;#365 lets evaluate this based on the previous submission and refactor towards simplicity while merging the good partsive pulled the other one in so we get the functionality (and serialsubscription) and unit tests and now lets iterate on simplifying the concurrency behavior || @benjchristensen  do you think which one is better? i can help merge these two prs || @zsxwing i would prefer a simpler synchronization model as discussed here >  ||;;;;0;1;;
451;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored timeout and after concurrent test;refactored concurrent test in order to 433. the implementation now uses  an  executor to perform async calls instead of extending  thread  and doesn t extend testbase anymore.   i also added a stopwatch which can be used for further time dependent testing. in the future i want to use this class to write more tests for after/timeout.;;0;metadata api;;;;;;1;1;rewrite apis with optional parametersadds a qualifiedtableprefix object that may containcatalogcatalogschemacatalogschematablefor all those apis that take optional parameters;
451;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored timeout and after concurrent test;refactored concurrent test in order to 433. the implementation now uses  an  executor to perform async calls instead of extending  thread  and doesn t extend testbase anymore.   i also added a stopwatch which can be used for further time dependent testing. in the future i want to use this class to write more tests for after/timeout.;;0;(question) how can i show the task progress with rxjava?;;"this is a snippet of groovy code that will probably do most of what you want``` javainput  from([1234])// we are going to be branching off of the input observable three times so cache itcached  inputcache()// produce an observable that is the fraction completed in this case 025 05 075 1fract  cachedreduce(0 {countvalue -> count+1})mapmany({size -> cachedmapwithindex({valueindex -> (index+1)/size})})// zip the fraction observable with the values to sync the timing of the values coming out with the fraction of completionoutput  observablezip(cachedfract {value fractiondone ->    // side effect to update progress bar with fraction done    println ""done $fractiondone""    return value})// or// if updating the status of a progress bar produces an observable youll have to use this for the last zipoutput  observablemerge(observablezip(cachedfract {value fractiondone ->    // operation to update progress bar with fraction done results in an observable too    update  just(""done $fractiondone"")    return zip(just(value) update {value2 updatestatus -> value2})}))``` || closing out  further conversation can be taken up on  || ";;;;0;1;;
451;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored timeout and after concurrent test;refactored concurrent test in order to 433. the implementation now uses  an  executor to perform async calls instead of extending  thread  and doesn t extend testbase anymore.   i also added a stopwatch which can be used for further time dependent testing. in the future i want to use this class to write more tests for after/timeout.;;433.0;refactored timeout and after concurrent test;refactored concurrent test in order to 433 the implementation now uses  an `executor`to perform async calls instead of extending `thread` and doesnt extend testbase anymore i also added a stopwatch which can be used for further time dependent testing in the future i want to use this class to write more tests for after/timeout;can you rebase this to the latest removal of deprecated api?  seems like something went wrong with my rebase i will look tomorrow into it ||   @christianschwarz i think its preferable to rebase (eg `pull --rebase upstream master`) a pull request instead of merging that hides unrelated commits and makes reviewing easier thanks!edit: just saw your comment above so please ignore this || this lgtm but one small comment thank you again for your work! || okay i  the formatting issues || lgtm! || i guess it would have been better to use more lenient timeouts:  || it really sucks that we only experience this flakiness on master and now when we are reviewing such pull requests i cant seem to recreate these timing issues locally either || i can replicate the issues if i decrease the timeouts and run a timeout test in an endless looptravis builds have very limited cpu resources: so  so failures of multi-threaded tests are more likely ||;fix swinging concurrent tests;the following concurrent tests fail currently with a >50% chance this should be !here is a build with multiple failed test that are related to concurrent issues #763  verificationwithtimeouttestshouldallowmixingonlywithtimeoutandfailverificationwithtimeouttestshouldallowmixingothermodeswithtimeoutverificationwithtimeouttestshouldallowmixingonlywithtimeout verificationwithtimeouttestshouldallowmixingothermodeswithtimeoutandfail```;those are time-out-dependant test those are generally a bit hard to test but i have never seen them fail maybe it depends on how busy travis is at the moment || i have restarted lets see if they keep on failing if they are passing now i would file it under flakiness and disregard the failures || oh right the original pr was closed so travis could not pull the branch  looking at our build history it seems to be happening very rarely so if it happens again we should restart the build if it then fails again a manual inspection should be done ||;1;0;refactored timeout and after concurrent test;
452;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;revise maintable;complete check and rewrite of maintable and related classes  this will fix and implement: -  #315  -  #384 - show tooltip for header columns -  #384 - show tooltip for contents which are too long for table columns -  #443  -  #445  -  add ability to drag and drop specialfield columns - ~~ allow storing position of specialfield columns~~ postponed to another pr -  remove table column for  pdf/ps  which is obsolete (498) -  remove option  show one letter heading for icon columns  which is now obsolete -  changed default order in main table: # | all file based icons (file  url/doi  ) | all bibtex field based icons (bibtexkey  entrytype  author  title  ...) | all special field icons - ~~ #490~~ postponed - ~~ think about  must be implemented  vernünftig (matthias)   entry table -> fit table horizontally ....   from the minutes~~ postponed -  final cleanup + changelog;;0;plain parameters api in charstreams; charstreams has methods with inputstreamsupplierin would be great if such methods would be overloaded with methods that take only inputstream as a parametereg charstreams has tostring(inputstreamsupplier supplier)one needs to add tostring(inputstream inputstream); ;;;;0;1;;
452;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;revise maintable;complete check and rewrite of maintable and related classes  this will fix and implement: -  #315  -  #384 - show tooltip for header columns -  #384 - show tooltip for contents which are too long for table columns -  #443  -  #445  -  add ability to drag and drop specialfield columns - ~~ allow storing position of specialfield columns~~ postponed to another pr -  remove table column for  pdf/ps  which is obsolete (498) -  remove option  show one letter heading for icon columns  which is now obsolete -  changed default order in main table: # | all file based icons (file  url/doi  ) | all bibtex field based icons (bibtexkey  entrytype  author  title  ...) | all special field icons - ~~ #490~~ postponed - ~~ think about  must be implemented  vernünftig (matthias)   entry table -> fit table horizontally ....   from the minutes~~ postponed -  final cleanup + changelog;;0;javadoc: improve grammar of some sentences;;  ;;;;1;1;javadoc: improve grammar of some sentences;
452;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;revise maintable;complete check and rewrite of maintable and related classes  this will fix and implement: -  #315  -  #384 - show tooltip for header columns -  #384 - show tooltip for contents which are too long for table columns -  #443  -  #445  -  add ability to drag and drop specialfield columns - ~~ allow storing position of specialfield columns~~ postponed to another pr -  remove table column for  pdf/ps  which is obsolete (498) -  remove option  show one letter heading for icon columns  which is now obsolete -  changed default order in main table: # | all file based icons (file  url/doi  ) | all bibtex field based icons (bibtexkey  entrytype  author  title  ...) | all special field icons - ~~ #490~~ postponed - ~~ think about  must be implemented  vernünftig (matthias)   entry table -> fit table horizontally ....   from the minutes~~ postponed -  final cleanup + changelog;;0;optimizers api;do not work on this before  has been applied this sits on top of that pull request;;;;;1;1;rework the planoptimizer api to take the session as a method parametermakes plan optimizer creation much simpler and allows for them to be singletons everywhereonce we have figured out how to manage the ordering between them thiscan then turn into a multibinder-like arrangement;
452;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;revise maintable;complete check and rewrite of maintable and related classes  this will fix and implement: -  #315  -  #384 - show tooltip for header columns -  #384 - show tooltip for contents which are too long for table columns -  #443  -  #445  -  add ability to drag and drop specialfield columns - ~~ allow storing position of specialfield columns~~ postponed to another pr -  remove table column for  pdf/ps  which is obsolete (498) -  remove option  show one letter heading for icon columns  which is now obsolete -  changed default order in main table: # | all file based icons (file  url/doi  ) | all bibtex field based icons (bibtexkey  entrytype  author  title  ...) | all special field icons - ~~ #490~~ postponed - ~~ think about  must be implemented  vernünftig (matthias)   entry table -> fit table horizontally ....   from the minutes~~ postponed -  final cleanup + changelog;;0;implemented the scheduler version of the return operator;hi this is the scheduler version of the return operator #73;#371;;;;1;1;updated the comments;
454;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;modified javadoc for argumentmatcher;to 453 - this is the amendment to the  argumentmatcher  javadoc.;;0;document immutability of `patternfilenamefilter`;j@ it looks to me that `patternfilenamefilter`&nbspis immutable and maybe even thread-safe (im not absolutely sure though) if that is the case (but also if not) please document these propertiesbackground: one might want to use instances of this class as constants; this will be  in the next release--- ;;;;0;1;;
454;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;modified javadoc for argumentmatcher;to 453 - this is the amendment to the  argumentmatcher  javadoc.;;0;rename shardboundedexecutor to keyboundedexecutor;;;;;;1;1;rename shardboundedexecutor to keyboundedexecutor;
454;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;modified javadoc for argumentmatcher;to 453 - this is the amendment to the  argumentmatcher  javadoc.;;0;unsubscribing multiple times;"quoting from an email by @headinthebox to make sure we dont forget about this issue:> another bug in rxjava/scala> > when you create a new subscription it does not remember that is is already disposed> > in scala (using trivial companion object)> > val  s  subscription{ println(“hi”) }> sunsubscribe()> sunsubscribe()> > prints “hi” twice in net only once> > in the course i will tell the students it prints only oncethe issue is already present in java:``` java    public static void main(string args) {        subscription s  subscriptionscreate(new action0() {            public void call() {                systemoutprintln(""hi"")            }        })        sunsubscribe()        sunsubscribe()    }```also prints ""hi"" twicelets fix this first in java and then add a companion object `subscription` to rxscala";;;;;0;1;;
454;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;modified javadoc for argumentmatcher;to 453 - this is the amendment to the  argumentmatcher  javadoc.;;453.0;modified javadoc for argumentmatcher;to 453 - this is the amendment to the `argumentmatcher` javadoc;  ;either revert recent functional interfaces change or change javadoc;ive been reading the javadoc regarding `argumentmatcher` and i noticed a couple of things relating back to the changes of #338 - the example of how to override it is still based around `object` rather than `t`- someone has very deliberately decided not to make it use `t` in the past and now weve changed that> the argument is not using the generic type in order to force explicit casting in the implementation this way it is easier to debug when incompatible arguments are passed to the matchers you have to trust us on this one if we used parametrized type then classcastexception would be thrown in certain scenariosmy view at the time was that changing it to `t` would remove the class casting and that this would be a good thing it was kind of necessary to have it as `t` so that the lambda expressions in java 8 could infer the right typesthe rationale about a class cast exception giving weird results kind of makes sense but does that really really happen? it seems its either solve one problem or the otherwhat do folks think? ill happily amend the code either way;i cant imagine a scenario where the parameterized type cause problems and why it aids debuging if no type parameter is used@all do we have examples that illustrate the described problem? if not the javadoc should be removed! || #454 is one way we could wrap this up sorry for not noticing it sooner! || if we receive such a report we should catch such an exception and log an appropriate error why this is happening for now i cant see this breaking but i am happy to be proven wrong ||;1;0;modified javadoc for argumentmatcher;
455;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;activate verificationwithtimeouttest#shouldallowtimeoutverificationin…;…order  this test work since  but was deactivated by mistake with https://github.com/mockito/mockito/pull/451;;0;loss of type safety with itera*filter(itera* class); i had expected that this method which should be used instead of the other overload with predicatesinstanceof(class) would raise a compilation error if i use incompatible classes but instead the returned itera\* will simply be emptylets say we have two classes foo and bar which are not related the following:list&ltfoo> list  newarraylist()listadd(new foo())iterable&ltbar> result  iterablesfilter(list barclass)will make result empty while this behavior seems valid (nothing in the list passes the predicate) you are actually hiding a type cast error i think it would be better to raise a compilation error since you are basically doing an instanceof of incompatible operand type you can achieve this by changing the method signature frompublic static &ltt> iterable&ltt> filter( final iterable<?> unfiltered final class&ltt> type)topublic static &ltt> iterable&ltt> filter( final iterable<? super t> unfiltered final class&ltt> type)i also think that this change would not need to keep the old signature and make it deprecated (anyways you cant have both signature because of type erasure) changing the method signature should keep binary compatibility since both methods have the same erasure and behavior doesnt change and the new signature will work with actual usage that is unless you get the new error and in this case youve found a bug in your own code; this codelist&ltfoo> list  newarraylist()listadd(new foo())iterable&ltbar> result  iterablesfilter(list barclass)is perfectly valid when foo and bar are not provably incompatible types (eg string and integer) -- for example if they are list and serializable  there is no way for us to express this in the signature--- ;;;;0;1;;
455;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;activate verificationwithtimeouttest#shouldallowtimeoutverificationin…;…order  this test work since  but was deactivated by mistake with https://github.com/mockito/mockito/pull/451;;0;activate verificationwithtimeouttest#shouldallowtimeoutverificationin…;…orderthis test work since  but was deactivated by mistake with https://githubcom/mockito/mockito/pull/451;note to myself when reviewing prs: be more precise yes i missed this case too and it should not happen thank you for correcting me! ||  ;;;;1;1;activate verificationwithtimeouttest#shouldallowtimeoutverificationinorderthis test work since  but was deactivated by mistake with https://githubcom/mockito/mockito/pull/451;
455;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;activate verificationwithtimeouttest#shouldallowtimeoutverificationin…;…order  this test work since  but was deactivated by mistake with https://github.com/mockito/mockito/pull/451;;0;split stats;;;;;;1;1;print query url in client when in debug mode;
455;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;activate verificationwithtimeouttest#shouldallowtimeoutverificationin…;…order  this test work since  but was deactivated by mistake with https://github.com/mockito/mockito/pull/451;;0;scala adaptor: todo list and documentation;more complete todo list for scala adaptor and some documentation for [completenesstest](https://githubcom/samuelgruetter/rxjava/blob/scalaadaptor/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/completenesstestscala);#374 i have a fix ready forbring `booleansubscription` `compositesubscription` `multipleassignmentsubscription` to scala `compositesubscriptionsubscription  `instead of setter method add on `compositesubscription` should be `+`from: samuelgruetter [mailto:notifications@githubcom] sent: sunday october 27 2013 1:21 pmto: netflix/rxjavasubject: [rxjava] scala adaptor: todo list and documentation (#455)more complete todo list for scala adaptor and some documentation for completenesstest  ---you can merge this pull request by running  git pull  scalaadaptoror view comment on or merge it at:   summary-   update todos according to meeting-   merge branch master of githubcom:netflix/rxjava into scalaadaptor-   add one todo-   some documentation for completenesstestfile changes-   m language-adaptors/rxjava-scala/todomd   (49) -   m language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/completenesstestscala   (58) patch links:-       ||;;;;1;1;some documentation for completenesstest;
456;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;default time stamps follows iso-8601;default time stamps follows iso-8601. reason:   i am not aware of side effects at the currentdate formatter.;;0;make getservicename() in abstractexecutionthreadservice protected; currently getservicename() is private making it protected makes it easy to customize the thread name and tostring(); ;;;;0;1;;
456;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;default time stamps follows iso-8601;default time stamps follows iso-8601. reason:   i am not aware of side effects at the currentdate formatter.;;0;fix some rawtype warnings;; ;;;;1;1;fix some rawtype warnings;
456;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;default time stamps follows iso-8601;default time stamps follows iso-8601. reason:   i am not aware of side effects at the currentdate formatter.;;0;drop table;;other than those minor comments it ;;;;1;1;implement drop table for native tablesdrop tables from the native store clean up the shards on the nodes using a background cleaner process;
456;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;default time stamps follows iso-8601;default time stamps follows iso-8601. reason:   i am not aware of side effects at the currentdate formatter.;;0;(question) how to consume observable from client-side;"sorry if this is not the best place to ask this but i was looking for some quick suggestions specifically if my service layer returns an observable<?> to the controller how does the client-side handle the eventual results of that observable? normally you would process the results of the service call in the controller formate the response and send that down to the client what is the best and most ""frp"" way of doing this so as to not tie up the request thread waiting for the results? if this question doesnt make sense let me know and ill try to rephrase thanks so much for you help in advance!";i assume youre referring to having a server-side that emits data over a network to a client?if so then an async network connection using serversentevents or websockets works well to emit the data to the network (onnext of each event) and then consume that on the client with an observable consuming the network stream and turning it back into onnext events || first of all the rxjava community just rocks thanks for your quick reply so i think i got it as an example in this article  it talks about all service calls returning observables so in the `def observable getvideogridfordisplay(userid)` method the controller would get the observable back to render the json results and send it back down to the client would the controller block waiting for the oncomplete event and then render the results and return in the initial request thread? or would the controller return immediately and send the results down to the client in a web socket connection after the oncomplete? || in a blocking container like tomcat yes the request thread blocks until oncomplete the toblockingobservable() option expose several built in mechanisms for doing this in a non-blocking environment like netty or servlet 31 then you can stay non-blocking and write data out from onnext/onerror and only worry about oncompleted if you have a finite stream (close connection)  || closing out as i havent heard back on this  further conversation can be taken up on  or reopen this issue || @benjchristensen thanks ben your explanation make me more clear ||;;;;0;1;;
458;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove dead code in classcacheversusclassreloadingtest;;;0;linkedhashmultimap performance degrades badly for pathological input {a[a] b[b] }; <b>what steps will reproduce the problem?</b>1 compile and run the following code://////////////////////////////////////////////////////////////////////////static public void main(string  args) throws exception {```  // build data  list<string> data  listsnewarraylist()  for (int i  0 i < 20000 i++) {     dataadd( integertostring( i ) )  }  // pour the data into a linked list multimap  {     long start  systemcurrenttimemillis()     multimap<string string> mmap  linkedlistmultimapcreate()     for ( string key : data ) {        mmapput( key key )     }     long end  systemcurrenttimemillis()     systemoutprintln(""linkedlistmultimap took ""+(end-start)+"" ms"")  }  {     // pour the data into a linked hash multimap     long start  systemcurrenttimemillis()     multimap<string string> mmap  linkedhashmultimapcreate()     for ( string key : data ) {        mmapput( key key )     }     long end  systemcurrenttimemillis()     systemoutprintln(""linkedhashmultimap took ""+(end-start)+"" ms"")  }  {     // pour the data into ""hand made"" multimap     long start  systemcurrenttimemillis()     hashmap<string hashset<string>> mmap  mapsnewlinkedhashmap()     for ( string key : data ) {        hashset<string> set  setsnewhashset()        setadd(key)        mmapput( key set )     }     long end  systemcurrenttimemillis()     systemoutprintln(""manual multimap took ""+(end-start)+"" ms"")  }```&nbsp&nbsp&nbsp}}/////////////////////////////////////////////////////////////////////////the output from this code when i run it is:linkedlistmultimap took 62 mslinkedhashmultimap took 18128 msmanual multimap took 15 ms<b>what is the expected output? what do you see instead?</b>it seems to me that the linkedhashmultimap performance is so far out of line with the other two similiar techniques that there must be a bug in it somewhere  if not perhaps there should be a warning in the javadoc that adding elements to the linkedhashmultimap is particularly slow<b>what version of the product are you using? on what operating system?</b>this happens in gauva-r07 on windows 7"; fyi i think this issue has actually been resolved by  which avoid keeping a hashset of the entries themselves || ";;;;0;1;;
458;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove dead code in classcacheversusclassreloadingtest;;;0;remove dead code in classcacheversusclassreloadingtest;; ;;;;1;1;remove dead code in classcacheversusclassreloadingtest;
458;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove dead code in classcacheversusclassreloadingtest;;;0;fix missing import;;;;;;1;1;fix missing import;
458;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove dead code in classcacheversusclassreloadingtest;;;0;[rxjava-android] operationobservefromandroidcomponent;this is in reference to  applications can use this operator to safely observe a source sequence on the main user interface thread as long as the subscription is unsubscribed from in `ondestroy` or `ondetach` no resource leaks will occuri have also added an `androidobservable` class which acts as an entry point for instantiating android specific observer instances;#377 the build failed with an oom while compiling the scala module might just be a configuration issue || regarding cloudbees  ive been trying to increment the memory high enough to get builds working  still no luck i may need to get cloudbees support to help || @mttkay would it make sense to change onsubscribebase<t androidcomponent>iscomponentvalid() implementation to return !activityisfinishing() in case of an activity? i can send a pull request if you confirm || hiwe used to have this but decided it doesnt make sense you might find moreinformation in the gh issue historyiirc the reason was that since the client needs to unsubscribe in`ondestroy` anyway and since `isfinishing` is only meaningful during`onpause` it doesnt really add any value to have this check its prettyobvious that youre finishing the activity if `ondestroy` is called and aslong as you call unsubscribe in `ondestroy` all is goodon mon nov 4 2013 at 11:45 am vörös gyula notifications@githubcomwrote:> @mttkay  would it make sense to change> onsubscribebaseiscomponentvalid() implementation to return> !activityisfinishing() in case of an activity? i can send a pull request> if you confirm> > —> reply to this email directly or view it on github  ||;;;;1;1;singularize androidobservables move to observables package;
459;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;use default directory when adding files to an entry;see #458. - the current implementation is hard to understand. i don t get how these three existing folder preferences are used.  - also  the method itself should be simplified and return a list;;0;arraylistmultimap performance; <b>what steps will reproduce the problem?</b>1 create a multimap&ltstring myobj> m  arraylistmultimapcreate()2 insert 1000 elements3 query the map 80 million times<b>what is the expected output? what do you see instead?</b>the performance of the mget() method is low and eventually memory errors will occur using hashmap&ltstringarraylist&ltmyobj>> instead is much more efficient and no memory errors will rise <b>what version of the product are you using? on what operating system?</b>r07 ubuntu 1004 x64 oracle jrockit(r) (build r2801-21-133393-160_20-20100512-2126-linux-x86_64)<b>please provide any additional information below</b>; ;;;;0;1;;
459;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;use default directory when adding files to an entry;see #458. - the current implementation is hard to understand. i don t get how these three existing folder preferences are used.  - also  the method itself should be simplified and return a list;;0;fix some rawtype warnings in tests;; ;;;;1;1;fix some rawtype warnings in tests;
459;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;use default directory when adding files to an entry;see #458. - the current implementation is hard to understand. i don t get how these three existing folder preferences are used.  - also  the method itself should be simplified and return a list;;0;statement resource;;;;;;1;1;add light weight query stats for clients;
459;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;use default directory when adding files to an entry;see #458. - the current implementation is hard to understand. i don t get how these three existing folder preferences are used.  - also  the method itself should be simplified and return a list;;454.0; issue #454;hi i used safeobservablesubscription to fix the issue #454;#378 ;unsubscribing multiple times;"quoting from an email by @headinthebox to make sure we dont forget about this issue:> another bug in rxjava/scala> > when you create a new subscription it does not remember that is is already disposed> > in scala (using trivial companion object)> > val  s  subscription{ println(“hi”) }> sunsubscribe()> sunsubscribe()> > prints “hi” twice in net only once> > in the course i will tell the students it prints only oncethe issue is already present in java:``` java    public static void main(string args) {        subscription s  subscriptionscreate(new action0() {            public void call() {                systemoutprintln(""hi"")            }        })        sunsubscribe()        sunsubscribe()    }```also prints ""hi"" twicelets fix this first in java and then add a companion object `subscription` to rxscala";;1;0; issue #454;
460;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;delete disabled test for removed objenesis missing reporting feature;;;0;create equivalent to `mapsuniqueindex` that takes keys instead of values;j@ every now and then especially when grouping data for reporting-related functionality i find myself in situations where i intuitively would use what&nbsp&nbspuniqueindex(iterable&ltv> values function<? super vk> keyfunction)provides but instead of adding the iterables elements as values and applying the given function to it to generate the corresponding keys id like it the other way round ie add the elements as keys and generate the values from them using a functioni think this could also be used to cover #﻿331 ( but instead of directly supplying a default value one would pass in a function that always returns a  value (or a new instance each depending on the type)such a method is to me the long-time missing partner for `uniqueindex` please consider adding itps: yes i considered the fact that keys have different attributes in maps than values but at least one can expect users of this method to know what they are doing (and document it too for that matter) eg if an iterable with equal elements is passed to the method the map would have less keys than the iterable has/had elements and the given function would be applied redundantly as its results get discarded or replaced in the map; ill dup this out--- ;;;;0;1;;
460;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;delete disabled test for removed objenesis missing reporting feature;;;0;delete disabled test for removed objenesis missing reporting feature;;  assigning to @raphw as he spend more time with objenesis than me ||;;;;1;1;delete disabled test for removed objenesis missing reporting feature;
460;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;delete disabled test for removed objenesis missing reporting feature;;;0;make cli use new client api;;some minor style comments but all in all looks ok  ||;;;;1;1;move sql parser to separate module;
460;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;delete disabled test for removed objenesis missing reporting feature;;;22.0;implemented the amb operator;hi this pr implemented the `amb` operator #22 i used varargs to support the array version and first-second version in one method so in my pr there are only two variants;#379 you shouldnt define a vararg method taking a generic type because you cannot use it without getting warnings (weve already had this with other operators) instead define an overload for 2 args 3 args 4 args  || yup its a pain but this is what we ended up doing for zip merge etc instead of using varargs || #382 thank you ||;operator: amb;http://msdnmicrosoftcom/en-us/library/hh229115(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229733(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211783(vvs103)aspx;;1;0;removed the vararg overload and added 2-9 args overloads;
464;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;refactor code from cleanup action to separate classes;i removed all the functionality from  cleanupaction  to separate classes. the next step would be to add tests.next pr :);;0;add a type of ordered map that will allow you to insert a key/value at a certain index; right now there is no functionality of that sort in any mapit would be really nice to have an ordered map api that has that functionalitythanks :); ;;;;0;1;;
464;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;refactor code from cleanup action to separate classes;i removed all the functionality from  cleanupaction  to separate classes. the next step would be to add tests.next pr :);;0;fix some rawtype warnings in tests;; ;;;;1;1;fix some rawtype warnings in tests;
464;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;refactor code from cleanup action to separate classes;i removed all the functionality from  cleanupaction  to separate classes. the next step would be to add tests.next pr :);;0;simple heartbeat-based failure detector;"this is a naive failure detector that watches discovery for ""presto"" announcements and monitors the remote services using the  urlit considers a service failed if the percentage of failed requests over the last minute (exponentially decayed) is higher than a configurable threshold it also supports a configurable warmup period during which newly discovered nodes are considered failed";;;;;1;1;"simple heartbeat-based failure detectorthis is a naive failure detector that watches discovery for ""presto"" announcements and monitors the remote services using the  urlit considers a service failed if the percentage of failed requests over the last minute (exponentially decayed) is higher than a configurable threshold it also supports a configurable warmup period during which newly discovered nodes are considered failed";
464;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;refactor code from cleanup action to separate classes;i removed all the functionality from  cleanupaction  to separate classes. the next step would be to add tests.next pr :);;0;(question) is it right that rxobservablesblockingobservablelast() returns null when the observable is empty?;now `rxobservablesblockingobservablelast()` returns `null` when the observable is empty however `null` is a valid value in an observable so when `last` returns `null` we can not make a distinction between these two situations i think throwing an `indexoutofboundexception` is more reasonable;have  in #470 ||;;;;0;1;;
467;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add ability to restore focus to last focused tab on startup;;;0;mapsplitter; the splitter will do something like:map&ltstringstring> mymap  splitteron("""")keyvalueseparator("""")split(""k1v1k2v2"")see also http://stackoverflowcom/questions/4095262/is-there-a-string-to-map-splitter-in-google-collections"; this will be  in r10--- ;;;;0;1;;
467;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add ability to restore focus to last focused tab on startup;;;0;fix some rawtype warnings in tests;;  lgtm thanks for doing the chore work! ||;;;;1;1;fix some rawtype warnings in tests;
467;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add ability to restore focus to last focused tab on startup;;;0;fix overflow bug in status printer;;;;;;0;1;;
467;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add ability to restore focus to last focused tab on startup;;;0;merge amb operator in pr https://githubcom/netflix/rxjava/pull/460;split unit tests out while merging;#387;;;;1;1;separating unit tests out due to https://githubcom/netflix/rxjava/pull/466;
468;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;improved duplicate checker;i changed the core function of the duplicate checker from correlation to approximate string matching. this enables the test to work (which earlier failed as  bob  and  joyce  was deemed as close enough to indicate a duplicate). probably some of the constants used for comparison needs to be tuned. also  as the approximate string matching is based on edit distance (the number of edits required to turn one string into the other)  it might be that one may operate the complete comparison on the full string rather than the word by word style as currently is used.  i think this is good to go (in the sense that it probably performs better than the previous)  but please check it with a few different databases to make sure that the false positives or missing hits are to frequent.;;0;expose inner api (used protected instead of private); it would be useful if some of the methods / inner classes / nested classes are declared as protected rather than privatefor example i want to extend splitter to be able to limit the number of splits but i cant do this because splitter only has private constructors and the inner interface strategy is declared as private; these things are private because they are implementation details that we are not willing to commit to freezing  turning something like splitter into a safely user-extendable class would be a bigger project than it may seemwe are actually working on adding the limit feature to splitter--- ;;;;0;1;;
468;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;improved duplicate checker;i changed the core function of the duplicate checker from correlation to approximate string matching. this enables the test to work (which earlier failed as  bob  and  joyce  was deemed as close enough to indicate a duplicate). probably some of the constants used for comparison needs to be tuned. also  as the approximate string matching is based on edit distance (the number of edits required to turn one string into the other)  it might be that one may operate the complete comparison on the full string rather than the word by word style as currently is used.  i think this is good to go (in the sense that it probably performs better than the previous)  but please check it with a few different databases to make sure that the false positives or missing hits are to frequent.;;0;add missing since javadoc tags for recently added methods and classes…;;  ;;;;1;1;add missing since javadoc tags for recently added methods and classes (420);
468;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;improved duplicate checker;i changed the core function of the duplicate checker from correlation to approximate string matching. this enables the test to work (which earlier failed as  bob  and  joyce  was deemed as close enough to indicate a duplicate). probably some of the constants used for comparison needs to be tuned. also  as the approximate string matching is based on edit distance (the number of edits required to turn one string into the other)  it might be that one may operate the complete comparison on the full string rather than the word by word style as currently is used.  i think this is good to go (in the sense that it probably performs better than the previous)  but please check it with a few different databases to make sure that the false positives or missing hits are to frequent.;;0;fix overflow bug in status printer;;;;;;1;1;fix overflow bug in status printer;
468;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;improved duplicate checker;i changed the core function of the duplicate checker from correlation to approximate string matching. this enables the test to work (which earlier failed as  bob  and  joyce  was deemed as close enough to indicate a duplicate). probably some of the constants used for comparison needs to be tuned. also  as the approximate string matching is based on edit distance (the number of edits required to turn one string into the other)  it might be that one may operate the complete comparison on the full string rather than the word by word style as currently is used.  i think this is good to go (in the sense that it probably performs better than the previous)  but please check it with a few different databases to make sure that the false positives or missing hits are to frequent.;;0;unsubscribe is not propagated through a mapmany operation;"if you have an observable and you mapmany from it calling unsubscribe from the last observable in the chain does not propagate unsubscribe through to the initial observablethis is a particular problem for infinite sequence observables such as observableinterval as they will now never terminate the following test demonstrates this:```package testsimport orgjunittestimport rxobservableimport rxobserverimport rxsubscriptionimport rxconcurrencyschedulersimport rxsubscriptionssubscriptionsimport rxutilfunctionsfunc1import javautilconcurrenttimeunitpublic class unsubscribetest {    @test    public void testunsubscribe() throws interruptedexception {        subscription sub  observableinterval(1 timeunitseconds)                map(new func1<long long>() {                    @override                    public long call(long along) {                        systemoutprintln(""generated "" + along)                        return along                    }                })                mapmany(new func1<long observable<long>>() {                    @override                    public observable<long> call(final long along) {                        return observablecreate(new observableonsubscribefunc<long>() {                            @override                            public subscription onsubscribe(observer<? super long> observer) {                                systemoutprintln(""mapmany for "" + along)                                observeronnext(along)                                return subscriptionsempty()                            }                        })                    }                })                subscribeon(schedulerscurrentthread())                observeon(schedulerscurrentthread())                subscribe(new observer<long>() {                    @override                    public void oncompleted() {                        //to change body of implemented methods use file | settings | file templates                    }                    @override                    public void onerror(throwable e) {                        //to change body of implemented methods use file | settings | file templates                    }                    @override                    public void onnext(long args) {                        systemoutprintln(""received "" + args)                    }                })        threadsleep(3000)        systemoutprintln(""calling unsubscribe"")        subunsubscribe()        threadsleep(3000)    }}```the output from running this is as follows:generated 0mapmany for 0received 0generated 1mapmany for 1received 1generated 2mapmany for 2received 2calling unsubscribegenerated 3generated 4generated 5from this you can see that unsubscribing from the mapmany observable is not terminating the interval observable";which version did you test? i ran your test in the latest version and the output was:<pre>generated 0mapmany for 0received 0generated 1mapmany for 1received 1generated 2mapmany for 2received 2calling unsubscribe</pre> || awesome yes it is  in 0148 i was using 0142 ;;;;0;1;;
469;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix some rawtype warnings in tests;;;0;implement splitteromitsingleempty(); hi please add a omitsingleempty() ability to splitter that makes it return an empty iterable if the underlying iterable only contains a single empty stringsometimes this is more appropriate than omitemptystrings() eg when you want to test for (and reject) empty items in your iterable but allow an empty overall iterable; ;;;;0;1;;
469;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix some rawtype warnings in tests;;;0;fix some rawtype warnings in tests;;  ;;;;1;1;fix some rawtype warnings in tests;
469;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix some rawtype warnings in tests;;;0;more updates for new client api;;;;;;1;1;cleanup handling of states and failures;
469;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix some rawtype warnings in tests;;;0;why are publishsubject etc considered internal/not needed by users in scala-lang?; have an instance in an akka actor where id like to pass back an observable to the a client and then manually convert messages passed to that actor as events on that observable for the client to handle i can do this with:``` scalaval ps  publishsubjectcreate[int]()val o  observable(ps)// send o to client// on incoming messagepsonnext(i)```which works fine but it seems like shows that publishsubject can be used in a not-internal way and i certainly would use one out of the scala-lang package instead of having to dip outside of iti havent used rxjava much but i used to do this with a net rx project a lot where objects would manage observables and converting non-iobservable pattern events into events on those observables is there a better way to convert akka message streams\arbitrary non-rxjava streams into observable events that i am missing?;"probably they have just not been wrapped yet by those contributing to the scala-lang modulehere is a blog post from @jmhofer working with akka:  can see some background on the scala support being added here:  and learn more about the implementation via this presentation starting around the 52 minute mark:  can get involved and contribute to this module:  || thanks for the resources ill take a look i worked in c# for years and used rx extensively im glad to see it make its way into scala ill see what i can contributecheersrob || its me who wrote that ""publishsubject etc are considered internal/not needed by users"" but thats wrong please discard it i think @headinthebox started/wanted to start writing scala bindings for these subjects but im not sure what the status is || ";;;;0;1;;
470;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored mock cache to be non-blocking.;the previous cache used a lock to unify concurrency and weak references. instead  keys are now explicitly wrapped using weak references and similarly to the functioning of a weak hash map  the entries are polled upon accessing the cache. this avoids blocking.;;0;refactored mock cache to be non-blocking;the previous cache used a lock to unify concurrency and weak references instead keys are now explicitly wrapped using weak references and similarly to the functioning of a weak hash map the entries are polled upon accessing the cache this avoids blocking;  looks good codewisei wonder if coverage can be increased however || ;;;;1;1;refactored mock cache to be non-blocking;
470;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored mock cache to be non-blocking.;the previous cache used a lock to unify concurrency and weak references. instead  keys are now explicitly wrapped using weak references and similarly to the functioning of a weak hash map  the entries are polled upon accessing the cache. this avoids blocking.;;0;fixes;;;;;;1;1;fix deadlock issue;
470;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored mock cache to be non-blocking.;the previous cache used a lock to unify concurrency and weak references. instead  keys are now explicitly wrapped using weak references and similarly to the functioning of a weak hash map  the entries are polled upon accessing the cache. this avoids blocking.;;0;operator: last;adds `observablelast` and fixes behavior of `blockingobservablelast` based on email discussion with @headinthebox;#395;;;;1;1;fix behavior of blockingobservablelastit now throws an illegalargumentexception instead of returning null if no elements are emittedthis is based on feedback from @headinthebox confirming this expected behavior:var xs  observablerange(10)                       		// empty sequenceint x  xslast()dump()                             		// throws “sequence contains no elements”       rxjava > blockingobservablelast()iobservable<int> ys  xstakelast(1)dump()          // oncompleted()                                                rxjava > observabletakelast(1)iobservable<int> zs  xslastasync()dump()          // onerror(“sequence contains no elements”)    rxjava > observablelast();
475;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix that the cleanup process aborts if linked file does not exists;the cleanup process sometimes wasn t successful and reported a  null  reference. the reason was that a registered file wasn t available. this is fixed in this pr.  moreover  if an exception is thrown in actions then a more detailed error message is displayed including the stack trace.;;0;typo fix;thanks for the contribution this is awesome> as you may have read project members have somehow an opinionated view on what and how should be> mockito eg we dont want mockito to be a feature bloat> there may be a thorough review with feedback -> code change loop> > _this block can be removed_> _something wrong in the template fix it here `github/pull_request_templatemd`check list-  pr should be motivated ie what does it fix why and if relevant how-  if possible / relevant include an example in the description that could help all readers     including project members to get a better picture of the change-  avoid other runtime dependencies-  meaningful commit history  intention is important please rebase your commit history so that each     commit is meaningful and help the people that will explore a change in 2 years-  read the [contributing guide](  mention `<issue number>` in the description _if relevant_-  at least one commit should mention `fixes #<issue number>` _if relevant_; ;;;;1;1;typo fix;
475;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix that the cleanup process aborts if linked file does not exists;the cleanup process sometimes wasn t successful and reported a  null  reference. the reason was that a registered file wasn t available. this is fixed in this pr.  moreover  if an exception is thrown in actions then a more detailed error message is displayed including the stack trace.;;0;fix console --execute;;;;;;1;1;fix console --execute;
475;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix that the cleanup process aborts if linked file does not exists;the cleanup process sometimes wasn t successful and reported a  null  reference. the reason was that a registered file wasn t available. this is fixed in this pr.  moreover  if an exception is thrown in actions then a more detailed error message is displayed including the stack trace.;;0;additional unit test for reduce;;#400;;;;1;1;additional unit test for reduce;
476;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactored threadsafemockingprogress to a singleton;the actual implementation of [threadsafemockingprogress]( disguise that it is effectively a singleton cause the threadlocal member is static. this makes it hard to see that different instances  share the same state.  this pr - refactores  threadsafemockingprogress to provider of mockingprogress instances - uses the standard way of instantiating the initial  threadlocal value this also avoids possible race conditions;;0;iteratorslimit bug; static method limit in class iterators should increase the count variable only on succesfull iteratornext() call iteratornext() can throw exceptionpublic t next() {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspif (count > limitsize) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspthrow new nosuchelementexception()&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp}&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspt next  iteratornext()&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspcount++&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn next&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp}; agreed one should not expect sane behavior of any object after its thrown an unchecked exception  note that we cant even provide the sane behavior because we cant know what state the _backing_ iterator is in after this either--- ;;;;0;1;;
476;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactored threadsafemockingprogress to a singleton;the actual implementation of [threadsafemockingprogress]( disguise that it is effectively a singleton cause the threadlocal member is static. this makes it hard to see that different instances  share the same state.  this pr - refactores  threadsafemockingprogress to provider of mockingprogress instances - uses the standard way of instantiating the initial  threadlocal value this also avoids possible race conditions;;0;refactored threadsafemockingprogress to a singleton;the actual implementation of [threadsafemockingprogress]( disguise that it is effectively a singleton cause the threadlocal member is static this makes it hard to see that different instances  share the same statethis pr- refactores `threadsafemockingprogress`to provider of mockingprogress instances- uses the standard way of instantiating the initial `threadlocal`value this also avoids possible race conditions;  @timvdlippe that was ticky but i found a solution the only restriction is not to cache the mockingprogress in an instance or static field other wise thread safety get lost || i am fine with these changes but would like to have a second opinion of either @bric3 or @raphw  || @bric3  the review issues || ok  thank you @christianschwarz for this work this is much appreciated ||;;;;1;1;refactored threadsafemockingprogress to a singleton;
476;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactored threadsafemockingprogress to a singleton;the actual implementation of [threadsafemockingprogress]( disguise that it is effectively a singleton cause the threadlocal member is static. this makes it hard to see that different instances  share the same state.  this pr - refactores  threadsafemockingprogress to provider of mockingprogress instances - uses the standard way of instantiating the initial  threadlocal value this also avoids possible race conditions;;0;minor statement api cleanups;;;;;;1;1;minor statement api cleanups;
476;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactored threadsafemockingprogress to a singleton;the actual implementation of [threadsafemockingprogress]( disguise that it is effectively a singleton cause the threadlocal member is static. this makes it hard to see that different instances  share the same state.  this pr - refactores  threadsafemockingprogress to provider of mockingprogress instances - uses the standard way of instantiating the initial  threadlocal value this also avoids possible race conditions;;0;dont emit null oncomplete when no onnext received in asyncsubject;reported via email by @axel22 and @headinthebox;#401;;;;1;1;dont emit null oncomplete when no onnext received;
479;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix grammar of sentence in mockito javadoc;;;0;ordering should have a method for wrapping comparators with function; im missing a method in ordering which i think should be therei tried to stick to guava coding standards however it might not be perfect but i think it gets the point across:- in orderingjava:public static &ltio> ordering&lto> transformativeordering(function&ltoi> function comparator&lti> comparator) {return new transformativeordering(checknotnull(function)checknotnull(comparator))}@﻿visiblefortesting class transformativeordering&lti u> extends ordering&ltu> {```    private final function<u i> transformer    private final comparator<i> internalcomparator    private transformativeordering(function<u i> transformer comparator<i> internalcomparator) {        super()        thistransformer  transformer        thisinternalcomparator  internalcomparator    }    @override    public int compare(u arg0 u arg1) {        return internalcomparatorcompare(transformerapply(arg0) transformerapply(arg1))    }            @override            public string tostring() {                 return ""transformativeordering(""+internalcomparatortostring()+"")""            }}```"; yup learn something new every day :) ||;;;;0;1;;
479;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix grammar of sentence in mockito javadoc;;;0;fix grammar of sentence in mockito javadoc;;;;;;1;1;fix grammar of sentence in mockito javadoc;
479;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix grammar of sentence in mockito javadoc;;;0;fix cancel;;;;;;1;1;support canceling a task before the create occurs;
479;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix grammar of sentence in mockito javadoc;;;40.0;adds dooneach operator;i thought this would be a good and simple way to start getting my feet wet with rxjava  this implements #40any feedback would be greatthanksscott;"thank you @nullstyle for this pr i always wanted to have dooneach but never had time to implement it :-)one issue to discuss: what should happen if an exception is thrown during the execution of the onnext/onerror/oncomplete function passed to dooneach?im not sure and i dont have a computer right now to test it but id answer as follows:-    exception in onnext: catch and call onerror the same way as map does-     exception in onerror or oncomplete: this ""must not happen""can someone please test it in c# and correct me if needed? || good point i handnt considered behavior when the observer provided to dooneach is the source of the exception  ill write up a simple c# app to investigate how it behaves || looking at the source for rx (i dont have access to a windows machine at the moment) it seems that any errors in the actions provided to do will call onerror on the downstream observables as expressed by this snippet:``` c#            public void onnext(tsource value)            {                try                {                    _parent_onnext(value)                }                catch (exception ex)                {                    base_observeronerror(ex)                    basedispose()                    return                }                base_observeronnext(value)            }```ill update my implementation tonight to provide consistent behavior and add some test cases to cover it || #408  thats correct anytime a user function is invoked it must have error handling around it we sometimes use try/catch other times wrap with safeobserver thank you for contributing! || looks good only change id make is put the observer/action wrappers inside the operation class so we reduce code in observable (since that class is huge) merging nowthank you for getting involved! || thanks for merging!ill work on a separate pr to refactor that code into the operation class this weekend when i get some time-scott || ";operator: do;http://msdnmicrosoftcom/en-us/library/hh229804(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229307(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229659(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229539(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229830(vvs103)aspx;"was trying to implement this but since `do` is a java keyword we cat have it as a method name net/js use `do` with capsreactivecocoa uses `donext` `doerror` and `docompleted` should rxjava too use this naming standard? || i dont see how we would have all 3 of `donext` `doerror` and `docompleted` as method names as those are the various overload arguments being passed in for the method name i wish `foreach` wasnt used for the synchronous version as that is exactly what this is  options i can think of are:- doforeach- dooneach- for- each- oneach- dotothis should be easy to implement using `map` since it seems to basically be `map` except it always returns the same type `t` instead of allowing it to be transformed am i understanding it correctly?i believe the method signatures will end up looking like this  once we figure out the name:``` javaobservable<t> nameoffunction(observable<t> source action1<t> onnext)observable<t> nameoffunction(observable<t> source observer<t> observer)observable<t> nameoffunction(observable<t> source action1<t> onnext action oncompleted)observable<t> nameoffunction(observable<t> source action1<t> onnext action1<exception> onerror)observable<t> nameoffunction(observable<t> source action1<t> onnext action1<exception> onerror action oncompleted)``` || does this function allow modifying the values or does it always return the exact same observable source? in other words is this only for performing side-effects?  || i think a function name with `do` prefix might be better coming from a net rx/rac i would expect a `do` methodyes it can be easily implemented using `map` but this would only work for onnext migt have to use `mapmany` or `materialize`/`dematerialize` combination for otherssome info on rx do:  || `operationmap` creates a new `mapobserver` with every subscription  as a consequence `func` is evaluated for every `onnext` as many times as there are subscriptions  while this might be ok for pure functions it would be very inconvenient for a `do` observable that is only there for its side-effects eg something that logs events || generally operators in a sequence do execute each time they are subscribed to - unless something like publish multicast replay etc caches the results of a subscription and becomes the source of a new sequencethe documentation ive read is very unclear regarding `do` but i dont see anything implying that it would ignore subsequence `subscribe` invocationsfor example: ``` groovydef o  anobservable      take(5)      map({transformhere}}      merge(anotherobservable)      do({dosideeffectshere})// subscribe to it onceosubscribe()// then subscribe again with another transformation doneomap({anothertransformation})subscribe()```with sequence `o` being subscribed to twice i dont see anything about it that says it should cache everything before it and only be invoked once it seems to me that it will perform the side-effects twice unless the sequence has `publish` `multicast` `refcount` etc put into:```def o  anobservable      take(5)      map({transformhere}}      merge(anotherobservable)      do({dosideeffectshere})      publish()refcount()```the code above adds `publish()refcount()` which will cause the previous operators to be executed only once and shared to all subsequent subscriptions ( is the net code for `do`:  not experienced with c# so cant guarantee i understand it but i see nothing in that code that automatically is caching the sequencethus i think the `do` operator will be executed each time just like other operators when subscribed toam i misunderstanding something about the contract specified by rxnet? || @prabirshrestha it makes sense to keep the do\* prefix so what do you prefer of these?- doforeach- dooneach- dotois there a better option?i lean towards `dooneach` because `on` fits the `onnext\onerror\oncompleted` naming convention || @benjchristensen even i preferred `dooneach` that was what i started to use> thus i think the do operator will be executed each time just like other operators when subscribed tothats right i will verify this with net too@mva `do` operator can be used to follow divide and conquer pattern tohere is a c# sample code from  c#observablefromevent<textchangedeventargs>(searchtextbox ""textchanged"")          select(e > ((textbox)esender)text)          where(text > textlength > 2)          do(s > searchresultsopacity  05)       // reduce list opacity when typing             throttle(timespanfrommilliseconds(400))          observeondispatcher()          do(s > loadingindicatorvisibility  visibilityvisible)  // show the loading indicator           selectmany(txt > searchtwitter(txt))          select(searchres > parsetwittersearch(searchres))          observeondispatcher()          do(s > loadingindicatorvisibility  visibilitycollapsed) // hide the loading indicator          do(s > searchresultsopacity  1)                          // return the list opacity to one          subscribe(tweets > searchresultsitemssource  tweets)```i found using `do` in mobile apps this way really useful || @benjchristensen i think i am starting to understand the distinction you are making  the side-effect of a `do` is not ""owned"" by the single observable instance but rather by its potentially many subscribersusing logging as an example: this makes perfect sense for a cold/passive observable because every value send to a subscriber is independent of all other values and deserves its own log entryon the other hand if i want to log the output of a hot/active observable irregardless of the (possibly zero) number of subscribers i would put the `do` on the path from the observable to a publish/connect  here exactly one log entry would be written for each value produced by the hot observablethank you for your explanation! || ";1;0;wraps dooneach in a safeobserverthis commit leverages the safeobserver facility to get the desiredbehavior in the face of exceptions  specifically if any of theoperations performed within the dooneach handler raises an exceptionthat exception will propagate through the observable chain;
486;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add autocomplete tests;- add mockito test framework: it felt really easy to write tests changing properties with mockito. see for example  namefieldautocompletertest   where the preference changes are just a one line thing. this however only works if the dependencies can be easily injected into the class.  - add a few tests to the autocompleter framework. fixed some nullpointexceptions which i found. - fixed the bug that short keys and names were not completed  tests:  bibtexkeyautocompletertest.completeshortkeyreturnskey  and  namefieldautocompletertest.completeshortnamereturnsname;;0;a future that always times out; guava provides futures that populate a value/exception immediately but ive got a use-case for a future that populates a value/exception after some predetermined timeid like to implement the null object design pattern for a asynchronousbytechannel associated with a disconnected device all i/o operations are expected to time out because no data will ever be read or written some methods return a future so i need to implement a future that always times out waiting for a value extrapolating this to a more general case i propose implementing a future where the value is populated after some pre-determined time that is:futuresnewfuturevalue(v value long timeout timeunit unit)futuresnewfutureexception(throwable throwable long timeout timeunit unit)futuresnewcheckedfuturevalue(v value long timeout timeunit unit)futuresnewcheckedfutureexception(e exception long timeout timeunit unit); thats true earwin--- ;;;;0;1;;
486;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add autocomplete tests;- add mockito test framework: it felt really easy to write tests changing properties with mockito. see for example  namefieldautocompletertest   where the preference changes are just a one line thing. this however only works if the dependencies can be easily injected into the class.  - add a few tests to the autocompleter framework. fixed some nullpointexceptions which i found. - fixed the bug that short keys and names were not completed  tests:  bibtexkeyautocompletertest.completeshortkeyreturnskey  and  namefieldautocompletertest.completeshortnamereturnsname;;0;cleanup: removed dead/unnecessary classes;removed dead/unnecessary classes:- varargcapturingmatcher and test- anyvararg removed in favor of any any can now used as varargs matcher too     removed test [shouldnotallowanyobjectmatchentirevararg()]( cause it was not clear why any should not be allowed as varargs matcher;  1 small documentation update other than that  @timvdlippe  ||;;;;1;1;removed anyvararg in favor of any;
486;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add autocomplete tests;- add mockito test framework: it felt really easy to write tests changing properties with mockito. see for example  namefieldautocompletertest   where the preference changes are just a one line thing. this however only works if the dependencies can be easily injected into the class.  - add a few tests to the autocompleter framework. fixed some nullpointexceptions which i found. - fixed the bug that short keys and names were not completed  tests:  bibtexkeyautocompletertest.completeshortkeyreturnskey  and  namefieldautocompletertest.completeshortnamereturnsname;;0;fix bug in statementresource purger;;;;;;1;1;fix bug in statementresource purger;
486;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add autocomplete tests;- add mockito test framework: it felt really easy to write tests changing properties with mockito. see for example  namefieldautocompletertest   where the preference changes are just a one line thing. this however only works if the dependencies can be easily injected into the class.  - add a few tests to the autocompleter framework. fixed some nullpointexceptions which i found. - fixed the bug that short keys and names were not completed  tests:  bibtexkeyautocompletertest.completeshortkeyreturnskey  and  namefieldautocompletertest.completeshortnamereturnsname;;0;bugfix: asyncsubject;- it was not emitting values to observers that subscribed after oncompleted/onerror;#411 ;;;;1;1;bugfix: asyncsubject- it was not emitting values to observers that subscribed after oncompleted/onerror;
490;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;atleast to static;- unified  atleastxnumberofinvocationschecker  and    atleastxnumberofinvocationsinorderchecker  into a static utility class - unified  missinginvocationchecker  and  missinginvocationinorderchecker  in   a static utility class;;0;atleast to static;- unified `atleastxnumberofinvocationschecker` and  `atleastxnumberofinvocationsinorderchecker` into a static utility class- unified `missinginvocationchecker` and `missinginvocationinorderchecker` in  a static utility class;  failing codecov checks are due to private constructors || rebased to head ||;;;;1;1;unified atleastxnumberofinvocationscheckers andmissinginvocationcheckers ina static utility classes;
490;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;atleast to static;- unified  atleastxnumberofinvocationschecker  and    atleastxnumberofinvocationsinorderchecker  into a static utility class - unified  missinginvocationchecker  and  missinginvocationinorderchecker  in   a static utility class;;0;fix setting timeouts for hive metastore client;;;;;;1;1;rename simplehivecluster to testinghivecluster;
490;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;atleast to static;- unified  atleastxnumberofinvocationschecker  and    atleastxnumberofinvocationsinorderchecker  into a static utility class - unified  missinginvocationchecker  and  missinginvocationinorderchecker  in   a static utility class;;0;scala adaptor: inheritance subscriptions and subjects;i tried to add subscriptions and subjects using the value class trick and came to the conclusion that it wont work the problem is that inheritance and value classes dont work together because value classes cannot be extended we want observable to be a value class and at the same time we want subject to extend observable so that doesnt workthis pr is very similar to [eriks code]( but i added a trait``` scalatrait javawrapper[+w] {  def asjava: w}```which all classes extend this allows us to have an `asjava` method everywhere (instead of `asjavasubject` / `asjavaobserver` etc) the main challenge was to get the double inheritance subject extends observer and observable workingnow all wrappers  the same way for instance observable looks as follows:``` scalatrait observable[+t] extends javawrapper[rxobservable[_ <: t]] {    }object observable {  private[observable] class observablewrapper[+t](val asjava: rxobservable[_ <: t]) extends observable[t] {}  def apply[t](asjava: rxobservable[_ <: t]): observable[t]  {    new observablewrapper[t](asjava)  }  }```in scala code to convert from scala types to java types theres the `asjava` method and to convert from java types to scala types theres an `apply` method in each companion objectwhen we used value classes such conversions were not necessary in java because scala types appeared as java types for the java compiler now they become necessary but note that this pr does not yet contain such conversions but that should be no big problem;#413  im reviewing this with erik tomorrow and will get this or some variant of it pulled in || yes this pr is incomplete closing ||;;;;0;1;;
491;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;add close all/others/ in database tab menu;see #314;;0;enummutimap; even though there is enummutiset implementation is no implementation for enummultimapcheck this stackoverflow question for one of the use caseshttp://stackoverflowcom/questions/4343748/java-data-structure/4344035#4344035; ;;;;0;1;;
491;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;add close all/others/ in database tab menu;see #314;;0;flush buffered console results during slow queries;;other than the minor concurrency stuff  im redoing all this ||;;;;0;1;;
491;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;add close all/others/ in database tab menu;see #314;;0;baseline checkin for android sample app;began work on a sample android app to help myself understand rx as applied to a java client  thought it would be useful for others to see comment on improve and add tohave discussed with @mttkay he has offered to review and possibly contribute as well-greg;#414  thanks greg! im at the gde summit for the next few days but will definitely get to it later this weekone thing i noticed: we should probably not push eclipse project files ide project files can be easily generated from poms and gradle build scripts this is also considering that google is moving quickly to android studio which is based around gradle and intellij i usually try not to alienate any users based on their choice of idelet me see if i can contribute a gradle build file that should be easy since i already had a sandbox style adnroid studio project for rxjava stuff on android heregood work! || that would be helpful thanksi was unsure about including the eclipse files and i know its a bitold-school  the biggest reason was to include the lib pointers but iimagine gradle has a way of doing that?ill try to look into it more this week-gon mon nov 18 2013 at 9:16 am matthias käpplernotifications@githubcomwrote:> thanks greg! im at the gde summit for the next few days but will> definitely get to it later this week> > one thing i noticed: we should probably not push eclipse project files> ide project files can be easily generated from poms and gradle build> scripts this is also considering that google is moving quickly to android> studio which is based around gradle and intellij i usually try not to> alienate any users based on their choice of ide> > let me see if i can contribute a gradle build file that should be easy> since i already had a sandbox style adnroid studio project for rxjava stuff> on android here> > good work!> > —> reply to this email directly or view it on github  || closing this out while the work is being done  please submit a new one once ready ||;;;;0;1;;
491;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;add close all/others/ in database tab menu;see #314;;390.0;deprecate whitebox and corresponding verboserunner and junitfailureha…;a quick google showed that there are almost zero usages of this runner moreover it was relying on a very hackish implementation i think we can do a better job by creating a new runner with junit 5 as part of #390 therefore the intent is to deprecate these classes and remove them in mockito 30489;  491 by private methods || rebased and updated pull request with feedback ptal    || indeed the timeout test is picky especially with openjdk 6 i restarted the job 2 times || verbose runner and console spamming runner are now both deprecated lets kill them in 30 :) ||;support for junit 5 (junit lambda);i think we should support junit 5 with mockito 2 currently we maintain an optional dependency on junit four but the junit 5 api is completely incompatible to the old one i already explored the extension mechanism a bit and for our use case it is quite trivialthere are some caveats with junit 5 for example the possibility to reuse a test instance what would require us to extend the rule for reseting mocks between runs but it is more than doable actually i suggest making `@mock` a meta annotation this way we can completely drop the mockitojunitrunner runner and the mockitojunit rule and make the setup even easierthe junit 5 api is still in alpha how do we do this?;junit 5 seems to support only java 8 is its api java 7 compatible? or maybe you meant mockito 3 (incoming just after mockito 2 but with official java 8 support :) )? || that is why i would suggest to put it into a side-project junit 5 is compiled to java 8 byte code but we could deliver the integration in java 6 nevertheless  || junit 5 looks very promising extensions replacing [runner rule & classrule]( surprise surprise    here is a sample -> the [mockitoextension]( || while i do think it is worth exploring in my eyes pushing this to mockito 30 with java 8 seems more safe this also gives time for the junit team to tinker everything and push to beta to reduce the compatibility burden for jumping on the train too soon || merging this into #445  ||;1;0;remove whitebox and deprecate corresponding verboserunner and junitfailurehacker;
492;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;revert  remove deprecated method;simple git revert for an accidental removal of a deprecated api since 2.0 instead of 1.x.  482.;;68.0;implement the scheduler overloads for range from startwith;hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks!;#415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 ;operator: range;http://msdnmicrosoftcom/en-us/library/hh229460(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211896(vvs103)aspx;the first ( is implemented in  second is waiting on schedulers || leaving open for the schedulers implementation ||;1;0;implement the scheduler overloads for range from startwith;
492;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;revert  remove deprecated method;simple git revert for an accidental removal of a deprecated api since 2.0 instead of 1.x.  482.;;98.0;implement the scheduler overloads for range from startwith;hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks!;#415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 ;operator: toobservable with scheduler;http://msdnmicrosoftcom/en-us/library/hh212140(vvs103)aspx;;1;0;implement the scheduler overloads for range from startwith;
492;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;revert  remove deprecated method;simple git revert for an accidental removal of a deprecated api since 2.0 instead of 1.x.  482.;;82.0;implement the scheduler overloads for range from startwith;hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks!;#415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 ;operator: startwith;http://msdnmicrosoftcom/en-us/library/hh229340(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229372(vvs103)aspx;;1;0;implement the scheduler overloads for range from startwith;
492;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;revert  remove deprecated method;simple git revert for an accidental removal of a deprecated api since 2.0 instead of 1.x.  482.;;482.0;"revert ""remove deprecated method""";simple git revert for an accidental removal of a deprecated api since 20 instead of 1x482; ;restore depecated answersget() method;commit da5e750957b494e7fa0548bf1286d67b8b0386d5 removed the deprecated `answersget()` method however the method was only deprecated in the 20 beta line and never made it into a ga release it would be helpful if the method could remain in the deprecated form in 20 to give people an opportunity to move away from it(originally raise by a spring boot user [here](https://githubcom/spring-projects/spring-boot/pull/6323));"on a related note adding a ""as of"" to the deprecated description would also be useful:``` java/** * @deprecated as of 20 in favor of using the enum-constant directly this method will be removed in a future release<br>  * eg instead of <code>answerscalls_real_methodsget()</code> use <code>answerscalls_real_methods</code>  */``` || i would agree with @philwebb that this method had been made deprecated in 20 (-beta2) not in 110x (in fact at first it was [removed]( completely and one month later [restored]( as deprecated) but what is more important `answers` started implementing `answer` then because of that when i was fixing that issue in spring boot it was hard to keep code compatible with both versions at runtime (for 1x casting using it as answer does not work for never 2x `get()` is not available) in the end i had to [do]( ugly casting through `object` to fool the compiler with that spring boot should work fine (at least with changes related to `answers` :) ) but there could be other tools (powermock?) that after removing this method cannot be easily compatible with both mockito 1x and 2x imho it would be good to keep this method in 2x and remove in 3x || yes that seems like a good idea mind want to open a pull request? || ";1;0;"revert ""remove deprecated method""this reverts commit da5e750957b494e7fa0548bf1286d67b8b0386d5";
492;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;revert  remove deprecated method;simple git revert for an accidental removal of a deprecated api since 2.0 instead of 1.x.  482.;;0;fix client hang for simple queries with no output stage;"this makes eg ""drop table"" not hang in the cli";;;;;1;1;"fix client hang for simple queries with no output stagethis makes eg ""drop table"" not hang in the cli";
492;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;revert  remove deprecated method;simple git revert for an accidental removal of a deprecated api since 2.0 instead of 1.x.  482.;;0;andpredicate and orpredicate hashcode methods leaves something to be desired; the hashcode functions for these two classes use and and or respectively to compose the hashcode while this almost makes sense when considering the functions that the classes perform it leaves the hashcode function almost entirely useless for larger predicatesif you have 7 predicates within an and or or predicate the likelihood is that the hashcode returned from the and or or predicate will be either 0 of 0xffffffff respectively id say this is a cute way of solving the hashcodes but ultimately it goes beyond what the class is perceived to do and will cause issues for complex predicate structures; ;;;;0;1;;
495;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;moves reporter friendly exception factory to internal package;the  reporter  friendly exception factory class lies in  org.mockito.exceptions.reporter   however it s api is subject to change without really impacting user experience.  thus  i propose to move  org.mockito.exceptions.reporter  to  org.mockito.internal.exceptions.reporter .  i didn t provided a dummy class for two reasons : 1. i would like to schedule this for mockito 2 a major version 2. this class shouldn t be used outside framework development;;0;documentation error; http://guava-librariesgooglecodecom/svn/trunk/javadoc/com/google/common/base/splitterhtml#onpattern(javalangstring)shouldntsplitteronpattern(""\r?\n"")split(entirefile)besplitteronpattern(""\r?\n"")split(entirefile)"; either way works--- ;;;;0;1;;
495;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;moves reporter friendly exception factory to internal package;the  reporter  friendly exception factory class lies in  org.mockito.exceptions.reporter   however it s api is subject to change without really impacting user experience.  thus  i propose to move  org.mockito.exceptions.reporter  to  org.mockito.internal.exceptions.reporter .  i didn t provided a dummy class for two reasons : 1. i would like to schedule this for mockito 2 a major version 2. this class shouldn t be used outside framework development;;0;moves reporter friendly exception factory to internal package;the `reporter` friendly exception factory class lies in `orgmockitoexceptionsreporter` however its api is subject to change without really impacting user experiencethus i propose to move `orgmockitoexceptionsreporter` to `orgmockitointernalexceptionsreporter`i didnt provided a dummy class for two reasons :1 i would like to schedule this for mockito 2 a major version2 this class shouldnt be used outside framework development;  lgtm but also requires a rebase ||;;;;1;1;moves reporter friendly exception factory to internal package;
495;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;moves reporter friendly exception factory to internal package;the  reporter  friendly exception factory class lies in  org.mockito.exceptions.reporter   however it s api is subject to change without really impacting user experience.  thus  i propose to move  org.mockito.exceptions.reporter  to  org.mockito.internal.exceptions.reporter .  i didn t provided a dummy class for two reasons : 1. i would like to schedule this for mockito 2 a major version 2. this class shouldn t be used outside framework development;;0;improvements to analyzer and planner;- add support for group by ordinals- add support for order by ordinals- fix order by semantics- add support for mixing aggregations with window functions- fix scoping rules for aliased joins- implement having- improve output column naming- support inline views without alias- better handling of certain group by edge cases such as sum(x)/x when x is not in the group by clause- add support for with- allow queries without from clause;looks good overall will review analyzer and planner in depth ||  ;;;;0;1;;
495;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;moves reporter friendly exception factory to internal package;the  reporter  friendly exception factory class lies in  org.mockito.exceptions.reporter   however it s api is subject to change without really impacting user experience.  thus  i propose to move  org.mockito.exceptions.reporter  to  org.mockito.internal.exceptions.reporter .  i didn t provided a dummy class for two reasons : 1. i would like to schedule this for mockito 2 a major version 2. this class shouldn t be used outside framework development;;0;zip many rewritten concat with iterable merge with iterable;ive rewritten the zip method to terminate as soon as possible in addition the concat(iterable<observable<t>> and merge(iterable<observable<t>>) where missing from observable;"#418  @akarnokd thank you for this im checking out the branch now to play with it and see how the problematic unit tests behavewould you mind re-submitting the pull request though after rebasing this onto a new branch so we dont have all the commit clutter resulting from you working on your master branch? the commit ""merge origin/master""  and commits before that are a result of merging /netflix/rxjava master into your master then submitting back from the same branch it is preferable to always commit only to a clean branch and submit a pull request from that so only the relevant commits are applied the only time anything should commit to your forked master is when fetching from the upstream to sync back up i want to confirm a unit test for this code @headinthebox can you please validate something? the following unit test shows how this will correctly complete once the first stream completes however it still waits until all items are emitted before the `oncompleted` is sent i want to ensure thats how it should behave as opposed to skipping those and completing as soon as oncomplete is sent (like onerror should)``` java    @test    public void testonfirstcompletion() {        publishsubject<string> oa  publishsubjectcreate()        publishsubject<string> ob  publishsubjectcreate()        @suppresswarnings(""unchecked"")        observer<string> observer  mock(observerclass)        observable<string> o  observablecreate(zip(oa ob getconcat2strings()))        osubscribe(observer)        inorder inorder  inorder(observer)        oaonnext(""a1"")        inorderverify(observer never())onnext(anystring())        obonnext(""b1"")        inorderverify(observer times(1))onnext(""a1-b1"")        obonnext(""b2"")        inorderverify(observer never())onnext(anystring())        oaonnext(""a2"")        inorderverify(observer times(1))onnext(""a2-b2"")        oaonnext(""a3"")        oaonnext(""a4"")        oaonnext(""a5"")        oaoncompleted()        // should oncomplete be emitted here instead of waiting       // for b3 b4 b5 to be emitted?        obonnext(""b3"")        obonnext(""b4"")        obonnext(""b5"")        inorderverify(observer times(1))onnext(""a3-b3"")        inorderverify(observer times(1))onnext(""a4-b4"")        inorderverify(observer times(1))onnext(""a5-b5"")        // we receive the oncomplete here        inorderverify(observer times(1))oncompleted()        obonnext(""b6"")        obonnext(""b7"")        obonnext(""b8"")        obonnext(""b9"")        // never completes (infinite stream for example)        // we should receive nothing else despite ob continuing after oa completed        inorderverifynomoreinteractions()    }    private func2<string string string> getconcat2strings() {        return new func2<string string string>() {            @override            public string call(string t1 string t2) {                return t1 + ""-"" + t2            }        }    }``` || this confirms the `onerror` event is propagated immediately:``` java@test    public void testonerrortermination() {        publishsubject<string> oa  publishsubjectcreate()        publishsubject<string> ob  publishsubjectcreate()        @suppresswarnings(""unchecked"")        observer<string> observer  mock(observerclass)        observable<string> o  observablecreate(zip(oa ob getconcat2strings()))        osubscribe(observer)        inorder inorder  inorder(observer)        oaonnext(""a1"")        inorderverify(observer never())onnext(anystring())        obonnext(""b1"")        inorderverify(observer times(1))onnext(""a1-b1"")        obonnext(""b2"")        inorderverify(observer never())onnext(anystring())        oaonnext(""a2"")        inorderverify(observer times(1))onnext(""a2-b2"")        oaonnext(""a3"")        oaonnext(""a4"")        oaonnext(""a5"")        oaonerror(new runtimeexception(""forced failure""))        // it should emit failure immediately        inorderverify(observer times(1))onerror(any(runtimeexceptionclass))        obonnext(""b3"")        obonnext(""b4"")        obonnext(""b5"")        obonnext(""b6"")        obonnext(""b7"")        obonnext(""b8"")        obonnext(""b9"")        // never completes (infinite stream for example)        // we should receive nothing else despite ob continuing after oa completed        inorderverifynomoreinteractions()    }``` || sorry for the clutter im new to git in this manner will do a new pull shortly || > sorry for the clutter im new to git in this manner will do a new pull shortlynot a problem the git flow for pull requests is not obvious when first starting i totally messed up a few repos when i first started had to wipe them out and start fresh with clean forks until i got the hang of it :-) || closing as replaced by  || ";;;;0;1;;
496;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;renames matchers to argumentmatchers to avoid name clash with hamcrest matchers class;renames  matchers  to  argumentmatchers  to avoid name clash with hamcrest  org.hamcrest.matchers  class.  this plagued usage of mockito and hamcrest together since the introduction of matchers. the work in mockito 2 beta allowed to avoid relying on hamcrest internally and thus split the hamcrest matcher factory  mockitohamcrest . yet this is not enough as using both mockito matchers and hamcrest matchers in the same class  made the developer life not comfortable when using both api.  this change helps in that regard  as it renames the import class. not this change tweaks only the class hierarchy  so current code still compiles  thanks to the javac compiler that can lookup static method in parent classes. (that is why i didn t updated tests yest  they could be upgraded in a late pr  a good timing would probably be when  matchers  is removed)   matchers  class can be removed in the next version of mockito  likely 3.0.;;0;sources dont compile - in r136 assertassertfalse() and assertassertnull() were removed but theyre still in use; im trying to compile latest (r144) version from repository im getting errors of the like:/home/igor/projects/guava/test/com/google/common/testing/asserttestjava:[8510] cannot find symbolsymbol  : method assertfalse(javalangstringboolean)location: class comgooglecommontestingassertmethods assertassertfalse() and assertassertnull() were removed in r136 leaving ""asserttest"" tests in uncompilable state"; ant dist works  if anything else ever worked it was just by accident we still have a lot more work to do making things work reliably--- ;;;;0;1;;
496;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;renames matchers to argumentmatchers to avoid name clash with hamcrest matchers class;renames  matchers  to  argumentmatchers  to avoid name clash with hamcrest  org.hamcrest.matchers  class.  this plagued usage of mockito and hamcrest together since the introduction of matchers. the work in mockito 2 beta allowed to avoid relying on hamcrest internally and thus split the hamcrest matcher factory  mockitohamcrest . yet this is not enough as using both mockito matchers and hamcrest matchers in the same class  made the developer life not comfortable when using both api.  this change helps in that regard  as it renames the import class. not this change tweaks only the class hierarchy  so current code still compiles  thanks to the javac compiler that can lookup static method in parent classes. (that is why i didn t updated tests yest  they could be upgraded in a late pr  a good timing would probably be when  matchers  is removed)   matchers  class can be removed in the next version of mockito  likely 3.0.;;0;renames matchers to argumentmatchers to avoid name clash with hamcrest matchers class;renames `matchers` to `argumentmatchers` to avoid name clash with hamcrest `orghamcrestmatchers` classthis plagued usage of mockito and hamcrest together since the introduction of matchers the work in mockito 2 beta allowed to avoid relying on hamcrest internally and thus split the hamcrest matcher factory `mockitohamcrest` yet this is not enough as using both mockito matchers and hamcrest matchers in the same class made the developer life not comfortable when using both apithis change helps in that regard as it renames the import class not this change tweaks only the class hierarchy so current code still compiles thanks to the javac compiler that can lookup static method in parent classes (that is why i didnt updated tests yest they could be upgraded in a late pr a good timing would probably be when `matchers` is removed)`matchers` class can be removed in the next version of mockito likely 30;  note im open on the name of `argumentmatchers` || lgtm! || ah but it requires a rebase   ||;;;;1;1;renames `matchers` to `argumentmatchers` to avoid name clash with hamcrest `orghamcrestmatchers` classtis plagued usage of mockito and hamcrest together since the introduction of matchers the work in mockito 2 beta allowed to avoid relying on hamcrest internally and thus split the hamcrest matcher factory `mockitohamcrest` yet this is not enough as using both mockito matchers and hamcrest matchers in the same class made the developer life not comfortable when using both apithis change helps in that regard as it renames the import class not this change tweaks only the class hierarchy so current code still compiles thanks to the javac compiler that can lookup static method in parent classes (that is why i didnt updated tests yest they could be upgraded in a late pr a good timing would probably be when `matchers` is removed)`matchers` class can be removed in the next version of mockito likely 30;
496;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;renames matchers to argumentmatchers to avoid name clash with hamcrest matchers class;renames  matchers  to  argumentmatchers  to avoid name clash with hamcrest  org.hamcrest.matchers  class.  this plagued usage of mockito and hamcrest together since the introduction of matchers. the work in mockito 2 beta allowed to avoid relying on hamcrest internally and thus split the hamcrest matcher factory  mockitohamcrest . yet this is not enough as using both mockito matchers and hamcrest matchers in the same class  made the developer life not comfortable when using both api.  this change helps in that regard  as it renames the import class. not this change tweaks only the class hierarchy  so current code still compiles  thanks to the javac compiler that can lookup static method in parent classes. (that is why i didn t updated tests yest  they could be upgraded in a late pr  a good timing would probably be when  matchers  is removed)   matchers  class can be removed in the next version of mockito  likely 3.0.;;0;create refresh;;all merged in ||;;;;0;1;;
496;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;renames matchers to argumentmatchers to avoid name clash with hamcrest matchers class;renames  matchers  to  argumentmatchers  to avoid name clash with hamcrest  org.hamcrest.matchers  class.  this plagued usage of mockito and hamcrest together since the introduction of matchers. the work in mockito 2 beta allowed to avoid relying on hamcrest internally and thus split the hamcrest matcher factory  mockitohamcrest . yet this is not enough as using both mockito matchers and hamcrest matchers in the same class  made the developer life not comfortable when using both api.  this change helps in that regard  as it renames the import class. not this change tweaks only the class hierarchy  so current code still compiles  thanks to the javac compiler that can lookup static method in parent classes. (that is why i didn t updated tests yest  they could be upgraded in a late pr  a good timing would probably be when  matchers  is removed)   matchers  class can be removed in the next version of mockito  likely 3.0.;;494.0;add contravariant for min and max;hi this pr added  contravariant for min and max mentioned in #494;#419 ;operators without co- or contravariance;"im looking at the operator definition and found a bunch of places where the ""lambda"" functions do not have wildcard bounds specified egreduce(func2[t t t])max(comparator[t])etcis there a particular reason these are not:reduce(func2[? super t ? super t ? extends t])max(comparator[? super t])?";reduce:thats a long story see     and   in short:-    its considered unnecessary (or not necessary enough to complicate the signature)-    note though that the signature of reduce is not entirely correct because the covariant type parameter t appears in a contravariant position so you cant use reduce on an `observable<? extends xxx>`  but only on an `observable<xxx>`  to fix this one would need lower bounds for type parameters but java doesnt support thismin/max:imho it would be a good idea to add wildcards what do others think? || for min/max i agree with you ill fix it || it seems we can close this issue now ||;1;0;add contravariant for min and max;
498;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;remove unused imports;;;0;filesdeletedirectorycontents() fails for relative directory; hi ive created a file object from a relative path under windows:new file(""/src/test/resources/target-dir"")i copied some files inside this directory and tried to remove the content with filesdeletedirectorycontents()it fails silently cause of:if (!directorygetcanonicalpath()equals(directorygetabsolutepath())) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn}the cause is that directorygetcanonicalpath() returns ""c:\work\dev\test\src\test\resources\target-dir\tmp""and directorygetabsolutepath() returns ""c:\work\dev\test\src\test\resources\target-dir\tmp""(notice the dot before src)"; issue #﻿637 is already pointing out the problem with that dain bramaged code  ||;;;;0;1;;
498;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;remove unused imports;;;0;remove unused imports;;"does it build locally after your changes?```:compiletestjava/home/travis/build/mockito/mockito/src/test/java/org/mockitousage/matchers/matcherstestjava  cannot find symbolsymbol  : method eq(doubledouble)location: class orgmockitousagematchersmatcherstest        when(mockonearg(eq(10d 01d)))thenreturn(""1"")``` || locally it worked but that does not matter i will add back the import ||    ";;;;1;1;remove unused imports;
498;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;remove unused imports;;;0;drop fixes;;;;;;0;1;;
498;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;remove unused imports;;;0;implement the repeat operator;hi this pr implemented the `repeat` operator #70 please take a look thanks!;"#422  i believe this stack overflows:``` java        observablefrom(1)repeat()toblockingobservable()foreach(new action1<integer>() {            @override            public void call(integer t1) {            }})```stacktrace:```javalangruntimeexception: javalangstackoverflowerror    at rxobservablesblockingobservableforeach(blockingobservablejava:159)    at rxoperatorsoperationrepeattestmain(operationrepeattestjava:39)caused by: javalangstackoverflowerror    at javautilhashmap$entry<init>(hashmapjava:814)    at javautilhashmapcreateentry(hashmapjava:901)    at javautilhashmapaddentry(hashmapjava:888)    at javautilhashmapput(hashmapjava:509)    at rxsubjectsreplaysubject$subscriptionfunccall(replaysubjectjava:115)    at rxsubjectsreplaysubject$subscriptionfunccall(replaysubjectjava:1)    at rxsubjectsreplaysubject$delegatesubscriptionfunconsubscribe(replaysubjectjava:84)    at rxobservablesubscribe(observablejava:224)    at rxoperatorsoperationmulticast$multicastconnectableobservable$1onsubscribe(operationmulticastjava:41)    at rxobservablesubscribe(observablejava:224)    at rxoperatorsoperationobserveon$observeononsubscribe(operationobserveonjava:50)    at rxobservablesubscribe(observablejava:224)    at rxoperatorsoperationrepeat$1$1oncompleted(operationrepeatjava:82)    at rxsubjectsreplaysubjectoncompleted(replaysubjectjava:141)    at rxoperatorsoperationmulticast$multicastconnectableobservable$2oncompleted(operationmulticastjava:54)    at rxoperatorsoperationtoobservableiterable$toobservableiterableonsubscribe(operationtoobservableiterablejava:48)    at rxobservablesubscribe(observablejava:224)    at rxoperatorsoperationmulticast$multicastconnectableobservableconnect(operationmulticastjava:51)    at rxoperatorsoperationrepeat$1$1oncompleted(operationrepeatjava:83)    at rxsubjectsreplaysubjectoncompleted(replaysubjectjava:141)    at rxoperatorsoperationmulticast$multicastconnectableobservable$2oncompleted(operationmulticastjava:54)    at rxoperatorsoperationtoobservableiterable$toobservableiterableonsubscribe(operationtoobservableiterablejava:48)    at rxobservablesubscribe(observablejava:224)    at rxoperatorsoperationmulticast$multicastconnectableobservableconnect(operationmulticastjava:51)    at rxoperatorsoperationrepeat$1$1oncompleted(operationrepeatjava:83)    at rxsubjectsreplaysubjectoncompleted(replaysubjectjava:141)    at rxoperatorsoperationmulticast$multicastconnectableobservable$2oncompleted(operationmulticastjava:54)    at rxoperatorsoperationtoobservableiterable$toobservableiterableonsubscribe(operationtoobservableiterablejava:48)    at rxobservablesubscribe(observablejava:224)    at rxoperatorsoperationmulticast$multicastconnectableobservableconnect(operationmulticastjava:51)    at rxoperatorsoperationrepeat$1$1oncompleted(operationrepeatjava:83)    at rxsubjectsreplaysubjectoncompleted(replaysubjectjava:141)    at rxoperatorsoperationmulticast$multicastconnectableobservable$2oncompleted(operationmulticastjava:54)    at rxoperatorsoperationtoobservableiterable$toobservableiterableonsubscribe(operationtoobservableiterablejava:48)    at rxobservablesubscribe(observablejava:224)    at rxoperatorsoperationmulticast$multicastconnectableobservableconnect(operationmulticastjava:51)    at rxoperatorsoperationrepeat$1$1oncompleted(operationrepeatjava:83)    at rxsubjectsreplaysubjectoncompleted(replaysubjectjava:141)    at rxoperatorsoperationmulticast$multicastconnectableobservable$2oncompleted(operationmulticastjava:54)    at rxoperatorsoperationtoobservableiterable$toobservableiterableonsubscribe(operationtoobservableiterablejava:48)    at rxobservablesubscribe(observablejava:224) etc```if `subscriptions` has not been touched before the stackoverflow you will instead see this:```javalangnoclassdeffounderror: could not initialize class rxsubscriptionssubscriptions    at rxobservablesubscribe(observablejava:254)    at rxobservablesblockingobservableprotectivelywrapandsubscribe(blockingobservablejava:93)    at rxobservablesblockingobservableforeach(blockingobservablejava:121)    at rxoperatorsoperationrepeattestmain(operationrepeattestjava:39)```we need to use the recursive scheduler idiom to implement repeat || small detail: in some places you should replace ""the number of times to repeat the element"" by ""the number of times to repeat the source sequence"" || is there a reason the repeat() uses an external scheduler and the replaysubject? how about a simpler approach:``` java    public static <t> onsubscribefunc<t> repeat(final observable<t> source final int count) {        return new onsubscribefunc<t>() {            @override            public subscription onsubscribe(final observer<? super t> t1) {                final serialsubscription sreg  new serialsubscription()                final observable<t> ssource  sourcesubscribeon(schedulerscurrentthread())                observer<t> o  new observer<t>() {                    int remaining  count                    @override                    public void onnext(t args) {                        t1onnext(args)                    }                    @override                    public void onerror(throwable e) {                        try {                            t1onerror(e)                        } finally {                            sregunsubscribe()                        }                    }                    @override                    public void oncompleted() {                        if (remaining-- > 0) {                            sregsetsubscription(ssourcesubscribe(this))                        } else {                            t1oncompleted()                            sregunsubscribe()                        }                    }                }                sregsetsubscription(ssourcesubscribe(o))                return sreg            }        }    }``` || @benjchristensen i think using schedulersimmediate() causes the stack overflow problem here is a test in c#:``` c#        static void main(string args)        {            iobservable<int> obs  observablecreate<int>(o > new foo(o)test(schedulerimmediate 0))            obssubscribe(                x > consolewriteline(""onnext: "" + x)                )            consolereadline()        }        class foo        {            iobserver<int> _o            public foo(iobserver<int> o)            {                _o  o            }            public idisposable test(ischeduler s int i)            {               return sschedule(i + 1  (scheduler x) > {                    _oonnext(x)                    return thistest(scheduler x)                })            }        }```this code does not cause a stack overflow exceptionbut in rxjava the following unit test will cause a stack overflow exception:``` java    @test    public void testrecursivescheduler1() {        observable<integer> obs  observable                create(new onsubscribefunc<integer>() {                    @override                    public subscription onsubscribe(                            final observer<? super integer> observer) {                        return schedulersimmediate()schedule(0                                new func2<scheduler integer subscription>() {                                    @override                                    public subscription call(                                            scheduler scheduler integer i) {                                        observeronnext(i)                                        return schedulerschedule(i + 1 this)                                    }                                })                    }                })        obssubscribe(new observer<integer>() {            @override            public void oncompleted() {            }            @override            public void onerror(throwable e) {                eprintstacktrace()            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })    }```im trying to understand the immediatescheduler in rxnet seems that it also uses a queue to save the actions to avoid the stack overflow exception || #444 #445 [rxjava-pull-requests #446 the current implementation still has some problems which can not be simply handled in `operationrepeat` if using immediatescheduler in `repeat` operator there may be a stack overflow exception mentioned above if using currentthreadscheduler the following test will not stop i suppose it should stop when the observer has some error``` java    @test    public void testrepeatwithinfiniterepeatcountwithcurrentthread() {        observable<string> observable  repeat(""foo"" schedulerscurrentthread())        @suppresswarnings(""unchecked"")        observer<string> observer  (observer<string>) mock(observerclass)        doanswer(new answer<void>() {            private int count  0            @override            public void answer(invocationonmock invocation) throws throwable {                count++                if (count  100) {                    // only verify if repeating 100 times                    // we can not really verify if repeating infinitely                    throw new runtimeexception(""some error"")                }                return null            }        })when(observer)onnext(anystring())        observablesubscribe(observer)        inorder inorder  inorder(observer)        inorderverify(observer times(100))onnext(""foo"")        inorderverify(observer)onerror(isa(runtimeexceptionclass))        inorderverifynomoreinteractions()    }``` || - you should use the current thread scheduler (which is what c# does) see my pull request- i dont think we need an overload with count just as easy to do a take(n) afterwards- there is an issue with toblocking observable where it does not terminate that does not appear in toeneumerable() in net || > you should use the current thread scheduler (which is what c# does) see my pull requestagree but now as the current thread has some issue i use immediatescheduler to pass the unit test> i dont think we need an overload with count just as easy to do a take(n) afterwardscould you give me an example? how can we know the `n` to use in `take` when the observable size is unknown> there is an issue with toblocking observable where it does not terminate that does not appear in toeneumerable() in neti suppose my problem its about safeobservablesubscription and safeobserver but maybe we are talking about the same issue since safeobservablesubscription and safeobserver are used in toblockingobservable too || this hangs in rxnet as well (21302140)``` c#observablereturn(1)repeat()take(100)subscribe(consolewriteline)```the issue is in the `repeatsubscribe()` not returning until the (infinite) re-subscription finishes so there is no way the take method can signal its uplink to terminate as it hasnt yet received a reference to it however this works:``` c#observablereturn(1 schedulerdefault)repeat()take(100)subscribe(consolewriteline)```as now the repeatoncompleted can run in another thread and the repeatsubscribe() can returni believe this can be achieved by not subscribing to the raw source in the repeatsubscribe() but rather using subscribeon(schedulersnewthread()) to move the subscription into a parallel thread and let the repeatsubscribe() return``` javapublic static <t> onsubscribefunc<t> repeat(final observable<t> source final int count) {    return new onsubscribefunc<t>() {        @override        public subscription onsubscribe(final observer<? super t> t1) {            final serialsubscription sreg  new serialsubscription()            final observable<t> ssource  sourcesubscribeon(schedulersnewthread())            observer<t> o  new observer<t>() {                int remaining  count                @override                public void onnext(t args) {                    t1onnext(args)                }                @override                public void onerror(throwable e) {                    try {                        t1onerror(e)                    } finally {                        sregunsubscribe()                    }                }                @override                public void oncompleted() {                    if (remaining-- > 0) {                        sregsetsubscription(ssourcesubscribe(this))                    } else {                        t1oncompleted()                        sregunsubscribe()                    }                }            }            sregsetsubscription(ssourcesubscribe(o))            return sreg        }    }}``` || > i believe this can be achieved by not subscribing to the raw source in the repeatsubscribe() but rather using subscribeon(schedulersnewthread()) to move the subscription into a parallel thread and let the repeatsubscribe() returnthanks you remind me one thing: there is not an `repeat` overload with observable and scheduler together in rxnet when i tried to implement the `repeat` overload i was wondering why there was not a such overload maybe this is because `repeat` can not be used with all of schedulers however even if we do not provide such overload users still can use schedulers  observeon` for example `observablefrom(1)repeat()take(100)observeon()(schedulerscurrentthread)`so is it ok that we do not provide this kind of method and warn that `should not use repeat with schedulerscurrentthread() or schedulersimmediate()` in the document? || i think rxnet started out its return operator to run on the threadpool if manually put back there the example works nowadays it runs on the immediate scheduler causing the problem even if you warn the user about the scheduler there is no way to know if an incoming observable is dangerous or not this affects other operators such as concat and onerrorresume || return always used the immediate scheduler :-) || same stack overflow issue happens in `interval```` java    @test    public void testintervalwithimmediatescheduler() {        observableinterval(1 timeunitmilliseconds schedulersimmediate())                subscribe(new observer<long>() {                    @override                    public void oncompleted() {                        systemoutprintln(""oncompleted"")                    }                    @override                    public void onerror(throwable e) {                        eprintstacktrace()                    }                    @override                    public void onnext(long args) {                        systemoutprintln(args)                    }                })    }``` || currentthreadscheduler can work with `interval` because `interval` does not use safeobservablesubscription and safeobserver || i am working with @headinthebox on changes to schedulers including `interval` and will come back to this and  when ready || completed in  || ";;;;0;1;;
499;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;401 - makes the junit runner detect unused stubs;401  this is a breaking change because junit runner will now fail the test class if there is an unused stubbing.  feedback is welcome. sorry for working on it for a long time and big number of commits.;;0;objectstostring(obj) for null-safe tostring() call; eg```public static string tostring(object obj) {    return tostring(obj """")}public static string tostring(object obj string defaultstr) {    return obj ! null ? objtostring() : defaultstr}```"; we dont think highly of null-safe libraries  we are stuck with a few but we dont wish to grow that setweve seen firsthand that if you make a reliance on nullable values easier you just get more reliance on nullable values  the spread of nullability through a codebase is a sickness  it should instead be chopped off as close to the source as possiblewhen you _have to_ deal with null it _should_ be harder and uglier than not having to deal with it--- ;;;;0;1;;
499;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;401 - makes the junit runner detect unused stubs;401  this is a breaking change because junit runner will now fail the test class if there is an unused stubbing.  feedback is welcome. sorry for working on it for a long time and big number of commits.;;0;create alias;;good to go ||;;;;1;1;revert logicalexecutionplanner changesthe sub planner is required because it gets a different symbol/type map which is needed for the execution;
499;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;401 - makes the junit runner detect unused stubs;401  this is a breaking change because junit runner will now fail the test class if there is an unused stubbing.  feedback is welcome. sorry for working on it for a long time and big number of commits.;;0;observeon refactor;refactor and small fixes of observeon with @headinthebox;#423 ;;;;1;1;refactored observeon without scheduledobserver;
499;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;401 - makes the junit runner detect unused stubs;401  this is a breaking change because junit runner will now fail the test class if there is an unused stubbing.  feedback is welcome. sorry for working on it for a long time and big number of commits.;;401.0;401 - makes the junit runner detect unused stubs;401this is a breaking change because junit runner will now fail the test class if there is an unused stubbingfeedback is welcome sorry for working on it for a long time and big number of commits;investigating the failure on travis works for me locally! :d || i would rather not default to strict right away this will break a lot of user test suites which significantly increasing the upgrade process to mockito 20if we let developers know our intention is to makr the strict version default later they can slowly make the changes for each of their runners then we can change the default in mockito 30 so developers had some time to adopt ||   it this weekend || late in the review game but nice feature ||;junit runner detects unused stubs;it is useful to know that stubbing in the test was not used perhaps the stubbing is not needed? removal of unnecessary code from the test is important for code claritymore details:- we detect unused stubs only for passing tests (adding different failure to an existing failure could be confusing)- need to have something similar for junit rules (will create separate ticket)- stubbing in @before or class constructor should be used in at least one test- stubbing in test needs to be used in that test;the current impl is not thread safe reopening ||;1;0;avoided unnecessary object creation- great feedback from tim- the code is cleaner too;
501;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;refactored testmethodsfinder to a static utility class (#426);;;0;ensure that gwt artifacts are present in the maven central repositories as part of release process; if you want to use guava in a gwt project you currently have to deploy the guava-r07-gwtjar in your own maven repository as its not on maven centralnot a show stopper for us but it would be much better if we werent force to do it (and repeat it when well switch to r08); these will be pushed when we push the release candidate--- ;;;;0;1;;
501;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;refactored testmethodsfinder to a static utility class (#426);;;0;fix bug in tupleinfosetnull/setnotnull;;;;;;1;1;fix bug in tupleinfosetnull/setnotnull;
501;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;refactored testmethodsfinder to a static utility class (#426);;;0;parallelmerge operator;;#425 ;;;;1;1;parallelmerge operator;
501;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;refactored testmethodsfinder to a static utility class (#426);;;426.0;refactored testmethodsfinder to a static utility class (#426);; ;refactor instance based utility classes to static utility classes;the internal implementation of mockito contains numerous helper classed that serve as a container for useful methods by its nature these classes dont have a state currently some them are instance based in other word you need to create the utility class to call a helper method this not only pollutes the heap but also the code cause instance methods cant be imported statically here is an example:```javahelper helper  new helper()if (helperisinputvalid(input)){   }```vs static import of helperisinputvalid```javaif (isinputvalid(input)){   }```the aim of this ticket is to identify canidates that can be refactored to static utility classes if you like to refactoring and mockito feel free to send a pr and reference this issuerefactoring canidates:-  `accessibilitychanger`-  `beanpropertysetter`-  `conditionalstacktracefilter`-  `fieldcopier`-  `fieldreader`-  `genericmaster` should be integrate into `generictyperesolver`-  `junitfailurehacker` can be removed when the deprecated `verbosemockitojunitrunner` is removed-  `lenientcopytool`-  `matcherbinder`-  `mockitocore` should better be a singleton-  `mockcreationvalidator`- [ ] `removefirstline`-  #591 `argumentmatchingtool`-  #515 `allinvocationsfinder`-  #502 `argumentscomparator`-  #540 `arrayutils`-  #490 `atleastxnumberofinvocationschecker`-  #490 `atleastxnumberofinvocationsinorderchecker`- [ ] #912 `constructors`-  #427 `fieldsetter`-  #908 `friendlyexceptionmaker`-  #431 `handyreturnvalues` - [x] #432 `invocationmarker`- [x] #462 `invocationsfinder`- [x] #908 `junitdetecter`- [x] #490 `missinginvocationchecker`- [x] #490 `missinginvocationinorderchecker`- [x] #514 `mockutil`- [x] #503 `nongreedynumberofinvocationsinorderchecker`- [x] #907 `numberofinvocationsinorderchecker`- [x] #907 `numberofinvocationschecker`- [x] #547 `objectmethodsguru`- [x] #427 `reporter`- [x] #535 `supertypeslastsorter`- [x] #501 `testmethodfinder`- [x] #515 `verifiableinvocationsfinder`;"@raphw thanks for merging the pr that fast!  would you mind reopening this ticket? there are more classes that can be refactored that way i would like to extend the list || big :+1: for me btw but please keep the pull requests managable and as small as possible preferably refactoring 1 method at a time that way it is a lot easier to review || i agree there is nothing wrong with multiple prs the quick merge is a reaction to an easy overview (and being stuck at an ukrainian airport without access to the eurocup) || there are still two unit tests failing could you have a look @christianschwarz - i just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `reporter`i should have checked more thoroughly before merging hopefully you can fix the problem soon alternatively i will just rollback the one commit (the first one is good) and we can reapply the patch once you  the two unit tests thank you really this was great clean-up || i fixed the one test error i push it tonightps: i also fixed a bug in the stack trace cleaner not a biggy but please do not `@ignore` tests especially in big commits it is easy to miss that single annotation || @raphw which test(s) is/are failing? i will fix it asap! too bad that some test fail on a regulare base is it possible to ignore them in the ide only? || you can see the build output here:  advise you to run the tests with `/gradlew build` this should work || @timvdlippe know what you mean! the next prs include only one refactored class at a time || i have it all fixed on local but i did not have access to wifi without 22 blocked will commit soon || @raphw can you please reopen this issue  || sorry github automatically closes issues that reference a pr || @christianschwarz if a commit contains a comment like ""426"" the mentioned issue is automatically closed by github || @pascalschumacher good to know! i will leave it out for the upcoming prs  now that we are pulling in static methods i would like to propose a new (linter) rule to make it easier to read a file i would like that all methods invoked in the current class are referenced with `this` (and `super` for that matter) therefore if we see `thisverify` we know it is in the current class and the same object whereas `verify` references a static method in this class or an imported static method do you agree @mockito/developers ? || > i would like that all methods invoked in the current class are referenced with this (and super for that matter)to me it feels like unnecessary/duplicate code cause `this` is implicit adding `this` before every instance call would create a lot more text and would imho reduce readability eg:`thisdosometing(thiswithprivatemethod())` vs `dosomething(withprivatemethod())`> therefore if we see thisverify we know it is in the current class and the same object whereas verify references a static method in this class or an imported static methodan other option avoid ambiguity is to qualify static methods via its class name  this way you can also distinguish which verify() is called ( `mockitocoreverify()` / `mocktioverify()`)  which is not an easy task when a static import is used || im not coding too much in mockito atm (hopefully now after springone conference ill have more time) but i fully agree with @christianschwarz  imo the best solution is to: - omit `this` before method calls - if necessary provide the class for static method call || respectful -1i like when the class formally declares collaborators instead of calling out to static methods this makes it easy to reason about the code i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etc another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too proceduralthe benefits for converting to static utilities have minimal significance to me yet there is a downside i care about (eg maintainability of procedural code static methods that consume static methods that consume static methods)hence i down vote this sort of changes going down this path all stateless classes in mockito would become static utilities :)you can get +1s from other maintainers and have your changes merged - im not here to block your changes but to give honest feedback i see merit in arguments for static utilities they do not outweigh the cost in my opinion || im mitigated about this as well i understand well that mockito creates garbage but they are short lived and **most probably** wont go in the old generation especially in the test phase yet the faster the tests are the more developers will run them it **may** have impacts on big projects also design wise i dont like much static methods toohowever i dont totally agree with the above points : > i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etccoupling appears also in the import section  static methods are visible there and modern ide usually highlight this intellij even have a warning if import section is too big just as theres warning if theres too many fields this point should not be the reason to avoid static methods> maintainability of procedural code static methods that consume static methods that consume static methodshaving instance methods does not protect again procedural code---i believe theres middle ground there : - mockito project contains a lot of small utility stateless objects that are supporting mockito features these are usually collections tools reflection tools those could are good candidate for static methods objects like `fieldsetter` `fieldcopier` `lenientcopytool` could be nice candidate for static methods- mockito features could be backed by object instances objects like `mockitocore` `mockcreationvalidator` `argumentmatchingtool` are candidate to stay objects || exactly the middle ground described by brice is my motivation for merging most of the prs this is also the reason i have not yet merged the mockitocore pr for this exact reasonif an object is not a attribute or parameter but an internal creation and immediately dismissed i value a pure function more || thought: when we switch to java 8 we can use interfaces with defaultmethods the switch from static utility to interface is very easy now (justa couple of text replaces no method reference modifications)on fri 12 aug 2016 17:23 brice dutheil notifications@githubcom wrote:> im mitigated about this as well i understand well that mockito creates> garbage but they are short lived and _most probably_ wont go in the old> generation especially in the test phase yet the faster the tests are the> more developers will run them it _may_ have impacts on big projects> also design wise i dont like much static methods too> > however i dont totally agree with the above points :> > i dont need to read every line of code in the class to find out external> couplings realized via static methods i can see the couplings via fields> i can easily query how the field variable is used etc> > coupling appears also in the import section  static methods are visible> there and modern ide usually highlight this intellij even have a warning> if import section is too big just as theres warning if theres too many> fields this point should not be the reason to avoid static methods> > maintainability of procedural code static methods that consume static> methods that consume static methods> > ## having instance methods does not protect again procedural code> > i believe theres middle ground there :> >    -> >    mockito project contains a lot of small utility stateless objects that>    are supporting mockito features these are usually collections tools>    reflection tools those could are good candidate for static methods>    objects like fieldsetter fieldcopier lenientcopytool could be nice>    candidate for static methods>    -> >    mockito features could be backed by object instances objects like>    mockitocore mockcreationvalidator argumentmatchingtool are candidate>    to stay objects> > —> you are receiving this because you modified the open/close state> reply to this email directly view it on github>  or mute the thread>   || this feels like a misuse of the default methods || i think you mean static-methods in interfaces here? default-methods require an instance to be called onanyway i dont think that it is a good idea  it would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods imho a class with private constructor is the best construct to do this || > > thought: when we switch to java 8 we can use interfaces with default> > methods> > default-methods require an instance to be called oni was thinking exactly that default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface) || @christianschwarz what do you think to continue the work here with the middle ground described [here]( ? || i am attempting to refactor the matcherbinder class to a static utility class and am having trouble refactoring the following from mockhandlerimpltestjava: `handlermatchersbinder  new matchersbinder() {            public invocationmatcher bindmatchers(argumentmatcherstorage argumentmatcherstorage invocation invocation) {                throw new invaliduseofmatchersexception()            }} `how can i maintain the abstract class definition when i am not able to create an object of matcherbinder?any help is appreciated!  || lets close this ticket refactorings can be done as needed as we work with the code || ";1;0;refactored testmethodsfinder to a static utility class (#426);
502;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;unused code;removes unused code. rationales are given for each removal in commit message.;;0;intsreverse(int) etc; a method for reversing the values of an array of primitive would be welcomeuse case is the same as with collectionsreverse or iterablesreverse; since {listscollections}reverse(intsaslist()) are functional equivalents covering both the view and the edit-in-place use cases and since when one needs higher performance its not hard to hand-code the ""algorithm"" this really rests on our discovering that this is a very common thing to want to do  so far from perusing internal code i see virtually no evidence that this is the case--- ;;;;0;1;;
502;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;unused code;removes unused code. rationales are given for each removal in commit message.;;0;flush buffered console results during slow queries;;nice! ||;;;;1;1;flush buffered console results during slow queries;
502;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;unused code;removes unused code. rationales are given for each removal in commit message.;;0;fix observeon and add parallelmerge scheduler overload;- observeon was not correctly recursing when the source was async it would create a new scheduler (ie a new thread) each time- also added unit tests to parallelmerge;this is debugged and pair programmed with @headinthebox  || #426 ;;;;1;1;fix observeon and add parallelmerge scheduler overload- observeon was not correctly recursing when the source was async it would create a new scheduler (ie a new thread) each time- also added unit tests to parallelmerge;
502;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;unused code;removes unused code. rationales are given for each removal in commit message.;;426.0;refactored argumentscomparator to a static utility class (#426);; ;refactor instance based utility classes to static utility classes;the internal implementation of mockito contains numerous helper classed that serve as a container for useful methods by its nature these classes dont have a state currently some them are instance based in other word you need to create the utility class to call a helper method this not only pollutes the heap but also the code cause instance methods cant be imported statically here is an example:```javahelper helper  new helper()if (helperisinputvalid(input)){   }```vs static import of helperisinputvalid```javaif (isinputvalid(input)){   }```the aim of this ticket is to identify canidates that can be refactored to static utility classes if you like to refactoring and mockito feel free to send a pr and reference this issuerefactoring canidates:-  `accessibilitychanger`-  `beanpropertysetter`-  `conditionalstacktracefilter`-  `fieldcopier`-  `fieldreader`-  `genericmaster` should be integrate into `generictyperesolver`-  `junitfailurehacker` can be removed when the deprecated `verbosemockitojunitrunner` is removed-  `lenientcopytool`-  `matcherbinder`-  `mockitocore` should better be a singleton-  `mockcreationvalidator`- [ ] `removefirstline`-  #591 `argumentmatchingtool`-  #515 `allinvocationsfinder`-  #502 `argumentscomparator`-  #540 `arrayutils`-  #490 `atleastxnumberofinvocationschecker`-  #490 `atleastxnumberofinvocationsinorderchecker`- [ ] #912 `constructors`-  #427 `fieldsetter`-  #908 `friendlyexceptionmaker`-  #431 `handyreturnvalues` - [x] #432 `invocationmarker`- [x] #462 `invocationsfinder`- [x] #908 `junitdetecter`- [x] #490 `missinginvocationchecker`- [x] #490 `missinginvocationinorderchecker`- [x] #514 `mockutil`- [x] #503 `nongreedynumberofinvocationsinorderchecker`- [x] #907 `numberofinvocationsinorderchecker`- [x] #907 `numberofinvocationschecker`- [x] #547 `objectmethodsguru`- [x] #427 `reporter`- [x] #535 `supertypeslastsorter`- [x] #501 `testmethodfinder`- [x] #515 `verifiableinvocationsfinder`;"@raphw thanks for merging the pr that fast!  would you mind reopening this ticket? there are more classes that can be refactored that way i would like to extend the list || big :+1: for me btw but please keep the pull requests managable and as small as possible preferably refactoring 1 method at a time that way it is a lot easier to review || i agree there is nothing wrong with multiple prs the quick merge is a reaction to an easy overview (and being stuck at an ukrainian airport without access to the eurocup) || there are still two unit tests failing could you have a look @christianschwarz - i just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `reporter`i should have checked more thoroughly before merging hopefully you can fix the problem soon alternatively i will just rollback the one commit (the first one is good) and we can reapply the patch once you  the two unit tests thank you really this was great clean-up || i fixed the one test error i push it tonightps: i also fixed a bug in the stack trace cleaner not a biggy but please do not `@ignore` tests especially in big commits it is easy to miss that single annotation || @raphw which test(s) is/are failing? i will fix it asap! too bad that some test fail on a regulare base is it possible to ignore them in the ide only? || you can see the build output here:  advise you to run the tests with `/gradlew build` this should work || @timvdlippe know what you mean! the next prs include only one refactored class at a time || i have it all fixed on local but i did not have access to wifi without 22 blocked will commit soon || @raphw can you please reopen this issue  || sorry github automatically closes issues that reference a pr || @christianschwarz if a commit contains a comment like ""426"" the mentioned issue is automatically closed by github || @pascalschumacher good to know! i will leave it out for the upcoming prs  now that we are pulling in static methods i would like to propose a new (linter) rule to make it easier to read a file i would like that all methods invoked in the current class are referenced with `this` (and `super` for that matter) therefore if we see `thisverify` we know it is in the current class and the same object whereas `verify` references a static method in this class or an imported static method do you agree @mockito/developers ? || > i would like that all methods invoked in the current class are referenced with this (and super for that matter)to me it feels like unnecessary/duplicate code cause `this` is implicit adding `this` before every instance call would create a lot more text and would imho reduce readability eg:`thisdosometing(thiswithprivatemethod())` vs `dosomething(withprivatemethod())`> therefore if we see thisverify we know it is in the current class and the same object whereas verify references a static method in this class or an imported static methodan other option avoid ambiguity is to qualify static methods via its class name  this way you can also distinguish which verify() is called ( `mockitocoreverify()` / `mocktioverify()`)  which is not an easy task when a static import is used || im not coding too much in mockito atm (hopefully now after springone conference ill have more time) but i fully agree with @christianschwarz  imo the best solution is to: - omit `this` before method calls - if necessary provide the class for static method call || respectful -1i like when the class formally declares collaborators instead of calling out to static methods this makes it easy to reason about the code i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etc another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too proceduralthe benefits for converting to static utilities have minimal significance to me yet there is a downside i care about (eg maintainability of procedural code static methods that consume static methods that consume static methods)hence i down vote this sort of changes going down this path all stateless classes in mockito would become static utilities :)you can get +1s from other maintainers and have your changes merged - im not here to block your changes but to give honest feedback i see merit in arguments for static utilities they do not outweigh the cost in my opinion || im mitigated about this as well i understand well that mockito creates garbage but they are short lived and **most probably** wont go in the old generation especially in the test phase yet the faster the tests are the more developers will run them it **may** have impacts on big projects also design wise i dont like much static methods toohowever i dont totally agree with the above points : > i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etccoupling appears also in the import section  static methods are visible there and modern ide usually highlight this intellij even have a warning if import section is too big just as theres warning if theres too many fields this point should not be the reason to avoid static methods> maintainability of procedural code static methods that consume static methods that consume static methodshaving instance methods does not protect again procedural code---i believe theres middle ground there : - mockito project contains a lot of small utility stateless objects that are supporting mockito features these are usually collections tools reflection tools those could are good candidate for static methods objects like `fieldsetter` `fieldcopier` `lenientcopytool` could be nice candidate for static methods- mockito features could be backed by object instances objects like `mockitocore` `mockcreationvalidator` `argumentmatchingtool` are candidate to stay objects || exactly the middle ground described by brice is my motivation for merging most of the prs this is also the reason i have not yet merged the mockitocore pr for this exact reasonif an object is not a attribute or parameter but an internal creation and immediately dismissed i value a pure function more || thought: when we switch to java 8 we can use interfaces with defaultmethods the switch from static utility to interface is very easy now (justa couple of text replaces no method reference modifications)on fri 12 aug 2016 17:23 brice dutheil notifications@githubcom wrote:> im mitigated about this as well i understand well that mockito creates> garbage but they are short lived and _most probably_ wont go in the old> generation especially in the test phase yet the faster the tests are the> more developers will run them it _may_ have impacts on big projects> also design wise i dont like much static methods too> > however i dont totally agree with the above points :> > i dont need to read every line of code in the class to find out external> couplings realized via static methods i can see the couplings via fields> i can easily query how the field variable is used etc> > coupling appears also in the import section  static methods are visible> there and modern ide usually highlight this intellij even have a warning> if import section is too big just as theres warning if theres too many> fields this point should not be the reason to avoid static methods> > maintainability of procedural code static methods that consume static> methods that consume static methods> > ## having instance methods does not protect again procedural code> > i believe theres middle ground there :> >    -> >    mockito project contains a lot of small utility stateless objects that>    are supporting mockito features these are usually collections tools>    reflection tools those could are good candidate for static methods>    objects like fieldsetter fieldcopier lenientcopytool could be nice>    candidate for static methods>    -> >    mockito features could be backed by object instances objects like>    mockitocore mockcreationvalidator argumentmatchingtool are candidate>    to stay objects> > —> you are receiving this because you modified the open/close state> reply to this email directly view it on github>  or mute the thread>   || this feels like a misuse of the default methods || i think you mean static-methods in interfaces here? default-methods require an instance to be called onanyway i dont think that it is a good idea  it would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods imho a class with private constructor is the best construct to do this || > > thought: when we switch to java 8 we can use interfaces with default> > methods> > default-methods require an instance to be called oni was thinking exactly that default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface) || @christianschwarz what do you think to continue the work here with the middle ground described [here]( ? || i am attempting to refactor the matcherbinder class to a static utility class and am having trouble refactoring the following from mockhandlerimpltestjava: `handlermatchersbinder  new matchersbinder() {            public invocationmatcher bindmatchers(argumentmatcherstorage argumentmatcherstorage invocation invocation) {                throw new invaliduseofmatchersexception()            }} `how can i maintain the abstract class definition when i am not able to create an object of matcherbinder?any help is appreciated!  || lets close this ticket refactorings can be done as needed as we work with the code || ";1;0;refactored argumentscomparator to a static utility class (#426);
503;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored nongreedynumberofinvocationsinorderchecker to a static uti…;…lity class (#426);;0;stringslenientsubstring(); please add a stringssubstring() method similar to int int); proposed issue 1124 to support just the negative indexes from the end of a string without the leniency || ";;;;0;1;;
503;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored nongreedynumberofinvocationsinorderchecker to a static uti…;…lity class (#426);;0;add support for if expressions;;;;;;0;1;;
503;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored nongreedynumberofinvocationsinorderchecker to a static uti…;…lity class (#426);;0;new scala bindings;"# alternative rx bindings for scalathe previous rxscala binding attempt to optimize for seamless interop between scala and javathe intended interop is illustrated by the following example where in scala a class is defined that takesan `observable[movie]` that is transformed using rxscala operators:``` scalaclass movielib(val moviesstream: observable[movie]) {   val threshold  1200   def shortmovies: observable[movie]  ???   def longmovies: observable[movie]  ???}```which is then called in java passing a java `observable<movie>` to the constructor``` javapublic void test() {   movielib lib  new movielib(observablefrom())   liblongmovies()subscribe(movieprinter)}```the technique used to obtain this transparency is to use a value class with a private constructor that implementsthe rx operators in an idiomatic scala way and a companion object that is used to construct instances in scala``` scalaobject observable {   def apply[t](asjava: rxobservable[_ <: t]): observable[t]  { new observable[t](asjava) }}class observable[+t] private[scala] (val asjava: rxobservable[_ <: t])  extends anyval {   // idiomatic scala friendly definitions of rx operators}```since `rxlangscalaobservable[t] extends anyval` the underlying representation of `rxlangscalaobservable[t]`is the same as `rxobservable<t>` because `rxlangscalaobservable[t]` is an opaque type in scalathe scala programmer only sees the scala-friendly operatorshowever in the current the illusion of interop is quickly lost when going beyond this simple examplefor example but type `notification[t]` and `scheduler[t]` are defined using wrappersand hence they are not compatible with `notification<t>` respectively `scheduler<t>`for instance when materializing an `observable[t]` in scala to an `observable[notification[t]]`we lost the seamless interop with `observable<notification<t>>` on the java sidehowever the real problems with seamless interop show up when we try to creating bindings for other rx typesin particular types that have inheritance or more structurefor example rxscala currently defines a type synonym `type observer[-t]  rxobserver[_ >: t]`but no further bindings for observerssimilarly for subjects rxscala defines `type subject[-t +r]  rxsubjectssubject[_ >: t _ <: r]`the problem with these definitions is that on the java side subjects are defined as:``` scalapublic abstract class subject<t r> extends observable<r> implements observer<t> { …}```without binding any of the rx subjectsthe consequence is that `subject[st]` in scala is unrelated to `rxlangscalaobservable[t]` in scalabut shows up as a `rxobservable[t]` the problem however is that if we want to expose subjects in scalasuch that they derive from both `observable[s]` and `observer[t]` we cannot use the `extend anyval` trickwe used for `observable[t]` and immediately lose transparent interop with javathe problem is even worse because `asyncsubject<t>` `behaviorsubject<t>` … all derive from `subject<tt>`so if we want them to derive from a common base `subject[tt]` type in scala we lose transparency for those as welland again if we expose the various subjects by extending `anyval` they are useless in scala because they do not inheritfrom a common base type to avoid implementing all methods of observable and observer on each specific subjectwe might add implicit conversions to `observable[t]` and `observer[t]` but that still does not give scala usersa native `subject[st]` type``` scalaobject asyncsubject {    def apply[t](): asyncsubject[t]       new asyncsubject[t](rxsubjectsasyncsubjectcreate())}class asyncsubject[t] private [scala] (val inner: rxsubjectsasyncsubject[t])    extends anyval{ … }implicit final def asobservable[t](subject: asyncsubject[t]): observable[t]   observable(subjectinner)implicit final def asobserver[t](subject: asyncsubject[t]): observer[t]   subjectinner```the inheritance problem is not just limited to subjects but also surfaces for subscriptionsrx scala currently defines `type subscription  rxsubscription` using a type synonym as welland we run into exactly the same problems as with subjects when we try to bind thevarious rx subscriptions `booleansubscription` `serialsubscription`  etcsince we cannot wrap rx types in scala such that they are both (a) transparently interoperable with javaand (b) feel native and idiomatic to scala we should decide in favor of optimizing rxscala for scalaand consumption of rx values from java but not for scala as a producerthe new bindings feel like a completely native scala library without needing any complications of the scala side``` scalaobject observer { …}trait observable[+t] {   def asjavaobservable: rxobservable[_ <: t]}object observer {…}trait observer[-t] {  def asjavaobserver: rxobserver[_ >: t]}object subject {…}trait subject[-t +r] extends observable[r] with observer[t] {  val asjavasubject: rxsubjectssubject[_ >: t _<: r]}object scheduler {…}trait scheduler {   def asjavascheduler: rxscheduler}object notification {…}trait notification[+t] {  def asjavanotification: rxnotification[_ <: t]}object subscription {…}trait subscription {   def asjavasubscription: rxsubscription}```you pay the price when crossing the scala/java interop boundary which is where it should bethe proper way is to put the burden of interop on the scala side in case you want to createa reusable rx-based library in scala or wrap and unwrap on the java side``` javapublic static void main(string args) {   observable<movie> movies  observablefrom(new movie(3000) new movie(1000) new movie(2000))   movielib lib  new movielib(toscalaobservable(movies))   liblongmovies()asjavaobservable()subscribe(m ->      systemoutprintln(""a movie of length "" + mlengthinseconds() + ""s"")   )}```## delegation versus inheritancethe obvious thought is that using delegation instead of inheritance ( lead to excessive wrapping since all scala types wrap and delegate to an underlying rxjava implementationnote however that the wrapping happens at query generation time and incurs no overhead when messages are flowingthrough the pipeline say we have a query `xsmap(f)filter(p)subscribe(o)` even though the scala types are wrappersthe callback that is registered with xs is something like `x > { val y  f(x) if(p(y)){ oasjavaobserveronnext(y) }}`and hence there is no additional runtime penalty";#427 ;;;;1;1;updated readme;
503;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored nongreedynumberofinvocationsinorderchecker to a static uti…;…lity class (#426);;426.0;refactored nongreedynumberofinvocationsinorderchecker to a static uti…;…lity class (#426); ;refactor instance based utility classes to static utility classes;the internal implementation of mockito contains numerous helper classed that serve as a container for useful methods by its nature these classes dont have a state currently some them are instance based in other word you need to create the utility class to call a helper method this not only pollutes the heap but also the code cause instance methods cant be imported statically here is an example:```javahelper helper  new helper()if (helperisinputvalid(input)){   }```vs static import of helperisinputvalid```javaif (isinputvalid(input)){   }```the aim of this ticket is to identify canidates that can be refactored to static utility classes if you like to refactoring and mockito feel free to send a pr and reference this issuerefactoring canidates:-  `accessibilitychanger`-  `beanpropertysetter`-  `conditionalstacktracefilter`-  `fieldcopier`-  `fieldreader`-  `genericmaster` should be integrate into `generictyperesolver`-  `junitfailurehacker` can be removed when the deprecated `verbosemockitojunitrunner` is removed-  `lenientcopytool`-  `matcherbinder`-  `mockitocore` should better be a singleton-  `mockcreationvalidator`- [ ] `removefirstline`-  #591 `argumentmatchingtool`-  #515 `allinvocationsfinder`-  #502 `argumentscomparator`-  #540 `arrayutils`-  #490 `atleastxnumberofinvocationschecker`-  #490 `atleastxnumberofinvocationsinorderchecker`- [ ] #912 `constructors`-  #427 `fieldsetter`-  #908 `friendlyexceptionmaker`-  #431 `handyreturnvalues` - [x] #432 `invocationmarker`- [x] #462 `invocationsfinder`- [x] #908 `junitdetecter`- [x] #490 `missinginvocationchecker`- [x] #490 `missinginvocationinorderchecker`- [x] #514 `mockutil`- [x] #503 `nongreedynumberofinvocationsinorderchecker`- [x] #907 `numberofinvocationsinorderchecker`- [x] #907 `numberofinvocationschecker`- [x] #547 `objectmethodsguru`- [x] #427 `reporter`- [x] #535 `supertypeslastsorter`- [x] #501 `testmethodfinder`- [x] #515 `verifiableinvocationsfinder`;"@raphw thanks for merging the pr that fast!  would you mind reopening this ticket? there are more classes that can be refactored that way i would like to extend the list || big :+1: for me btw but please keep the pull requests managable and as small as possible preferably refactoring 1 method at a time that way it is a lot easier to review || i agree there is nothing wrong with multiple prs the quick merge is a reaction to an easy overview (and being stuck at an ukrainian airport without access to the eurocup) || there are still two unit tests failing could you have a look @christianschwarz - i just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `reporter`i should have checked more thoroughly before merging hopefully you can fix the problem soon alternatively i will just rollback the one commit (the first one is good) and we can reapply the patch once you  the two unit tests thank you really this was great clean-up || i fixed the one test error i push it tonightps: i also fixed a bug in the stack trace cleaner not a biggy but please do not `@ignore` tests especially in big commits it is easy to miss that single annotation || @raphw which test(s) is/are failing? i will fix it asap! too bad that some test fail on a regulare base is it possible to ignore them in the ide only? || you can see the build output here:  advise you to run the tests with `/gradlew build` this should work || @timvdlippe know what you mean! the next prs include only one refactored class at a time || i have it all fixed on local but i did not have access to wifi without 22 blocked will commit soon || @raphw can you please reopen this issue  || sorry github automatically closes issues that reference a pr || @christianschwarz if a commit contains a comment like ""426"" the mentioned issue is automatically closed by github || @pascalschumacher good to know! i will leave it out for the upcoming prs  now that we are pulling in static methods i would like to propose a new (linter) rule to make it easier to read a file i would like that all methods invoked in the current class are referenced with `this` (and `super` for that matter) therefore if we see `thisverify` we know it is in the current class and the same object whereas `verify` references a static method in this class or an imported static method do you agree @mockito/developers ? || > i would like that all methods invoked in the current class are referenced with this (and super for that matter)to me it feels like unnecessary/duplicate code cause `this` is implicit adding `this` before every instance call would create a lot more text and would imho reduce readability eg:`thisdosometing(thiswithprivatemethod())` vs `dosomething(withprivatemethod())`> therefore if we see thisverify we know it is in the current class and the same object whereas verify references a static method in this class or an imported static methodan other option avoid ambiguity is to qualify static methods via its class name  this way you can also distinguish which verify() is called ( `mockitocoreverify()` / `mocktioverify()`)  which is not an easy task when a static import is used || im not coding too much in mockito atm (hopefully now after springone conference ill have more time) but i fully agree with @christianschwarz  imo the best solution is to: - omit `this` before method calls - if necessary provide the class for static method call || respectful -1i like when the class formally declares collaborators instead of calling out to static methods this makes it easy to reason about the code i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etc another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too proceduralthe benefits for converting to static utilities have minimal significance to me yet there is a downside i care about (eg maintainability of procedural code static methods that consume static methods that consume static methods)hence i down vote this sort of changes going down this path all stateless classes in mockito would become static utilities :)you can get +1s from other maintainers and have your changes merged - im not here to block your changes but to give honest feedback i see merit in arguments for static utilities they do not outweigh the cost in my opinion || im mitigated about this as well i understand well that mockito creates garbage but they are short lived and **most probably** wont go in the old generation especially in the test phase yet the faster the tests are the more developers will run them it **may** have impacts on big projects also design wise i dont like much static methods toohowever i dont totally agree with the above points : > i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etccoupling appears also in the import section  static methods are visible there and modern ide usually highlight this intellij even have a warning if import section is too big just as theres warning if theres too many fields this point should not be the reason to avoid static methods> maintainability of procedural code static methods that consume static methods that consume static methodshaving instance methods does not protect again procedural code---i believe theres middle ground there : - mockito project contains a lot of small utility stateless objects that are supporting mockito features these are usually collections tools reflection tools those could are good candidate for static methods objects like `fieldsetter` `fieldcopier` `lenientcopytool` could be nice candidate for static methods- mockito features could be backed by object instances objects like `mockitocore` `mockcreationvalidator` `argumentmatchingtool` are candidate to stay objects || exactly the middle ground described by brice is my motivation for merging most of the prs this is also the reason i have not yet merged the mockitocore pr for this exact reasonif an object is not a attribute or parameter but an internal creation and immediately dismissed i value a pure function more || thought: when we switch to java 8 we can use interfaces with defaultmethods the switch from static utility to interface is very easy now (justa couple of text replaces no method reference modifications)on fri 12 aug 2016 17:23 brice dutheil notifications@githubcom wrote:> im mitigated about this as well i understand well that mockito creates> garbage but they are short lived and _most probably_ wont go in the old> generation especially in the test phase yet the faster the tests are the> more developers will run them it _may_ have impacts on big projects> also design wise i dont like much static methods too> > however i dont totally agree with the above points :> > i dont need to read every line of code in the class to find out external> couplings realized via static methods i can see the couplings via fields> i can easily query how the field variable is used etc> > coupling appears also in the import section  static methods are visible> there and modern ide usually highlight this intellij even have a warning> if import section is too big just as theres warning if theres too many> fields this point should not be the reason to avoid static methods> > maintainability of procedural code static methods that consume static> methods that consume static methods> > ## having instance methods does not protect again procedural code> > i believe theres middle ground there :> >    -> >    mockito project contains a lot of small utility stateless objects that>    are supporting mockito features these are usually collections tools>    reflection tools those could are good candidate for static methods>    objects like fieldsetter fieldcopier lenientcopytool could be nice>    candidate for static methods>    -> >    mockito features could be backed by object instances objects like>    mockitocore mockcreationvalidator argumentmatchingtool are candidate>    to stay objects> > —> you are receiving this because you modified the open/close state> reply to this email directly view it on github>  or mute the thread>   || this feels like a misuse of the default methods || i think you mean static-methods in interfaces here? default-methods require an instance to be called onanyway i dont think that it is a good idea  it would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods imho a class with private constructor is the best construct to do this || > > thought: when we switch to java 8 we can use interfaces with default> > methods> > default-methods require an instance to be called oni was thinking exactly that default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface) || @christianschwarz what do you think to continue the work here with the middle ground described [here]( ? || i am attempting to refactor the matcherbinder class to a static utility class and am having trouble refactoring the following from mockhandlerimpltestjava: `handlermatchersbinder  new matchersbinder() {            public invocationmatcher bindmatchers(argumentmatcherstorage argumentmatcherstorage invocation invocation) {                throw new invaliduseofmatchersexception()            }} `how can i maintain the abstract class definition when i am not able to create an object of matcherbinder?any help is appreciated!  || lets close this ticket refactorings can be done as needed as we work with the code || ";1;0;refactored nongreedynumberofinvocationsinorderchecker to a static utility class (#426);
504;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;biblioscapeimportertest;;;0;a sorted computingmap; id like to be able to construct a computingmap with sorted keys alternatively id like to be able to combine the functionality of two different map types for example id like be able to construct a sortedmap ""view"" on top of a computingmap or vice versasee  for a related discussion"; im afraid that a sorted version of our computing map would be a _very_ large effort and require extreme duplication of code from mapmaker and i dont expect this would ever be a priority  i agree with ben maness advice on so--- ;;;;0;1;;
504;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;biblioscapeimportertest;;;0; some rawtype warnings;; ;;;;1;1; some rawtype warnings;
504;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;biblioscapeimportertest;;;0;fix task error detection thresholds to work properly;;;;;;1;1;;
504;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;biblioscapeimportertest;;;0;operator: tomap (todictionary) and tomultimap (tolookup);operators tomap and tomultimapive tried my best to describe them in the javadoc;#428  the code and unit tests look good we just need to figure out what to do about the overloads that have the same erased signatures we use groovy for asserting the various overloads work for dynamic languages by putting unit tests here (not as comprehensive as id like):  || im not familiar with groovy but in the future ill watch the overloads from this perspective || thank you @akarnokd you can use groovy more or less as if it is java 8  write everything as statically typed java except that when you are going to use an anonymous inner class you pass a lambda with slightly different syntax than java 8 lambdas || ill look into the groovy part create a new branch/pull ||;;;;0;1;;
507;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;gui testing;adds the ability to do gui tests automatically.   with just 80 lines of testing code  i was able to raise the code coverage by 15%. and i detected two nullpointerexceptions (still to be fixed) plus three places where swing classes were interacted with outside of the edt.   this change allows to model bug reports as test cases on a gui level.   what has been done -  tests fail when an uncaught exception occurs on the edt -  raise test coverageby 15% -  gui tests run on circleci -  fix language to english for all (gui) tests -  somehow only run the tests on circleci? -  maybe use headless mode @matthiasgeiger - not possible with the used api -  make it work with gradle sync in intellij so that one can edit the tests and run them from within the ide -  make tests work on travis-ci -  enable tests on circle-ci as well;;0;exception from hostspecificfrom(string) leaves out useful information; when throwing an exception in a catch block please always set the initcause() to the original exceptionfor example in hostspecifier notice how the comment in the catch block notes that ""the iae can originate at several different points inside fromvalid()"" and this code makes damn certain that the exact location will continue to be mysterious! why the secrecy? debugging production server exceptions are hard enough please show _all_ available information! there is no reason why the new parseexception can not have its initcause set to the iae!line 122 (r07):&nbsp&nbsppublic static hostspecifier from(string specifier)&nbsp&nbsp&nbsp&nbsp&nbsp&nbspthrows parseexception {&nbsp&nbsp&nbsp&nbsptry {&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn fromvalid(specifier)&nbsp&nbsp&nbsp&nbsp} catch (illegalargumentexception e) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp// since the iae can originate at several different points inside&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp// fromvalid() we implement this method in terms of that one rather&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp// than the reverse```  throw new parseexception(""invalid host specifier: "" + specifier 0)}```&nbsp&nbsp}"; ;;;;0;1;;
507;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;gui testing;adds the ability to do gui tests automatically.   with just 80 lines of testing code  i was able to raise the code coverage by 15%. and i detected two nullpointerexceptions (still to be fixed) plus three places where swing classes were interacted with outside of the edt.   this change allows to model bug reports as test cases on a gui level.   what has been done -  tests fail when an uncaught exception occurs on the edt -  raise test coverageby 15% -  gui tests run on circleci -  fix language to english for all (gui) tests -  somehow only run the tests on circleci? -  maybe use headless mode @matthiasgeiger - not possible with the used api -  make it work with gradle sync in intellij so that one can edit the tests and run them from within the ide -  make tests work on travis-ci -  enable tests on circle-ci as well;;0;make extract field keywords non-reserved;;;;;;1;1;make extract field keywords non-reserved;
507;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;gui testing;adds the ability to do gui tests automatically.   with just 80 lines of testing code  i was able to raise the code coverage by 15%. and i detected two nullpointerexceptions (still to be fixed) plus three places where swing classes were interacted with outside of the edt.   this change allows to model bug reports as test cases on a gui level.   what has been done -  tests fail when an uncaught exception occurs on the edt -  raise test coverageby 15% -  gui tests run on circleci -  fix language to english for all (gui) tests -  somehow only run the tests on circleci? -  maybe use headless mode @matthiasgeiger - not possible with the used api -  make it work with gradle sync in intellij so that one can edit the tests and run them from within the ide -  make tests work on travis-ci -  enable tests on circle-ci as well;;0;operation join;issue #56;#431  this needs to be rebased before it can merge (probably because of your other pr i just merged) can you please update or resubmit? || will do shortly ||;;;;0;1;;
507;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;gui testing;adds the ability to do gui tests automatically.   with just 80 lines of testing code  i was able to raise the code coverage by 15%. and i detected two nullpointerexceptions (still to be fixed) plus three places where swing classes were interacted with outside of the edt.   this change allows to model bug reports as test cases on a gui level.   what has been done -  tests fail when an uncaught exception occurs on the edt -  raise test coverageby 15% -  gui tests run on circleci -  fix language to english for all (gui) tests -  somehow only run the tests on circleci? -  maybe use headless mode @matthiasgeiger - not possible with the used api -  make it work with gradle sync in intellij so that one can edit the tests and run them from within the ide -  make tests work on travis-ci -  enable tests on circle-ci as well;;506.0;improved exception message - fixes issue 506;506; ;improved exception message for wanted but not invoked;currently mockito prints following message when specific verification fails:```wanted but not invoked:mocksimplemethod()-> at however there were other interactions with this mock:mockothermethod()-> at mockbooleanreturningmethod()-> at ```it would be useful to print the number of invocations:```wanted but not invoked:mocksimplemethod()-> at however there were exactly 2 interactions with this mock:mockothermethod()-> at mockbooleanreturningmethod()-> at ```;;1;0;improved exception message506;
510;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;silverplatterimportertest;;;0;nullpointertester fails on @nullable parameter without default value;goo@ for this test i used the current svn trunk (revision 144)the attached test class reveals a potential problem with the nullpointertester class: for a parameter that is @﻿nullable but has no configured default value in the nullpointertester (eg a user defined class) the tester fails instead of just setting the parameter nulli expect the nullpointertester to use null for @﻿nullable parameters without a configured default value and pass the attached test case instead i get an exceptionjavalangruntimeexception: no default value found for comgooglecommontestingnullpointertestertest$nodefaultvalue&nbsp&nbsp&nbsp&nbspat comgooglecommontestingassertfail(assertjava:43)&nbsp&nbsp&nbsp&nbspat comgooglecommontestingassertasserttrue(assertjava:64)&nbsp&nbsp&nbsp&nbspat comgooglecommontestingnullpointertesterbuildparamlist(nullpointertesterjava:284)&nbsp&nbsp&nbsp&nbspat comgooglecommontestingnullpointertestertestfunctorparameter(nullpointertesterjava:249)&nbsp&nbsp&nbsp&nbspat comgooglecommontestingnullpointertestertestmethodparameter(nullpointertesterjava:194)&nbsp&nbsp&nbsp&nbspat comgooglecommontestingnullpointertestertestmethod(nullpointertesterjava:166)&nbsp&nbsp&nbsp&nbspat comgooglecommontestingnullpointertestertestallpublicstaticmethods(nullpointertesterjava:137)&nbsp&nbsp&nbsp&nbspat comgooglecommontestingnullpointertestertesttestbuildparameterlist(nullpointertestertestjava:13)im pretty sure the line nullpointertesterjava:283if (!parameterisprimitiveornullable(func indexofparamtosettonull)) {should readif (!parameterisprimitiveornullable(func i)) {; test added:  for the bug the delay in fixing it the lack of notification and the failure to add a test  ugh ||;;;;0;1;;
510;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;silverplatterimportertest;;;0;fix parsing of identifiers that start with a digit;;;;;;1;1;fix parsing of identifiers that start with a digit;
510;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;silverplatterimportertest;;;0;bugfix: zip;this is a manual merge of  where i added some unit tests and suppressed warnings while reviewing the refactor done by @akarnokdi believe this fixes issue https://githubcom/netflix/rxjava/issues/387;;;;;1;1;unit tests and suppresswarningsadded tests while validating pull requestthis fixes issue https://githubcom/netflix/rxjava/issues/387;
510;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;silverplatterimportertest;;;194.0;194 tweaks any matchers;details is #194 i took the opportunity to - replace `testbaseassertthat` by more powerful assertj equivalent theres still some work to be done in this class- add iterable matchersbefore merging-  i ponder to make `anyobject()` not to accept `null` currently `any()` is an alias of `anyobject()` > keeping the `anyobjet` behaviour and deprecate the method-  i need to update `anyint` family description;"  ";tweaks matchersany family matchers behavior;this issue is a follow up of the work started in #141 by @pimterry also heres an extract of a message on [this thread]( of the mailing list :---the origin of these methods is they come from `anything` ie anything matches later for shortness and cast avoidance the aliases grew but the api naming thus became inconsistent with what a human would expect so this behavior is being changed in mockito 2 beta to be precise heres the status on these api in the version 205-beta :- `any` `anyobject` `any(class)` wont check anything (at first they were just aliases for _anything_ and for cast avoidance) `null` is a valid value- `anyx` like `anystring` will check the arg is not `null` and that has the correct type- `anylist` will check the argument is not null and a `list` instance- `anylistof` (and the likes) at the moment are just aliases to their non generic counter part like `anylist`note this is work in progress (started here in 141]( these new behavior can / will change in the beta phase im especially wondering if the `any` family should allow `null` and if not do a type check for example with these matchers : - `any` `anyobject` stay the same they currently allow `null` and dont have to do type check anyway- `any(class)` currently allows `null` and doesnt do type check > allows `null` and if not checks for the given type- `any<collection>of` currently doesnt allow `null` and does a type check of the collection not elements > allows `null` if not checks collection type if not empty checks element typemaybe extend/create a _symmetric_  `isa` family api that wont allow any `null` arguments---;"`any` family is currently _(at his time up to 205-beta)_ inconsistent on the way they allow or not `null`s type checking is ok but `null` check behavior consistency is also important || anyx gramtaically tends to imply to return false for null because anyobject is not null i agree completely the api should be consistenton sun apr 5 2015 11:54 brice dutheil notifications@githubcom wrote:> any family is currently _(at his time up to 205-beta)_ inconsistent on> the way they allow or not nulls type checking is ok but null check> behavior consistency is also important> > ## > > reply to this email directly or view it on github>  || > anyx gramtaically tends to imply to return false for null because any object is not nullim not anymore of sure of that anyway the changes introduced in this api make it inconsistentthats why i propose any validates `null` and if not `null` then validates the typealso on the mentioned thread _francisco olarte_ was proposing a `anynotnull` family this could clarify the behavior on `null` of these apis || agreed any should return false for null and false for wrong type (instanceof) otherwise i think it would violate the principle of least surpriseon sun apr 5 2015 12:57 brice dutheil notifications@githubcom wrote:> anyx gramtaically tends to imply to return false for null because any> object is not null> > im not anymore of sure of that anyway the changes introduced in this api> make it inconsistent> thats why i propose any validates null and if not null then validates> the type> > also on the mentioned thread _francisco olarte_ was proposing a anynotnull> family this could clarify the behavior on null of these apis> > ## > > reply to this email directly or view it on github>  || i see anystring() ( and friends ) checking for null and anyobject() not doing it as an inconsistency potentially leading to user surprise object is as much of a class as string ( or other )other thing is i fail to see is the difference ( if there is any ) between isa(klazz) and notnull(klazz) ( or isnotnull but i see that one is a forwarder ) to me they seem they do the same given the docs but the code is different and im not familiar enough with it to assert they do the same thing when doing dsl helper libraries ive found ( the hard way ) having slightly different names for the same thing seems a good idea initially but leads to problem along the way so i would vote for just having one of notnull/isnotnull ( and isa if it is functionally equivalent ) || i think there might be confusion here: @szczepiq i dont think the two of you are agreeing @bric3 seems to be saying that `any` should match nulls and anynotnull should exist (and presumably not match null) while youre saying that `any` should not match nulli think the problem here is that theres two use cases that currently arent clearly separated both of which we need to support1 i dont care what the value im matching is _at all_ i want a very simple intuitive wildcard matcher that will match absolutely anything and will compile with no extra effort (so no casts)2 i care about the type of the value that im matching but no details beyond that i want a matcher that will not match values with the wrong typei think both of these are major common use cases if we make any of the `anyx()` methods reject nulls they no longer support the first case and if we leave it as-is then they currently appear to support the 2nd case but arent really doing so which is where all this came from originallyi do think any api that supports use case 2 should reject nulls by default: if youre asserting specifically on the type of the value we should push people to be clear about whether or not null is valid in the given case i think an api for use case 1 should not reject nulls because you want to match _everything_these are two quite different apis though and to get any kind of api consistency were going to need them to be separate sets of methods i suggest:- `any()` - matches absolutely anything including nulls as a generic method returning t (as now)- `anyasx()` and `anyas(xclass)` - matches absolutely anything including nulls as a generic method returning x  - this is as in 19 but with the names changed to make it clear that this is purely a type casting concern not type checking and intentionally being a bit more verbose to discourage unnecessary use  - note that as of java 8 target type inference considers method arguments so you should be able to use `any()` in every case except choosing between overloaded methods (pretty rare?) in addition note that java 7s final update is this month and then its unsupported  - wed also obviously document that users should prefer isa etc if they want to check the type but i think its much more obvious that `anyasstring()` isnt actually checking the values a string (unlike `anystring()` which did suggest that)- `isa/isan(xclass)` and `isanx()` - matches on type rejecting nulls- `isnulloran(xclass)` and `isnulloranx()` - matches on type accepting nullsi think this makes for a relatively small change so gives fairly easy migration but makes it clear that the `any()` methods are all just generic wildcards (for use case 1) and provides a clear set of other methods to support actual type checking and pushing users to be clear about nullability along the way (for use case 2)the only other option i can see we might want to do is stop supporting use case 1 entirely make everybody be much more specific about what they want and reject nulls everywhere i think use case one is likely to be the most common case for use argument matchers anywhere though far more than anything else and we definitely definitely need to support it as an intuitive easy first-class citizenthoughts? do people agree both use cases are common and important? does anybody have a better solution to help us get both while keeping a sensible consistent api? || on tue apr 7 2015 at 5:12 pm tim perry notifications@githubcom wrote:> these are two quite different apis though and to get any kind of api> consistency were going to need them to be separate sets of methods i> suggest:> - any() - matches absolutely anything including nulls as a generic>   method returning t (as now)> - anyasx() and anyas(xclass) - matches absolutely anything including>   nulls as a generic method returning x>   - this is as in 19 but with the names changed to make it clear>     that this is purely a type casting concern not type checking and>     intentionally being a bit more verbose to discourage unnecessary use>   - note that as of java 8 target type inference considers method>     arguments so you should be able to use any() in every case except>     choosing between overloaded methods (pretty rare?) in addition note that>     java 7s final update is this month and then its unsupported>   - wed also obviously document that users should prefer isa etc if>     they want to check the type but i think its much more obvious that>     anyasstring() isnt actually checking the values a string (unlike>     anystring() which did suggest that)>     - isa/isan(xclass) and isanx() - matches on type rejecting nulls> - isnullor(xclass) and isnullorx() - matches on type accepting nulls> > i think this makes for a relatively small change so gives fairly easy> migration but makes it clear that the any() methods are all just generic> wildcards (for use case 1) and provides a clear set of other methods to> support actual type checking and pushing users to be clear about> nullability along the way (for use case 2)> > the only other option i can see we might want to do is stop supporting use> case 1 entirely make everybody be much more specific about what they want> and reject nulls everywhere i think use case one is likely to be the most> common case for use argument matchers anywhere though far more than> anything else and we definitely definitely need to support it as an> intuitive easy first-class citizen> > thoughts? do people agree both use cases are common and important? does> anybody have a better solution to help us get both while keeping a sensible> consistent api?​i agree all are used and importantsim still struggling with the difference between `isnullor(xclass)` and `anyas(xclass)` the only difference i see is if i have a class `a` with a subclass `suba` and a class `b` with a subclass `subb` and a couple of methods `m(a)` and `m(b)` is that `m(anyas(subbclass))` will select `m(b)` and match on a `b` but `m(isnullor(subbclass)` will select it and match only on a `subb` so i could have a broader matcher for `m(isnullor(bclass))`even if this is the case i would just suppress the `anyas(xclass)` as my contrived example could be better written as `anyas(bclass)` in which case i would rename isnullor to any and isa to anynotnull in the naming side i find `any()` ​natural `anyas` forced as i consistently read `any(xclass)`as _any thing which can be assigned to a variable of type x_so i would end up with only two method names any and `anynotnull` with a parameterless plus a class parameter variant ( discounting typeing helpers like `anynotnullstring`) which would work:1 `anynotnull` in any variant does not accept nulls any does2 a parameterless `any()`/`anynotnull()` is equivalent to the same method with the declared parameter class note if you can use `any[notnull]()` in the methods there are no overloads and the language guarantees i cannot use an incorrect typeso if i have a method `m(list l)` `m(any(arraylistclass))` would match anything which can be stored in an `arraylist` var subclasses and `null` included and `anynotnull(arraylistclass)` will need a not null one `m(any())` would exactly as `m(any(listclass))` mockito cannot check it but i cannot write code to call `m` with a non-list argument java is type checked same goes for `anynotnull`otoh if i have `m(set s)` too i must use `m(any(setclass))` or `m(any(listclass))` just to resolve the overload although in this case the matcher type checking is superfluousi do not see the point on `any(xclass)` not checking the type and having `isa(xclass)` which does it seems confusing to me so my proposal is basically zapping any of the variants i mean from the description in the overloaded method `m(any(arraylistclass))` will select the list variant butmatch a call with any `list` subtype while `isnullor(arraylistclass)` will only match `arraylist`s ? i do not see this has any real use ( the parameter type must be accessible in the test if you want any list use `isnullor(listclass)`)maybe im missing something but i see `any(xclass)` redundant better served  isnullor` the rest is just naming disagreement​francisco olarte​ || the issue with getting rid of `anyas(xclass)` is that we want two things:- a way to match an argument without checking anything about its value (any)- a way to match an argument and check its type (isa)i think your solution is to just use `any()` with no parameter everywhere to cover the first case and specify the type when you want the 2nd case that wont work because target type inference doesnt work for method arguments in java < 8 so its impossible to use any() without an argument (unless the parameter is just `object` typed)specifically in java 7 the below wont compile:``` javaclass x {   public bool method(list l) {  }}x x  mock(xclass)// error: method(javacollectionslist) cannot be applied to (javalangobject)when (xmethod(any())thenreturn(true)```anybody on java < 8 has to specify the type every time they match anything or its impossible to make it compile they can never really use `any()` they always have to use `any(xclass)` (or equivalent) we need a way in java 7 that you can say match absolutely anything please that compiles and i think `any(xclass)` or equivalent is the only optionif you make that `any(xclass)` matcher check the type (as you suggest) then it no longer matches everything any more and it becomes impossible to wildcard match everything in java < 8 (without casting but that would be pretty nasty)therefore if you want to be able to both match specific types and wildcard match everything in java < 8 you have to have two separate apis to do so the names of those apis need to clearly tell the user which of those two things theyre doing (match anything but cast the matcher to make it compile vs match only this type)i dont think thats avoidable im very happy to take better suggestions for `anyas(xclass)` that make it clearer its just a convenient casting method (without making it so nasty that it stops being convenient) but that method does still need to exist i thinkin addition to all that: wed rather the match a specific type matcher didnt accept nulls by default (as your `any(listclass)` does) we need to make people opt in to matching nulls because its good practice and because theres some potentially confusing behaviour there as nulls are kind of outside the type system we also cant have the wildcard matcher reject nulls or its not matching everything any more thus again they need to be two different methods || hi tim:on tue apr 7 2015 at 7:37 pm tim perry notifications@githubcom wrote:> the issue with getting rid of anyas(xclass) is that we want two things:> > a way to match an argument without checking anything about its value (any)> a way to match an argument and check its type (isa)> > i think your solution is to just use any() with no parameter everywhere to cover the first case and specify the type when you want the 2nd case that wont work because target type inference doesnt work for method arguments in java < 8 so its impossible to use any() without an argument (unless the parameter is just object typed)i dont think youve understood my solution from the previouslypropossed one ( any() + anyas(class) + isa(class) + isnullora(class) (- notnull() which is in another place ) i propose to remove anyas  given it does not check type rename isa(class) to anynotnull(class)  rename isnullora(class) to any(class) and rename ( or forward )  notnull() to anynotnull()> specifically in java 7 the below wont compile:> > class x {>    public bool method(list l) {  }> }> > x x  mock(xclass)> > // error: method(javacollectionslist) cannot be applied to (javalangobject)> when (xmethod(any())thenreturn(true)perfect in this case you use the propossed isnullora(class) which iproposed to rename as any(class)also just grepped and got this from one of my test files:```    ac1  mock(autocallerclass)    when(ac1makecall((accallrequest) any()))thenreturn(resp1)```in case you wonder autocaller is an interface with a method""makecallresponse makecall(accallrequest)"" not overloadedi think this is clearly superior in java 7 ( im unable to use java 8on those projects due to problems with the app server ) the any()conveys the i do not care just make this compile and the castclearly says this is due to one of those java 7 shortcomings to me> anybody on java < 8 has to specify the type every time they match anything or its impossible to make it compile they can never really use any() they always have to use any(xclass) (or equivalent) we need a way in java 7 that you can say match absolutely anything please that compiles and i think any(xclass) or equivalent is the only optionwhich is what i proposed you have isnullora(class) which coversthis correct me if wrong> if you make that any(xclass) matcher check the type (as you suggest) then it no longer matches everything any more and it becomes impossible to wildcard match everything in java < 8 (without casting but that would be pretty nasty)it is the method has a declared argument type of list which meansthe compiler will check that when you use the mock inxmethod(whatever) whatever implements list so isnullora(listclass)or any(listclass) will allways match whatever with an extraredundant type check> therefore if you want to be able to both match specific types and wildcard match everything in java < 8 you have to have two separate apis to do so the names of those apis need to clearly tell the user which of those two things theyre doing (match anything but cast the matcher to make it compile vs match only this type)as i said im not knowdledgeable enough and havent got timepresently to dig through the sources if any(listclass) matches wheni pass an arraylist to the mock i can always wildcard by using thedeclared argument type> i dont think thats avoidable im very happy to take better suggestions for anyas(xclass) that make it clearer its just a convenient casting method (without making it so nasty that it stops being convenient) but that method does still need to exist i thinkforget about my proposed renaming with the any/anyas/isa/isnulloraproposal is there any case in which you must use anyas() which cannotbe solved by using isnullora(xclass)? i think they are synonims theproblem i see with anyas as stated is that in the previous example (without overloads ) i could code a matcher aswhen(xmethod(anyas(arraylistclass))) and it shoud fire ( as it doesnot check type ) when i do xmethod(new linkedlist()) i think this isconfusing and asking for problem and by making it check the type icould make when(xmethod(anyass(arraylistclass))) to catch onespecific thing and after that add when(xmethod(anyas(listclass)) fora catch all in java<8 or just plain any() in >8my proposal of getting rid of anyas can be read the other way makeanyas() check type and get rid of isnullorarepeating my self i proposed to get rid of anyas(class) as a i feelit seems to match something which it does not and it cannot doanything which cannot be done with isnullor(class) name it whateveris the functionality with worries me> in addition to all that: wed rather the match a specific type matcher didnt accept nulls by default (as your any(listclass) does) we need to make people opt in to matching nulls because its good practice and because theres some potentially confusing behaviour there as nulls are kind of outside the type system we also cant have the wildcard matcher reject nulls or its not matching everything any more thus again they need to be two different methodsthats another thing what i propose is to simplify so i have twonames ( anyincludingnull anynotnull ) which indicate wether null isaccepted plus two overrides no parameters and a class parameter thenull accepting behaviour is functionaly equivalent to haven just aname plus a boolean parameter ( notreallyany(boolean acceptnull) +notreallyany(boolean acceptnull class klass) )what makes me feel uncorfortable with the proposal is :- too many names i think two suffice- different names for similar methods similar names for different  null accepting behaviourgiven this i think:- anyincludingnul() anyincludingnul(class) anynotnull()  anynotnul(class) cover all cases for jdk <8 & 8 ( although  parameterless ones are not too useful in <8 ) ( your example would be  served by when(xmethod(anyincludingnull(listclass)) )- names should be kept paired you state opting in for nulls is good  practice ill accept that without discussion you say people should  opt in to use them i accept thas as a precondition writing  anyincludingnull is for me opting inbut then we want any() its nice sounds good it is short readsgood (any() in 8 i do not care just need this to compileany(listclass) in 7 i do not care but well then writing any( isopting in to use nulls so the class version should begin with any(too i have no problem with having the null accepting versionsnondefaultacceptingnullsanymatcher and the other one any orisa ides are really good at completing and i can easily manage acouple of names but having any anyas isa isnullora and notnullhorrifies mewell thats all for today i hope it clarifies my positionregards    francisco olarte || ok i think that mostly makes sense although im not clear exactly what the full api youre proposing is that fits the requirements here your last paragraph seems to contradict the four methods youve suggested just abovei think youre still suggesting an `any()` method with actively different behaviour to an `any(xclass)` method though inconsistencies between those two are how we ended up here because one does active type matching and the other doesnt and you need different null matching behaviour too in addition you definitely need `any()` or itll be confusing so i dont think theres any way you can have an `any(xclass)` method that does actual matchingsounds like there is a route through though: what happens if we accept that java 7 is on the way out stick only to casts and stop making the api confusing just to support now unsupported java versions? that would give an api of:- `any()` - matches anything- `isa(xclass)` - matches things with x type not nulls- `isnullora(xclass)` - matches things with x type or nullsif youre using java 8 all is good simple and clear if youre using java 7 you have to cast `any()` but `(myclass) any()` is clearer about what its doing than anything else we have here actually shorter than `any(myclassclass)` anyway and good ides will automatically suggest the cast for you too so pretty easy to find for newbies null behaviour is also clear here and were pushing people to be explicit about whether they match nulls in all arguments they care abouthow does that sound to everybody? || hi tim:on wed apr 8 2015 at 8:38 pm tim perry notifications@githubcom wrote:> ok i think that mostly makes sense although im not clear exactly what the full api youre proposing is that fits the requirements here your last paragraph seems to contradict the four methods youve suggested just aboveany of my paragraphs may seem contradictory but i do not know how toconvey the info and do not know what the exact requirements are butanyway lets go on> i think youre still suggesting an any() method with actively different behaviour to an any(xclass) method thoughin my full sugestion not exactly i suggested any to be the same asany(objectclass) ( declared parameter class really but it could beimplemented this way ) it checks the passed thing is null or asubclass of object ( second check redundant stated for completitude)> inconsistencies between those two are how we ended up here because one does active type matching and the other doesnt and you need different null matching behaviour too in addition you definitely need any() or itll be confusing so i dont think theres any way you can have an any(xclass) method that does actual matching> > sounds like there is a route through though: what happens if we accept that java 7 is on the way out stick only to casts and stop making the api confusing just to support now unsupported java versions? that would give an api of:> any() - matches anything> isa(xclass) - matches things with x type not nulls> isnullora(xclass) - matches things with x type or nullsim definitely in favour of sticking to casts as they are a standardlanguage feature and should be clearnow on your three proposed methods you are forgetting one which ison another part of the current api notnull() ( or its cousingnotnull(class) i do not know whic notnull is not declared genericlike any though i think it should be for java 8 )you have 2 choices 1- accept nulls 2-check class for 1 you needeither a boolean argument or different names for 2 you need a classargument to check against so in your proposal you would have:- accept nulls do not check class:  any() used as is in java 8  casted in 7 ( or for overload resolution in 8 )- accept nulls check class: isnullora(class)- reject nulls do not check class: notnull() ( same comments as any )- reject nulls check class: isa(class)which is fine dandy for me ( the naming stuff is trivial to achieveusing a franciscoolarteadditionalmatchers helper class )basically you can have a makematcher(boolean acceptnulls class klass) and then any()makematcher(true objectclass)isnullora(klass)makematcher(true klass)notnull()makematcher(false objectclass)isa(klass)makematcher(false klass)> if youre using java 8 all is good simple and clear if youre using java 7 you have to cast any() but (myclass) any() is clearer about what its doing than anything else we have here actually shorter than any(myclassclass) anyway and good ides will automatically suggest the cast for you too so pretty easy to find for newbies null behaviour is also clear here and were pushing people to be explicit about whether they match nulls in all arguments they care abouti think the null / check behaviour is clearer if you group themtogether somehow ( like ive done above ) as this gets rid of theconfusing (current) anyas(class) also i think notnull(class) must goas what is does is served by isa(class)> how does that sound to everybody?fine for me---------------not a proposal----------------now ill explain what i proposed ( for naming along with somemotivations ) i think this discussion seems to prove it is not easilyunderstood this is only for referencenote there are no functional changes with the proposal above justname reorganizations as i think current names are confusing ( and iknow they are for me but this is my problem and i can solve it )0- get rid of anyas and notnull(class) ( served by isa and isnullora )1- any() - keep as it is2- isnullora(class): rename to any(class) as functionality is verysimilar (any()isnullora(declaredparameterclassclass))3- isa() - rename to anynotnull ( it appears next to any() in methodslist and makes the behavioural differences easy to spot also if youhave a method any() and anynotnull ( both being offered byautocomplete ) is natural to assume that anyanyincludingnull whichis correct )4- notnull() - rename to anynotnull() ( to complete the matrix )note: in my naming proposal naked anyacceptnulls it could easily bereversed ( any>anyornull anynotnull>any it just sounds bad to methat way ( maybe because im used to x(object) and x(@nonnull object)and/or explicitly documenting when nulls are not allowed)extra things:- anyobject() - seems to do the same thing as any if so get rid of it  if to avoid confusion if not do the same as with anystring below- isnull(class) - given it can be done with (class)isnull() get rid  of it no need for a class checking version on this- anystring: confusing name with current behaviour given any() accept  nulls rename it to isastring and then per rule 3 above to  anynotnullstring then i would add an anystring equal to  isnullora(stringclass) or any(stringclass) per rule 2 also  consider deleting it (note below)- anyint/anychar/: as with anystring in nearly all aspects- anymap/anymapof ( and its friends anylist anycollection ): similar  to anystring rename to anynotnullmap and then use the now free  anymap to build one accepting nullsfor anystring/anyint/ i would consider having a basic matchersclass with any/anynotnull etc and a matchers derived class ( a laadditionalmatchers ) and relegate all aliases to that one so thejavadoc for the basic matchers class concentrates on basicfunctionality and the one for the aliases/forwarders just states theequivalence ) in fact i would better put a class for just the basicany\* matchers ( including just any() any(class) anynotnull()anynotnull(class) and isnull(class)) another one foreq/startswith/ another one for the anystring and friends staticimports make them easy to use in modern java and the documentationwould be much easier to read (for me at least)## hope this explains my visionregards   francisco olarte || i apologize i havent read the entire thread im still setting up myfamily in ca and trying to manage priorioritiesi think we have following use cases:1 i dont care about the parameter2 i care that it is not null3 i care about the type (implies (2))solutions:1) any() perhaps kill anyobject() needs explicit casting2) no special api kill isnotnull()/notnull() or just leave theisnotnull()/notnull() needs explicit casting3) any(stringclass) alias to isa(stringclass) (or kill isa())i think it is ok if only use case 3) offers api that avoids casting egif the user wants to avoid casting he needs to specify the matcher better(which i dont think is a problem)cheers!on thu apr 9 2015 at 2:39 am francisco olarte notifications@githubcomwrote:> hi tim:> > on wed apr 8 2015 at 8:38 pm tim perry notifications@githubcom> wrote:> > > ok i think that mostly makes sense although im not clear exactly what> > the full api youre proposing is that fits the requirements here your last> > paragraph seems to contradict the four methods youve suggested just above> > any of my paragraphs may seem contradictory but i do not know how to> convey the info and do not know what the exact requirements are but> anyway lets go on> > > i think youre still suggesting an any() method with actively different> > behaviour to an any(xclass) method though> > in my full sugestion not exactly i suggested any to be the same as> any(objectclass) ( declared parameter class really but it could be> implemented this way ) it checks the passed thing is null or a> subclass of object ( second check redundant stated for completitude> )> > > inconsistencies between those two are how we ended up here because one> > does active type matching and the other doesnt and you need different> > null matching behaviour too in addition you definitely need any() or> > itll be confusing so i dont think theres any way you can have an> > any(xclass) method that does actual matching> > > > sounds like there is a route through though: what happens if we accept> > that java 7 is on the way out stick only to casts and stop making the api> > confusing just to support now unsupported java versions? that would give an> > api of:> > any() - matches anything> > isa(xclass) - matches things with x type not nulls> > isnullora(xclass) - matches things with x type or nulls> > im definitely in favour of sticking to casts as they are a standard> language feature and should be clear> > now on your three proposed methods you are forgetting one which is> on another part of the current api notnull() ( or its cousing> notnull(class) i do not know whic notnull is not declared generic> like any though i think it should be for java 8 )> > you have 2 choices 1- accept nulls 2-check class for 1 you need> either a boolean argument or different names for 2 you need a class> argument to check against so in your proposal you would have:> - accept nulls do not check class: any() used as is in java 8>   casted in 7 ( or for overload resolution in 8 )> - accept nulls check class: isnullora(class)> - reject nulls do not check class: notnull() ( same comments as any )> - reject nulls check class: isa(class)> > which is fine dandy for me ( the naming stuff is trivial to achieve> using a franciscoolarteadditionalmatchers helper class )> > basically you can have a makematcher(boolean acceptnulls class klass> ) and then any()makematcher(true objectclass)> isnullora(klass)makematcher(true klass)> notnull()makematcher(false objectclass)> isa(klass)makematcher(false klass)> > > if youre using java 8 all is good simple and clear if youre using> > java 7 you have to cast any() but (myclass) any() is clearer about what> > its doing than anything else we have here actually shorter than> > any(myclassclass) anyway and good ides will automatically suggest the> > cast for you too so pretty easy to find for newbies null behaviour is> > also clear here and were pushing people to be explicit about whether they> > match nulls in all arguments they care about> > i think the null / check behaviour is clearer if you group them> together somehow ( like ive done above ) as this gets rid of the> confusing (current) anyas(class) also i think notnull(class) must go> as what is does is served by isa(class)> > > how does that sound to everybody?> > fine for me> > ---------------not a proposal----------------> now ill explain what i proposed ( for naming along with some> motivations ) i think this discussion seems to prove it is not easily> understood this is only for reference> > note there are no functional changes with the proposal above just> name reorganizations as i think current names are confusing ( and i> know they are for me but this is my problem and i can solve it )> > 0- get rid of anyas and notnull(class) ( served by isa and isnullora )> > 1- any() - keep as it is> 2- isnullora(class): rename to any(class) as functionality is very> similar (any()isnullora(declaredparameterclassclass))> 3- isa() - rename to anynotnull ( it appears next to any() in methods> list and makes the behavioural differences easy to spot also if you> have a method any() and anynotnull ( both being offered by> autocomplete ) is natural to assume that anyanyincludingnull which> is correct )> 4- notnull() - rename to anynotnull() ( to complete the matrix )> > note: in my naming proposal naked anyacceptnulls it could easily be> reversed ( any>anyornull anynotnull>any it just sounds bad to me> that way ( maybe because im used to x(object) and x(@nonnull object)> and/or explicitly documenting when nulls are not allowed)> > extra things:> - anyobject() - seems to do the same thing as any if so get rid of it>   if to avoid confusion if not do the same as with anystring below> - isnull(class) - given it can be done with (class)isnull() get rid>   of it no need for a class checking version on this> - anystring: confusing name with current behaviour given any() accept>   nulls rename it to isastring and then per rule 3 above to>   anynotnullstring then i would add an anystring equal to>   isnullora(stringclass) or any(stringclass) per rule 2 also>   consider deleting it (note below)> - anyint/anychar/: as with anystring in nearly all aspects> - anymap/anymapof ( and its friends anylist anycollection ): similar>   to anystring rename to anynotnullmap and then use the now free>   anymap to build one accepting nulls> > for anystring/anyint/ i would consider having a basic matchers> class with any/anynotnull etc and a matchers derived class ( a la> additionalmatchers ) and relegate all aliases to that one so the> javadoc for the basic matchers class concentrates on basic> functionality and the one for the aliases/forwarders just states the> equivalence ) in fact i would better put a class for just the basic> any\* matchers ( including just any() any(class) anynotnull()> anynotnull(class) and isnull(class)) another one for> eq/startswith/ another one for the anystring and friends static> imports make them easy to use in modern java and the documentation> would be much easier to read (for me at least)> > ## hope this explains my vision> > regards> francisco olarte> > ## > > reply to this email directly or view it on github>  szczepan faberfounder mockitoorg core dev gradleorgtweets as @szczepiq blogs at blogmockitoorg || hi szczepan:mmmm delicious top posting anyway:on thu apr 9 2015 at 3:59 pm szczepan faber notifications@githubcom wrote:> i think we have following use cases:> 1 i dont care about the parameter> 2 i care that it is not null> 3 i care about the type (implies (2))i think you lack at least one ( 4- i care it is null but it isalready served by isnull() ( or a casted null iirc ) not discussed )> solutions:> 1) any() perhaps kill anyobject() needs explicit casting> 2) no special api kill isnotnull()/notnull() or just leave the> isnotnull()/notnull() needs explicit casting> 3) any(stringclass) alias to isa(stringclass) (or kill isa())> > i think it is ok if only use case 3) offers api that avoids casting eg> if the user wants to avoid casting he needs to specify the matcher better> (which i dont think is a problem)i dont think casting specially in such a specialized case asmockiing in tests is an issue and j8 will avoid most of it what idislike of this is having mockm((string)any()) accept nulls andmockm(any(stringclass)) reject nulls isa sounds/reads fine to me iprefer anynotnull as name for 2 and 3 as it reads better highlightsthe relation with any ( they are the family of matchers which justchecks type not value ) but ive reached a point where i think theonly form to expose a proposal is to implement it to expose how itlooks which will have to wait in my casealso thinking about the previous stuff im beginnging to thinkisnullora(class) although it has a clear definition ( i have amockm(list) i want to match anything assignable to an arraylistwhich are null or arraylist subclasses so mockm(any(arraylist)) )im not too sure about its usefulness ( as i can do it with twomatchers and isnull plus an isa with the same target or useadditionalmatchersor )francisco olarte || i agree with francisco if were going for casts i dont think we can have `any(stringclass)` still exist because we cant make it usefully be consistent with `any()` i think just `isa` works fine for that case though and i find it quite readable and cleari do marginally prefer `notnull()` to `anynotnull()` just because its shorter and simpler i think `when(omethod(notnull() notnull()))` reads easier than `when(omethod(anynotnull() anynotnull()))` and while anynotnull makes sense in relation to any its less clear what it does when you see it standalone notnull however is very clear indeed it also doesnt feel quite so much like `any` and `notnull` are the same family as much as `isa/isnullora` are just because `any` is kind of a special case (any + specific values are all people will probably use 1/2 the time i expect)i also do think `isnullora(xclass)` does need to exist explicitly too just because its a common case and having to write `or(isnull() isa(stringclass))` (or `or((string) isnull() isa(stringclass))` for java 7) everywhere is quite substantially messier and harder to parse internally just being an alias to that is fine thoughdefinitely feels like were getting pretty close now! one more api update then:- `any()` - matches anything including nulls- `notnull()` matches anything except nulls- `isa(xclass)` matches things of x type except nulls- `isnullora(xclass)` matches things of x type including nulls- we get rid of every other variant (`anystring()` `isnotnull()` etc)i think there are some other extra variants we will still need for things like generic list type checks and varargs but those should follow on fairly cleanly from these thoughts? || hi time:on thu apr 9 2015 at 6:34 pm tim perry notifications@githubcom wrote:> i agree with francisco if were going for casts i dont think we can have any(stringclass) still exist because we cant make it usefully be consistent with any() i think just isa works fine for that case though and i find it quite readable and clearok> i do marginally prefer notnull() to anynotnull() just because its shorter and simpler i think when(omethod(notnull() notnull())) reads easier than when(omethod(anynotnull() anynotnull())) and while anynotnull makes sense in relation to any its less clear what it does when you see it standalone notnull however is very clear indeedok i donot agree with the arguments but i feel voting for notnull nowis much better than following the thread i retract all my proposalsfor anynotnull--- aside---> it also doesnt feel quite so much like any and notnull are the same family as much as isa/isnullora are just because any is kind of a special case (any + specific values are all people will probably use 1/2 the time i expect)> i think if you place them in a square it does isa is nw isnullora> is ne any is se ¿ which one goes into sw ? ( reminds me of the test> i did in school )also any() is like isnullora(objectclass) notnull() is likeisa(objectclass)not a proposal/discussion on the main issue just put here as anexplanation of my abandoned views--- /aside ---> i also do think isnullora(xclass) does need to exist explicitly too just because its a common case and having to write or(isnull() isa(stringclass)) (or or((string) isnull() isa(stringclass)) for java 7) everywhere is quite substantially messier and harder to parse internally just being an alias to that is fine thoughok with it> definitely feels like were getting pretty close now! one more api update then:> > any() - matches anything including nulls> notnull() matches anything except nulls> isa(xclass) matches things of x type except nulls> isnullora(xclass) matches things of x type including nulls> we get rid of every other variant (anystring() isnotnull() etc)> > i think there are some other extra variants we will still need for things like generic list type checks and varargs but those should follow on fairly cleanly from these thoughts?ok my main problem is i find current naming extremely confussingonce anyas is gone and replaced with ( more correct imo )  isnullorait nearly vanishes but if variants are recovered/kept ( i would do itin a separate class which could be very easily documented at the topand methods otherwise they clutter the main matchers docs classedare cheap specially in test code ) keep their name coherent to theimplementation ie givien anystring() can (should?) be implementedas isa(stringclass) to achieve current behaviour name it isastring()(same goes if behaviour is simillar to isnullora) ( or zap it iprefer just a longer way to do a thing than a confusing alternative )( i used to try to put short names to things but since about 20 yearsago ive been progresively going to longer and clearer typing iseasier than thinking ymmv )francisco olarte || cool i think were in agreement then im very happy to zap lots of the extra methods like `anystring()` where java 8 means theyre not going to be useful and theres a simple easy to find alternative to them (like just casting `any()` which most ides will even suggest and do for you)@bric3 @szczepiq are you two happy if i open a pr extending my previous changes to implement this api as in my message above? || hi @pimterry @folarte thanks for the discussion i was also away staffed at devoxx fr for the past week i think theres some agreement here im basically ok for these changes : - `<t> t any()` - matches anything including nulls- `<t> t notnull()` matches anything except nulls- `<t> t isa(class<t> clazz)` matches things of `t` type but `null`  > naming could be tweaked without the `is` thus becoming `a(xclass)` i understand this one is kinda bold- `<t> t isnullora(class<t> clazz)` matches things of `t` type including `null`  > naming could be tweaked without the `is` thus becoming `nullora(xclass)`- we get rid of every other variant (`anystring()` `isnotnull(class)` etc)  > theres still need for primitive matchers : `anyint` should stay in my opinion but this raises another issue with primitive wrappers should they allow null in my opinion they should not@szczepiq another related task would be to deprecate apis in the 1x line || happy to drop the `is` prefix seems shorter and clearer this might be one place where we do want an alias for `a(stringclass)` and `an(elementclass)` as otherwise i think its quite difficult to read> - we get rid of every other variant (anystring() isnotnull(class) etc)> > > theres still need for primitive matchers : anyint should stay in my opinion but this raises another issue with primitive wrappers should they allow null in my opinion they should notdo mean `anyint()` or `anint()`? i think the conclusion of the above discussion is that we cant have an `anyint()` method without breaking the api: either `anyint()` actively matches the type and rejects null (confusingly inconsistent with `any()`) or it doesnt and its confusing and people use it wrong (the current state of affairs)for java 8 `any()` should work everywhere i think and for java 7 you can use `(int) any()` i cant easily test this right now is there something about primitives generics and our implementation that means this doesnt work? thats going to be a difficult problem to solve if sofor `anint()` on the other hand it doesnt actually make the api inconsistent if we do add that as another method so thats very doable not clear why we need it in this case either thoughdo you have an example that doesnt work with this as given? || hi brice:on sun apr 12 2015 at 7:55 pm brice dutheil notifications@githubcom wrote:> thanks for the discussion i was also away staffed at devoxx fr for the past week i think theres some agreement here im basically ok for these changes :> > <t> t any() - matches anything including nulls> <t> t notnull() matches anything except nulls> > <t> t isa(class<t> clazz) matches things of t type but null> > naming could be tweaked without the is thus becoming a(xclass) i understand this one is kinda boldi strongly disagree with naming it a or ( sorry tim ) an i feel theyare too short and error prone ( and this is not cobol a pl/dsl is notenglish )> <t> t isnullora(class<t> clazz) matches things of t type including null> > naming could be tweaked without the is thus becoming nullora(xclass)i stil think my any/anynotnull overrrides where superior names but asthis is functionally equivalent ill just wrap it ok so far> we get rid of every other variant (anystring() isnotnull(class) etc)> > theres still need for primitive matchers : anyint should stay in my opinion but this raises another issue with primitive wrappers should they allow null in my opinion they should noti think the point of allowing nulls for primitives is a no point if ihave a method mockmethod(int) which i match withwhen(mockmethod(anyint())) it doesnt matter that the matcherreceives an integer due to boxing/reflection stuff it will never benull becuase if i do ""integer integer  null  mockmethod(integer)""autounboxing will raise npe before matchers get anything to say andif there was another override mockmethod(integer) well first thisshould have been matched by an appropiately casted any/is\* and secondits so perverse that user deserves whatever happens therefrancisco olarte || soon its next in my queue :) thank you guys for patience || great discussion thanks everybody for chipping in lets get this sorted out> what i> dislike of this is having mockm((string)any()) accept nulls and> mockm(any(stringclass)) reject nullsi agree there is a gotcha: given that any(sometypeclass) is most used matcher method it will be a pain to users to upgrade to mockito 20however if we tell users that any(stringclass) checks type but (string) any() does not it is rather awkward message and it might confusing down the roadby now most users are probably used to the behavior of mockito matchers and the pitfall is well documented ) so there is an option to leave things as they areremoving any(t) pretty much means that we need to remove all matcher methods like anystring() anylist() etc this increases the impact on the userill think about this a bit more and get back by the end of today || btw what do you guys think about #246? || i think were down to following options please vote or suggest other options:1 shoot down any(t) and anyt() in favor of isa() this thread seems to be converging on this approach consistent and clean high impact potential churn2 change any(t) and anyt() methods to reject nulls suggested by the community originally potentially confusing down the road due to inconsistence with any() this inconsistence becomes less of a problem with java83 do (2) but also shoot down any() replacing it with anyobject() or anything() or _ (ala spock ) not sure i like killing any() because it is neatly compact4 leave things as they are for now perhaps revisit for java8 support || hi​ ​szczepan:> btw what do you guys think about #246>  > ​i think it may have some problems and be an overload abuse​ if done this> way i would vote for having long named methods with is() being just a> forwarder and i think there may be some ambiguities if overloaded is() is> used to test overloaded method ( ie when you mock m(is(stringclass))> are you mocking m(class c) ( as m(eq(stringclass))  )  or m(string s) with> any string? ( its a contrived overload but ive seem some of these where> the string version takes a class name i think osgi has some of them )> having a long method (anyistanceof equalto evenm specially isnull()> which i personally prefer to is(null) ( which overload is it going to pick> the object one with a null param ) ) lets people key a little more in the> difficult cases and does not at too many complexity or a signigicant run> time for test code ( is() is just a one line forwarder and its javedoc> can be left as such which just an @link to the unoverloaded method )regarding readability im not sure compact overloaded names are morereadable they may be easier to read aloud but you need to invoke higherlevel brain functions to parse it and distinguish the overload being usedbut maybe im just becoming slower​francisco olarte​ || yep i prefer option 1#246 sounds like a good idea to me but we should definitely market it very clearly as a convenience method (as francisco mentions) and obviously keep the explicit methods so people are aware they can opt in to explicitly choosing the relevant option if they need to or theyre not sure what the overloading doesthe overload im most suspicious of is `is(t)` just because its most likely to be ambiguous in practice and when trying to just think about what a line is doing `is(null)` seems clear `is(stringstartingwithhello)` is fine but if i saw`when(is(100) is(stringclass))` i think my default would be to assume that the argument needed to literally be the class object not totally sure about that though happy to go with it if others are happy || any progress on this? are people happy for me to put together a potential pr for option 1 which it sounds like weve settled on as something concrete to discuss? || my preference is to have the following matchers (option 1?):-  `<t> t any()`  that accepts anything including `null`  i associate _""any""_ to the _""anything""_ in my world that includes null-values and instances it is compact and suitable for the most common cases- `<t> t anyobject()` or `<t> t notnull()` reject `null` values opposite to any() the name should indicate that null is rejected to avoid confusion about its behaviour- `<t> t isa(class<? extends t>)` reject `null` values and all values that are not a subtype of `t` like instanceof- all `any*()` and `any(t)` should be dropped cause they have different behaviour (as described before) || > 1 shoot down any(t) and anyt() in favor of isa() this thread seems to be converging on this approach consistent and clean high impact potential churn> 2 change any(t) and anyt() methods to reject nulls suggested by the community originally potentially confusing down the road due to inconsistence with any() this inconsistence becomes less of a problem with java8> 3 do (2) but also shoot down any() replacing it with anyobject() or anything() or _ (ala spock ) not sure i like killing any() because it is neatly compact> 4 leave things as they are for now perhaps revisit for java8 supportlets try to be decisive :)tim & christian vote for option 1) i very much appreciate those votes and option 1 does have a lot of charm :)myself i vote for 2) because:- any(t) reads better (seems more fluent) is more intuitive to write than isa() it looks good in tests- it is consistent gramatically with any() it makes the api a bit more consistent- java8 is very popular people use any() for matching anything and can use any(t) for matching specific type (not null)- removing any(t) (options 1 and 3) seems like a churn and big impact on users without strong enough justification it seems arbitrary that we remove the any(t) methods eg myself as a user i would not be convinced that migrating to mockito 20 is a good idea because i need to fix hundreds of compilation errors due to removal fundamental api method (anyt/any(t)) even if i make that search&replace im not convinced that tests look better now the change also hurts muscle memory and users would be finding themselves using any(t) methods finding the code not compile then realizing that aha! this method was removed however if we update the behavior of any() (option 2) we will provide very nice signal to users during the migration to 20 we could potentially expose bugs most users expect nulls to be rejected by any(t) - mockito 20 will make expose tests that fail that assumptionwe dont have to agree however it would really cool if we were on the same page :) it would be so nice if everyone of us could stand behind decisions we make as a teamwe definitely need to make the decision!!! (if left undecided were effectively deciding on option 4) || i would like to suggest introducing the isa api alongside any the latter would accept nulls while the former would rejecet themnulls are pretty common as values so we ahould not make this more difficult than necessary also tgis makes migration easier || i already started the work on this a few days ago and i chose to kinda follow option 2 as well heres the plan :- `<t> t any()` that accepts anything including `null` i am pondering the addition of `anything` as it is the original meaning of `any`- `* any*()` / `<t> any(t)` will be aliases of `<t> isa(t)` **this is the expected behaviour by users** doing this will introduce the rejection of `null` with java 8 i saw young developer to switching to `any()` when `null` values where used instead of `anyint`since we want to do a release candidate i suggest that we ship the _null safe_ `any*` and remove the `null` check if too much people complaincc @timvdlippe @marcingrzejszczak @raphw @szpak  || thanks for feedback!+1 to your plan-1 to anything it feels that it does not add sufficient value its alonger alias - not sure why would someone want to use iton mon jul 25 2016 at 10:10 am brice dutheil notifications@githubcomwrote:> i already started the work on this a few days ago and i chose to kinda> follow option 2 as well heres the plan :> - <t> t any() that accepts anything including null i am pondering the>   addition of anything as it is the original meaning of any> - \* any_() / <t> any(t) will be aliases of <t> isa(t) *this is the>   expected behaviour by users_ doing this will introduce the rejection>   of null with java 8 i saw young developer to switching to any() when>   null values where used instead of anyint> > since we want to do a release candidate i suggest that we ship the _null> safe_ any* and remove the null check if too much people complain> > cc @timvdlippe  @marcingrzejszczak>  @raphw  @szpak  > —> you are receiving this because you were mentioned> reply to this email directly view it on github>  or mute the thread>   || +1 i agree lets try this for the rc || ";1;0;adds deprecation for generic method to avoid casting as it is not anymore necessary in java 8;
511;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;bibtexmlimportertest;;;0;equivalencesidentity()s behavior does not match its javadoc; in comgooglecommonbaseequivalencesequivalent()s javadoc: equivalence#equivalent} returns {@﻿code true} if both values are null""--> but implementation throws npe when a is null""{@﻿link equivalence#hash} throws a {@﻿link nullpointerexception} if passed a null value""--> but implementation returns 0 when passed a null value (because systemidentityhashcode() returns 0 for null values)thanks :)"; ;;;;0;1;;
511;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;bibtexmlimportertest;;;0;fix some warnings; various warnings mostly unused imports but also a couple of unnecessary semicolons and interface modifiers`/gradlew build` built successfully; ;;;;1;1;remove redundant interface modifiers;
511;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;bibtexmlimportertest;;;0;add additional retention property for test tables;;;;;;1;1;add additional retention property for test tables;
511;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;bibtexmlimportertest;;;0;operation groupbyuntil;issue #52note that rxnets subject<t> once oncompleted() or onerror()d any subsequent subscriptions from observers will immediately receive oncompleted() or onerror() rxjavas publishsubject however doesnt seem to do that leaving future observers never do anything since the rxnetgroupbyuntil relied on the described behavior to handle escaped groups the proposed implementation inside the groupsubject will do this manually;#435  needs to be rebased before it can merge || will do shortly ||;;;;0;1;;
512;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;ovidimportertest;;;0;"using consistent parameter name ""errormessage"" instead of ""desc"" in preconditions"; most methods use the parameter name ""errormessage"" for the error message but checkelementindex()/checkpositioninex() names it ""desc"" maybe this should be refactored to ""errormessage"" too or does this have a reason?"; that parameter isnt an error message its a description of what the index represents which will be _used_ as part of the constructed error message""@﻿param desc the text to use to describe this index in an error message""--- ;;;;0;1;;
512;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;ovidimportertest;;;0;fix some raw type warnings in tests;; ;;;;1;1;fix some raw type warnings in tests;
512;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;ovidimportertest;;;0;minor (hacky) refactoring to fix missing stats from completion event;;looks good ;;;;1;1;minor (hacky) refactoring to fix missing stats from completion event;
512;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;ovidimportertest;;;0;scala adaptor details;"with  some files were lost so i added them again and i also  many other details there are no changes in functionality/inheritance only ""cosmetics"" except  : @headinthebox could you please confirm this one-line change?";"@headinthebox @samuelgruetter please confirm the two of you agree on this and ill merge || #437  looks good  || found a small bug (copy & paste)object publishsubject {  def apply[t](value: t): publishsubject[t]  {    new publishsubject[t](rxsubjectspublishsubjectcreate%28%29)  }}we need to add as well (and have the above call this one) i use the above to force type inference object publishsubject {  def apply[t](): publishsubject[t]  {    new publishsubject[t](rxsubjectspublishsubjectcreate%28%29)  }} || 2x exactly the same?(btw please indent code by 4 spaces -) ) || @headinthebox i still dont understand what you mean with this [comment]( || this is a trick we often use in c# you pass in a dummy ""witness"" of type t to help the compiler infer types if you say publishsubject() it will infer publishsubject[nothing] and you are forced tp write publishsubject[t]() i _never_ want to write a concrete type anywhere || with the current code``` scalaobject publishsubject {  def apply[t](): publishsubject[t]  {    new publishsubject[t](rxsubjectspublishsubjectcreate())  }}```we can do the following:``` scalaval s1  publishsubject[int]() // inferred type of s1: publishsubject[int]val s2  publishsubject()      // inferred type of s2: publishsubject[nothing]val s3: publishsubject[int]  publishsubject() // also works```what else do you want to be possible? || so you want to write```val s4  publishsubject(0)```because you prefer writing `0` over writing `int`? thats never done in scala and looks very weird to me || ";;;;1;1;merge branch master of githubcom:netflix/rxjava into scalaadaptor;
513;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;repecnepimportertest;;;0;closeablesclosequietly() with varargs; it would be more concise and more comfortable to have closequietly(closeable closeables) i often encouter code where i have to close at least two closeablessome code block egreader readerwriter writertry {&nbsp&nbsp}finally {&nbsp&nbspcloseablesclosequietly(reader writer)}; i see nothing wrong with multiple sequential calls to closequietly--- ;;;;0;1;;
513;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;repecnepimportertest;;;0;replace testbase#assertcontainsignoringcase(string sub string string…;…) with assertj #containsignoringcaseother methods of testbase could be replaced in a similar way;     ;;;;1;1;replace testbase#assertcontainsignoringcase(string sub string string) with assertj #containsignoringcase;
513;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;repecnepimportertest;;;0;record failures for any error during task scheduling;;;;;;1;1;record failures for any error during task scheduling;
513;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;repecnepimportertest;;;96.0;operators tomap and tomultimap again;issue #96 and issue #97tomap: 3 overloadstomultimap: 4 overloadsadded groovy test to verify overloading;#438  ah  this cant merge anymore because of other commits (probably the join operator on your other pr) can you rebase? ||;operator: todictionary;http://msdnmicrosoftcom/en-us/library/hh229137(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh212046(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh212075(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229073(vvs103)aspx;i believe the equivalent to idictionary is a map in java but there are a lot of map classes (linked concurrent etc) which one should be the default value type? is it okay to call the methods observabletomap() ? || i vote for javautilhashmap by default with an overload that lets you pass in a map class of any type you want```public <k v m extends javautilmap<k v>> observable<m> tomap(class<m> mapclass func1<? super t ? extends k> keyselector func1<? super t ? extends v> elementselector) {}```ps: not sure if i got the co/contra-variance right on thatpps: i think the consensus was to ignore equalitycomparators overloads because the idiomatic java way is to implement equals/hashcode on the class || two questions:-    how many times will this operator call onnext? just once or every time it gets a new item?-    are users allowed to modify the returned map? || this is how i did it somewhere else (below):- takes a factory which returns a map instance on subscription- emits the map once the source finishes- no variance on the output observables type``` javapublic class operationtomap {    public static class tomap<t k v> implements onsubscribefunc<map<k v>> {        private final observable<t> source        private final func1<? super t ? extends k> keyselector        private final func1<? super t ? extends v> valueselector        private final func0<? extends map<k v>> mapfactory        public tomap(                observable<t> source                func1<? super t ? extends k> keyselector                func1<? super t ? extends v> valueselector                func0<? extends map<k v>> mapfactory                ) {            thissource  source            thiskeyselector  keyselector            thisvalueselector  valueselector            thismapfactory  mapfactory        }        @override        public subscription onsubscribe(observer<? super map<k v>> t1) {            return sourcesubscribe(new tomapobserver(t1))        }        public class tomapobserver implements observer<t> {            map<k v> map            private final observer<? super map<k v>> t1            public tomapobserver(observer<? super map<k v>> t1) {                map  mapfactorycall()                thist1  t1            }            @override            public void oncompleted() {                map<k v> map0  map                map  null                t1onnext(map0)                t1oncompleted()            }            @override            public void onerror(throwable e) {                map  null                t1onerror(e)            }            @override            public void onnext(t args) {                k key  keyselectorcall(args)                v value  valueselectorcall(args)                mapput(key value)            }        }    }}``` ||;1;0;merge upstream/master into tomapandtomultimap;
513;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;repecnepimportertest;;;97.0;operators tomap and tomultimap again;issue #96 and issue #97tomap: 3 overloadstomultimap: 4 overloadsadded groovy test to verify overloading;#438  ah  this cant merge anymore because of other commits (probably the join operator on your other pr) can you rebase? ||;operator: tolookup;http://msdnmicrosoftcom/en-us/library/hh212098(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211805(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229101(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211616(vvs103)aspx;;1;0;merge upstream/master into tomapandtomultimap;
514;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactored mockutil to a static utility class (#426);;;0;clarify multimaps#indexs key / value order (javadoc and example);  multimaps#index returns an immutablelistmultimap which has according to its javadoc a ""reliable user-specified key and value iteration order""since this return type is specified in immutablelistmultimap#indexs method signature i suppose it may be considered as a part of the apis contract the iteration order of the returned multimaps keys should thus have the same order as the order in which the keys are encountered when iterating on the source iterable applying the keyfunction a quick look at the source code seems to confirm thisbut the example given in the javadoc is confusing according to it:list&ltstring> badguys  arraysaslist(""inky"" ""blinky"" ""pinky"" ""pinky"" ""clyde"")function&ltstring integer> stringlengthfunction  multimap&ltinteger string> index  multimapsindex(badguys stringlengthfunction)systemoutprintln(index)should print:{4[inky] 5[pinky pinky clyde] 6[blinky]}(notice that it is ordered by ordering the keys)it didnt match my expectations so i tested it and it actually prints:{4[inky] 6[blinky] 5[pinky pinky clyde]}(notice that ""6[blinky]"" comes before ""5[pinky pinky clyde]}"" because ""blinky"" (5 letters long) precedes ""pinky"" (the first element in the source values which is 4 letters long)it would be great if the javadoc clarified the intent concerning the returned multimaps iteration order (if it indeed is part of the methods contract?) i think the example should also be updated because it is currently wrong/confusing"; sweet!--- ;;;;0;1;;
514;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactored mockutil to a static utility class (#426);;;0;expressionformatter fixes;;;;;;1;1;rename expressionformattertostring() to formatexpression()to make it easier to import statically;
514;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactored mockutil to a static utility class (#426);;;0;operation join again;issue #56;#439 ;;;;1;1;merge upstream/master into operationjoin2conflicts:	rxjava-core/src/main/java/rx/observablejava;
514;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactored mockutil to a static utility class (#426);;;426.0;refactored mockutil to a static utility class (#426);;  514  ;refactor instance based utility classes to static utility classes;the internal implementation of mockito contains numerous helper classed that serve as a container for useful methods by its nature these classes dont have a state currently some them are instance based in other word you need to create the utility class to call a helper method this not only pollutes the heap but also the code cause instance methods cant be imported statically here is an example:```javahelper helper  new helper()if (helperisinputvalid(input)){   }```vs static import of helperisinputvalid```javaif (isinputvalid(input)){   }```the aim of this ticket is to identify canidates that can be refactored to static utility classes if you like to refactoring and mockito feel free to send a pr and reference this issuerefactoring canidates:-  `accessibilitychanger`-  `beanpropertysetter`-  `conditionalstacktracefilter`-  `fieldcopier`-  `fieldreader`-  `genericmaster` should be integrate into `generictyperesolver`-  `junitfailurehacker` can be removed when the deprecated `verbosemockitojunitrunner` is removed-  `lenientcopytool`-  `matcherbinder`-  `mockitocore` should better be a singleton-  `mockcreationvalidator`- [ ] `removefirstline`-  #591 `argumentmatchingtool`-  #515 `allinvocationsfinder`-  #502 `argumentscomparator`-  #540 `arrayutils`-  #490 `atleastxnumberofinvocationschecker`-  #490 `atleastxnumberofinvocationsinorderchecker`- [ ] #912 `constructors`-  #427 `fieldsetter`-  #908 `friendlyexceptionmaker`-  #431 `handyreturnvalues` - [x] #432 `invocationmarker`- [x] #462 `invocationsfinder`- [x] #908 `junitdetecter`- [x] #490 `missinginvocationchecker`- [x] #490 `missinginvocationinorderchecker`- [x] #514 `mockutil`- [x] #503 `nongreedynumberofinvocationsinorderchecker`- [x] #907 `numberofinvocationsinorderchecker`- [x] #907 `numberofinvocationschecker`- [x] #547 `objectmethodsguru`- [x] #427 `reporter`- [x] #535 `supertypeslastsorter`- [x] #501 `testmethodfinder`- [x] #515 `verifiableinvocationsfinder`;"@raphw thanks for merging the pr that fast!  would you mind reopening this ticket? there are more classes that can be refactored that way i would like to extend the list || big :+1: for me btw but please keep the pull requests managable and as small as possible preferably refactoring 1 method at a time that way it is a lot easier to review || i agree there is nothing wrong with multiple prs the quick merge is a reaction to an easy overview (and being stuck at an ukrainian airport without access to the eurocup) || there are still two unit tests failing could you have a look @christianschwarz - i just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `reporter`i should have checked more thoroughly before merging hopefully you can fix the problem soon alternatively i will just rollback the one commit (the first one is good) and we can reapply the patch once you  the two unit tests thank you really this was great clean-up || i fixed the one test error i push it tonightps: i also fixed a bug in the stack trace cleaner not a biggy but please do not `@ignore` tests especially in big commits it is easy to miss that single annotation || @raphw which test(s) is/are failing? i will fix it asap! too bad that some test fail on a regulare base is it possible to ignore them in the ide only? || you can see the build output here:  advise you to run the tests with `/gradlew build` this should work || @timvdlippe know what you mean! the next prs include only one refactored class at a time || i have it all fixed on local but i did not have access to wifi without 22 blocked will commit soon || @raphw can you please reopen this issue  || sorry github automatically closes issues that reference a pr || @christianschwarz if a commit contains a comment like ""426"" the mentioned issue is automatically closed by github || @pascalschumacher good to know! i will leave it out for the upcoming prs  now that we are pulling in static methods i would like to propose a new (linter) rule to make it easier to read a file i would like that all methods invoked in the current class are referenced with `this` (and `super` for that matter) therefore if we see `thisverify` we know it is in the current class and the same object whereas `verify` references a static method in this class or an imported static method do you agree @mockito/developers ? || > i would like that all methods invoked in the current class are referenced with this (and super for that matter)to me it feels like unnecessary/duplicate code cause `this` is implicit adding `this` before every instance call would create a lot more text and would imho reduce readability eg:`thisdosometing(thiswithprivatemethod())` vs `dosomething(withprivatemethod())`> therefore if we see thisverify we know it is in the current class and the same object whereas verify references a static method in this class or an imported static methodan other option avoid ambiguity is to qualify static methods via its class name  this way you can also distinguish which verify() is called ( `mockitocoreverify()` / `mocktioverify()`)  which is not an easy task when a static import is used || im not coding too much in mockito atm (hopefully now after springone conference ill have more time) but i fully agree with @christianschwarz  imo the best solution is to: - omit `this` before method calls - if necessary provide the class for static method call || respectful -1i like when the class formally declares collaborators instead of calling out to static methods this makes it easy to reason about the code i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etc another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too proceduralthe benefits for converting to static utilities have minimal significance to me yet there is a downside i care about (eg maintainability of procedural code static methods that consume static methods that consume static methods)hence i down vote this sort of changes going down this path all stateless classes in mockito would become static utilities :)you can get +1s from other maintainers and have your changes merged - im not here to block your changes but to give honest feedback i see merit in arguments for static utilities they do not outweigh the cost in my opinion || im mitigated about this as well i understand well that mockito creates garbage but they are short lived and **most probably** wont go in the old generation especially in the test phase yet the faster the tests are the more developers will run them it **may** have impacts on big projects also design wise i dont like much static methods toohowever i dont totally agree with the above points : > i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etccoupling appears also in the import section  static methods are visible there and modern ide usually highlight this intellij even have a warning if import section is too big just as theres warning if theres too many fields this point should not be the reason to avoid static methods> maintainability of procedural code static methods that consume static methods that consume static methodshaving instance methods does not protect again procedural code---i believe theres middle ground there : - mockito project contains a lot of small utility stateless objects that are supporting mockito features these are usually collections tools reflection tools those could are good candidate for static methods objects like `fieldsetter` `fieldcopier` `lenientcopytool` could be nice candidate for static methods- mockito features could be backed by object instances objects like `mockitocore` `mockcreationvalidator` `argumentmatchingtool` are candidate to stay objects || exactly the middle ground described by brice is my motivation for merging most of the prs this is also the reason i have not yet merged the mockitocore pr for this exact reasonif an object is not a attribute or parameter but an internal creation and immediately dismissed i value a pure function more || thought: when we switch to java 8 we can use interfaces with defaultmethods the switch from static utility to interface is very easy now (justa couple of text replaces no method reference modifications)on fri 12 aug 2016 17:23 brice dutheil notifications@githubcom wrote:> im mitigated about this as well i understand well that mockito creates> garbage but they are short lived and _most probably_ wont go in the old> generation especially in the test phase yet the faster the tests are the> more developers will run them it _may_ have impacts on big projects> also design wise i dont like much static methods too> > however i dont totally agree with the above points :> > i dont need to read every line of code in the class to find out external> couplings realized via static methods i can see the couplings via fields> i can easily query how the field variable is used etc> > coupling appears also in the import section  static methods are visible> there and modern ide usually highlight this intellij even have a warning> if import section is too big just as theres warning if theres too many> fields this point should not be the reason to avoid static methods> > maintainability of procedural code static methods that consume static> methods that consume static methods> > ## having instance methods does not protect again procedural code> > i believe theres middle ground there :> >    -> >    mockito project contains a lot of small utility stateless objects that>    are supporting mockito features these are usually collections tools>    reflection tools those could are good candidate for static methods>    objects like fieldsetter fieldcopier lenientcopytool could be nice>    candidate for static methods>    -> >    mockito features could be backed by object instances objects like>    mockitocore mockcreationvalidator argumentmatchingtool are candidate>    to stay objects> > —> you are receiving this because you modified the open/close state> reply to this email directly view it on github>  or mute the thread>   || this feels like a misuse of the default methods || i think you mean static-methods in interfaces here? default-methods require an instance to be called onanyway i dont think that it is a good idea  it would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods imho a class with private constructor is the best construct to do this || > > thought: when we switch to java 8 we can use interfaces with default> > methods> > default-methods require an instance to be called oni was thinking exactly that default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface) || @christianschwarz what do you think to continue the work here with the middle ground described [here]( ? || i am attempting to refactor the matcherbinder class to a static utility class and am having trouble refactoring the following from mockhandlerimpltestjava: `handlermatchersbinder  new matchersbinder() {            public invocationmatcher bindmatchers(argumentmatcherstorage argumentmatcherstorage invocation invocation) {                throw new invaliduseofmatchersexception()            }} `how can i maintain the abstract class definition when i am not able to create an object of matcherbinder?any help is appreciated!  || lets close this ticket refactorings can be done as needed as we work with the code || ";1;0;refactored mockutil to a static utility class (#426);
515;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;bibteximporter test;added tests for bibteximporter  depends on pr #514 (missing gradle test encoding  special char  ß );;0;filescopy deletes the file contents when both from and to refer to the same file; @﻿testpublic void shouldnotdestroycontents() throws ioexception {&nbsp&nbsp&nbsp&nbspfile file  filecreatetempfile(""test"" ""txt"")&nbsp&nbsp&nbsp&nbspfileswrite(""hello world"" file charsetsutf_8)&nbsp&nbsp&nbsp&nbspassertasserttrue(filelength()>0)&nbsp&nbsp&nbsp&nbspfilescopy(file file)&nbsp&nbsp&nbsp&nbspassertasserttrue(filelength()>0)  &nbsp&nbsp&nbsp&nbspfiledelete()}i expect the copy operation to do nothing when file is copied over itself instead the file contents get truncated to zero length and the test failsversion r06this could get very complicated to test especially on linux where files can appear to have distinct paths yet refer physically to the same file anyway i should have been at least warned in the documentation that this function can destroy my data"; a warning has been added to the javadoc about this--- ;;;;0;1;;
515;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;bibteximporter test;added tests for bibteximporter  depends on pr #514 (missing gradle test encoding  special char  ß );;0;fix bug when ordering by window function;;;;;;1;1;fix bug when ordering by window function;
515;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;bibteximporter test;added tests for bibteximporter  depends on pr #514 (missing gradle test encoding  special char  ß );;0;operation groupbyuntil again;issue #52;#440  im going to need to spend more time on this one thing that jumps out right now is the covariance/contra-variance generics isnt there and thus doesnt match the other `groupby` operators  || yes this project made me cautious with variances im going to update the signatures but ill wait a bit to avoid rebasing all the time ||;;;;0;1;;
515;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;bibteximporter test;added tests for bibteximporter  depends on pr #514 (missing gradle test encoding  special char  ß );;426.0;refactored allinvocationsfinder and verifiableinvocationsfinder to st…;…atic utility classes (#426);  515   @pascalschumacher these 2 classes have only one public method they can be merged into:- `verificationfinder::findverified()` /  `::findall()`what do you think? || @christianschwarz sure ||;refactor instance based utility classes to static utility classes;the internal implementation of mockito contains numerous helper classed that serve as a container for useful methods by its nature these classes dont have a state currently some them are instance based in other word you need to create the utility class to call a helper method this not only pollutes the heap but also the code cause instance methods cant be imported statically here is an example:```javahelper helper  new helper()if (helperisinputvalid(input)){   }```vs static import of helperisinputvalid```javaif (isinputvalid(input)){   }```the aim of this ticket is to identify canidates that can be refactored to static utility classes if you like to refactoring and mockito feel free to send a pr and reference this issuerefactoring canidates:-  `accessibilitychanger`-  `beanpropertysetter`-  `conditionalstacktracefilter`-  `fieldcopier`-  `fieldreader`-  `genericmaster` should be integrate into `generictyperesolver`-  `junitfailurehacker` can be removed when the deprecated `verbosemockitojunitrunner` is removed-  `lenientcopytool`-  `matcherbinder`-  `mockitocore` should better be a singleton-  `mockcreationvalidator`- [ ] `removefirstline`-  #591 `argumentmatchingtool`-  #515 `allinvocationsfinder`-  #502 `argumentscomparator`-  #540 `arrayutils`-  #490 `atleastxnumberofinvocationschecker`-  #490 `atleastxnumberofinvocationsinorderchecker`- [ ] #912 `constructors`-  #427 `fieldsetter`-  #908 `friendlyexceptionmaker`-  #431 `handyreturnvalues` - [x] #432 `invocationmarker`- [x] #462 `invocationsfinder`- [x] #908 `junitdetecter`- [x] #490 `missinginvocationchecker`- [x] #490 `missinginvocationinorderchecker`- [x] #514 `mockutil`- [x] #503 `nongreedynumberofinvocationsinorderchecker`- [x] #907 `numberofinvocationsinorderchecker`- [x] #907 `numberofinvocationschecker`- [x] #547 `objectmethodsguru`- [x] #427 `reporter`- [x] #535 `supertypeslastsorter`- [x] #501 `testmethodfinder`- [x] #515 `verifiableinvocationsfinder`;"@raphw thanks for merging the pr that fast!  would you mind reopening this ticket? there are more classes that can be refactored that way i would like to extend the list || big :+1: for me btw but please keep the pull requests managable and as small as possible preferably refactoring 1 method at a time that way it is a lot easier to review || i agree there is nothing wrong with multiple prs the quick merge is a reaction to an easy overview (and being stuck at an ukrainian airport without access to the eurocup) || there are still two unit tests failing could you have a look @christianschwarz - i just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `reporter`i should have checked more thoroughly before merging hopefully you can fix the problem soon alternatively i will just rollback the one commit (the first one is good) and we can reapply the patch once you  the two unit tests thank you really this was great clean-up || i fixed the one test error i push it tonightps: i also fixed a bug in the stack trace cleaner not a biggy but please do not `@ignore` tests especially in big commits it is easy to miss that single annotation || @raphw which test(s) is/are failing? i will fix it asap! too bad that some test fail on a regulare base is it possible to ignore them in the ide only? || you can see the build output here:  advise you to run the tests with `/gradlew build` this should work || @timvdlippe know what you mean! the next prs include only one refactored class at a time || i have it all fixed on local but i did not have access to wifi without 22 blocked will commit soon || @raphw can you please reopen this issue  || sorry github automatically closes issues that reference a pr || @christianschwarz if a commit contains a comment like ""426"" the mentioned issue is automatically closed by github || @pascalschumacher good to know! i will leave it out for the upcoming prs  now that we are pulling in static methods i would like to propose a new (linter) rule to make it easier to read a file i would like that all methods invoked in the current class are referenced with `this` (and `super` for that matter) therefore if we see `thisverify` we know it is in the current class and the same object whereas `verify` references a static method in this class or an imported static method do you agree @mockito/developers ? || > i would like that all methods invoked in the current class are referenced with this (and super for that matter)to me it feels like unnecessary/duplicate code cause `this` is implicit adding `this` before every instance call would create a lot more text and would imho reduce readability eg:`thisdosometing(thiswithprivatemethod())` vs `dosomething(withprivatemethod())`> therefore if we see thisverify we know it is in the current class and the same object whereas verify references a static method in this class or an imported static methodan other option avoid ambiguity is to qualify static methods via its class name  this way you can also distinguish which verify() is called ( `mockitocoreverify()` / `mocktioverify()`)  which is not an easy task when a static import is used || im not coding too much in mockito atm (hopefully now after springone conference ill have more time) but i fully agree with @christianschwarz  imo the best solution is to: - omit `this` before method calls - if necessary provide the class for static method call || respectful -1i like when the class formally declares collaborators instead of calling out to static methods this makes it easy to reason about the code i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etc another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too proceduralthe benefits for converting to static utilities have minimal significance to me yet there is a downside i care about (eg maintainability of procedural code static methods that consume static methods that consume static methods)hence i down vote this sort of changes going down this path all stateless classes in mockito would become static utilities :)you can get +1s from other maintainers and have your changes merged - im not here to block your changes but to give honest feedback i see merit in arguments for static utilities they do not outweigh the cost in my opinion || im mitigated about this as well i understand well that mockito creates garbage but they are short lived and **most probably** wont go in the old generation especially in the test phase yet the faster the tests are the more developers will run them it **may** have impacts on big projects also design wise i dont like much static methods toohowever i dont totally agree with the above points : > i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etccoupling appears also in the import section  static methods are visible there and modern ide usually highlight this intellij even have a warning if import section is too big just as theres warning if theres too many fields this point should not be the reason to avoid static methods> maintainability of procedural code static methods that consume static methods that consume static methodshaving instance methods does not protect again procedural code---i believe theres middle ground there : - mockito project contains a lot of small utility stateless objects that are supporting mockito features these are usually collections tools reflection tools those could are good candidate for static methods objects like `fieldsetter` `fieldcopier` `lenientcopytool` could be nice candidate for static methods- mockito features could be backed by object instances objects like `mockitocore` `mockcreationvalidator` `argumentmatchingtool` are candidate to stay objects || exactly the middle ground described by brice is my motivation for merging most of the prs this is also the reason i have not yet merged the mockitocore pr for this exact reasonif an object is not a attribute or parameter but an internal creation and immediately dismissed i value a pure function more || thought: when we switch to java 8 we can use interfaces with defaultmethods the switch from static utility to interface is very easy now (justa couple of text replaces no method reference modifications)on fri 12 aug 2016 17:23 brice dutheil notifications@githubcom wrote:> im mitigated about this as well i understand well that mockito creates> garbage but they are short lived and _most probably_ wont go in the old> generation especially in the test phase yet the faster the tests are the> more developers will run them it _may_ have impacts on big projects> also design wise i dont like much static methods too> > however i dont totally agree with the above points :> > i dont need to read every line of code in the class to find out external> couplings realized via static methods i can see the couplings via fields> i can easily query how the field variable is used etc> > coupling appears also in the import section  static methods are visible> there and modern ide usually highlight this intellij even have a warning> if import section is too big just as theres warning if theres too many> fields this point should not be the reason to avoid static methods> > maintainability of procedural code static methods that consume static> methods that consume static methods> > ## having instance methods does not protect again procedural code> > i believe theres middle ground there :> >    -> >    mockito project contains a lot of small utility stateless objects that>    are supporting mockito features these are usually collections tools>    reflection tools those could are good candidate for static methods>    objects like fieldsetter fieldcopier lenientcopytool could be nice>    candidate for static methods>    -> >    mockito features could be backed by object instances objects like>    mockitocore mockcreationvalidator argumentmatchingtool are candidate>    to stay objects> > —> you are receiving this because you modified the open/close state> reply to this email directly view it on github>  or mute the thread>   || this feels like a misuse of the default methods || i think you mean static-methods in interfaces here? default-methods require an instance to be called onanyway i dont think that it is a good idea  it would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods imho a class with private constructor is the best construct to do this || > > thought: when we switch to java 8 we can use interfaces with default> > methods> > default-methods require an instance to be called oni was thinking exactly that default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface) || @christianschwarz what do you think to continue the work here with the middle ground described [here]( ? || i am attempting to refactor the matcherbinder class to a static utility class and am having trouble refactoring the following from mockhandlerimpltestjava: `handlermatchersbinder  new matchersbinder() {            public invocationmatcher bindmatchers(argumentmatcherstorage argumentmatcherstorage invocation invocation) {                throw new invaliduseofmatchersexception()            }} `how can i maintain the abstract class definition when i am not able to create an object of matcherbinder?any help is appreciated!  || lets close this ticket refactorings can be done as needed as we work with the code || ";1;0;refactored allinvocationsfinder and verifiableinvocationsfinder to static utility classes (#426);
516;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace testbase#assertnotcontains(string sub  string string) with as…;…sertj #doesnotcontain(charsequence sequence);;0;inetaddressesforstring throws illegalargumentexception on valid ipv6 address; <b>what steps will reproduce the problem?</b>1 inetaddressesforstring("": 6 4 2:1"")<b>what is the expected output? what do you see instead?</b>i expect a javanetinet6address objectinstead i get exception: ""javalangillegalargumentexception: : 6 4 2:1 is not an ip string literal""<b>what version of the product are you using? on what operating system?</b>guava-r07 // compiled from inetaddressesjava (version 15 : 490 super bit)windows xp professional 32bit<b>please provide any additional information below</b>cases: ""8 6 4 2:1"" ""0 6 4 2:1"" " 6 4 2:1"" "": 5 3 1"" works all right it happens when only the first group are zeros (suppressed to double colons)http://wwwfaqsorg/rfcs/rfc1884html"; ;;;;0;1;;
516;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace testbase#assertnotcontains(string sub  string string) with as…;…sertj #doesnotcontain(charsequence sequence);;0;replace testbase#assertnotcontains(string sub string string) with as…;…sertj #doesnotcontain(charsequence sequence);    ;;;;1;1;replace testbase#assertnotcontains(string sub string string) with assertj #doesnotcontain(charsequence sequence);
516;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace testbase#assertnotcontains(string sub  string string) with as…;…sertj #doesnotcontain(charsequence sequence);;0;fix sql formatter and add tests;;;;;;1;1;fix sql formatter and add tests;
516;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace testbase#assertnotcontains(string sub  string string) with as…;…sertj #doesnotcontain(charsequence sequence);;0;adding utility functions for observables of strings useful for processing non blocking io;i started developing this for use with the rxjava-apache- contrib module to safely and scalable decode infinite observables of byte arrays into strings but thought it should live in core because it could be useful for non blocking disk ioi did not make this part of rxobservable because these operators only work on observables of string the drawback is that discoverability will be harder;"#441  #442 #451 looking at this more this seems to fit better as a contrib module nowhere else in rxjava do we have utility classes for doing specific types of data manipulation once we have string manipulation well open the door for all kinds of others similar to how swing and android utilities are in a separate jar should we have a data-transformations contrib module where this stuff goes? || there are these four that operate on observables of numbersrxobservablesum(observable<integer>)rxobservablesumdoubles(observable<double>)rxobservablesumfloats(observable<float>)rxobservablesumlongs(observable<long>) || the various aggregation operators like sum are unfortunately monomorphic because java (and net) lack a type like scalas  however if you squint your eyes the various aggregates are generics i agree with ben that it is best to keep the core as polymorphic and tight as possible that is operators on observable<t> where t is a set of types > 1 and have a (hopefully) thriving ecosystem of ""domain specific"" operations to a contrib modulethere are a couple of tricks that we can pull to still allow for a fluent coding style || i wasnt trying to highlight how monomorphic aspect but that it seems inconsistent to the accumulation of javalangnumber (sum) to exist in the core but not the accumulation of javalangstring (concat) to also be part of the coreill rejigger the pr to put it in a new module so this can be closed || [rxjava-pull-requests #455 much better  just a question on the `assertobservable` class that doesnt feel like its in the right place || [rxjava-pull-requests #469 [rxjava-pull-requests #470]( failurelooks like theres a problem with this pull request || [rxjava-pull-requests #471 looks good || ";;;;1;1;setting the up that string test to use core test;
519;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fixed all fields set to null;as entry.setfield() does not accept a null argument anymore  the method entry.clearfield() is used instead.;;0;iterablestomap; ive implemented a method to create a map from an iterable that might be useful:public static &ltef> map&ltfe> tomap(iterable&lte> iterable final function<? super e ? extends f> keyselector)public static &ltefg> map&ltfg> tomap(iterable&lte> iterablefinal function<? super e ? extends f> keyselectorfinal function<? super e? extends g> valueselector)the implementation and test ist appended; well its still a good idea to share you never know how many people might want to do the same thing!it would be great if we had some kind of ""guava-extensions"" project that would contain all the nice extensions / utility methods that build upon guava but werent included in guava proper (because the library would be to big) || ";;;;0;1;;
519;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fixed all fields set to null;as entry.setfield() does not accept a null argument anymore  the method entry.clearfield() is used instead.;;0;replace testbase#assertcontains(string sub string string) with asser…;…tj #contains and #hasmessagecontaining;  519   lgtmit was a very ungrateful work thanks pascal! ||;;;;1;1;replace testbase#assertcontains(string sub string string) with assertj #contains and #hasmessagecontaining;
519;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fixed all fields set to null;as entry.setfield() does not accept a null argument anymore  the method entry.clearfield() is used instead.;;0;ask for partition info in exponentially increasing batch sizes;this should help speed up trivial queries (eg limit) when the number of candidate partitions is large and the partition information hasnt been cached yet;;;;;1;1;ask for partition info in exponentially increasing batch sizesthis should help speed up trivial queries (eg limit) when the number of candidate partitions is large and the partition information hasnt been cached yet;
519;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fixed all fields set to null;as entry.setfield() does not accept a null argument anymore  the method entry.clearfield() is used instead.;;0;operator generate again;issue #49- updated tests to use testscheduler- removed class timespan and the timeselectors are expected to return a nanosecond-resolution value;#447  a small tip about github: you can continue to push any commits to your remote branch the pull request will be updated automaticallyif you find some conflicts between your remote branch and your local branch you can use `--force` to override your remote branch by force github will keep the pull request consistent with your remote branch i think its better than opening another pull request || @zsxwing i know my very first pull was such but i received the tip to use clean branches especially when the master changes above me || do you mean  ? i think @benjchristensen was suggesting `git rebase` || in addition if its hard to rebase it on master i also think a new pull request is good || > removed class timespan and the timeselectors are expected to return a nanosecond-resolution valuewe need to support `long delaytime timeunit unit` as discussed at: ||;;;;0;1;;
523;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;made some timeouts in verificationafterdelaytest and verificationwith…;…timeouttest more lenient to prevent frequent build failures on travis ci;;0;preconditionscheckelementindex with desctemplate and descargs; it seems for me that preconditions class missing checkelementindex() method with template and varargs just like for checkargument() or checknotnull() methodsi suggest this implementation:&nbsp/**&nbsp&nbsp\* ensures that {@﻿code index} specifies a valid <i>element</i> in an array list or string of size&nbsp&nbsp\* {@﻿code size} an element index may range from zero inclusive to {@﻿code size} exclusive&nbsp&nbsp\* &nbsp&nbsp\* @﻿param index a user-supplied index identifying an element of an array list or string&nbsp&nbsp\* @﻿param size the size of that array list or string&nbsp&nbsp\* @﻿param desctemplate the message template to use to describe this index in an error message&nbsp&nbsp\* @﻿param descargs the arguments to be substituted into the message template&nbsp&nbsp\* @﻿return the value of {@﻿code index}&nbsp&nbsp\* @﻿throws indexoutofboundsexception if {@﻿code index} is negative or is not less than {@﻿code size}&nbsp&nbsp\* @﻿throws illegalargumentexception if {@﻿code size} is negative&nbsp&nbsp*/&nbsppublic static int checkelementindex(int index int size&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp@﻿nullable string desctemplate&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp@﻿nullable object descargs){&nbsp&nbsp// carefully optimized for execution by hotspot (explanatory comment above)&nbsp&nbspif (index < 0 || index > size){&nbsp&nbsp&nbspthrow new indexoutofboundsexception(badelementindex(index size format(desctemplate descargs)))&nbsp&nbsp}&nbsp&nbspreturn index&nbsp}; what he said  thanks for the report--- ;;;;0;1;;
523;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;made some timeouts in verificationafterdelaytest and verificationwith…;…timeouttest more lenient to prevent frequent build failures on travis ci;;0;made some timeouts in verificationafterdelaytest and verificationwith…;…timeouttest more lenient to prevent frequent build failures on travis ci;  523  **< ;;;;1;1;made some timeouts in verificationafterdelaytest and verificationwithtimeouttest more lenient to prevent frequent build failures on travis ci;
523;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;made some timeouts in verificationafterdelaytest and verificationwith…;…timeouttest more lenient to prevent frequent build failures on travis ci;;0;fix benchmarks;;;;;;1;1;fix broken show table test;
523;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;made some timeouts in verificationafterdelaytest and verificationwith…;…timeouttest more lenient to prevent frequent build failures on travis ci;;0;feature request: add filternot to scala language adapter for observable;scala has the syntax filter/filternot as being pretty standard it would nice to embed the filternot directly into the language adapter for observable;@headinthebox has accepted this and while doing so will review other scala collection methods as well || @headinthebox @zsxwing  do either of you want to do this? || ok i will take it ||;;;;0;1;;
525;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;add regression test for #508;as mentioned in the bug report for #508   adds a test which would catch this issue if it happened to regress in the future.;;0;iterablesreverse(list) has been deprecated too early; i dont think this method should be @﻿deprecated yet because its replacement is still @﻿beta; ;;;;0;1;;
525;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;add regression test for #508;as mentioned in the bug report for #508   adds a test which would catch this issue if it happened to regress in the future.;;0;fix starvation (task should run if the query is not done);;;;;;1;1;fix starvation (task should run if the query is not done);
525;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;add regression test for #508;as mentioned in the bug report for #508   adds a test which would catch this issue if it happened to regress in the future.;;0;bugfix: handling of terminal state for behavior/publish subjects;- they were not correctly emitting oncompleted when new observers subscribed after the subject was terminated- added same logic that already existed on asyncsubject;#453;;;;1;1;bugfix: handling of terminal state for behavior/publish subjects- they were not correctly emitting oncompleted when new observers subscribed after the subject was terminated- added same logic that already existed on asyncsubject;
525;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;add regression test for #508;as mentioned in the bug report for #508   adds a test which would catch this issue if it happened to regress in the future.;;508.0;add regression test for #508;as mentioned in the bug report for #508  adds a test which would catch this issue if it happened to regress in the future; ;mockitowhen() fails when method could originate from superclass or interface;i was testing/rebuilding a project with the latest mockito 20-beta when i noticed a couple of tests had started failing looked into why and was able to reduce the issue to [a reproducible test case]( it looks like the problem is somehow caused by the method signature for `getfoo()` the subclass gets this method from two places the superclass with generic return type and from the interface with a concrete one and this seems to be confusing mockito the test works with 11019 but fails with 2090-beta (/latest head)ps feel free to replace the title with something more descriptive;"i think this is an issue with bytebuddy wdyt @raphw? || ~~@hansjoachim have you tried other mockito 2 beta versions ?~~ not needed i did a `git bisect` || byte buddy overrides the method as follows:``` javapublic string getfoo() {  return (string) mockmethodinterceptor$dispatcherdefaultingtorealmethodinterceptsupercallable(    this    mockitointerceptor     cachedmethod     new object[0]    new foo$sub$mockitomock$58829931$auxiliary$ey71zqfr(this)  )}```this is the expected value does not look like a byte buddy related problem to me || after a `git bisect` the problem appeared with this commit 7fabd84fdfb2f80f8c135fe3865263c684c0d4e7```~/opensource/mockito ± ❯ git bisect bad~/opensource/mockito ± ❯ git bisect good v2026-betagit bisect run /gradlew :test --tests ""orgmockitousagebugsconfusedsignaturetest""[7fabd84fdfb2f80f8c135fe3865263c684c0d4e7] updated to byte buddy 07: adds support for preserving generic type information at runtimerunning /gradlew :test --tests orgmockitousagebugsconfusedsignaturetestparallel execution is an incubating feature compilejava up-to-date compilegroovy up-to-date processresources up-to-date classes up-to-date jar up-to-date assemble up-to-date compiletestjava up-to-date compiletestgroovy up-to-date processtestresources up-to-date testclasses up-to-date test up-to-date check up-to-date build up-to-dateversion: 2031-beta  some input files use or override a deprecated apinote: recompile with -xlint:deprecation for detailsnote: some input files use unchecked or unsafe operationsnote: recompile with -xlint:unchecked for details:processresources up-to-date compiletestjavanote: some input files use or override a deprecated apinote: recompile with -xlint:deprecation for detailsnote: some input files use unchecked or unsafe operationsnote: recompile with -xlint:unchecked for details:processtestresources up-to-date testobjc[46062]: class javalaunchhelper is implemented in both /library/java/javavirtualmachines/jdk180_77jdk/contents/home/bin/java and /library/java/javavirtualmachines/jdk180_77jdk/contents/home/jre/lib/libinstrumentdylib one of the two will be used which one is undefinedorgmockitousagebugsconfusedsignaturetest > should_work failed    orgmockitoexceptionsmisusingmissingmethodinvocationexception:    when() requires an argument which has to be a method call on a mock    for example:        when(mockgetarticles())thenreturn(articles)    also this error might show up because:    1 you stub either of: final/private/equals()/hashcode() methods       those methods *cannot* be stubbed/verified       mocking methods declared on non-public parent classes is not supported    2 inside when() you dont call method on mock but on some other object        at orgmockitoexceptionsreportermissingmethodinvocation(reporterjava:102)        at orgmockitointernalmockitocorestub(mockitocorejava:64)        at orgmockitointernalmockitocorewhen(mockitocorejava:76)        at orgmockitomockitowhen(mockitojava:1615)        at orgmockitousagebugsconfusedsignaturetestshould_work(confusedsignaturetestjava:16)30 tests completed 1 failed 29 skipped:test failedfailure: build failed with an exception* what went wrong:execution failed for task :test> there were failing tests see the report at: file:///users/brice/opensource/mockito/build/reports/tests/indexhtml* try:run with --stacktrace option to get the stack trace run with --info or --debug option to get more log outputbuild failedtotal time: 5939 secs7fabd84fdfb2f80f8c135fe3865263c684c0d4e7 is the first bad commitcommit 7fabd84fdfb2f80f8c135fe3865263c684c0d4e7author: rafael winterhalter <rafaelwth@webde>date:   thu nov 12 11 07 2015 +0100    updated to byte buddy 07: adds support for preserving generic type information at runtime    for users of mockito this version brings the following advantages:    1 a mocked method contains its generic type: a mocked method of type list<string> will not be erased to list many frameworks / libraries extract this information and would then react differently when encountering an instance of the mock class compared to the original class    2 bridge methods can only be resolved appropriately when the generic type information is processed this allows for a reliable recovery of ""visibility bridges"" which are no true bridges and are now reliably mocked:100644 100644 d27873a17388f63c683339dfaa640d35f0ac27ed 72f5bb3fbdf07ea04900c195c46ab3990f91135b m  buildgradle:040000 040000 20affcb117604ba6251e1195c1820ffb09664cec aa31f07848d605ab4564587afa2c5b63daf5fca7 m  srcbisect run success``` || strangely enough when setting a breakpoint the interceptor method does not seem to be invoked i will look into it probably a problem with resolving bridge methods || yes it is weird the issue seems to have been introduced by bytebuddy 07 || things that matter im using java 17```~/opensource/mockito ± ❯ java -versionjava version ""170_80""java(tm) se runtime environment (build 170_80-b15)java hotspot(tm) 64-bit server vm (build 2480-b11 mixed mode)``` || @raphw yup the test fails with `missingmethodinvocationexception` || i found the problem the bridge method is no longer identified for some reason it seems like byte buddy struggles to determine the bridge methods target i am going to fix this asap || i  it still cleaning up for a new byte buddy release should be fixed by tomorrow or latest friday || thanks @raphw ! || thank you ive tested again and its working now :)i didnt see any tests added alongside the fix and since it seems this bug was introduced a while back i wonder if there should be one to catch regressions if youd like to i can submit the test i made above in a pr i wasnt really sure where to place the test so if you have any suggestions for this or general style guidelines just let me know || the regression test was added to bytebuddy which is the dependency with the fixed bug however adding a regression test in mockito seems fair too i would add the test in the bugs package inside mockitousage iirc || ";1;0;slightly more descriptive test name;
528;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;missing generics info on collection matchers;follow up on #510 (issue #194) following this comment   basically it tweaks the collection matchers with generic support. it should have bee in abf9851.;;0;omnibus issue for release08 futuresmakelistenable improvements;  makelistenable(somefuture) now catches any runtimeexception thrown by somefutureget() and invokes the user callback at that point  in short it treats a never-wrapped runtimeexception like an executionexception  this prevents an unexpected runtimeexception from breaking callback invocation- if the future is already completed makelistenable now enqueues its  listeners inline instead of in an executor thread  note that the actual execution of the listeners still occurs in the threads associated with them in addlistener so this change is only an optimization except in the case of executors like samethreadexecutor (which of course should only be used in cases where this distinction is unimportant :))- makelistenable now gives its threads meaningful names  the current form is ""listenablefutureadapter-thread-%d"""; ;;;;0;1;;
528;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;missing generics info on collection matchers;follow up on #510 (issue #194) following this comment   basically it tweaks the collection matchers with generic support. it should have bee in abf9851.;;0;fix calls to optionalget() without optionalispresent();;;;;;1;1;fix calls to optionalget() without optionalispresent();
528;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;missing generics info on collection matchers;follow up on #510 (issue #194) following this comment   basically it tweaks the collection matchers with generic support. it should have bee in abf9851.;;0;operation groupbyuntil;"issue #52- added variance to ""lambda"" parameters- using publishsubject as it now properly handles subscriptions after its terminal statecant do much about the scala tests failing";"#457 @akarnokd while reviewing this @headinthebox and i were comparing with c# and this looks similar so i need to validate the licensing and copyright is this copy-paste-modified from the rxnet codebase or just inspired by and written from scratch? the rxnet code is open source but i need to validate with legal how to represent the licenses and copyrights if this is from there || factually ive written it from scratch based on the join() operators pattern but i took a strong inspiration for the join() operator from the rxnet sources i didnt copy-paste the operators code but only the test strings from one of the rxnet tests of this operator the operator looks similar but since groupedobservable is not an interface in rxjava i had to work around it with the publishsubject otherwise i would say the same behavior can be expressed in java very look-alike i admit i havent bothered giving different names to classes and fields i believe with the given rxjava style constraints there was only one way to implement these operators which thereby look almost the same as the rxnet versionsi certainly dont want to fall into an oracle vs google situation but unfortunately certain patterns are already established in rxjava i could have used locks ignored the try-catches used different names etc (when i started my r4j library back in 2011 there was no source code available no documentation but only a bunch of videos and blog posts: i had no choice but work from them and have a truly ""clean room"" implementation) so lets say there werent any rxnet sources available today but the api documentation would be extensive i could almost certainly do most operators from scratch and in the ""java way"" but unfortunately the documentation is inadequate and the aim to produce compatible behavior makes me look at the c# code to figure out the missing logic i guess half of the rxjavas bugs came from this situationi whish to be a valuable part of the rxjava community and see the reactive concept to become mainstream and ""standard"" in java please advise given the constraints how i can avoid such situations in the future || thank you for the details im just being cautious to make sure things are good and i very much appreciate your involvementim still clarifying some things with legal to understand what ""derivative"" means and if we need to include notices copyrights etc from the c# code > but unfortunately the documentation is inadequate and the aim to produce compatible behavior makes me look at the c# code to figure out the missing logic i guess half of the rxjavas bugs came from this situationthis is correct and why now with @headinthebox involved were fixing nuanced bugs that resulted from desired behavior not being clear in the signature or documentation > i whish to be a valuable part of the rxjava community and see the reactive concept to become mainstream and ""standard"" in java please advise given the constraints how i can avoid such situations in the futurethank you for getting involved and please continue to be so im just making sure we figure this out now rather than down the road || ive talked with legal and are good to go basically add any notices/copyrights if needed and if not needed then just the apache license header like all other files in this projectcan you rebase this so it can be merged? the master branch has changed enough that this conflicts now right away || ";;;;0;1;;
528;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;missing generics info on collection matchers;follow up on #510 (issue #194) following this comment   basically it tweaks the collection matchers with generic support. it should have bee in abf9851.;;194.0;missing generics info on collection matchers;follow up on #510 (issue #194) following this comment  it tweaks the collection matchers with generic support it should have bee in abf9851;;tweaks matchersany family matchers behavior;this issue is a follow up of the work started in #141 by @pimterry also heres an extract of a message on [this thread]( of the mailing list :---the origin of these methods is they come from `anything` ie anything matches later for shortness and cast avoidance the aliases grew but the api naming thus became inconsistent with what a human would expect so this behavior is being changed in mockito 2 beta to be precise heres the status on these api in the version 205-beta :- `any` `anyobject` `any(class)` wont check anything (at first they were just aliases for _anything_ and for cast avoidance) `null` is a valid value- `anyx` like `anystring` will check the arg is not `null` and that has the correct type- `anylist` will check the argument is not null and a `list` instance- `anylistof` (and the likes) at the moment are just aliases to their non generic counter part like `anylist`note this is work in progress (started here in 141]( these new behavior can / will change in the beta phase im especially wondering if the `any` family should allow `null` and if not do a type check for example with these matchers : - `any` `anyobject` stay the same they currently allow `null` and dont have to do type check anyway- `any(class)` currently allows `null` and doesnt do type check > allows `null` and if not checks for the given type- `any<collection>of` currently doesnt allow `null` and does a type check of the collection not elements > allows `null` if not checks collection type if not empty checks element typemaybe extend/create a _symmetric_  `isa` family api that wont allow any `null` arguments---;"`any` family is currently _(at his time up to 205-beta)_ inconsistent on the way they allow or not `null`s type checking is ok but `null` check behavior consistency is also important || anyx gramtaically tends to imply to return false for null because anyobject is not null i agree completely the api should be consistenton sun apr 5 2015 11:54 brice dutheil notifications@githubcom wrote:> any family is currently _(at his time up to 205-beta)_ inconsistent on> the way they allow or not nulls type checking is ok but null check> behavior consistency is also important> > ## > > reply to this email directly or view it on github>  || > anyx gramtaically tends to imply to return false for null because any object is not nullim not anymore of sure of that anyway the changes introduced in this api make it inconsistentthats why i propose any validates `null` and if not `null` then validates the typealso on the mentioned thread _francisco olarte_ was proposing a `anynotnull` family this could clarify the behavior on `null` of these apis || agreed any should return false for null and false for wrong type (instanceof) otherwise i think it would violate the principle of least surpriseon sun apr 5 2015 12:57 brice dutheil notifications@githubcom wrote:> anyx gramtaically tends to imply to return false for null because any> object is not null> > im not anymore of sure of that anyway the changes introduced in this api> make it inconsistent> thats why i propose any validates null and if not null then validates> the type> > also on the mentioned thread _francisco olarte_ was proposing a anynotnull> family this could clarify the behavior on null of these apis> > ## > > reply to this email directly or view it on github>  || i see anystring() ( and friends ) checking for null and anyobject() not doing it as an inconsistency potentially leading to user surprise object is as much of a class as string ( or other )other thing is i fail to see is the difference ( if there is any ) between isa(klazz) and notnull(klazz) ( or isnotnull but i see that one is a forwarder ) to me they seem they do the same given the docs but the code is different and im not familiar enough with it to assert they do the same thing when doing dsl helper libraries ive found ( the hard way ) having slightly different names for the same thing seems a good idea initially but leads to problem along the way so i would vote for just having one of notnull/isnotnull ( and isa if it is functionally equivalent ) || i think there might be confusion here: @szczepiq i dont think the two of you are agreeing @bric3 seems to be saying that `any` should match nulls and anynotnull should exist (and presumably not match null) while youre saying that `any` should not match nulli think the problem here is that theres two use cases that currently arent clearly separated both of which we need to support1 i dont care what the value im matching is _at all_ i want a very simple intuitive wildcard matcher that will match absolutely anything and will compile with no extra effort (so no casts)2 i care about the type of the value that im matching but no details beyond that i want a matcher that will not match values with the wrong typei think both of these are major common use cases if we make any of the `anyx()` methods reject nulls they no longer support the first case and if we leave it as-is then they currently appear to support the 2nd case but arent really doing so which is where all this came from originallyi do think any api that supports use case 2 should reject nulls by default: if youre asserting specifically on the type of the value we should push people to be clear about whether or not null is valid in the given case i think an api for use case 1 should not reject nulls because you want to match _everything_these are two quite different apis though and to get any kind of api consistency were going to need them to be separate sets of methods i suggest:- `any()` - matches absolutely anything including nulls as a generic method returning t (as now)- `anyasx()` and `anyas(xclass)` - matches absolutely anything including nulls as a generic method returning x  - this is as in 19 but with the names changed to make it clear that this is purely a type casting concern not type checking and intentionally being a bit more verbose to discourage unnecessary use  - note that as of java 8 target type inference considers method arguments so you should be able to use `any()` in every case except choosing between overloaded methods (pretty rare?) in addition note that java 7s final update is this month and then its unsupported  - wed also obviously document that users should prefer isa etc if they want to check the type but i think its much more obvious that `anyasstring()` isnt actually checking the values a string (unlike `anystring()` which did suggest that)- `isa/isan(xclass)` and `isanx()` - matches on type rejecting nulls- `isnulloran(xclass)` and `isnulloranx()` - matches on type accepting nullsi think this makes for a relatively small change so gives fairly easy migration but makes it clear that the `any()` methods are all just generic wildcards (for use case 1) and provides a clear set of other methods to support actual type checking and pushing users to be clear about nullability along the way (for use case 2)the only other option i can see we might want to do is stop supporting use case 1 entirely make everybody be much more specific about what they want and reject nulls everywhere i think use case one is likely to be the most common case for use argument matchers anywhere though far more than anything else and we definitely definitely need to support it as an intuitive easy first-class citizenthoughts? do people agree both use cases are common and important? does anybody have a better solution to help us get both while keeping a sensible consistent api? || on tue apr 7 2015 at 5:12 pm tim perry notifications@githubcom wrote:> these are two quite different apis though and to get any kind of api> consistency were going to need them to be separate sets of methods i> suggest:> - any() - matches absolutely anything including nulls as a generic>   method returning t (as now)> - anyasx() and anyas(xclass) - matches absolutely anything including>   nulls as a generic method returning x>   - this is as in 19 but with the names changed to make it clear>     that this is purely a type casting concern not type checking and>     intentionally being a bit more verbose to discourage unnecessary use>   - note that as of java 8 target type inference considers method>     arguments so you should be able to use any() in every case except>     choosing between overloaded methods (pretty rare?) in addition note that>     java 7s final update is this month and then its unsupported>   - wed also obviously document that users should prefer isa etc if>     they want to check the type but i think its much more obvious that>     anyasstring() isnt actually checking the values a string (unlike>     anystring() which did suggest that)>     - isa/isan(xclass) and isanx() - matches on type rejecting nulls> - isnullor(xclass) and isnullorx() - matches on type accepting nulls> > i think this makes for a relatively small change so gives fairly easy> migration but makes it clear that the any() methods are all just generic> wildcards (for use case 1) and provides a clear set of other methods to> support actual type checking and pushing users to be clear about> nullability along the way (for use case 2)> > the only other option i can see we might want to do is stop supporting use> case 1 entirely make everybody be much more specific about what they want> and reject nulls everywhere i think use case one is likely to be the most> common case for use argument matchers anywhere though far more than> anything else and we definitely definitely need to support it as an> intuitive easy first-class citizen> > thoughts? do people agree both use cases are common and important? does> anybody have a better solution to help us get both while keeping a sensible> consistent api?​i agree all are used and importantsim still struggling with the difference between `isnullor(xclass)` and `anyas(xclass)` the only difference i see is if i have a class `a` with a subclass `suba` and a class `b` with a subclass `subb` and a couple of methods `m(a)` and `m(b)` is that `m(anyas(subbclass))` will select `m(b)` and match on a `b` but `m(isnullor(subbclass)` will select it and match only on a `subb` so i could have a broader matcher for `m(isnullor(bclass))`even if this is the case i would just suppress the `anyas(xclass)` as my contrived example could be better written as `anyas(bclass)` in which case i would rename isnullor to any and isa to anynotnull in the naming side i find `any()` ​natural `anyas` forced as i consistently read `any(xclass)`as _any thing which can be assigned to a variable of type x_so i would end up with only two method names any and `anynotnull` with a parameterless plus a class parameter variant ( discounting typeing helpers like `anynotnullstring`) which would work:1 `anynotnull` in any variant does not accept nulls any does2 a parameterless `any()`/`anynotnull()` is equivalent to the same method with the declared parameter class note if you can use `any[notnull]()` in the methods there are no overloads and the language guarantees i cannot use an incorrect typeso if i have a method `m(list l)` `m(any(arraylistclass))` would match anything which can be stored in an `arraylist` var subclasses and `null` included and `anynotnull(arraylistclass)` will need a not null one `m(any())` would exactly as `m(any(listclass))` mockito cannot check it but i cannot write code to call `m` with a non-list argument java is type checked same goes for `anynotnull`otoh if i have `m(set s)` too i must use `m(any(setclass))` or `m(any(listclass))` just to resolve the overload although in this case the matcher type checking is superfluousi do not see the point on `any(xclass)` not checking the type and having `isa(xclass)` which does it seems confusing to me so my proposal is basically zapping any of the variants i mean from the description in the overloaded method `m(any(arraylistclass))` will select the list variant butmatch a call with any `list` subtype while `isnullor(arraylistclass)` will only match `arraylist`s ? i do not see this has any real use ( the parameter type must be accessible in the test if you want any list use `isnullor(listclass)`)maybe im missing something but i see `any(xclass)` redundant better served  isnullor` the rest is just naming disagreement​francisco olarte​ || the issue with getting rid of `anyas(xclass)` is that we want two things:- a way to match an argument without checking anything about its value (any)- a way to match an argument and check its type (isa)i think your solution is to just use `any()` with no parameter everywhere to cover the first case and specify the type when you want the 2nd case that wont work because target type inference doesnt work for method arguments in java < 8 so its impossible to use any() without an argument (unless the parameter is just `object` typed)specifically in java 7 the below wont compile:``` javaclass x {   public bool method(list l) {  }}x x  mock(xclass)// error: method(javacollectionslist) cannot be applied to (javalangobject)when (xmethod(any())thenreturn(true)```anybody on java < 8 has to specify the type every time they match anything or its impossible to make it compile they can never really use `any()` they always have to use `any(xclass)` (or equivalent) we need a way in java 7 that you can say match absolutely anything please that compiles and i think `any(xclass)` or equivalent is the only optionif you make that `any(xclass)` matcher check the type (as you suggest) then it no longer matches everything any more and it becomes impossible to wildcard match everything in java < 8 (without casting but that would be pretty nasty)therefore if you want to be able to both match specific types and wildcard match everything in java < 8 you have to have two separate apis to do so the names of those apis need to clearly tell the user which of those two things theyre doing (match anything but cast the matcher to make it compile vs match only this type)i dont think thats avoidable im very happy to take better suggestions for `anyas(xclass)` that make it clearer its just a convenient casting method (without making it so nasty that it stops being convenient) but that method does still need to exist i thinkin addition to all that: wed rather the match a specific type matcher didnt accept nulls by default (as your `any(listclass)` does) we need to make people opt in to matching nulls because its good practice and because theres some potentially confusing behaviour there as nulls are kind of outside the type system we also cant have the wildcard matcher reject nulls or its not matching everything any more thus again they need to be two different methods || hi tim:on tue apr 7 2015 at 7:37 pm tim perry notifications@githubcom wrote:> the issue with getting rid of anyas(xclass) is that we want two things:> > a way to match an argument without checking anything about its value (any)> a way to match an argument and check its type (isa)> > i think your solution is to just use any() with no parameter everywhere to cover the first case and specify the type when you want the 2nd case that wont work because target type inference doesnt work for method arguments in java < 8 so its impossible to use any() without an argument (unless the parameter is just object typed)i dont think youve understood my solution from the previouslypropossed one ( any() + anyas(class) + isa(class) + isnullora(class) (- notnull() which is in another place ) i propose to remove anyas  given it does not check type rename isa(class) to anynotnull(class)  rename isnullora(class) to any(class) and rename ( or forward )  notnull() to anynotnull()> specifically in java 7 the below wont compile:> > class x {>    public bool method(list l) {  }> }> > x x  mock(xclass)> > // error: method(javacollectionslist) cannot be applied to (javalangobject)> when (xmethod(any())thenreturn(true)perfect in this case you use the propossed isnullora(class) which iproposed to rename as any(class)also just grepped and got this from one of my test files:```    ac1  mock(autocallerclass)    when(ac1makecall((accallrequest) any()))thenreturn(resp1)```in case you wonder autocaller is an interface with a method""makecallresponse makecall(accallrequest)"" not overloadedi think this is clearly superior in java 7 ( im unable to use java 8on those projects due to problems with the app server ) the any()conveys the i do not care just make this compile and the castclearly says this is due to one of those java 7 shortcomings to me> anybody on java < 8 has to specify the type every time they match anything or its impossible to make it compile they can never really use any() they always have to use any(xclass) (or equivalent) we need a way in java 7 that you can say match absolutely anything please that compiles and i think any(xclass) or equivalent is the only optionwhich is what i proposed you have isnullora(class) which coversthis correct me if wrong> if you make that any(xclass) matcher check the type (as you suggest) then it no longer matches everything any more and it becomes impossible to wildcard match everything in java < 8 (without casting but that would be pretty nasty)it is the method has a declared argument type of list which meansthe compiler will check that when you use the mock inxmethod(whatever) whatever implements list so isnullora(listclass)or any(listclass) will allways match whatever with an extraredundant type check> therefore if you want to be able to both match specific types and wildcard match everything in java < 8 you have to have two separate apis to do so the names of those apis need to clearly tell the user which of those two things theyre doing (match anything but cast the matcher to make it compile vs match only this type)as i said im not knowdledgeable enough and havent got timepresently to dig through the sources if any(listclass) matches wheni pass an arraylist to the mock i can always wildcard by using thedeclared argument type> i dont think thats avoidable im very happy to take better suggestions for anyas(xclass) that make it clearer its just a convenient casting method (without making it so nasty that it stops being convenient) but that method does still need to exist i thinkforget about my proposed renaming with the any/anyas/isa/isnulloraproposal is there any case in which you must use anyas() which cannotbe solved by using isnullora(xclass)? i think they are synonims theproblem i see with anyas as stated is that in the previous example (without overloads ) i could code a matcher aswhen(xmethod(anyas(arraylistclass))) and it shoud fire ( as it doesnot check type ) when i do xmethod(new linkedlist()) i think this isconfusing and asking for problem and by making it check the type icould make when(xmethod(anyass(arraylistclass))) to catch onespecific thing and after that add when(xmethod(anyas(listclass)) fora catch all in java<8 or just plain any() in >8my proposal of getting rid of anyas can be read the other way makeanyas() check type and get rid of isnullorarepeating my self i proposed to get rid of anyas(class) as a i feelit seems to match something which it does not and it cannot doanything which cannot be done with isnullor(class) name it whateveris the functionality with worries me> in addition to all that: wed rather the match a specific type matcher didnt accept nulls by default (as your any(listclass) does) we need to make people opt in to matching nulls because its good practice and because theres some potentially confusing behaviour there as nulls are kind of outside the type system we also cant have the wildcard matcher reject nulls or its not matching everything any more thus again they need to be two different methodsthats another thing what i propose is to simplify so i have twonames ( anyincludingnull anynotnull ) which indicate wether null isaccepted plus two overrides no parameters and a class parameter thenull accepting behaviour is functionaly equivalent to haven just aname plus a boolean parameter ( notreallyany(boolean acceptnull) +notreallyany(boolean acceptnull class klass) )what makes me feel uncorfortable with the proposal is :- too many names i think two suffice- different names for similar methods similar names for different  null accepting behaviourgiven this i think:- anyincludingnul() anyincludingnul(class) anynotnull()  anynotnul(class) cover all cases for jdk <8 & 8 ( although  parameterless ones are not too useful in <8 ) ( your example would be  served by when(xmethod(anyincludingnull(listclass)) )- names should be kept paired you state opting in for nulls is good  practice ill accept that without discussion you say people should  opt in to use them i accept thas as a precondition writing  anyincludingnull is for me opting inbut then we want any() its nice sounds good it is short readsgood (any() in 8 i do not care just need this to compileany(listclass) in 7 i do not care but well then writing any( isopting in to use nulls so the class version should begin with any(too i have no problem with having the null accepting versionsnondefaultacceptingnullsanymatcher and the other one any orisa ides are really good at completing and i can easily manage acouple of names but having any anyas isa isnullora and notnullhorrifies mewell thats all for today i hope it clarifies my positionregards    francisco olarte || ok i think that mostly makes sense although im not clear exactly what the full api youre proposing is that fits the requirements here your last paragraph seems to contradict the four methods youve suggested just abovei think youre still suggesting an `any()` method with actively different behaviour to an `any(xclass)` method though inconsistencies between those two are how we ended up here because one does active type matching and the other doesnt and you need different null matching behaviour too in addition you definitely need `any()` or itll be confusing so i dont think theres any way you can have an `any(xclass)` method that does actual matchingsounds like there is a route through though: what happens if we accept that java 7 is on the way out stick only to casts and stop making the api confusing just to support now unsupported java versions? that would give an api of:- `any()` - matches anything- `isa(xclass)` - matches things with x type not nulls- `isnullora(xclass)` - matches things with x type or nullsif youre using java 8 all is good simple and clear if youre using java 7 you have to cast `any()` but `(myclass) any()` is clearer about what its doing than anything else we have here actually shorter than `any(myclassclass)` anyway and good ides will automatically suggest the cast for you too so pretty easy to find for newbies null behaviour is also clear here and were pushing people to be explicit about whether they match nulls in all arguments they care abouthow does that sound to everybody? || hi tim:on wed apr 8 2015 at 8:38 pm tim perry notifications@githubcom wrote:> ok i think that mostly makes sense although im not clear exactly what the full api youre proposing is that fits the requirements here your last paragraph seems to contradict the four methods youve suggested just aboveany of my paragraphs may seem contradictory but i do not know how toconvey the info and do not know what the exact requirements are butanyway lets go on> i think youre still suggesting an any() method with actively different behaviour to an any(xclass) method thoughin my full sugestion not exactly i suggested any to be the same asany(objectclass) ( declared parameter class really but it could beimplemented this way ) it checks the passed thing is null or asubclass of object ( second check redundant stated for completitude)> inconsistencies between those two are how we ended up here because one does active type matching and the other doesnt and you need different null matching behaviour too in addition you definitely need any() or itll be confusing so i dont think theres any way you can have an any(xclass) method that does actual matching> > sounds like there is a route through though: what happens if we accept that java 7 is on the way out stick only to casts and stop making the api confusing just to support now unsupported java versions? that would give an api of:> any() - matches anything> isa(xclass) - matches things with x type not nulls> isnullora(xclass) - matches things with x type or nullsim definitely in favour of sticking to casts as they are a standardlanguage feature and should be clearnow on your three proposed methods you are forgetting one which ison another part of the current api notnull() ( or its cousingnotnull(class) i do not know whic notnull is not declared genericlike any though i think it should be for java 8 )you have 2 choices 1- accept nulls 2-check class for 1 you needeither a boolean argument or different names for 2 you need a classargument to check against so in your proposal you would have:- accept nulls do not check class:  any() used as is in java 8  casted in 7 ( or for overload resolution in 8 )- accept nulls check class: isnullora(class)- reject nulls do not check class: notnull() ( same comments as any )- reject nulls check class: isa(class)which is fine dandy for me ( the naming stuff is trivial to achieveusing a franciscoolarteadditionalmatchers helper class )basically you can have a makematcher(boolean acceptnulls class klass) and then any()makematcher(true objectclass)isnullora(klass)makematcher(true klass)notnull()makematcher(false objectclass)isa(klass)makematcher(false klass)> if youre using java 8 all is good simple and clear if youre using java 7 you have to cast any() but (myclass) any() is clearer about what its doing than anything else we have here actually shorter than any(myclassclass) anyway and good ides will automatically suggest the cast for you too so pretty easy to find for newbies null behaviour is also clear here and were pushing people to be explicit about whether they match nulls in all arguments they care abouti think the null / check behaviour is clearer if you group themtogether somehow ( like ive done above ) as this gets rid of theconfusing (current) anyas(class) also i think notnull(class) must goas what is does is served by isa(class)> how does that sound to everybody?fine for me---------------not a proposal----------------now ill explain what i proposed ( for naming along with somemotivations ) i think this discussion seems to prove it is not easilyunderstood this is only for referencenote there are no functional changes with the proposal above justname reorganizations as i think current names are confusing ( and iknow they are for me but this is my problem and i can solve it )0- get rid of anyas and notnull(class) ( served by isa and isnullora )1- any() - keep as it is2- isnullora(class): rename to any(class) as functionality is verysimilar (any()isnullora(declaredparameterclassclass))3- isa() - rename to anynotnull ( it appears next to any() in methodslist and makes the behavioural differences easy to spot also if youhave a method any() and anynotnull ( both being offered byautocomplete ) is natural to assume that anyanyincludingnull whichis correct )4- notnull() - rename to anynotnull() ( to complete the matrix )note: in my naming proposal naked anyacceptnulls it could easily bereversed ( any>anyornull anynotnull>any it just sounds bad to methat way ( maybe because im used to x(object) and x(@nonnull object)and/or explicitly documenting when nulls are not allowed)extra things:- anyobject() - seems to do the same thing as any if so get rid of it  if to avoid confusion if not do the same as with anystring below- isnull(class) - given it can be done with (class)isnull() get rid  of it no need for a class checking version on this- anystring: confusing name with current behaviour given any() accept  nulls rename it to isastring and then per rule 3 above to  anynotnullstring then i would add an anystring equal to  isnullora(stringclass) or any(stringclass) per rule 2 also  consider deleting it (note below)- anyint/anychar/: as with anystring in nearly all aspects- anymap/anymapof ( and its friends anylist anycollection ): similar  to anystring rename to anynotnullmap and then use the now free  anymap to build one accepting nullsfor anystring/anyint/ i would consider having a basic matchersclass with any/anynotnull etc and a matchers derived class ( a laadditionalmatchers ) and relegate all aliases to that one so thejavadoc for the basic matchers class concentrates on basicfunctionality and the one for the aliases/forwarders just states theequivalence ) in fact i would better put a class for just the basicany\* matchers ( including just any() any(class) anynotnull()anynotnull(class) and isnull(class)) another one foreq/startswith/ another one for the anystring and friends staticimports make them easy to use in modern java and the documentationwould be much easier to read (for me at least)## hope this explains my visionregards   francisco olarte || i apologize i havent read the entire thread im still setting up myfamily in ca and trying to manage priorioritiesi think we have following use cases:1 i dont care about the parameter2 i care that it is not null3 i care about the type (implies (2))solutions:1) any() perhaps kill anyobject() needs explicit casting2) no special api kill isnotnull()/notnull() or just leave theisnotnull()/notnull() needs explicit casting3) any(stringclass) alias to isa(stringclass) (or kill isa())i think it is ok if only use case 3) offers api that avoids casting egif the user wants to avoid casting he needs to specify the matcher better(which i dont think is a problem)cheers!on thu apr 9 2015 at 2:39 am francisco olarte notifications@githubcomwrote:> hi tim:> > on wed apr 8 2015 at 8:38 pm tim perry notifications@githubcom> wrote:> > > ok i think that mostly makes sense although im not clear exactly what> > the full api youre proposing is that fits the requirements here your last> > paragraph seems to contradict the four methods youve suggested just above> > any of my paragraphs may seem contradictory but i do not know how to> convey the info and do not know what the exact requirements are but> anyway lets go on> > > i think youre still suggesting an any() method with actively different> > behaviour to an any(xclass) method though> > in my full sugestion not exactly i suggested any to be the same as> any(objectclass) ( declared parameter class really but it could be> implemented this way ) it checks the passed thing is null or a> subclass of object ( second check redundant stated for completitude> )> > > inconsistencies between those two are how we ended up here because one> > does active type matching and the other doesnt and you need different> > null matching behaviour too in addition you definitely need any() or> > itll be confusing so i dont think theres any way you can have an> > any(xclass) method that does actual matching> > > > sounds like there is a route through though: what happens if we accept> > that java 7 is on the way out stick only to casts and stop making the api> > confusing just to support now unsupported java versions? that would give an> > api of:> > any() - matches anything> > isa(xclass) - matches things with x type not nulls> > isnullora(xclass) - matches things with x type or nulls> > im definitely in favour of sticking to casts as they are a standard> language feature and should be clear> > now on your three proposed methods you are forgetting one which is> on another part of the current api notnull() ( or its cousing> notnull(class) i do not know whic notnull is not declared generic> like any though i think it should be for java 8 )> > you have 2 choices 1- accept nulls 2-check class for 1 you need> either a boolean argument or different names for 2 you need a class> argument to check against so in your proposal you would have:> - accept nulls do not check class: any() used as is in java 8>   casted in 7 ( or for overload resolution in 8 )> - accept nulls check class: isnullora(class)> - reject nulls do not check class: notnull() ( same comments as any )> - reject nulls check class: isa(class)> > which is fine dandy for me ( the naming stuff is trivial to achieve> using a franciscoolarteadditionalmatchers helper class )> > basically you can have a makematcher(boolean acceptnulls class klass> ) and then any()makematcher(true objectclass)> isnullora(klass)makematcher(true klass)> notnull()makematcher(false objectclass)> isa(klass)makematcher(false klass)> > > if youre using java 8 all is good simple and clear if youre using> > java 7 you have to cast any() but (myclass) any() is clearer about what> > its doing than anything else we have here actually shorter than> > any(myclassclass) anyway and good ides will automatically suggest the> > cast for you too so pretty easy to find for newbies null behaviour is> > also clear here and were pushing people to be explicit about whether they> > match nulls in all arguments they care about> > i think the null / check behaviour is clearer if you group them> together somehow ( like ive done above ) as this gets rid of the> confusing (current) anyas(class) also i think notnull(class) must go> as what is does is served by isa(class)> > > how does that sound to everybody?> > fine for me> > ---------------not a proposal----------------> now ill explain what i proposed ( for naming along with some> motivations ) i think this discussion seems to prove it is not easily> understood this is only for reference> > note there are no functional changes with the proposal above just> name reorganizations as i think current names are confusing ( and i> know they are for me but this is my problem and i can solve it )> > 0- get rid of anyas and notnull(class) ( served by isa and isnullora )> > 1- any() - keep as it is> 2- isnullora(class): rename to any(class) as functionality is very> similar (any()isnullora(declaredparameterclassclass))> 3- isa() - rename to anynotnull ( it appears next to any() in methods> list and makes the behavioural differences easy to spot also if you> have a method any() and anynotnull ( both being offered by> autocomplete ) is natural to assume that anyanyincludingnull which> is correct )> 4- notnull() - rename to anynotnull() ( to complete the matrix )> > note: in my naming proposal naked anyacceptnulls it could easily be> reversed ( any>anyornull anynotnull>any it just sounds bad to me> that way ( maybe because im used to x(object) and x(@nonnull object)> and/or explicitly documenting when nulls are not allowed)> > extra things:> - anyobject() - seems to do the same thing as any if so get rid of it>   if to avoid confusion if not do the same as with anystring below> - isnull(class) - given it can be done with (class)isnull() get rid>   of it no need for a class checking version on this> - anystring: confusing name with current behaviour given any() accept>   nulls rename it to isastring and then per rule 3 above to>   anynotnullstring then i would add an anystring equal to>   isnullora(stringclass) or any(stringclass) per rule 2 also>   consider deleting it (note below)> - anyint/anychar/: as with anystring in nearly all aspects> - anymap/anymapof ( and its friends anylist anycollection ): similar>   to anystring rename to anynotnullmap and then use the now free>   anymap to build one accepting nulls> > for anystring/anyint/ i would consider having a basic matchers> class with any/anynotnull etc and a matchers derived class ( a la> additionalmatchers ) and relegate all aliases to that one so the> javadoc for the basic matchers class concentrates on basic> functionality and the one for the aliases/forwarders just states the> equivalence ) in fact i would better put a class for just the basic> any\* matchers ( including just any() any(class) anynotnull()> anynotnull(class) and isnull(class)) another one for> eq/startswith/ another one for the anystring and friends static> imports make them easy to use in modern java and the documentation> would be much easier to read (for me at least)> > ## hope this explains my vision> > regards> francisco olarte> > ## > > reply to this email directly or view it on github>  szczepan faberfounder mockitoorg core dev gradleorgtweets as @szczepiq blogs at blogmockitoorg || hi szczepan:mmmm delicious top posting anyway:on thu apr 9 2015 at 3:59 pm szczepan faber notifications@githubcom wrote:> i think we have following use cases:> 1 i dont care about the parameter> 2 i care that it is not null> 3 i care about the type (implies (2))i think you lack at least one ( 4- i care it is null but it isalready served by isnull() ( or a casted null iirc ) not discussed )> solutions:> 1) any() perhaps kill anyobject() needs explicit casting> 2) no special api kill isnotnull()/notnull() or just leave the> isnotnull()/notnull() needs explicit casting> 3) any(stringclass) alias to isa(stringclass) (or kill isa())> > i think it is ok if only use case 3) offers api that avoids casting eg> if the user wants to avoid casting he needs to specify the matcher better> (which i dont think is a problem)i dont think casting specially in such a specialized case asmockiing in tests is an issue and j8 will avoid most of it what idislike of this is having mockm((string)any()) accept nulls andmockm(any(stringclass)) reject nulls isa sounds/reads fine to me iprefer anynotnull as name for 2 and 3 as it reads better highlightsthe relation with any ( they are the family of matchers which justchecks type not value ) but ive reached a point where i think theonly form to expose a proposal is to implement it to expose how itlooks which will have to wait in my casealso thinking about the previous stuff im beginnging to thinkisnullora(class) although it has a clear definition ( i have amockm(list) i want to match anything assignable to an arraylistwhich are null or arraylist subclasses so mockm(any(arraylist)) )im not too sure about its usefulness ( as i can do it with twomatchers and isnull plus an isa with the same target or useadditionalmatchersor )francisco olarte || i agree with francisco if were going for casts i dont think we can have `any(stringclass)` still exist because we cant make it usefully be consistent with `any()` i think just `isa` works fine for that case though and i find it quite readable and cleari do marginally prefer `notnull()` to `anynotnull()` just because its shorter and simpler i think `when(omethod(notnull() notnull()))` reads easier than `when(omethod(anynotnull() anynotnull()))` and while anynotnull makes sense in relation to any its less clear what it does when you see it standalone notnull however is very clear indeed it also doesnt feel quite so much like `any` and `notnull` are the same family as much as `isa/isnullora` are just because `any` is kind of a special case (any + specific values are all people will probably use 1/2 the time i expect)i also do think `isnullora(xclass)` does need to exist explicitly too just because its a common case and having to write `or(isnull() isa(stringclass))` (or `or((string) isnull() isa(stringclass))` for java 7) everywhere is quite substantially messier and harder to parse internally just being an alias to that is fine thoughdefinitely feels like were getting pretty close now! one more api update then:- `any()` - matches anything including nulls- `notnull()` matches anything except nulls- `isa(xclass)` matches things of x type except nulls- `isnullora(xclass)` matches things of x type including nulls- we get rid of every other variant (`anystring()` `isnotnull()` etc)i think there are some other extra variants we will still need for things like generic list type checks and varargs but those should follow on fairly cleanly from these thoughts? || hi time:on thu apr 9 2015 at 6:34 pm tim perry notifications@githubcom wrote:> i agree with francisco if were going for casts i dont think we can have any(stringclass) still exist because we cant make it usefully be consistent with any() i think just isa works fine for that case though and i find it quite readable and clearok> i do marginally prefer notnull() to anynotnull() just because its shorter and simpler i think when(omethod(notnull() notnull())) reads easier than when(omethod(anynotnull() anynotnull())) and while anynotnull makes sense in relation to any its less clear what it does when you see it standalone notnull however is very clear indeedok i donot agree with the arguments but i feel voting for notnull nowis much better than following the thread i retract all my proposalsfor anynotnull--- aside---> it also doesnt feel quite so much like any and notnull are the same family as much as isa/isnullora are just because any is kind of a special case (any + specific values are all people will probably use 1/2 the time i expect)> i think if you place them in a square it does isa is nw isnullora> is ne any is se ¿ which one goes into sw ? ( reminds me of the test> i did in school )also any() is like isnullora(objectclass) notnull() is likeisa(objectclass)not a proposal/discussion on the main issue just put here as anexplanation of my abandoned views--- /aside ---> i also do think isnullora(xclass) does need to exist explicitly too just because its a common case and having to write or(isnull() isa(stringclass)) (or or((string) isnull() isa(stringclass)) for java 7) everywhere is quite substantially messier and harder to parse internally just being an alias to that is fine thoughok with it> definitely feels like were getting pretty close now! one more api update then:> > any() - matches anything including nulls> notnull() matches anything except nulls> isa(xclass) matches things of x type except nulls> isnullora(xclass) matches things of x type including nulls> we get rid of every other variant (anystring() isnotnull() etc)> > i think there are some other extra variants we will still need for things like generic list type checks and varargs but those should follow on fairly cleanly from these thoughts?ok my main problem is i find current naming extremely confussingonce anyas is gone and replaced with ( more correct imo )  isnullorait nearly vanishes but if variants are recovered/kept ( i would do itin a separate class which could be very easily documented at the topand methods otherwise they clutter the main matchers docs classedare cheap specially in test code ) keep their name coherent to theimplementation ie givien anystring() can (should?) be implementedas isa(stringclass) to achieve current behaviour name it isastring()(same goes if behaviour is simillar to isnullora) ( or zap it iprefer just a longer way to do a thing than a confusing alternative )( i used to try to put short names to things but since about 20 yearsago ive been progresively going to longer and clearer typing iseasier than thinking ymmv )francisco olarte || cool i think were in agreement then im very happy to zap lots of the extra methods like `anystring()` where java 8 means theyre not going to be useful and theres a simple easy to find alternative to them (like just casting `any()` which most ides will even suggest and do for you)@bric3 @szczepiq are you two happy if i open a pr extending my previous changes to implement this api as in my message above? || hi @pimterry @folarte thanks for the discussion i was also away staffed at devoxx fr for the past week i think theres some agreement here im basically ok for these changes : - `<t> t any()` - matches anything including nulls- `<t> t notnull()` matches anything except nulls- `<t> t isa(class<t> clazz)` matches things of `t` type but `null`  > naming could be tweaked without the `is` thus becoming `a(xclass)` i understand this one is kinda bold- `<t> t isnullora(class<t> clazz)` matches things of `t` type including `null`  > naming could be tweaked without the `is` thus becoming `nullora(xclass)`- we get rid of every other variant (`anystring()` `isnotnull(class)` etc)  > theres still need for primitive matchers : `anyint` should stay in my opinion but this raises another issue with primitive wrappers should they allow null in my opinion they should not@szczepiq another related task would be to deprecate apis in the 1x line || happy to drop the `is` prefix seems shorter and clearer this might be one place where we do want an alias for `a(stringclass)` and `an(elementclass)` as otherwise i think its quite difficult to read> - we get rid of every other variant (anystring() isnotnull(class) etc)> > > theres still need for primitive matchers : anyint should stay in my opinion but this raises another issue with primitive wrappers should they allow null in my opinion they should notdo mean `anyint()` or `anint()`? i think the conclusion of the above discussion is that we cant have an `anyint()` method without breaking the api: either `anyint()` actively matches the type and rejects null (confusingly inconsistent with `any()`) or it doesnt and its confusing and people use it wrong (the current state of affairs)for java 8 `any()` should work everywhere i think and for java 7 you can use `(int) any()` i cant easily test this right now is there something about primitives generics and our implementation that means this doesnt work? thats going to be a difficult problem to solve if sofor `anint()` on the other hand it doesnt actually make the api inconsistent if we do add that as another method so thats very doable not clear why we need it in this case either thoughdo you have an example that doesnt work with this as given? || hi brice:on sun apr 12 2015 at 7:55 pm brice dutheil notifications@githubcom wrote:> thanks for the discussion i was also away staffed at devoxx fr for the past week i think theres some agreement here im basically ok for these changes :> > <t> t any() - matches anything including nulls> <t> t notnull() matches anything except nulls> > <t> t isa(class<t> clazz) matches things of t type but null> > naming could be tweaked without the is thus becoming a(xclass) i understand this one is kinda boldi strongly disagree with naming it a or ( sorry tim ) an i feel theyare too short and error prone ( and this is not cobol a pl/dsl is notenglish )> <t> t isnullora(class<t> clazz) matches things of t type including null> > naming could be tweaked without the is thus becoming nullora(xclass)i stil think my any/anynotnull overrrides where superior names but asthis is functionally equivalent ill just wrap it ok so far> we get rid of every other variant (anystring() isnotnull(class) etc)> > theres still need for primitive matchers : anyint should stay in my opinion but this raises another issue with primitive wrappers should they allow null in my opinion they should noti think the point of allowing nulls for primitives is a no point if ihave a method mockmethod(int) which i match withwhen(mockmethod(anyint())) it doesnt matter that the matcherreceives an integer due to boxing/reflection stuff it will never benull becuase if i do ""integer integer  null  mockmethod(integer)""autounboxing will raise npe before matchers get anything to say andif there was another override mockmethod(integer) well first thisshould have been matched by an appropiately casted any/is\* and secondits so perverse that user deserves whatever happens therefrancisco olarte || soon its next in my queue :) thank you guys for patience || great discussion thanks everybody for chipping in lets get this sorted out> what i> dislike of this is having mockm((string)any()) accept nulls and> mockm(any(stringclass)) reject nullsi agree there is a gotcha: given that any(sometypeclass) is most used matcher method it will be a pain to users to upgrade to mockito 20however if we tell users that any(stringclass) checks type but (string) any() does not it is rather awkward message and it might confusing down the roadby now most users are probably used to the behavior of mockito matchers and the pitfall is well documented ) so there is an option to leave things as they areremoving any(t) pretty much means that we need to remove all matcher methods like anystring() anylist() etc this increases the impact on the userill think about this a bit more and get back by the end of today || btw what do you guys think about #246? || i think were down to following options please vote or suggest other options:1 shoot down any(t) and anyt() in favor of isa() this thread seems to be converging on this approach consistent and clean high impact potential churn2 change any(t) and anyt() methods to reject nulls suggested by the community originally potentially confusing down the road due to inconsistence with any() this inconsistence becomes less of a problem with java83 do (2) but also shoot down any() replacing it with anyobject() or anything() or _ (ala spock ) not sure i like killing any() because it is neatly compact4 leave things as they are for now perhaps revisit for java8 support || hi​ ​szczepan:> btw what do you guys think about #246>  > ​i think it may have some problems and be an overload abuse​ if done this> way i would vote for having long named methods with is() being just a> forwarder and i think there may be some ambiguities if overloaded is() is> used to test overloaded method ( ie when you mock m(is(stringclass))> are you mocking m(class c) ( as m(eq(stringclass))  )  or m(string s) with> any string? ( its a contrived overload but ive seem some of these where> the string version takes a class name i think osgi has some of them )> having a long method (anyistanceof equalto evenm specially isnull()> which i personally prefer to is(null) ( which overload is it going to pick> the object one with a null param ) ) lets people key a little more in the> difficult cases and does not at too many complexity or a signigicant run> time for test code ( is() is just a one line forwarder and its javedoc> can be left as such which just an @link to the unoverloaded method )regarding readability im not sure compact overloaded names are morereadable they may be easier to read aloud but you need to invoke higherlevel brain functions to parse it and distinguish the overload being usedbut maybe im just becoming slower​francisco olarte​ || yep i prefer option 1#246 sounds like a good idea to me but we should definitely market it very clearly as a convenience method (as francisco mentions) and obviously keep the explicit methods so people are aware they can opt in to explicitly choosing the relevant option if they need to or theyre not sure what the overloading doesthe overload im most suspicious of is `is(t)` just because its most likely to be ambiguous in practice and when trying to just think about what a line is doing `is(null)` seems clear `is(stringstartingwithhello)` is fine but if i saw`when(is(100) is(stringclass))` i think my default would be to assume that the argument needed to literally be the class object not totally sure about that though happy to go with it if others are happy || any progress on this? are people happy for me to put together a potential pr for option 1 which it sounds like weve settled on as something concrete to discuss? || my preference is to have the following matchers (option 1?):-  `<t> t any()`  that accepts anything including `null`  i associate _""any""_ to the _""anything""_ in my world that includes null-values and instances it is compact and suitable for the most common cases- `<t> t anyobject()` or `<t> t notnull()` reject `null` values opposite to any() the name should indicate that null is rejected to avoid confusion about its behaviour- `<t> t isa(class<? extends t>)` reject `null` values and all values that are not a subtype of `t` like instanceof- all `any*()` and `any(t)` should be dropped cause they have different behaviour (as described before) || > 1 shoot down any(t) and anyt() in favor of isa() this thread seems to be converging on this approach consistent and clean high impact potential churn> 2 change any(t) and anyt() methods to reject nulls suggested by the community originally potentially confusing down the road due to inconsistence with any() this inconsistence becomes less of a problem with java8> 3 do (2) but also shoot down any() replacing it with anyobject() or anything() or _ (ala spock ) not sure i like killing any() because it is neatly compact> 4 leave things as they are for now perhaps revisit for java8 supportlets try to be decisive :)tim & christian vote for option 1) i very much appreciate those votes and option 1 does have a lot of charm :)myself i vote for 2) because:- any(t) reads better (seems more fluent) is more intuitive to write than isa() it looks good in tests- it is consistent gramatically with any() it makes the api a bit more consistent- java8 is very popular people use any() for matching anything and can use any(t) for matching specific type (not null)- removing any(t) (options 1 and 3) seems like a churn and big impact on users without strong enough justification it seems arbitrary that we remove the any(t) methods eg myself as a user i would not be convinced that migrating to mockito 20 is a good idea because i need to fix hundreds of compilation errors due to removal fundamental api method (anyt/any(t)) even if i make that search&replace im not convinced that tests look better now the change also hurts muscle memory and users would be finding themselves using any(t) methods finding the code not compile then realizing that aha! this method was removed however if we update the behavior of any() (option 2) we will provide very nice signal to users during the migration to 20 we could potentially expose bugs most users expect nulls to be rejected by any(t) - mockito 20 will make expose tests that fail that assumptionwe dont have to agree however it would really cool if we were on the same page :) it would be so nice if everyone of us could stand behind decisions we make as a teamwe definitely need to make the decision!!! (if left undecided were effectively deciding on option 4) || i would like to suggest introducing the isa api alongside any the latter would accept nulls while the former would rejecet themnulls are pretty common as values so we ahould not make this more difficult than necessary also tgis makes migration easier || i already started the work on this a few days ago and i chose to kinda follow option 2 as well heres the plan :- `<t> t any()` that accepts anything including `null` i am pondering the addition of `anything` as it is the original meaning of `any`- `* any*()` / `<t> any(t)` will be aliases of `<t> isa(t)` **this is the expected behaviour by users** doing this will introduce the rejection of `null` with java 8 i saw young developer to switching to `any()` when `null` values where used instead of `anyint`since we want to do a release candidate i suggest that we ship the _null safe_ `any*` and remove the `null` check if too much people complaincc @timvdlippe @marcingrzejszczak @raphw @szpak  || thanks for feedback!+1 to your plan-1 to anything it feels that it does not add sufficient value its alonger alias - not sure why would someone want to use iton mon jul 25 2016 at 10:10 am brice dutheil notifications@githubcomwrote:> i already started the work on this a few days ago and i chose to kinda> follow option 2 as well heres the plan :> - <t> t any() that accepts anything including null i am pondering the>   addition of anything as it is the original meaning of any> - \* any_() / <t> any(t) will be aliases of <t> isa(t) *this is the>   expected behaviour by users_ doing this will introduce the rejection>   of null with java 8 i saw young developer to switching to any() when>   null values where used instead of anyint> > since we want to do a release candidate i suggest that we ship the _null> safe_ any* and remove the null check if too much people complain> > cc @timvdlippe  @marcingrzejszczak>  @raphw  @szpak  > —> you are receiving this because you were mentioned> reply to this email directly view it on github>  or mute the thread>   || +1 i agree lets try this for the rc || ";1;0;adds missing generics info on collection matchers follow-up to #510 #194 abf9851;
532;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo in javadocs;-  pr should be motivated  i.e. what does it fix  why  and if relevant how -  if possible / relevant include an example in the description  that could help all readers      including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history   intention is important please rebase your commit history so that each      commit is meaningful and help the people that will explore a change in 2 years -  read the [contributing guide]( -  mention  <issue number>  in the description _if relevant_ -  at least one commit should mention  fixes #<issue number>  _if relevant_  also improve sentence structure of surrounding sentences.;;0;suppliersmemoize() should use double-checked locking; per discussion on guava-discuss; youre right josh bloch in its effective java 2nd edition clearly demonstrates it by using a volative field as you do -) and of course using compilation version > 15 to prevent running on java 14 as you do too ||;;;;0;1;;
532;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo in javadocs;-  pr should be motivated  i.e. what does it fix  why  and if relevant how -  if possible / relevant include an example in the description  that could help all readers      including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history   intention is important please rebase your commit history so that each      commit is meaningful and help the people that will explore a change in 2 years -  read the [contributing guide]( -  mention  <issue number>  in the description _if relevant_ -  at least one commit should mention  fixes #<issue number>  _if relevant_  also improve sentence structure of surrounding sentences.;;0;fix typo in javadocs;-  pr should be motivated ie what does it fix why and if relevant how-  if possible / relevant include an example in the description that could help all readers     including project members to get a better picture of the change-  avoid other runtime dependencies-  meaningful commit history  intention is important please rebase your commit history so that each     commit is meaningful and help the people that will explore a change in 2 years-  read the [contributing guide](  mention `<issue number>` in the description _if relevant_-  at least one commit should mention `fixes #<issue number>` _if relevant_also improve sentence structure of surrounding sentences;@raphw @bric3  ||  ;;;;1;1;fix typo in javadocsalso improve sentence structure of surrounding sentences;
532;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo in javadocs;-  pr should be motivated  i.e. what does it fix  why  and if relevant how -  if possible / relevant include an example in the description  that could help all readers      including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history   intention is important please rebase your commit history so that each      commit is meaningful and help the people that will explore a change in 2 years -  read the [contributing guide]( -  mention  <issue number>  in the description _if relevant_ -  at least one commit should mention  fixes #<issue number>  _if relevant_  also improve sentence structure of surrounding sentences.;;0;fix symbol to qualifiedname conversion;;;;;;1;1;fix symbol to qualifiedname conversion;
532;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo in javadocs;-  pr should be motivated  i.e. what does it fix  why  and if relevant how -  if possible / relevant include an example in the description  that could help all readers      including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history   intention is important please rebase your commit history so that each      commit is meaningful and help the people that will explore a change in 2 years -  read the [contributing guide]( -  mention  <issue number>  in the description _if relevant_ -  at least one commit should mention  fixes #<issue number>  _if relevant_  also improve sentence structure of surrounding sentences.;;0;dooneach variance;just to make sure we dont forget about this one: `dooneach` & friends still need `? extends t` / `? super t`;this is completed along with a refactoring to having `dooneach` `doonnext` `dooncompleted` and `doonerror` ||;;;;0;1;;
535;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored supertypeslastsorter to a static utility class;refactored supertypeslastsorter to a static utility class  relates to #426;;0;missing static builders in lists and sets; the following builders are missing for consistency:setsnewenumset(iterator&lte> class&lte>)setsnewlinkedhashset(iterator&lte>)setsnewtreeset(iterator&lte>)listsnewlinkedlist(iterator&lte>); wow olivier i hadnt realized you were the reporter for the google-collections issue i linked to above! i simply remembered reading about this earlier and searched the google-collections issue tracker when i couldnt find it here funny coincidencei think i know how you feel: i also wish some utility methods were available in guava but understand the need to keep the library focused with a high ""power-to-weight"" ratioi formulated this better in my answer to this stackoverflow question:  (see ""guava has a high power-to-weight ratio"")while these factory methods are absent from guava the iterators class still helps with the workaround:setsnewenumset(iterator&lte> class&lte>)-->set&ltfoo> foos  new enumset&ltfoo>(fooclass)iteratorsaddall(foos fooiterator)setsnewlinkedhashset(iterator&lte>)-->set&ltfoo> foos  setsnewlinkedhashset()iteratorsaddall(foos fooiterator)setsnewtreeset(iterator&lte>)-->set&ltfoo> foos  setsnewtreeset()iteratorsaddall(foos fooiterator)its indeed more verbose and it could be encapsulated in a project-specific ""sets2"" utility class there might even be an opportunity to create some kind of ""guava-extensions"" project that would build on guava and provide these ""nice-to-have"" utility methods || ";;;;0;1;;
535;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored supertypeslastsorter to a static utility class;refactored supertypeslastsorter to a static utility class  relates to #426;;0;generate better error message if nodes are unavailable;"right now the call to orderingmin() fails with nosuchelementexception and show ""failed: null"" to the user";;;;;1;1;;
535;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored supertypeslastsorter to a static utility class;refactored supertypeslastsorter to a static utility class  relates to #426;;0;fix compilation errors due to referencing the android support library directly;this is to prevent compilation failures in projects that do not link the support-v4 library the only other option i saw to fix this would have been to split up the android module into one for native fragments and one for support fragments which i found would come with unjustified overhead hence i settled for the cheap way which is to sacrifice type safety hererefs  @gbenson-nflx;should add we need this to go in to make headway with the android samples projects || #462  &#128077 ||;;;;1;1;use object as argument type for fromfragment helperthis is to prevent compilation failures in projects that do not link the support-v4 library the only other option i saw to fix this would have been to split up the android module into one for native fragments and one for support fragments which i found would come with unjustified overhead hence i settled for the cheap way which is to sacrifice type safety hererefs https://githubcom/soundcloud/rxjava/issues/2;
535;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored supertypeslastsorter to a static utility class;refactored supertypeslastsorter to a static utility class  relates to #426;;426.0;refactored supertypeslastsorter to a static utility class;refactored supertypeslastsorter to a static utility classrelates to #426; ;refactor instance based utility classes to static utility classes;the internal implementation of mockito contains numerous helper classed that serve as a container for useful methods by its nature these classes dont have a state currently some them are instance based in other word you need to create the utility class to call a helper method this not only pollutes the heap but also the code cause instance methods cant be imported statically here is an example:```javahelper helper  new helper()if (helperisinputvalid(input)){   }```vs static import of helperisinputvalid```javaif (isinputvalid(input)){   }```the aim of this ticket is to identify canidates that can be refactored to static utility classes if you like to refactoring and mockito feel free to send a pr and reference this issuerefactoring canidates:-  `accessibilitychanger`-  `beanpropertysetter`-  `conditionalstacktracefilter`-  `fieldcopier`-  `fieldreader`-  `genericmaster` should be integrate into `generictyperesolver`-  `junitfailurehacker` can be removed when the deprecated `verbosemockitojunitrunner` is removed-  `lenientcopytool`-  `matcherbinder`-  `mockitocore` should better be a singleton-  `mockcreationvalidator`- [ ] `removefirstline`-  #591 `argumentmatchingtool`-  #515 `allinvocationsfinder`-  #502 `argumentscomparator`-  #540 `arrayutils`-  #490 `atleastxnumberofinvocationschecker`-  #490 `atleastxnumberofinvocationsinorderchecker`- [ ] #912 `constructors`-  #427 `fieldsetter`-  #908 `friendlyexceptionmaker`-  #431 `handyreturnvalues` - [x] #432 `invocationmarker`- [x] #462 `invocationsfinder`- [x] #908 `junitdetecter`- [x] #490 `missinginvocationchecker`- [x] #490 `missinginvocationinorderchecker`- [x] #514 `mockutil`- [x] #503 `nongreedynumberofinvocationsinorderchecker`- [x] #907 `numberofinvocationsinorderchecker`- [x] #907 `numberofinvocationschecker`- [x] #547 `objectmethodsguru`- [x] #427 `reporter`- [x] #535 `supertypeslastsorter`- [x] #501 `testmethodfinder`- [x] #515 `verifiableinvocationsfinder`;"@raphw thanks for merging the pr that fast!  would you mind reopening this ticket? there are more classes that can be refactored that way i would like to extend the list || big :+1: for me btw but please keep the pull requests managable and as small as possible preferably refactoring 1 method at a time that way it is a lot easier to review || i agree there is nothing wrong with multiple prs the quick merge is a reaction to an easy overview (and being stuck at an ukrainian airport without access to the eurocup) || there are still two unit tests failing could you have a look @christianschwarz - i just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `reporter`i should have checked more thoroughly before merging hopefully you can fix the problem soon alternatively i will just rollback the one commit (the first one is good) and we can reapply the patch once you  the two unit tests thank you really this was great clean-up || i fixed the one test error i push it tonightps: i also fixed a bug in the stack trace cleaner not a biggy but please do not `@ignore` tests especially in big commits it is easy to miss that single annotation || @raphw which test(s) is/are failing? i will fix it asap! too bad that some test fail on a regulare base is it possible to ignore them in the ide only? || you can see the build output here:  advise you to run the tests with `/gradlew build` this should work || @timvdlippe know what you mean! the next prs include only one refactored class at a time || i have it all fixed on local but i did not have access to wifi without 22 blocked will commit soon || @raphw can you please reopen this issue  || sorry github automatically closes issues that reference a pr || @christianschwarz if a commit contains a comment like ""426"" the mentioned issue is automatically closed by github || @pascalschumacher good to know! i will leave it out for the upcoming prs  now that we are pulling in static methods i would like to propose a new (linter) rule to make it easier to read a file i would like that all methods invoked in the current class are referenced with `this` (and `super` for that matter) therefore if we see `thisverify` we know it is in the current class and the same object whereas `verify` references a static method in this class or an imported static method do you agree @mockito/developers ? || > i would like that all methods invoked in the current class are referenced with this (and super for that matter)to me it feels like unnecessary/duplicate code cause `this` is implicit adding `this` before every instance call would create a lot more text and would imho reduce readability eg:`thisdosometing(thiswithprivatemethod())` vs `dosomething(withprivatemethod())`> therefore if we see thisverify we know it is in the current class and the same object whereas verify references a static method in this class or an imported static methodan other option avoid ambiguity is to qualify static methods via its class name  this way you can also distinguish which verify() is called ( `mockitocoreverify()` / `mocktioverify()`)  which is not an easy task when a static import is used || im not coding too much in mockito atm (hopefully now after springone conference ill have more time) but i fully agree with @christianschwarz  imo the best solution is to: - omit `this` before method calls - if necessary provide the class for static method call || respectful -1i like when the class formally declares collaborators instead of calling out to static methods this makes it easy to reason about the code i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etc another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too proceduralthe benefits for converting to static utilities have minimal significance to me yet there is a downside i care about (eg maintainability of procedural code static methods that consume static methods that consume static methods)hence i down vote this sort of changes going down this path all stateless classes in mockito would become static utilities :)you can get +1s from other maintainers and have your changes merged - im not here to block your changes but to give honest feedback i see merit in arguments for static utilities they do not outweigh the cost in my opinion || im mitigated about this as well i understand well that mockito creates garbage but they are short lived and **most probably** wont go in the old generation especially in the test phase yet the faster the tests are the more developers will run them it **may** have impacts on big projects also design wise i dont like much static methods toohowever i dont totally agree with the above points : > i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etccoupling appears also in the import section  static methods are visible there and modern ide usually highlight this intellij even have a warning if import section is too big just as theres warning if theres too many fields this point should not be the reason to avoid static methods> maintainability of procedural code static methods that consume static methods that consume static methodshaving instance methods does not protect again procedural code---i believe theres middle ground there : - mockito project contains a lot of small utility stateless objects that are supporting mockito features these are usually collections tools reflection tools those could are good candidate for static methods objects like `fieldsetter` `fieldcopier` `lenientcopytool` could be nice candidate for static methods- mockito features could be backed by object instances objects like `mockitocore` `mockcreationvalidator` `argumentmatchingtool` are candidate to stay objects || exactly the middle ground described by brice is my motivation for merging most of the prs this is also the reason i have not yet merged the mockitocore pr for this exact reasonif an object is not a attribute or parameter but an internal creation and immediately dismissed i value a pure function more || thought: when we switch to java 8 we can use interfaces with defaultmethods the switch from static utility to interface is very easy now (justa couple of text replaces no method reference modifications)on fri 12 aug 2016 17:23 brice dutheil notifications@githubcom wrote:> im mitigated about this as well i understand well that mockito creates> garbage but they are short lived and _most probably_ wont go in the old> generation especially in the test phase yet the faster the tests are the> more developers will run them it _may_ have impacts on big projects> also design wise i dont like much static methods too> > however i dont totally agree with the above points :> > i dont need to read every line of code in the class to find out external> couplings realized via static methods i can see the couplings via fields> i can easily query how the field variable is used etc> > coupling appears also in the import section  static methods are visible> there and modern ide usually highlight this intellij even have a warning> if import section is too big just as theres warning if theres too many> fields this point should not be the reason to avoid static methods> > maintainability of procedural code static methods that consume static> methods that consume static methods> > ## having instance methods does not protect again procedural code> > i believe theres middle ground there :> >    -> >    mockito project contains a lot of small utility stateless objects that>    are supporting mockito features these are usually collections tools>    reflection tools those could are good candidate for static methods>    objects like fieldsetter fieldcopier lenientcopytool could be nice>    candidate for static methods>    -> >    mockito features could be backed by object instances objects like>    mockitocore mockcreationvalidator argumentmatchingtool are candidate>    to stay objects> > —> you are receiving this because you modified the open/close state> reply to this email directly view it on github>  or mute the thread>   || this feels like a misuse of the default methods || i think you mean static-methods in interfaces here? default-methods require an instance to be called onanyway i dont think that it is a good idea  it would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods imho a class with private constructor is the best construct to do this || > > thought: when we switch to java 8 we can use interfaces with default> > methods> > default-methods require an instance to be called oni was thinking exactly that default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface) || @christianschwarz what do you think to continue the work here with the middle ground described [here]( ? || i am attempting to refactor the matcherbinder class to a static utility class and am having trouble refactoring the following from mockhandlerimpltestjava: `handlermatchersbinder  new matchersbinder() {            public invocationmatcher bindmatchers(argumentmatcherstorage argumentmatcherstorage invocation invocation) {                throw new invaliduseofmatchersexception()            }} `how can i maintain the abstract class definition when i am not able to create an object of matcherbinder?any help is appreciated!  || lets close this ticket refactorings can be done as needed as we work with the code || ";1;0;refactored supertypeslastsorter to a static utility class;
540;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;some minor coverity warning fixes;;;0;organize imports; a lot of uneseccary import declarations are used better to remove them:the import javautiltreemap is never used    immutablesortedmapjava    /guava-src-r08/com/google/common/collect    line 35    java problemthe import javautiltreemap is never used    setsjava    /guava-src-r08/com/google/common/collect    line 49    java problemthe import javautilsortedset is never used    orderingjava    /guava-src-r08/com/google/common/collect    line 36    java problemthe import javautilsortedset is never used    setsjava    /guava-src-r08/com/google/common/collect    line 48    java problemthe import javautilsortedmap is never used    orderingjava    /guava-src-r08/com/google/common/collect    line 35    java problemthe import javautilset is never used    rowsortedtablejava    /guava-src-r08/com/google/common/collect    line 23    java problemthe import javautilset is never used    sortedsetmultimapjava    /guava-src-r08/com/google/common/collect    line 24    java problemthe import javautilset is never used    standardrowsortedtablejava    /guava-src-r08/com/google/common/collect    line 26    java problemthe import javautilset is never used    treebasedtablejava    /guava-src-r08/com/google/common/collect    line 28    java problemthe import javautilset is never used    treemultimapjava    /guava-src-r08/com/google/common/collect    line 29    java problemthe import javautilregexpatternsyntaxexception is never used    patternfilenamefilterjava    /guava-src-r08/com/google/common/io    line 25    java problemthe import javautilpriorityqueue is never used    minmaxpriorityqueuejava    /guava-src-r08/com/google/common/collect    line 37    java problemthe import javautilnosuchelementexception is never used    orderingjava    /guava-src-r08/com/google/common/collect    line 34    java problemthe import javautilnosuchelementexception is never used    peekingiteratorjava    /guava-src-r08/com/google/common/collect    line 22    java problemthe import javautilnosuchelementexception is never used    preconditionsjava    /guava-src-r08/com/google/common/base    line 22    java problemthe import javautilmap is never used    mapmakerjava    /guava-src-r08/com/google/common/collect    line 34    java problemthe import javautillistiterator is never used    abstractindexedlistiteratorjava    /guava-src-r08/com/google/common/collect    line 23    java problemthe import javautillist is never used    multisetjava    /guava-src-r08/com/google/common/collect    line 24    java problemthe import javautilidentityhashmap is never used    setsjava    /guava-src-r08/com/google/common/collect    line 41    java problemthe import javautilhashset is never used    immutablesetjava    /guava-src-r08/com/google/common/collect    line 28    java problemthe import javautilhashset is never used    iterablesjava    /guava-src-r08/com/google/common/collect    line 33    java problemthe import javautilhashset is never used    orderingjava    /guava-src-r08/com/google/common/collect    line 30    java problemthe import javautilhashmap is never used    immutablemapjava    /guava-src-r08/com/google/common/collect    line 27    java problemthe import javautilhashmap is never used    setsjava    /guava-src-r08/com/google/common/collect    line 39    java problemthe import javautilformatter is never used    stringsjava    /guava-src-r08/com/google/common/base    line 24    java problemthe import javautilconcurrentthreadpoolexecutorcallerrunspolicy is never used    moreexecutorsjava    /guava-src-r08/com/google/common/util/concurrent    line 31    java problemthe import javautilconcurrentthreadfactory is never used    moreexecutorsjava    /guava-src-r08/com/google/common/util/concurrent    line 29    java problemthe import javautilconcurrentrejectedexecutionexception is never used    listenablefuturejava    /guava-src-r08/com/google/common/util/concurrent    line 23    java problemthe import javautilconcurrentfuture is never used    checkedfuturejava    /guava-src-r08/com/google/common/util/concurrent    line 23    java problemthe import javautilconcurrentexecutionexception is never used    checkedfuturejava    /guava-src-r08/com/google/common/util/concurrent    line 22    java problemthe import javautilconcurrentexecutionexception is never used    servicejava    /guava-src-r08/com/google/common/base    line 21    java problemthe import javautilconcurrentcancellationexception is never used    checkedfuturejava    /guava-src-r08/com/google/common/util/concurrent    line 21    java problemthe import javautilcollections is never used    immutablelistjava    /guava-src-r08/com/google/common/collect    line 29    java problemthe import javautilcollections is never used    immutablemapjava    /guava-src-r08/com/google/common/collect    line 26    java problemthe import javautilcollections is never used    immutablesetjava    /guava-src-r08/com/google/common/collect    line 27    java problemthe import javautilcollections is never used    iterablesjava    /guava-src-r08/com/google/common/collect    line 32    java problemthe import javautilcollections is never used    multisetjava    /guava-src-r08/com/google/common/collect    line 22    java problemthe import javautilcollections is never used    sortedlistsjava    /guava-src-r08/com/google/common/collect    line 21    java problemthe import javautilcollection is never used    treemultisetjava    /guava-src-r08/com/google/common/collect    line 25    java problemthe import javautilbitset is never used    booleansjava    /guava-src-r08/com/google/common/primitives    line 29    java problemthe import javautilarrays is never used    booleansjava    /guava-src-r08/com/google/common/primitives    line 28    java problemthe import javautilarrays is never used    bytesjava    /guava-src-r08/com/google/common/primitives    line 28    java problemthe import javautilarrays is never used    charsjava    /guava-src-r08/com/google/common/primitives    line 29    java problemthe import javautilarrays is never used    doublesjava    /guava-src-r08/com/google/common/primitives    line 28    java problemthe import javautilarrays is never used    floatsjava    /guava-src-r08/com/google/common/primitives    line 28    java problemthe import javautilarrays is never used    intsjava    /guava-src-r08/com/google/common/primitives    line 29    java problemthe import javautilarrays is never used    listsjava    /guava-src-r08/com/google/common/collect    line 37    java problemthe import javautilarrays is never used    longsjava    /guava-src-r08/com/google/common/primitives    line 29    java problemthe import javautilarrays is never used    shortsjava    /guava-src-r08/com/google/common/primitives    line 29    java problemthe import javalangrefweakreference is never used    mapmakerjava    /guava-src-r08/com/google/common/collect    line 33    java problemthe import javalangrefsoftreference is never used    mapmakerjava    /guava-src-r08/com/google/common/collect    line 32    java problemthe import javalangrefreferencequeue is never used    finalizablephantomreferencejava    /guava-src-r08/com/google/common/base    line 18    java problemthe import javalangrefreferencequeue is never used    finalizablesoftreferencejava    /guava-src-r08/com/google/common/base    line 17    java problemthe import javalangrefreferencequeue is never used    finalizableweakreferencejava    /guava-src-r08/com/google/common/base    line 17    java problemthe import javaioserializable is never used    forwardingobjectjava    /guava-src-r08/com/google/common/collect    line 21    java problemthe import javaioioexception is never used    bytearraydatainputjava    /guava-src-r08/com/google/common/io    line 20    java problemthe import javaioioexception is never used    bytearraydataoutputjava    /guava-src-r08/com/google/common/io    line 20    java problemthe import comgooglecommonbaseservicestate is never used    abstractservicejava    /guava-src-r08/com/google/common/util/concurrent    line 24    java problemthe import comgooglecommonbaseobjects is never used    tablejava    /guava-src-r08/com/google/common/collect    line 21    java problem; re comment 3:import comgooglecommonbaseservicestate is never used    abstractservicejavaif i removed that i would have to change&nbsp&nbsp&nbsp\* implementing classes should invoke this method once their service has&nbsp&nbsp&nbsp\* started it will cause the service to transition from {@﻿link&nbsp&nbsp&nbsp\* state#starting} to {@﻿link state#running}to&nbsp&nbsp&nbsp\* implementing classes should invoke this method once their service has&nbsp&nbsp&nbsp\* started it will cause the service to transition from {@﻿link&nbsp&nbsp&nbsp\* comgooglecommonbaseservicestate#starting} to {@﻿link&nbsp&nbsp&nbsp\* comgooglecommonbaseservicestate#running}in fact to preserve the output i might even have to do this&nbsp&nbsp&nbsp\* implementing classes should invoke this method once their service has&nbsp&nbsp&nbsp\* started it will cause the service to transition from {@﻿link&nbsp&nbsp&nbsp\* comgooglecommonbaseservicestate#starting servicestarting} to {@﻿link&nbsp&nbsp&nbsp\* comgooglecommonbaseservicestate#running servicerunning}(but that i dont know)is that worth it?  to me the ease of readability of javadoc in both source form and generated form is more important than these other concernsbtw i even commented the import specifically hoping to avoid this complaint:import comgooglecommonbaseservicestate // javadoc needs thisit would be nice if javadoc didnt need it and could just tell that ""state"" refers to the nested class of the supertype but it doesyour other issue:the import comgooglecommonbaseobjects is never used    tablejavais indeed used in javadoc just like all this othersim going to let this drop now because its really not worth all this time and thought || ";;;;0;1;;
540;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;some minor coverity warning fixes;;;0;hive connector fixes;;;;;;0;1;;
540;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;some minor coverity warning fixes;;;0;purpose of rxutilopening and rxutilclosing interfaces?;is there a particular reason these two interfaces are used by the various buffer() and window() operators instead of allowing arbitrary generic types for opening and closing buffers/windows similar to the duration selectors in join() & groupbyuntil()?;"i think they are historical artifacts less types  better imhoon thu nov 28 2013 at 2:47 pm akarnokd notifications@githubcom wrote:> is there a particular reason these two interfaces are used by the various> buffer() and window() operators instead of allowing arbitrary generic types> for opening and closing buffers/windows similar to the duration selectors> in join() & groupbyuntil()?> > —> reply to this email directly or view it on github  || on a related issue we should move observerbase from rxjoins to rx right next to the observer interface nobody should directly implement observer observerbase ensure that the rx contract is enforcedit is a bit ugly that you need to override xxxcore so we should also add observercreate or a constructor with overloads that take funcs as well as one that takes an observer itself (which can be unsafe)you want to take this?see (did i say already that the msdn docs suck!) || @headinthebox sure i would do the refactorings but i think observerbase should be placed under rxoperators similar to the safeobserver and synchronizedobserver classes || probably yes and there is a lot of duplication between all of these various observers so you may want to have a look at that as well || if its job is to ensure the contract is kept then that is what safeobserver does  || > but i think observerbase should be placed under rxoperators similar to the safeobserver and synchronizedobserver classesyes we have kept the rx package to only the most top-level things so i agree this should be elsewhere however thus far the rxoperators package is not considered part of the public api and is excluded from javadocs if we are to have public observers then it would be an rxobservers package like rxobservables the rxoperators package is internal implementations and can be changed without breaking users  || i did the refactorings but couldnt get the observablescala working with it:  someone help with that part?```rxjava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\observablescala  error: type mismatch   found   : rxlangscalaobservable[closing]   required: rxutilfunctionsfunc0[_ <: rxobservable[closing]]      val f: func0[_ <: rxobservable[closing]]  closings()asjavaobservable                                                                              ^  rxjava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\observablescala  error: type mismatch   found   : opening > rxobservable[_ <: closing]   required: rxutilfunctionsfunc1[opening _ <: rxobservable[closing]]      val closing: func1[opening _ <: rxobservable[closing]]  (o: opening) > closings(o)asjavaobservable                                                                              ^  rxjava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\observablescala  error: type mismatch   found   : rxobservable[_$15] where type _$15 <: opening   required: rxobservable[opening]  note: _$15 <: opening but java-defined class observable is invariant in type t  you may wish to investigate a wildcard type such as `_ <: opening` (sls 3210)      val jobs: rxobservable[_ <: javautillist[_]]  asjavaobservablebuffer[opening closing](opening closing)                                                                                                  ^  rxjava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\observablescala  error: overloaded method window needs result type        asjavaobservablewindow(openingsasjavaobservable (op: opening) > closings(op)asjavaobservable))                               ^  rxjava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\observablescala  error: overloaded method value window with alternatives:    (x$1: int)rxobservable[rxobservable[_$1]] <and>    [tclosing](x$1: rxutilfunctionsfunc0[_ <: rxobservable[tclosing]])rxobservable[rxobservable[_$1]]   cannot be applied to (rxutilfunctionsfunc0[_$44])      val o1: rxobservable[_ <: rxobservable[_]]  asjavaobservablewindow(func)``` || observable is covariant in its type parameter in scala when you use a scala type scalac knows this automatically because its declared where the type is declared (using `trait observable[+t]` `+` means covariant `-` means contravariant) so `rxlangscalaobservable[t]` actually means ""an `rxlangscalaobservable` whose type parameter is `t` or any subclass of `t` however if you use a java type theres no `+` or `-` at declaration site so **whenever** you use `rxobservable` in scala you have to write `rxobservable[_ <: t]` **never** write `rxobservable[t]` || ";;;;0;1;;
540;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;some minor coverity warning fixes;;;426.0;inlined arrayutilsisempty() in argumentsprocessor;inlined arrayutilsisempty() in argumentsprocessor and removed arrayutils cause it was only used in argumentprocessoralso isempty() was renamed to isnullorempty() for clarityrelates to #426;  540   ;refactor instance based utility classes to static utility classes;the internal implementation of mockito contains numerous helper classed that serve as a container for useful methods by its nature these classes dont have a state currently some them are instance based in other word you need to create the utility class to call a helper method this not only pollutes the heap but also the code cause instance methods cant be imported statically here is an example:```javahelper helper  new helper()if (helperisinputvalid(input)){   }```vs static import of helperisinputvalid```javaif (isinputvalid(input)){   }```the aim of this ticket is to identify canidates that can be refactored to static utility classes if you like to refactoring and mockito feel free to send a pr and reference this issuerefactoring canidates:-  `accessibilitychanger`-  `beanpropertysetter`-  `conditionalstacktracefilter`-  `fieldcopier`-  `fieldreader`-  `genericmaster` should be integrate into `generictyperesolver`-  `junitfailurehacker` can be removed when the deprecated `verbosemockitojunitrunner` is removed-  `lenientcopytool`-  `matcherbinder`-  `mockitocore` should better be a singleton-  `mockcreationvalidator`- [ ] `removefirstline`-  #591 `argumentmatchingtool`-  #515 `allinvocationsfinder`-  #502 `argumentscomparator`-  #540 `arrayutils`-  #490 `atleastxnumberofinvocationschecker`-  #490 `atleastxnumberofinvocationsinorderchecker`- [ ] #912 `constructors`-  #427 `fieldsetter`-  #908 `friendlyexceptionmaker`-  #431 `handyreturnvalues` - [x] #432 `invocationmarker`- [x] #462 `invocationsfinder`- [x] #908 `junitdetecter`- [x] #490 `missinginvocationchecker`- [x] #490 `missinginvocationinorderchecker`- [x] #514 `mockutil`- [x] #503 `nongreedynumberofinvocationsinorderchecker`- [x] #907 `numberofinvocationsinorderchecker`- [x] #907 `numberofinvocationschecker`- [x] #547 `objectmethodsguru`- [x] #427 `reporter`- [x] #535 `supertypeslastsorter`- [x] #501 `testmethodfinder`- [x] #515 `verifiableinvocationsfinder`;"@raphw thanks for merging the pr that fast!  would you mind reopening this ticket? there are more classes that can be refactored that way i would like to extend the list || big :+1: for me btw but please keep the pull requests managable and as small as possible preferably refactoring 1 method at a time that way it is a lot easier to review || i agree there is nothing wrong with multiple prs the quick merge is a reaction to an easy overview (and being stuck at an ukrainian airport without access to the eurocup) || there are still two unit tests failing could you have a look @christianschwarz - i just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `reporter`i should have checked more thoroughly before merging hopefully you can fix the problem soon alternatively i will just rollback the one commit (the first one is good) and we can reapply the patch once you  the two unit tests thank you really this was great clean-up || i fixed the one test error i push it tonightps: i also fixed a bug in the stack trace cleaner not a biggy but please do not `@ignore` tests especially in big commits it is easy to miss that single annotation || @raphw which test(s) is/are failing? i will fix it asap! too bad that some test fail on a regulare base is it possible to ignore them in the ide only? || you can see the build output here:  advise you to run the tests with `/gradlew build` this should work || @timvdlippe know what you mean! the next prs include only one refactored class at a time || i have it all fixed on local but i did not have access to wifi without 22 blocked will commit soon || @raphw can you please reopen this issue  || sorry github automatically closes issues that reference a pr || @christianschwarz if a commit contains a comment like ""426"" the mentioned issue is automatically closed by github || @pascalschumacher good to know! i will leave it out for the upcoming prs  now that we are pulling in static methods i would like to propose a new (linter) rule to make it easier to read a file i would like that all methods invoked in the current class are referenced with `this` (and `super` for that matter) therefore if we see `thisverify` we know it is in the current class and the same object whereas `verify` references a static method in this class or an imported static method do you agree @mockito/developers ? || > i would like that all methods invoked in the current class are referenced with this (and super for that matter)to me it feels like unnecessary/duplicate code cause `this` is implicit adding `this` before every instance call would create a lot more text and would imho reduce readability eg:`thisdosometing(thiswithprivatemethod())` vs `dosomething(withprivatemethod())`> therefore if we see thisverify we know it is in the current class and the same object whereas verify references a static method in this class or an imported static methodan other option avoid ambiguity is to qualify static methods via its class name  this way you can also distinguish which verify() is called ( `mockitocoreverify()` / `mocktioverify()`)  which is not an easy task when a static import is used || im not coding too much in mockito atm (hopefully now after springone conference ill have more time) but i fully agree with @christianschwarz  imo the best solution is to: - omit `this` before method calls - if necessary provide the class for static method call || respectful -1i like when the class formally declares collaborators instead of calling out to static methods this makes it easy to reason about the code i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etc another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too proceduralthe benefits for converting to static utilities have minimal significance to me yet there is a downside i care about (eg maintainability of procedural code static methods that consume static methods that consume static methods)hence i down vote this sort of changes going down this path all stateless classes in mockito would become static utilities :)you can get +1s from other maintainers and have your changes merged - im not here to block your changes but to give honest feedback i see merit in arguments for static utilities they do not outweigh the cost in my opinion || im mitigated about this as well i understand well that mockito creates garbage but they are short lived and **most probably** wont go in the old generation especially in the test phase yet the faster the tests are the more developers will run them it **may** have impacts on big projects also design wise i dont like much static methods toohowever i dont totally agree with the above points : > i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etccoupling appears also in the import section  static methods are visible there and modern ide usually highlight this intellij even have a warning if import section is too big just as theres warning if theres too many fields this point should not be the reason to avoid static methods> maintainability of procedural code static methods that consume static methods that consume static methodshaving instance methods does not protect again procedural code---i believe theres middle ground there : - mockito project contains a lot of small utility stateless objects that are supporting mockito features these are usually collections tools reflection tools those could are good candidate for static methods objects like `fieldsetter` `fieldcopier` `lenientcopytool` could be nice candidate for static methods- mockito features could be backed by object instances objects like `mockitocore` `mockcreationvalidator` `argumentmatchingtool` are candidate to stay objects || exactly the middle ground described by brice is my motivation for merging most of the prs this is also the reason i have not yet merged the mockitocore pr for this exact reasonif an object is not a attribute or parameter but an internal creation and immediately dismissed i value a pure function more || thought: when we switch to java 8 we can use interfaces with defaultmethods the switch from static utility to interface is very easy now (justa couple of text replaces no method reference modifications)on fri 12 aug 2016 17:23 brice dutheil notifications@githubcom wrote:> im mitigated about this as well i understand well that mockito creates> garbage but they are short lived and _most probably_ wont go in the old> generation especially in the test phase yet the faster the tests are the> more developers will run them it _may_ have impacts on big projects> also design wise i dont like much static methods too> > however i dont totally agree with the above points :> > i dont need to read every line of code in the class to find out external> couplings realized via static methods i can see the couplings via fields> i can easily query how the field variable is used etc> > coupling appears also in the import section  static methods are visible> there and modern ide usually highlight this intellij even have a warning> if import section is too big just as theres warning if theres too many> fields this point should not be the reason to avoid static methods> > maintainability of procedural code static methods that consume static> methods that consume static methods> > ## having instance methods does not protect again procedural code> > i believe theres middle ground there :> >    -> >    mockito project contains a lot of small utility stateless objects that>    are supporting mockito features these are usually collections tools>    reflection tools those could are good candidate for static methods>    objects like fieldsetter fieldcopier lenientcopytool could be nice>    candidate for static methods>    -> >    mockito features could be backed by object instances objects like>    mockitocore mockcreationvalidator argumentmatchingtool are candidate>    to stay objects> > —> you are receiving this because you modified the open/close state> reply to this email directly view it on github>  or mute the thread>   || this feels like a misuse of the default methods || i think you mean static-methods in interfaces here? default-methods require an instance to be called onanyway i dont think that it is a good idea  it would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods imho a class with private constructor is the best construct to do this || > > thought: when we switch to java 8 we can use interfaces with default> > methods> > default-methods require an instance to be called oni was thinking exactly that default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface) || @christianschwarz what do you think to continue the work here with the middle ground described [here]( ? || i am attempting to refactor the matcherbinder class to a static utility class and am having trouble refactoring the following from mockhandlerimpltestjava: `handlermatchersbinder  new matchersbinder() {            public invocationmatcher bindmatchers(argumentmatcherstorage argumentmatcherstorage invocation invocation) {                throw new invaliduseofmatchersexception()            }} `how can i maintain the abstract class definition when i am not able to create an object of matcherbinder?any help is appreciated!  || lets close this ticket refactorings can be done as needed as we work with the code || ";1;0;inlined arrayutilsisempty() in argumentsprocessor;
547;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;medlineimportertest;new pr started because the old one was on a wrong branch.  medlineimportest + testfile added  couldn t cover two exceptions in importentries.;;0;wiki link needed to be ; on this page  the link of ""apache maven"" is not correct its supposed to be http://mavenapacheorg/"; thanks for pointing that out  it is  now--- ;;;;0;1;;
547;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;medlineimportertest;new pr started because the old one was on a wrong branch.  medlineimportest + testfile added  couldn t cover two exceptions in importentries.;;0;limit the max initial size for the topn priority queue;; ;;;;0;1;;
547;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;medlineimportertest;new pr started because the old one was on a wrong branch.  medlineimportest + testfile added  couldn t cover two exceptions in importentries.;;0;decouple getting a subscription from subscribing;ive been holding on to this for a while now because its a major departure and i wanted to make sure that it was really necessary  given all of the issues weve seen recently with schedulers and other operators i think its time to discussright now the core method of `subscription subscribe(observer)` just doesnt work well for synchronous source observables because downstream operations dont get a `subscription` until after the `observable` has been force fed all the data for example`observablefrom([123])map({ /* expensive operation here */ })take(1)`the subscribers to this chain of observables will see the correct result be the author might not realize that there is unnecessary computation going on because the expensive operation is also done for 2 and 3 and thrown away be the take operatorthe solution that im proposing is to split subscribing to an `observable` into two phases  the first step is to get the subscription with a new method on `observable` called:`public partialsubscription<t> getsubscription() {}`then define `partialsubscription` with all of the subscribe methods to start the sending of data to the observer:```public class partialsubscription<t> extends subscription    public void subscribe( observer<t> observer ) {}    }```the existing `subscribe` & `onsubscribefunc` can be deprecated and implemented using partial subscriptions means for backwards compatibility of existing operator implementations but to truly get all of the advantages of this all of the operators would have to be revisedive submitted an accompanying pull request with implementation implementation details;"on branch 2phase this test``` javafunc1<integer integer> expensive  new func1<integer integer>() {    @override    public integer call(integer t1) {        systemoutprintln(""omg this is so expensive"")        return t1    }}action1<integer> printit  new action1<integer>() {    @override    public void call(integer t1) {        systemoutprintln(""got "" + t1)    }}@testpublic void go() {    observable<integer> o  observablefrom(1 2 3)map(expensive)take(1)    ogetsubscription()subscribe(printit)}```outputs```omg this is so expensivegot 1omg this is so expensiveomg this is so expensive```on branch master (removing `getsubscription()` in `go()`) it outputs exactly the sameso i dont really get your point i thought you wanted to have only this output:```omg this is so expensivegot 1```could you please elaborate? || why complicate things unnecessarily you should _never_ use a synchronous source in the matter you describe in the first place thats why schedulers exist a synchronous source is only acceptable for doing cheap short work || i hadnt rewritten the from map or take operators to use the two phase subscriptions yet ive just committed the a unit test you wrote and made it work || i dont think it unnecessary if synchronous observables shouldnt be used than why do they existusers cant tell if an observable is synchronous or not if code is written that based on an observable that is asynchronous and it is later changed to synchronous then it could have unintended consequencesadding a thread doesnt guarantee that the receiver will get scheduled to issue the unsubscribe in time || btw _the subscribers to this chain of observables will see the correct result be the author might not realize that there is unnecessary computation going on because the expensive operation is also done for 2 and 3 and thrown away be the take operator_in c#new{ 123}toobservable()select(x > { consolewriteline(""expensive {0}"" x) return x })                take(1)subscribe(consolewriteline)prints as expectedexpensive 11only is you use the immediate scheduler you get as expected since immediate is not really a proper scheduler (and should be used with extreme care if any)expensive 11expensive 2expensive 3but all all other schedulers behave properlytoo lazy right now to check which scheduler is used by default for this in rxjava but we should use currentthread which should take care of your original problem || @abersnaze as i point out it should work if you use the current thread scheduler synchronous observables are like extremely sharp knives use them only when you know what you are doing or you risk to cut your limbs off || currentthreadscheduler only seems to work at the granularity of subscribe or not to subscribe to an observable  on the master branch i put these two unit tests the `testdontstart()` test uses `take(0)` and passes if i insert the current thread scheduler in two key places no amount current thread schedulers seems to make `testinterruptable()`@headinthebox is there something that im missing that will make `testinterruptable()` work?```    @test    public void testinterruptable() {        func1<integer integer> expensive  mock(func1class)        when(expensivecall(any(integerclass)))thenreturn(10)        scheduler sched  schedulerscurrentthread()        list<integer> v  observablefrom(1 2 3)map(expensive)subscribeon(sched)take(1)subscribeon(sched)tolist()toblockingobservable()single()        assertequals(1 vsize())        assertequals(10 vget(0)intvalue())        verify(expensive times(1))call(any(integerclass))    }    @test    public void testdontstart() {        func1<integer integer> expensive  mock(func1class)        when(expensivecall(any(integerclass)))thenreturn(10)        scheduler sched  schedulerscurrentthread()        list<integer> v  observablefrom(1 2 3)map(expensive)subscribeon(sched)take(0)subscribeon(sched)tolist()toblockingobservable()single()        assertequals(0 vsize())        verify(expensive never())call(any(integerclass))    }``` || list<integer> v  observablefrom(1 2 3)map(expensive)subscribeon(sched)>will not work you need to call _from_ with a scheduler see my remark about net (there toobservable() takes a scheduler)  || ive created a new branch in my fork called 1phase where ive been testing out your suggestions  i havent been able to get the unit tests working with observeron(currentthreadscheduler)  i found these comments in the `rxoperatorsoperationobserveon` interesting  should observeron(currentthreadscheduler) do something different?```        public subscription onsubscribe(final observer<? super t> observer) {            if (scheduler instanceof immediatescheduler) {                // do nothing if we request immediatescheduler so we dont invoke overhead                return sourcesubscribe(observer)            } else if (scheduler instanceof currentthreadscheduler) {                // do nothing if we request currentthreadscheduler so we dont invoke overhead                return sourcesubscribe(observer)            } else {                return new observation(observer)init()            }        }``` || you should no start with observablefrom(1 2 3) and avoid immediatescheduler like the plague ***_never ever**_\* use the observablefrom(123) overload instead use the one below and pass currentthreadschedulerpublic static <t> observable<t> from(iterable<? extends t> iterable scheduler scheduler) {        return from(iterable)observeon(scheduler)    } || sorry if i didnt make this clear but that is what i did in the 1phase branch but i still didnt see any change in behavior || this is related to fixing the `currentthreadscheduler` behavior @headinthebox and i are planning on working on that soon || the new subscriber/operator/onsubscribe should handle this case can you check & close? || ";;;;0;1;;
547;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;medlineimportertest;new pr started because the old one was on a wrong branch.  medlineimportest + testfile added  couldn t cover two exceptions in importentries.;;426.0;refactored objectmethodsguru to a static utility class;- refactored `objectmethodsguru` to a static utility class- removed unused methods and associated tests:  - `istostring(mockitomethod method)`  - `isequalsmethod(method method)`  - `ishashcodemethod(method method)`- renamed `istostring()` to `istostringmethod()`relates to #426;  547   ;refactor instance based utility classes to static utility classes;the internal implementation of mockito contains numerous helper classed that serve as a container for useful methods by its nature these classes dont have a state currently some them are instance based in other word you need to create the utility class to call a helper method this not only pollutes the heap but also the code cause instance methods cant be imported statically here is an example:```javahelper helper  new helper()if (helperisinputvalid(input)){   }```vs static import of helperisinputvalid```javaif (isinputvalid(input)){   }```the aim of this ticket is to identify canidates that can be refactored to static utility classes if you like to refactoring and mockito feel free to send a pr and reference this issuerefactoring canidates:-  `accessibilitychanger`-  `beanpropertysetter`-  `conditionalstacktracefilter`-  `fieldcopier`-  `fieldreader`-  `genericmaster` should be integrate into `generictyperesolver`-  `junitfailurehacker` can be removed when the deprecated `verbosemockitojunitrunner` is removed-  `lenientcopytool`-  `matcherbinder`-  `mockitocore` should better be a singleton-  `mockcreationvalidator`- [ ] `removefirstline`-  #591 `argumentmatchingtool`-  #515 `allinvocationsfinder`-  #502 `argumentscomparator`-  #540 `arrayutils`-  #490 `atleastxnumberofinvocationschecker`-  #490 `atleastxnumberofinvocationsinorderchecker`- [ ] #912 `constructors`-  #427 `fieldsetter`-  #908 `friendlyexceptionmaker`-  #431 `handyreturnvalues` - [x] #432 `invocationmarker`- [x] #462 `invocationsfinder`- [x] #908 `junitdetecter`- [x] #490 `missinginvocationchecker`- [x] #490 `missinginvocationinorderchecker`- [x] #514 `mockutil`- [x] #503 `nongreedynumberofinvocationsinorderchecker`- [x] #907 `numberofinvocationsinorderchecker`- [x] #907 `numberofinvocationschecker`- [x] #547 `objectmethodsguru`- [x] #427 `reporter`- [x] #535 `supertypeslastsorter`- [x] #501 `testmethodfinder`- [x] #515 `verifiableinvocationsfinder`;"@raphw thanks for merging the pr that fast!  would you mind reopening this ticket? there are more classes that can be refactored that way i would like to extend the list || big :+1: for me btw but please keep the pull requests managable and as small as possible preferably refactoring 1 method at a time that way it is a lot easier to review || i agree there is nothing wrong with multiple prs the quick merge is a reaction to an easy overview (and being stuck at an ukrainian airport without access to the eurocup) || there are still two unit tests failing could you have a look @christianschwarz - i just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `reporter`i should have checked more thoroughly before merging hopefully you can fix the problem soon alternatively i will just rollback the one commit (the first one is good) and we can reapply the patch once you  the two unit tests thank you really this was great clean-up || i fixed the one test error i push it tonightps: i also fixed a bug in the stack trace cleaner not a biggy but please do not `@ignore` tests especially in big commits it is easy to miss that single annotation || @raphw which test(s) is/are failing? i will fix it asap! too bad that some test fail on a regulare base is it possible to ignore them in the ide only? || you can see the build output here:  advise you to run the tests with `/gradlew build` this should work || @timvdlippe know what you mean! the next prs include only one refactored class at a time || i have it all fixed on local but i did not have access to wifi without 22 blocked will commit soon || @raphw can you please reopen this issue  || sorry github automatically closes issues that reference a pr || @christianschwarz if a commit contains a comment like ""426"" the mentioned issue is automatically closed by github || @pascalschumacher good to know! i will leave it out for the upcoming prs  now that we are pulling in static methods i would like to propose a new (linter) rule to make it easier to read a file i would like that all methods invoked in the current class are referenced with `this` (and `super` for that matter) therefore if we see `thisverify` we know it is in the current class and the same object whereas `verify` references a static method in this class or an imported static method do you agree @mockito/developers ? || > i would like that all methods invoked in the current class are referenced with this (and super for that matter)to me it feels like unnecessary/duplicate code cause `this` is implicit adding `this` before every instance call would create a lot more text and would imho reduce readability eg:`thisdosometing(thiswithprivatemethod())` vs `dosomething(withprivatemethod())`> therefore if we see thisverify we know it is in the current class and the same object whereas verify references a static method in this class or an imported static methodan other option avoid ambiguity is to qualify static methods via its class name  this way you can also distinguish which verify() is called ( `mockitocoreverify()` / `mocktioverify()`)  which is not an easy task when a static import is used || im not coding too much in mockito atm (hopefully now after springone conference ill have more time) but i fully agree with @christianschwarz  imo the best solution is to: - omit `this` before method calls - if necessary provide the class for static method call || respectful -1i like when the class formally declares collaborators instead of calling out to static methods this makes it easy to reason about the code i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etc another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too proceduralthe benefits for converting to static utilities have minimal significance to me yet there is a downside i care about (eg maintainability of procedural code static methods that consume static methods that consume static methods)hence i down vote this sort of changes going down this path all stateless classes in mockito would become static utilities :)you can get +1s from other maintainers and have your changes merged - im not here to block your changes but to give honest feedback i see merit in arguments for static utilities they do not outweigh the cost in my opinion || im mitigated about this as well i understand well that mockito creates garbage but they are short lived and **most probably** wont go in the old generation especially in the test phase yet the faster the tests are the more developers will run them it **may** have impacts on big projects also design wise i dont like much static methods toohowever i dont totally agree with the above points : > i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etccoupling appears also in the import section  static methods are visible there and modern ide usually highlight this intellij even have a warning if import section is too big just as theres warning if theres too many fields this point should not be the reason to avoid static methods> maintainability of procedural code static methods that consume static methods that consume static methodshaving instance methods does not protect again procedural code---i believe theres middle ground there : - mockito project contains a lot of small utility stateless objects that are supporting mockito features these are usually collections tools reflection tools those could are good candidate for static methods objects like `fieldsetter` `fieldcopier` `lenientcopytool` could be nice candidate for static methods- mockito features could be backed by object instances objects like `mockitocore` `mockcreationvalidator` `argumentmatchingtool` are candidate to stay objects || exactly the middle ground described by brice is my motivation for merging most of the prs this is also the reason i have not yet merged the mockitocore pr for this exact reasonif an object is not a attribute or parameter but an internal creation and immediately dismissed i value a pure function more || thought: when we switch to java 8 we can use interfaces with defaultmethods the switch from static utility to interface is very easy now (justa couple of text replaces no method reference modifications)on fri 12 aug 2016 17:23 brice dutheil notifications@githubcom wrote:> im mitigated about this as well i understand well that mockito creates> garbage but they are short lived and _most probably_ wont go in the old> generation especially in the test phase yet the faster the tests are the> more developers will run them it _may_ have impacts on big projects> also design wise i dont like much static methods too> > however i dont totally agree with the above points :> > i dont need to read every line of code in the class to find out external> couplings realized via static methods i can see the couplings via fields> i can easily query how the field variable is used etc> > coupling appears also in the import section  static methods are visible> there and modern ide usually highlight this intellij even have a warning> if import section is too big just as theres warning if theres too many> fields this point should not be the reason to avoid static methods> > maintainability of procedural code static methods that consume static> methods that consume static methods> > ## having instance methods does not protect again procedural code> > i believe theres middle ground there :> >    -> >    mockito project contains a lot of small utility stateless objects that>    are supporting mockito features these are usually collections tools>    reflection tools those could are good candidate for static methods>    objects like fieldsetter fieldcopier lenientcopytool could be nice>    candidate for static methods>    -> >    mockito features could be backed by object instances objects like>    mockitocore mockcreationvalidator argumentmatchingtool are candidate>    to stay objects> > —> you are receiving this because you modified the open/close state> reply to this email directly view it on github>  or mute the thread>   || this feels like a misuse of the default methods || i think you mean static-methods in interfaces here? default-methods require an instance to be called onanyway i dont think that it is a good idea  it would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods imho a class with private constructor is the best construct to do this || > > thought: when we switch to java 8 we can use interfaces with default> > methods> > default-methods require an instance to be called oni was thinking exactly that default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface) || @christianschwarz what do you think to continue the work here with the middle ground described [here]( ? || i am attempting to refactor the matcherbinder class to a static utility class and am having trouble refactoring the following from mockhandlerimpltestjava: `handlermatchersbinder  new matchersbinder() {            public invocationmatcher bindmatchers(argumentmatcherstorage argumentmatcherstorage invocation invocation) {                throw new invaliduseofmatchersexception()            }} `how can i maintain the abstract class definition when i am not able to create an object of matcherbinder?any help is appreciated!  || lets close this ticket refactorings can be done as needed as we work with the code || ";1;0;refactored objectmethodsguru to a static utility class;
549;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fully register a class ancestry for genericmetadatasupport;the old implemention would take a class x and consider all of its superclasses and the interfaces implemented by x and the interfaces implemented by all of its superclasses.  the new implementation also considers the superinterfaces of the interfaces implemented by x and the superinterfaces of the interfaces implemented by its superclasses.  497;;0;bytearraydatainputreadfully() throws a different exception than whats documented; im using comgooglecommoniobytearraydatainput in guava-r08 which i am creating using the factory method in bytestreams:byte buffer  bytearraydatainput in  bytestreamsnewdatainput(buffer)then i read data from this:byte bytes  new bytes[80]inreadfully(bytes)when end-of-file is reached according to the api documentation readfully() throws a javaioeofexception however it really throws a javalangillegalstateexception inside which the eofexception is wrapped example stack trace  javaioeofexception&nbsp&nbsp&nbsp&nbspat comgooglecommoniobytestreams$bytearraydatainputstreamreadfully(bytestreamsjava:269)&nbsp&nbsp&nbsp&nbspcaused by: javaioeofexception&nbsp&nbsp&nbsp&nbspat javaiodatainputstreamreadfully(datainputstreamjava:180)&nbsp&nbsp&nbsp&nbspat javaiodatainputstreamreadfully(datainputstreamjava:152)&nbsp&nbsp&nbsp&nbspat comgooglecommoniobytestreams$bytearraydatainputstreamreadfully(bytestreamsjava:267)&nbsp&nbsp&nbsp&nbsp 25 morenote that the api documentation for bytearraydatainputreadfully() was copied from javaiodatainputreadfully()why is this method wrapping the eofexception in an illegalstateexception?i suspect that the same problem exists in other methods of bytearraydatainput and also of bytearraydataoutput; the doc has been upgraded and im marking this  -- as fixed as it can beim sorry that you disagree with our choice but we made it a long time ago and even removed this interface from @﻿beta status more than two years ago  and as stated we _also_ disagree with our own choices here in a major way and want to put our energies on solving these problems properly in the future--- ;;;;0;1;;
549;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fully register a class ancestry for genericmetadatasupport;the old implemention would take a class x and consider all of its superclasses and the interfaces implemented by x and the interfaces implemented by all of its superclasses.  the new implementation also considers the superinterfaces of the interfaces implemented by x and the superinterfaces of the interfaces implemented by its superclasses.  497;;0;fully register a class ancestry for genericmetadatasupport;the old implemention would take a class x and consider all of its superclassesand the interfaces implemented by x and the interfaces implemented by all ofits superclassesthe new implementation also considers the superinterfaces of the interfacesimplemented by x and the superinterfaces of the interfaces implemented by itssuperclasses497;  549  **< ;;;;1;1;fully register a class ancestry for genericmetadatasupportthe old implemention would take a class x and consider all of its superclassesand the interfaces implemented by x and the interfaces implemented by all ofits superclassesthe new implementation also considers the superinterfaces of the interfacesimplemented by x and the superinterfaces of the interfaces implemented by itssuperclasses497;
549;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fully register a class ancestry for genericmetadatasupport;the old implemention would take a class x and consider all of its superclasses and the interfaces implemented by x and the interfaces implemented by all of its superclasses.  the new implementation also considers the superinterfaces of the interfaces implemented by x and the superinterfaces of the interfaces implemented by its superclasses.  497;;0;optimize like expressions;- if pattern does not have % or _ replace with comparison expression- return new like expression with optimized operands;;;;;1;1;optimize like expressions- if pattern does not have % or _ replace with comparison expression- return new like expression with optimized operands;
549;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fully register a class ancestry for genericmetadatasupport;the old implemention would take a class x and consider all of its superclasses and the interfaces implemented by x and the interfaces implemented by all of its superclasses.  the new implementation also considers the superinterfaces of the interfaces implemented by x and the superinterfaces of the interfaces implemented by its superclasses.  497;;0;creating observables in scala;"the constructors for observables in scala have multiple problems id like to start a systematic discussion about this hoping to find a good solutionfirst a list of use cases that we eventually want to cover:-    usecase01: ""observablecreate the mother of all factory methods"": construct from an onsubscribefunc-    usecase02: an empty observable-    usecase03: emit only 1 given element-    usecase04: emit a given (vararg)list of elements-    usecase05: emit all elements of an iterable-    usecase06: emit all elements of a possibly infinite iterable-    usecase07: emit the single item returned by a future-    usecase08: wrap a java observable (scala only)-    usecase09: emit only a given exception in onerror-    usecase10: emit a range of integers-    usecase11: emit one asynchronously calculated element (a shorthand for constructing a future and then applying usecase07note -    depending on the approach one constructor might cover several usecases since i tried to split them up as much as possible-    this list only contains ""very important"" constructors which are eligible to be called `observableapply` others which have names everyone agrees on such as `defer` `never` `interval` `generate` etc are not listednow a first **approach01** would be to use the same names as java does:``` java/*usecase01:*/ public static <t> observable<t> create(onsubscribefunc<t> func)/*usecase02:*/ public static <t> observable<t> empty()/*usecase03:*/ public static <t> observable<t> just(t value)/*usecase04:*/ public static <t> observable<t> from(t t1  t tn) /* 10 overloads *//*usecase05:*/ public static <t> observable<t> from(iterable<? extends t> iterable)/*usecase06:*/ /* not yet implemented *//*usecase07:*/ public static <t> observable<t> from(future<? extends t> future)/*usecase08:*/ /* na *//*usecase09:*/ public static <t> observable<t> error(throwable exception)/*usecase10:*/ public static observable<integer> range(int start int count)/*usecase11:*/ /* not yet implemented */```we decided against this because this has **problem01**: `observableapply` is not used so we dont exploit a nice feature of scalathats why we implemented this **approach02** (thats version 0151):``` scala/*usecase01:*/ def apply[t](func: observer[t] > subscription): observable[t]/*usecase02:*/ /* special case of usecase04 *//*usecase03:*/ /* special case of usecase04 *//*usecase04:*/ def apply[t](items: t*): observable[t]/*usecase05:*/ /* special case of usecase04 example: */ observable(mylist : _*)/*usecase06:*/ /* not yet implemented not even in java *//*usecase07:*/ /* not yet implemented *//*usecase08:*/ def apply[t](observable: rxobservable[_ <: t])/*usecase09:*/ def apply[t](exception: throwable): observable[t]/*usecase10:*/ def apply(range: range): observable[int]/*usecase11:*/ /* not yet implemented */```but this also turned out to have problems:**problem02**: if i write this:``` scalaval o  observable((observer: observer[int]) > { observeronnext(42) /* no subscription returned by mistake */ })```then i dont get an error but `o` is an `observable[observer[int] > unit]`**problem03**: `observable(new exception new exception)` yields an `observable[exception]` with 2 elements and is not the same as `observable(new exception) ++ observable(new exception)` which yields an `observable[nothing]` with 0 elements terminating with `onerror` coursera students got confused about this**problem04**: the varargs apply and the onsubscribefunc apply clash in such a way that parameter type inference is lost:``` scalaval o1  observable(observer > { subscription{} }) // error: missing parameter type should infer observer[nothing]val o2  observable[int](observer > { observeronnext(1) subscription{} }) // error: missing parameter type should infer observer[int]val o3: observable[int]  observable(observer > { observeronnext(1) subscription{} }) // works```**problem05**: cannot easily construct an observable emitting one future one exception or one range**problem06**: its possible to define both``` scaladef apply[t](items: t*): observable[t] def apply[t](items: iterable[t]): observable[t]```but when i want to use it (eg `observable(list(1 2 3))`) i get ```ambiguous reference to overloaded definition both method apply in object observable of type [t](items: iterable[t])rxlangscalaobservable[t] and method apply in object observable of type [t](items: t*)rxlangscalaobservable[t] match argument types (list[int])```we could also use implicit conversions **approach03**:-    usecase01: ""observablecreate"": call it observableapply-    usecase02: `list()toobservable`-    usecase03: `list(1)toobservable`-    usecase04: `list(1 2 3)toobservable`-    usecase05: `myiterabletoobservable`-    usecase06: `myiterabletoobservable`-    usecase07: `myfuturetoobservable`-    usecase08: `myjavaobservabletoobservable`-    usecase09: `observableerror(new exception)`-    usecase10: `(0 to 4)toobservable`-    usecase11: `observableasync{  }` or something elsehere usecases 02 03 04 05 06 and 10 would all be covered by one single implicit conversion from `iterable[t]` to `observable[t]`however im not yet sure if this approach would lead to other problemsi invite everyone to post new approaches and to comment on existing ones and please use increasing unique ids for usecase approach and problem to keep our discussion tidy -)";"@benjchristensen @headinthebox @jmhofer @phaller @retronym @vjovanov @xeno-by and everyone else your comments are welcome -) || here is my 2 cents1) ""observablecreate"" (note the quotes people :-) is the mother of all constructors so apply should be optimized for that2) add as many other overloads as possible that do not interfere with 1) 3) also have explicit names even for create using extensive overloading on apply is imho not that great since you loose intent for example say i want to do observablejust(new exception(""as a regular value"")) versus observableerror[integer](new exception%28""trigger onerror""%29)  || what about **approach04**:``` scala/ ;;;;0;1;;
550;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed #538 changed error message in case initialization for mock injection fails.;fixed #538  if a filed is annotated with @injectmocks and the type of a field is an enum  inner class  interface or local class the error message is now: _ mock injection failed on field  fieldname  cause the type  abstractcollection  is an abstract class._;;0;provide access to expirable entry age;jbel@ i would like to use mapmaperexpireafterwrite but i need access to the age of non-expired entries  (see https://issuesapacheorg/jira/browse/cassandra-2070); _issue #1484 has been merged into this issue_ || ";;;;0;1;;
550;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed #538 changed error message in case initialization for mock injection fails.;fixed #538  if a filed is annotated with @injectmocks and the type of a field is an enum  inner class  interface or local class the error message is now: _ mock injection failed on field  fieldname  cause the type  abstractcollection  is an abstract class._;;0;fix null handling in like expressions;;assuming a null escape should produce a null  yeah i checked the sql spec to be clear ||;;;;1;1;fix null handling in like expressions;
550;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed #538 changed error message in case initialization for mock injection fails.;fixed #538  if a filed is annotated with @injectmocks and the type of a field is an enum  inner class  interface or local class the error message is now: _ mock injection failed on field  fieldname  cause the type  abstractcollection  is an abstract class._;;0;provide support for remotingobservable;net version supports remotingobservable a similar solution using java rmi library as a first implementation and then prototype other transport mechanismthoughts?;"we are experimenting with remoteobservable strategies but will almost certainly have the implementations as contrib modules because implementations can vary widely for example one im working on right now uses netty with simple async message passingi highly doubt rmi makes sense it is basically a disaster to build and operate and far better approaches now exist i have done it in the past and will never do so again oracle/sun folks themselves talk about how much they despise java serialization in short java rmi is effectively deprecated what specifically are the use cases youre looking for in a remoteobservable? id like to find out if there is a core interface that unifies all use cases and can support different connectivity and serialization strategies as contrib modules  || 1 yes i thought rmi would be a clunky implementation but it could be a start i guess to prototype this2 my usecase is theoretical at the moment but could as well be practical :)3 basically i would like to be able to emit certain business events from some services and listen for those events on another end currently if i want to achieve this i would have to use something like jms or pubsub another protocol (amqp) the problem is that i want the client to be in control how to enrich filter and transform those events lets imagine a remote observable emits events: adevent of type changed updated or inserted the event looks like thiscase class adevent(type: type id: long version: long)case class ad(type: type id: long version: long some other attributes)currently i have to filter for ad type on the client level i also have to do transformation and composition on the client level this is less than ideal the ideal solution for me would be to pass a ""subscription - ie set of functions applied"" eg observablefilter(e: adevent > etype  typechanged)map(e: adevent > enrichevent(e))enrich method would perform an external call via future and receive data would effectively enrich the event of maybe get it from the cachein turn the object that would arrive to the client would be like a fairly complete domain object the amazing part and this is where i dont know if something like this could work is that enrichevent(e) would be invoked on the server side(!) rather than a client side maybe one would need to use some kind of scripting language to achieve this because in this case actually i would like to pass a computation to be done on the server sideis this something you are working on?mateusz || ";;;;0;1;;
550;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed #538 changed error message in case initialization for mock injection fails.;fixed #538  if a filed is annotated with @injectmocks and the type of a field is an enum  inner class  interface or local class the error message is now: _ mock injection failed on field  fieldname  cause the type  abstractcollection  is an abstract class._;;538.0; #538 changed error message in case initialization for mock injection fails;" #538if a filed is annotated with @injectmocks and the type of a field is an enum inner class interface or local class the error message is now: _""mock injection failed on field fieldname cause the type abstractcollection is an abstract class_""";"openjdk6 build failed the others gone clearwow! the native world exploded``` test*** buffer overflow detected ***: /usr/lib/jvm/java-6-openjdk-amd64/bin/java terminated backtrace: /lib/x86_64-linux-gnu/libcso6(__fortify_fail+0x37)[0x7fa189635e37]/lib/x86_64-linux-gnu/libcso6(+0x108d30)[0x7fa189634d30]/usr/lib/jvm/java-6-openjdk-amd64/jre/lib/amd64/libnetso(java_java_net_inet4addressimpl_getlocalhostname+0x1a0)[0x7fa1843c0d80][0x7fa17d0136b0]``` || this seem to be an issue with travis itself :  || from their thread the workaround in the [travisyml]( doesnt work anymorecc @raphw  || ha theres been a change a few days ago :  should use the hosts addon : ``` ymladdons:  hosts:    - myshorthost  hostname: myshorthost``` || aside from the help removal that i dont want removed the code  @christianschwarz you can rebase on master i may have pushed a working fix for the buffer overflow issue in #553 || @bric3 > aside from the help removal that i dont want removed the code looks goodthanks for reviewing! if you dont mind i would like to have a short discussion on the error message inorder to help devs to fix the issue---full error message:```cannot instantiate @injectmocks field named configurationmanageryou havent provided the instance at field declaration so i tried to construct the instancehowever i failed because: the type configurationmanager is an interfaceexamples of correct usage of @injectmocks:   @injectmocks service service  new service()   @injectmocks service service   //also dont forget about mockitoannotationsinitmocks()   //and dont forget about some @mocks for injection :)```**line 1**: `""cannot instantiate @injectmocks field named "" + fieldname + """"`okay that line was replaced with something like: `""@injectmocks failed on field f cause the type innerclass is an inner non static class""` so far so good**line 2**:  `""you havent provided the instance at field declaration so i tried to construct the instance""`i would like to remove that line the dev added @injectmocks in order to construct  an instance do  we really need to tell him what he did?  **line 3**: `""however i failed because: "" + detailsgetmessage()`can be removed it is now included in the first line**line 4**: `""examples of correct usage of @injectmocks:""`hmmm i have no idea how a dev can learn from the provided examples the field declaration is not wrong in this case but the provided filed type that is hard (impossible) to express in an example if you have an idea i will add it**line 5**: `""   @injectmocks service service  new service()""`ouch that hurts! i didnt know that it works! what do users expect to happen in this case big question? imho mockito should fail here indicating that either @injectmocks should be removed cause it have no effect or indicating that the field must be initialised with `null`/ leaved blank or is it over written after mockito set the field?**line 6**: `""   @injectmocks service service""`same as for line 4**line 7**: `""   //also dont forget about mockitoannotationsinitmocks()""`this line can be removed the user (or rule/runner) didnt forget to call initmocks() other wise he wont see this error message**line 8**:  `""   //and dont forget about some @mocks for injection :)""`that is confusing we dont need mocked fields if the class has an no arg  constructor` ||   550  **<  ";improve error message when @injectmocks is uses on an interface or enum field;by accident a tests delares a field of an interface type instead of the implementing class  ```@injectmockspublic interfacetype unitundertest```injection is not possible on interfaces or enums the error message should make this clear the currenta message that doesnt help much:```orgmockitoexceptionsbasemockitoexception: cannot instantiate @injectmocks field named configurationmanageryou havent provided the instance at field declaration so i tried to construct the instancehowever i failed because: the type configurationmanager is an interfaceexamples of correct usage of @injectmocks:   @injectmocks service service  new service()   @injectmocks service service   //also dont forget about mockitoannotationsinitmocks()   //and dont forget about some @mocks for injection :)```the error message should be someting like:`the field unitundertest can not be annotated with @injectmocks cause the type interfacetype  not a class!`;;1;0; #538 changed error message in case initialization for mockinjection fails;
555;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;junit rules report unused stubs - 384;- makes junit rules detect unused stubs - introduces mockitolistener api - see the use case in issue #384  - recreated pr #527 with squashed commits;;0;enummultisetcreate(iterable class); please implement the factory method &lte extends enum&lte>> enummultisetcreate(iterable&lte> class&lte>)the method create(iterable) already exists but doesnt allow empty iterables to be passed as argument this method would fix this issue as it would act like setsnewenumset(iterable class) but for enummultiset; submitted internally should be mirrored out soon--- ;;;;0;1;;
555;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;junit rules report unused stubs - 384;- makes junit rules detect unused stubs - introduces mockitolistener api - see the use case in issue #384  - recreated pr #527 with squashed commits;;0;do not assume metastoreget_partitions_by_names returns partitions in the same order as requested;;;;;;1;1;do not assume metastoreget_partitions_by_names returns partitions in the same order as requested;
555;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;junit rules report unused stubs - 384;- makes junit rules detect unused stubs - introduces mockitolistener api - see the use case in issue #384  - recreated pr #527 with squashed commits;;0;skipuntil() marble diagram and wiki link in javadoc;;#484 ;;;;1;1;skipuntil() marble diagram and wiki link in javadoc;
555;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;junit rules report unused stubs - 384;- makes junit rules detect unused stubs - introduces mockitolistener api - see the use case in issue #384  - recreated pr #527 with squashed commits;;384.0;junit rules report unused stubs - 384;- makes junit rules detect unused stubs- introduces mockitolistener api- see the use case in issue #384 - recreated pr #527 with squashed commits;lets merge this today this pr is a squash of #527 plus some code changes per code review feedback (i addressed code feedback subjectively and selectively :) ||   555  ;junit rule logs warnings about unsued / misused stubs;"### whywhen test fails the failure might be caused by misused stubs hence it might be worth to log out debugging information to the system out (eg misused stubs unused stubs) for more details see documentation for [mockitohint]( plan-  document 2x change-  tweak the warning message-  add behavior to the runner-  add silent runner-  add silent setting to the rule (or warnings level for all / exception only / none)-  deprecate/remove console spamming runner### implthe junit rule or the runner will potentially include following info in the output (somehow):  wondering if ""mockitovalidatemockitousage()"" should automatically print warnings we could provide boolean parameter to control printing of the warnings";"on it || i like the feature! what do you think about a `rule()strict()` that doesnt emit logs but fails asap?a note to the api:- how do we prevent misuse like -> `rule()strict()strict()` ? what about `rule(log_warnings)` aka `rule()` `rule(silent)` `rule(fail_fast)` || christian very cool ideas!!! im not sure ill have time for it before 20 however i want the new default behavior in rule / runner in 20 so that users see what it is doing then we can grow and add strict mode || @szczepiq: i like this feature very much also that the `mockitojunitrunner` fails by default is good i think a note in the javadoc of `unnecessarystubbingexception` to use `mockitojunitrunnersilent` would be helpfulwe often have quite complex test fixtures and its cumbersome to switch absolutely each and every stub on or off some methods simply have to be there its also not necessary to verify if theyve been invoked so it would be great to be able to disable it for some stubs but leave it on for others || @t1 that seems like a reasonable idea want to make a pr for that? || good feedback i think that mockitohint class should also mention that it is possible to silence the new mechanism || #609 || the [mockitohint]( documentation seems to indicate that this will give you warnings about mismatched arguments when using the mockitojunitrunner  however from my experience this doesnt seem to work with mockito 21heres the source im trying:``` javafoo foo  mock(fooclass)when(foobar(""baz""))thenreturn(""bar"")foobar(""baz"")foobar(""test"") // expected to get a warning here```is there something else i need to do to enable this functionality? || thank you for feedback!> is there something else i need to do to enable this functionality?this is how they were implemented runner should also report mismatches because it helps with debugging the reason it does not do it today is because i wanted to limit the noisewe will fix this issue also we will consider always printing warning when stub args mismatch even if one does not use runner / ruledo you want to open a separate ticket to track this improvement?thanks for reporting! || ive opened #725 to track this || came across this after running into this in my test :```[mockitohint] mytestchecksomething (see javadoc for mockitohint):[mockitohint] 1 unused -> at mytesttest1(mytestjava:584)```it is complaining about this (line 584):```   when(mockobjectgetpeerhost())thenreturn(""peer-host-from-mock"")```now my issue is this: this particular method `getpeerhost()` is indeed not called when the code works as expected eg something like this:```   if (newmethod()) {             string peerhost  mockobjectgetpeerhost()       // use peerhost in further processing         }````newmethod()` is the new code being added and should correctly return `false` however if there is a bug in `newmethod()` and it returns `true` then i want `getpeerhost()` to return some value which will cause a failure that i can detect so this requires me to mock a method even if it is not called in normal processing and there is no bug in the code i think that should not generate a warning has this been addressed? || do i need to open a new issue as i cannot reopen this? || > do i need to open a new issue as i cannot reopen this?yes please> has this been addressed?yes for example you can use ```lenient()when()``` stubbing to avoid reporting an unused stubbing however in your test case i would simply write ```verify(mockobject never())getpeerhost()```hope that helps! || > yes for example you can use `lenient()when()` stubbing to avoid reporting an unused stubbing thanks for the `lenient` tip - that helps> however in your test case i would simply write `verify(mockobject never())getpeerhost()`> thats more work and more white box testing than i want lets say this is for testing the ssl logic where peerhost (of a connection) is matched (or not matched) against ""subject-name"" in a cert under various conditions but i have common setup/initialization where i ""mock"" the peerhost of the connection in one of the conditions the host-name match is suppressed (ie `newmathod()` returns `false`) but because of the common setup code i get the unused warning from `mockitohint` for that test || my recommendation is to use lenient() + strict stubbing for this use caseif you feel we should still discuss the use case ``verify(never())`` vs ``when()thenthrow()`` then please open a separate tickethope that helps and thank you for feedback! || ";1;0;junit rules report unused stubs- this commit squashes 50+ commits- introduces new mockitolistener api issue #384;
555;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;junit rules report unused stubs - 384;- makes junit rules detect unused stubs - introduces mockitolistener api - see the use case in issue #384  - recreated pr #527 with squashed commits;;527.0;junit rules report unused stubs - 384;- makes junit rules detect unused stubs- introduces mockitolistener api- see the use case in issue #384 - recreated pr #527 with squashed commits;lets merge this today this pr is a squash of #527 plus some code changes per code review feedback (i addressed code feedback subjectively and selectively :) ||   555  ;384 - junit rule provides stubbing hint to help debugging tests;recreated the branch / recreated the pr this is ready i want to improve the docs (mockitohint) before mergingsee the use case in issue #384 im growing the stubbinglistener and getting junit rule take advantage of it to report hints to the user that hopefully help debugging tests;"if there is no feedback ill merge in the next 48 hours ||   very soon || im done currently the listeners need to be per thread and its documented in the javadoc i dont know if it is the best idea but given trade-offs i chose this implementation || @szczepiq the threading problem should be avoided before release i looked into it worked on a fix proposal that you can find here -> [gist]( idea is to store the listeners is in `threadsafemockingprogress` that is used as global access instead of the `mockingprogressimpl` that is used only for the calling threadwdyt? || @szczepiq more more thing that i noticed the listener methods should be pre with ""on"" like `onmockcreated()` and the notifing method should be prefixed with ""fire"" like `firemockcreated()` currently both methods (the notifying and listener method) cant be distinguished cause both have the name `mockcreated()` || @szczepiq `stubbinglistener` should implement `mockitolistener` this way it can be registered using  `mockingprogressaddlistener()` after that set-/ removestubbinglistener() can be removed || @christianschwarz great feedback thanks!+1 to the rename on the listeners-1 stubbinglistener changes - im getting rid of stubbinglistener i reopened #401 stubbinglistener does not work in multi-threaded environment where shared mock is interacted with from multiple threads stubbing used event can be triggered from multiple threads i would have to make stubbinglistener completely static to handle this scenario (which would introduce set of complexities) || feedback incorporated :) any final feedback?ill recreate pr with squashed commits tomorrow & merge next step for me: 401  || massive change (52 files) give us a bit more time ! || > massive change (52 files) give us a bit more time !@bric3 absolutely in return can you commit to review eta? (reopened issue #401 needs this pr merged) || @szczepiq doing it right now ) || ok reviewed nice work ! || recreated with squash at #555 addressed code feedback selectively making subjective judgements :) || you can push force on the same branch github will figure out the difference and will close comments that have been fixed  || @szczepiq did you see the comments were i not referenced your name? most of the them are uncommented || ";1;0;junit rules report unused stubs- this commit squashes 50+ commits- introduces new mockitolistener api issue #384;
556;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;move mockito internal classes to internal package;551;;0;comparisonchain doesnt support nulls; currently comparisonchainstart()compare(null null) will throw a npe this is reasonable of course but sometimes its useful to compare objects that have some of their fields unset with null appearing at the beginning or the endhow do people feel about supporting a comparenullablenullfirst() that does something reasonable along these lines?  (compare objectsequals() which is useful for handling equality with the possibility of null); thank you philips ||;;;;0;1;;
556;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;move mockito internal classes to internal package;551;;0;move mockito internal classes to internal package;551;;;;;1;1;move mockito internal classes to internal package;
556;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;move mockito internal classes to internal package;551;;0;add support for order by + limit by multiple fields;;;;;;0;1;;
556;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;move mockito internal classes to internal package;551;;0;are there any build in observers for invoking action if onerror or onnext was called?;are there any build in observers for invoking action if onerror or onnext was called?typical use case is rest call from ui before rest call you should disable inteface and if operation success or fails you should reenable it again```    progressdialogfragmentshow(getactivity())    apisomemethpd()            dooneach(new nextorerrorobserver<driverapplication>(new action0() {                @override                public void call() {                    progressdialogfragmentdismiss(getactivity())                }            }))            subscribe(new action1<result>() {                           @override                           public void call(result result) {                                                          }                       } new action1<throwable>() {                           @override                           public void call(throwable throwable) {                                                          }                       }            )```currently i implemented one by my self```    public class nextorerrorobserver<t> implements observer<t> {        private action0 nextorerroraction        public nextorerrorobserver(action0 nextorerroraction) {            thisnextorerroraction  nextorerroraction        }        @override        public void oncompleted() {        }        @override        public void onerror(throwable e) {            nextorerroractioncall()        }        @override        public void onnext(t args) {            nextorerroractioncall()        }    }```btw: i cannot use finallydo for this finally do only triggered for oncomplete and onerror also i need my method to be called before onnext and onerror;probably we can add additional variation of dooneach like doonnextorerror? || there are already options for this:- `doonerror`  `dooncompleted`  `dooneach` for various overloads:  can put these in the sequence wherever you want (before/after whichever sequence of the chain) || @benjchristensen so right now im using dooneach with my custom observer there is no doonnextorerror that i need do you thinks its reasonable to have this overload in framework? i can implement it and make a pull request || there is a dooneach that takes actions for onnext and onerror i dont understand how that is different than a doonnextoronerror  || @benjchristensen difference is that i need to run same logic in both onnext and onerror if i will use onnext and onerror i will need to call progressdialogfragmentdismiss() in each of them  || why is that an issue to call it in either of them? you can pass the same function to both the `onerror` and `onnext` args for `dooneach` one or the other will be called and `progressdialogfragmentdismiss()` will be invoked either way || @benjchristensen the only problem is that its very frequent use case so code like this will be repeated very often: apidooneach(actiononnextorerror actiononnextorerror)i just feel that this overload looks much nicer: apidoonnextorerror(actiononnextorerror) || its not appropriate to do both onnext and onerror with the same function as they receive different argument types onnext receives type t onerror receives throwable thus your use case is unique in ignoring either argument the oneach operator is not the right place to combine these it sounds like you want something like finallydo for terminal state (after oncomplete or onerror) but before instead of after  || @benjchristensen you are right i actually used finallydo before but in mine specific use case i realized that i cannot use finallydo since the code should be executed before onnext and onerrorso you think that should be another operator with name like beforedo?or its not a generic case and my approach with nextorerrorobserver is fine:```    apisomemethpd()            dooneach(new nextorerrorobserver<driverapplication>(new action0() {                @override                public void call() {                    progressdialogfragmentdismiss(getactivity())                }            }))``` || @benjchristensen i ended with using this custom class which i can supply as an argument to dooneach```    public abstract class nextorerroraction0<t> implements action0 observer<t> {        @override        public void oncompleted() {        }        @override        public void onerror(throwable e) {            call()        }        @override        public void onnext(t args) {            call()        }        @override        public abstract void call()    }``` || i think your use of `dooneach` is appropriate for your use case ||;;;;0;1;;
557;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace or remove code.google.com links in documentation;most links are replaced by their github equivalent. some links were pointing to issues on code.google.com  but given the large amount of documentation on these methods i decided to remove them.  533;;0;iterate over iterables using specified positions; i came across a situation in which i wanted to get a subset of a list defined by multiple positionswhat do you think about the following proposal:public static &ltt> iterable&ltt> filter(final iterable&ltt> iterable final iterable&ltinteger> positions) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsppreconditionschecknotnull(iterable)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsppreconditionschecknotnull(positions)```    final iterator<integer> positionsiterator  positionsiterator()    if (listclassisinstance(iterable)) {        return new iterable<t>() {            @suppresswarnings(""unchecked"")            final list<t> list  listclasscast(iterable)            @override            public iterator<t> iterator() {                return new abstractiterator<t>() {                    @override                    protected t computenext() {                        if (positionsiteratorhasnext()) {                            return listget(positionsiteratornext())                        }                        return endofdata()                    }                }            }        }    }    else {        return new iterable<t>() {            @override            public iterator<t> iterator() {                return new abstractiterator<t>() {                    @override                    protected t computenext() {                        if (positionsiteratorhasnext()) {                            return iterablesget(iterable positionsiteratornext())                        }                        return endofdata()                    }                }            }        }    }}```"; i agree with jim so `<t> function<integer t> functionsforlist(list<t>)` then? looks good to mealso the function can be passed to `liststransform` too besides `iterablestransform` || ";;;;0;1;;
557;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace or remove code.google.com links in documentation;most links are replaced by their github equivalent. some links were pointing to issues on code.google.com  but given the large amount of documentation on these methods i decided to remove them.  533;;0;replace or remove codegooglecom links in documentation;most links are replaced by their github equivalent some links were pointing to issues on codegooglecom but given the large amount of documentation on these methods i decided to remove them533;;;;;1;1;replace or remove codegooglecom links in documentation;
557;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace or remove code.google.com links in documentation;most links are replaced by their github equivalent. some links were pointing to issues on code.google.com  but given the large amount of documentation on these methods i decided to remove them.  533;;0;add more information to events;add source remote user address and user agent to sessionadd partition id to hive split info;;;;;1;1;add partitionid to hivesplit info object;
557;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace or remove code.google.com links in documentation;most links are replaced by their github equivalent. some links were pointing to issues on code.google.com  but given the large amount of documentation on these methods i decided to remove them.  533;;0;observeon: moved queue into a per-observer instance;"i dont fully understand why the original didnt work properly my guess is either the shared queue between observers or a race condition on the recursivescheduler field my implementation seems to work correctly with the test case in #551``` javapublic class observeontest {    static class printobserver<t> implements observer<t> {        private final string prefix        public printobserver(string prefix) {            thisprefix  prefix        }        void printprefix() {            systemoutprint(prefix)            systemoutprint("": "")        }        @override        public void onnext(t args) {            synchronized (printobserverclass) {                printprefix()                systemoutprintln(args)            }        }        @override        public void onerror(throwable e) {            synchronized (printobserverclass) {                printprefix()                systemoutprintln(e)            }        }        @override        public void oncompleted() {            synchronized (printobserverclass) {                printprefix()                systemoutprintln(""done"")            }        }    }    public static void main(string args) throws exception {        observable<integer> o  observablefrom(1 2 3)        observable<integer> o2  oobserveon(schedulersthreadpoolforcomputation())        systemoutprintln(""subscribe a"")        o2subscribe(new printobserver<>(""a""))        systemoutprintln(""subscribe b"")        o2subscribe(new printobserver<>(""b""))        systemoutprintln(""waiting"")        threadsleep(1000)        systemoutprintln(""done"")    }}```";"#485  i think this should work it seems you left some ""garbage"" in the `observeon` class as you introduced `observation` ``` private static class observeon<t> implements onsubscribefunc<t> {    private final observable<? extends t> source    private final scheduler scheduler    private volatile scheduler recursivescheduler    final concurrentlinkedqueue<notification<? extends t>> queue  new concurrentlinkedqueue<notification<?    extends t>>()    final atomicinteger counter  new atomicinteger(0)```can you also add the sample as a unit test? || ill remove the previous version and add the test shortly || ";;;;0;1;;
560;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;write all field keys in lower case;write all field keys in lower case. no more camel casing of field names. e.g.   title  is written instead of  title    howpublished  instead of  howpublished   and  doi  instead of  doi . the configuration option  use camel case for field names (e.g.   howpublished  instead of  howpublished )  is gone.  refs #116;;0;inetaddresses methods for string to int conversion; i suggest to provide these methods in inetaddresses:&nbsp&nbsppublic static int coercetointeger(string ip) {&nbsp&nbsp&nbsp&nbspreturn intsfrombytearray(texttonumericformatv4(ip))&nbsp&nbsp}&nbsp&nbsppublic static string fromintegertostring(int address) {&nbsp&nbsp&nbsp&nbspreturn utiljoin("""" intstobytearray(address))&nbsp&nbsp}where utiljoin() is the same as intsjoin() except that int is replaced by byte as follows:&nbsp&nbsppublic static string join(string separator byte array) {(feel free to name these differently if you decide to include them)this approach is faster than existing approach in inetaddresses which requires that you go through inetaddress objects it is useful to be able to store ip address as ints instead of string or inetaddress objects (saves a lot of space when you are storing large numbers of ip addresses)"; ;;;;0;1;;
560;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;write all field keys in lower case;write all field keys in lower case. no more camel casing of field names. e.g.   title  is written instead of  title    howpublished  instead of  howpublished   and  doi  instead of  doi . the configuration option  use camel case for field names (e.g.   howpublished  instead of  howpublished )  is gone.  refs #116;;0;date time and interval literals;; ;;;;0;1;;
560;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;write all field keys in lower case;write all field keys in lower case. no more camel casing of field names. e.g.   title  is written instead of  title    howpublished  instead of  howpublished   and  doi  instead of  doi . the configuration option  use camel case for field names (e.g.   howpublished  instead of  howpublished )  is gone.  refs #116;;532.0;add type variances for dooneach actions;this fixes the use of contravariant actions (issue #532);#487  ;dooneach variance;just to make sure we dont forget about this one: `dooneach` & friends still need `? extends t` / `? super t`;this is completed along with a refactoring to having `dooneach` `doonnext` `dooncompleted` and `doonerror` ||;1;0;add type variances for dooneach actionsthis fixes the use of contravariant actions;
560;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;write all field keys in lower case;write all field keys in lower case. no more camel casing of field names. e.g.   title  is written instead of  title    howpublished  instead of  howpublished   and  doi  instead of  doi . the configuration option  use camel case for field names (e.g.   howpublished  instead of  howpublished )  is gone.  refs #116;;554.0;554 : checkschecknotnull now throws iae instead of npe;changes npe to iae see #554;lgtm you can merge when travis passes ||;checkschecknotnull should emit illegalargumentexception instead of npe;checkschecknotnull emits npe i think it is better to emit iae because:- iae is more specific whereas npe is more generic specific exception is easier to test- specific exception gives better experience for users npe is often assumed to be developer errorthis change is not backwards compatible@bric3 thoughts?;definitely! personally i hate throwing npes npe can be thrown because youve forgotten to inject sth and your test (if you test for an npe exception to be thrown) will pass || agreed  ||;1;0;554 : checkschecknotnull now throws iae instead of npe;
568;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed #564: cite command changes are immediately reflected in the pus…;…h-to-application actions  and not only after restart;;0;incompatible byte code to java 5 in guava-r08-gwtjar;therrm@ using the release guava-r08-gwtjar on java 5 triggers a javalangunsupportedclassversionerror exception this issue can be resolved by adding a target""15"" attribute to the javac element of the gwtcompile targeti experienced this issue using jdk150_06 on debian linuxi could not reproduce the issue using the same version jdk on windowsxp"; ;;;;0;1;;
568;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed #564: cite command changes are immediately reflected in the pus…;…h-to-application actions  and not only after restart;;0;implement mysql-compatible date format/parse functions;;looks good to me but you might want to have @electrum review this || ;;;;1;1;implement mysql-compatible date format/parse functions;
568;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed #564: cite command changes are immediately reflected in the pus…;…h-to-application actions  and not only after restart;;0;use lock free strategy for several subscription implementations;reduce contention by using cas (compare and swap) operations to replacesubscription in several subscription implementations;#497  can you use 4-space indent to make this modification more clear? its better that keeping consistent || right there is a potential race condition im going to try to reproduce it via a unit test and find an alternative || i checked nullity because it was checked by the previous code as no unit test was covering nullity cases i chose to keep it compatible with null subscription do you suggest not to check for nullity ? || you need something like this:``` javapublic void setsubscription(final subscription subscription) {    subscription q  null    do {        subscription r  referenceget()        if (r  sentinel) {            q  newreg            break        }        if (referencecompareandset(r subscription)) {            q  r            break        }    } while (true)    if (q ! null) {        qunsubscribe()    }}```similar to [this]( || what about this version using a read/write lock to minimize contention between concurrent setsubscription() calls ? || #498 thanks to akarnokd i could get ride of the atomicboolean and read/write lock using a sentinel || #499 looks good || [rxjava-pull-requests #501 [rxjava-pull-requests #502]( successthis pull request looks good || [rxjava-pull-requests #503]( successthis pull request looks good || we should add isunsubscribed to serialsubscription || not sure if i understand the role of `unsubscribe` it is set to current when you actually unsubscribe (assuming single threaded execution)   sunsubscribe()   ~~>   setsubscription(unsubscribed)   ~~>   current  referenceget()   ~~~> [referencecompareandset(current subscription)  true ]   currentunsubscribe()   ~~~> [subscription  unsubscribed]  unsubscribe  currentnow we do ```ssetsubscription(x)~~~>current  referenceget()~~~> [ current  unsubscribed because we unsubscribed above ]subscriptionunsubscribe()```and then we do```sgetsubscription() ~~~>  subscription  referenceget()  ~~> [ subscription  unsubscribed] return unsubscribe // which was set above to current```so we are returning an arbitrary old subscription when you do getsubscription seems you can do without it``` @override public void unsubscribe() {    setsubscription(unsubscribed) }public void setsubscription(final subscription subscription) {    do {        final subscription current  referenceget()        if (current  unsubscribed) {            subscriptionunsubscribe()            break        }        if (referencecompareandset(current subscription)) {            currentunsubscribe()            if(subscription  unsubscribed) {                    unsubscribe  current            }            break        }    } while (true)}public subscription getsubscription() {        subscription subscription  referenceget()            return subscription  unsubscribed ? unsubscribe : subscription}``` || because we need a way to indicate completion of the subscription and empty is public so clients might swap it in or out reactivating the subscription my example matches the rxnet way || dont get what you say if you are unsubscribed anyway why not return unsubscribed? || sorry i couldnt follow jloisels commits due to the heavy rewriting the field `private volatile subscription unsubscribe` seems to be useless one should return `subscriptionsempty()` when unsubscribedthe `setsubscription(unsubscribed)` is an overkill we could just use `referencegetandset(unsubscribed)` and unsubscribe the returned value if not nullthe correct class should look like this:``` javapublic class serialsubscription implements subscription {    private final atomicreference<subscription> reference  new atomicreference<subscription>()    private static final subscription unsubscribed  new subscription() {        @override        public void unsubscribe() {        }    }    @override    public void unsubscribe() {        subscription q  referencegetandset(unsubscribed)        if (q ! null) {            qunsubscribe()        }    }    public void setsubscription(final subscription subscription) {        subscription q  null        do {            final subscription current  referenceget()            if (current  unsubscribed) {                q  subscription                break            }            if (referencecompareandset(current subscription)) {                q  current                break            }        } while (true)        if (q ! null) {            qunsubscribe()        }    }    public subscription getsubscription() {            subscription subscription  referenceget()            return subscription  unsubscribed ? subscriptionsempty() : subscription    }    public boolean isunsubscribed() {        return referenceget()  unsubscribed    }}``` || headinthebox > unsubscribed is the internal sentinel it should not escape from serialsubscription internal implementation since it could lead to unexpected behaviorwe could another complete different approach: since managing a thread-safe mutable state is difficult shouldnt we make the serial subscription immutable ? i mean:- getsubscription() method violates encapsulation: it lets the internal state escape one could unsubscribe the internal subscription from outside the serial subscription which could lead to double unscribe() if then unscribed from serial- shouldnt serialsubscription be package protected or have at least a static factory method with a private constructor like:```public static subscription serial(final subscription delegate) {    return new serialsubscription(delegate)}```and remove getsubscription() since its never used in the api of course this tends to no backward compatibility on this class since its public || if we tend to have the same behavior as before getsubscription() should return null when previously unscribed || [rxjava-pull-requests #505]( successthis pull request looks good || i think we cannot use subscriptionsempty() as unsubscribed sentinel since it would behave unexpectedly it one sets empty() from outside via setsubscription()i tend also to avoid null references in implementation to avoid unnecessary burden which reduces comprehensionrx-core code base analysis shows that serialsubscription could be easily immutable but it diverges with rx contract: than try to have a complex contract for serialsubscription i would give a try to make it immutable immutable is thread-safe by nature as well as contention free || oh it seems like due to cyclic dependencies (like on resultsink) its not possible to make it immutable || [rxjava-pull-requests #525]( successthis pull request looks good || looks like an improvement on current implementation and dont see problems using a state machine here is far preferable to the previous lock based implementation  this should help or fix  ||;;;;1;1;use non-locking state machine based on atomic reference;
568;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed #564: cite command changes are immediately reflected in the pus…;…h-to-application actions  and not only after restart;;332.0;ensured that mockitojunitrunner is thread safe wrt unused stubs detection;this pr concludes #401 yay!!!!highlights:-  the thread safety problem by leveraging the same api that junit rules used for hinting at unused stubs- removed stubbinglistener api (it could not work to the thread safety levels we support in mockito see also #545)closes #332401;  if no other feedback if youre happy with change merge yourself :) ||;finalize mockito runners;currently we have a couple of mockito runners that are a part of public api but they are largely unknown:- consolespammingmockitojunitrunner- verbosemockitojunitrunnerthey attempt to improve the testing / tdd experience by adding warnings for following scenarios:     - a) unused stubbing     - b) stubbed method called with different args (and a special variant of a)example of a warning:--- **\* stubbing warnings from mockito: ***stubbed with those args here   -> at orgmockitousagejunitrunnermodellingverbbut called with different args -> at orgmockitousagejunitrunnermodellingverbosemockitotestshouldlogunusedsthis stubbing was never used   -> at orgmockitousagejunitrunnermodellingverbosemockitotestshouldlogunusedstubbingwarningthis stubbing was never used   -> at orgmockitousagejunitrunnermodellingverbosemockitotestshouldlogunusedstubbingwarningwh---the rationale is explained in the javadoc of the above runners in 20 let’s include stubbing warnings in the default behavior of junit rule and the default runnerchallenges that need thinking through:- feature parity with junit rule- clean api so that the warning system can be integrated with other runners- some api to get hold of those warnings programmatically- feature toggle  - disable completely  - disable by test / test class / stubbing?- how can this be tested?;> how can this be tested?using `junitcore` theres already a few tests that uses it> - feature toggle>   - disable completely>   - disable by test / test class / stubbing?using the plugin switch functionality ?note theres some idea in the pull request to toggle stuff per test / test class however i dont feel this is mature enough to be integrated in mockito yetin my opinion the `rule` is the the right place to configure mockito per test ||;1;0;added javadocalthough those classes are internal javadoc is useful here because this part could be hard to grasp;
568;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed #564: cite command changes are immediately reflected in the pus…;…h-to-application actions  and not only after restart;;401.0;ensured that mockitojunitrunner is thread safe wrt unused stubs detection;this pr concludes #401 yay!!!!highlights:-  the thread safety problem by leveraging the same api that junit rules used for hinting at unused stubs- removed stubbinglistener api (it could not work to the thread safety levels we support in mockito see also #545)closes #332401;  if no other feedback if youre happy with change merge yourself :) ||;junit runner detects unused stubs;it is useful to know that stubbing in the test was not used perhaps the stubbing is not needed? removal of unnecessary code from the test is important for code claritymore details:- we detect unused stubs only for passing tests (adding different failure to an existing failure could be confusing)- need to have something similar for junit rules (will create separate ticket)- stubbing in @before or class constructor should be used in at least one test- stubbing in test needs to be used in that test;the current impl is not thread safe reopening ||;1;0;added javadocalthough those classes are internal javadoc is useful here because this part could be hard to grasp;
569;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove field saving options;as decided in #116 all field saving options should be removed.  this pr purges the options from the gui and cleans up related reader and formatter classes. this simplification greatly reduces the complexity of  bibentrywriter .;;0;annotation: @example;jatw@ often unit tests act as examples of how to use the object under test  unfortunately these handy tidbits tend to be lost under the weight of other unit tests and if a developer is not sure where to start it can be perilous to even locate the correct set of testssuggestion: introduce an @﻿example annotation which can be added to methods to indicate that the method shows a usage  this annotation can later be leveraged to generate an example bookone possible element could be ""scope"" which could be the classundertestclass or a string with a package name&nbsp@﻿example(scopefroodclassdescription""how to apply hoopiness to a frood"")"; thanks for the suggestion  its not bad but it feels out of scope for us because neither annotations nor testing are primary focuses of ours we basically intend to offer just what we ourselves need in these areasi do wish that someone would properly solve the problem of deriving user ""examples""/""recipe book"" documentation by extracting it from unit tests that pass thus solving the staleness problem  bob lee did something very clever like this for code samples in his presentations  whoever solves that can provide whatever annotation or comment convention is required though--- ;;;;0;1;;
569;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove field saving options;as decided in #116 all field saving options should be removed.  this pr purges the options from the gui and cleans up related reader and formatter classes. this simplification greatly reduces the complexity of  bibentrywriter .;;0;better constrain buffer memory usage;add soft limit to exchange client bufferadd soft limit to output sink buffer (sharedbuffer)size buffers in pagebuilder based on the size of previous page producedadd more testing to exchange client;;;;;1;1;add sequence id to page buffer protocol to support failed/duplicate requests;
569;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove field saving options;as decided in #116 all field saving options should be removed.  this pr purges the options from the gui and cleans up related reader and formatter classes. this simplification greatly reduces the complexity of  bibentrywriter .;;0;javadoc improvements (groupjoin groupbyuntil timestamp w/scheduler);adding marble diagrams and links to the rxjava wiki standardizing javadoc comment formatting;"#500  @davidmgross it would be nice to have a separate diagram for this overload of zip:``` javapublic static <r> observable<r> zip(observable<? extends observable<?>> ws funcn<? extends r> zipfunction)```today i wanted to explain this operator to some people and a nice marble diagram for this would have been useful as `zipfunction` maybe just take a `func3` which puts its 3 arguments into one ""box"" || ill see what i can come up withon fri dec 6 2013 at 4:43 am samuelgruetter notifications@githubcomwrote:> @davidmgross  it would be nice to have a> separate diagram for this overload of zip:> > public static <r> observable<r> zip(observable<? extends observable<?>> ws funcn<? extends r> zipfunction)> > today i wanted to explain this operator to some people and a nice marble> diagram for this would have been useful as zipfunction maybe just take> a func3 which puts its 3 arguments into one ""box""> > —> reply to this email directly or view it on github ## david m grossplp consulting || how does this look? fri dec 6 2013 at 9:59 am plp consulting (david gross) <davgross@netflixcom> wrote:> ill see what i can come up with> > on fri dec 6 2013 at 4:43 am samuelgruetter notifications@githubcomwrote:> > > @davidmgross  it would be nice to have a> > separate diagram for this overload of zip:> > > > public static <r> observable<r> zip(observable<? extends observable<?>> ws funcn<? extends r> zipfunction)> > > > today i wanted to explain this operator to some people and a nice marble> > diagram for this would have been useful as zipfunction maybe just take> > a func3 which puts its 3 arguments into one ""box""> > > > —> > reply to this email directly or view it on github > > > ## > > david m gross> plp consulting## david m grossplp consulting || nice! two ideas for improvement:-    having the three observables overlap each other in time would make the diagram more instructive-    `-->` binds stronger than `` in most languages so you really should add parentheses ie write `zip{ ( cloud circle triangle ) --> triangle }` because otherwise it is read as `zip{ cloud circle (triangle --> triangle) }` this confused me a lot even though i already knew the semantics of the operator || good suggestions  ill see what i can doon sun dec 8 2013 at 7:12 am samuelgruetter notifications@githubcomwrote:> nice! two ideas for improvement:> - having the three observables overlap each other in time would make>   the diagram more instructive> - --> binds stronger than  in most languages so you really should>   add parentheses ie write zip{ ( cloud circle triangle ) -->>   triangle } because otherwise it is read as zip{ cloud circle>   (triangle --> triangle) } this confused me a lot even though i>   already knew the semantics of the operator> > —> reply to this email directly or view it on github ## david m grossplp consulting || ";;;;1;1;javadoc improvements (groupjoin groupbyuntil timestamp w/scheduler);
569;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove field saving options;as decided in #116 all field saving options should be removed.  this pr purges the options from the gui and cleans up related reader and formatter classes. this simplification greatly reduces the complexity of  bibentrywriter .;;541.0;improved the public api of mockingdetails;541 highlights:- started exposing full mock creation information instead of just type to mock and extra interfaces- changed public api but only for methods that were introduced in 2x so it is _not_ backwards incompatible change as far as 110 is concerned;  if no other feedback if youre happy with change merge yourself :) || i needed to merge because it was blocking me i can address @bric3 comment later if such is the decision || @szczepiq nope your feedback works for me as well ) ||;improve mockitomockingdetails api;in order to make the api cleaner & expose useful information:1 mockingdetailsgetinvocations() throws meaningful exception when passed object is not a mock and documents this behavior2 getmockedtype() and getextrainterfaces() are replaced with getmockcreationsettings() that returns mockcreationsettings instance;ok but lets deprecate them instead of removing them (possibly in mockito 3) || given that getmockedtype() and getextrainterfaces() are unreleased yet (eg 20) do you still opt for deprecation? || good point lets remove them then ! ||;1;0;improved the public mockingdetails api- started exposing full mock creation information instead of just type to mock and extra interfaces- this also better leverages the existing api541;
571;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;pretty print primitive and wrappers types in maps;check list -  pr should be motivated  i.e. what does it fix  why  and if relevant how -  if possible / relevant include an example in the description  that could help all readers      including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history   intention is important please rebase your commit history so that each      commit is meaningful and help the people that will explore a change in 2 years -  read the [contributing guide]( -  mention  <issue number>  in the description _if relevant_ -  at least one commit should mention  fixes #<issue number>  _if relevant_  in following case  user can t understand the difference between expected and actual.  code:      @test public void foo() {     foo m = mock(foo.class)      m.foo(new hashmap<string  object>(){{         put( hoge   4)      }})      verify(m).foo(new hashmap<string  object>(){{         put( hoge   4l)      }})  }  public static class foo {     void foo(map<string  object> map) {     } }      output:      argument(s) are different! wanted: foo.foo(() {hoge=4})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method) actual invocation has different arguments: foo.foo(() {hoge=4})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method)      if mockito outputs the  l  suffix for long values  user can understand the difference easily.  after this commit  the output will be following:      argument(s) are different! wanted: foo.foo({ hoge =4l})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method) actual invocation has different arguments: foo.foo({ hoge =4})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method)      this will 570;;0;objects trouble in java 7; compiling guava with java 7 leads to several errors due to the ambiguous type objects in java 7 oracle declares objects in javautil and guava does in comgooglecommonbase with imports likeimport javautil_import javaxannotationnullableimport comgooglecommonannotations_import comgooglecommonbase*this is ambiguous in classes which uses objects and the *-import like forwardingmap:if (objectsequal(entrygetkey() key)) {&nbsp&nbsp&nbsp&nbsp^ the type objects is ambiguous; ;;;;0;1;;
571;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;pretty print primitive and wrappers types in maps;check list -  pr should be motivated  i.e. what does it fix  why  and if relevant how -  if possible / relevant include an example in the description  that could help all readers      including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history   intention is important please rebase your commit history so that each      commit is meaningful and help the people that will explore a change in 2 years -  read the [contributing guide]( -  mention  <issue number>  in the description _if relevant_ -  at least one commit should mention  fixes #<issue number>  _if relevant_  in following case  user can t understand the difference between expected and actual.  code:      @test public void foo() {     foo m = mock(foo.class)      m.foo(new hashmap<string  object>(){{         put( hoge   4)      }})      verify(m).foo(new hashmap<string  object>(){{         put( hoge   4l)      }})  }  public static class foo {     void foo(map<string  object> map) {     } }      output:      argument(s) are different! wanted: foo.foo(() {hoge=4})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method) actual invocation has different arguments: foo.foo(() {hoge=4})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method)      if mockito outputs the  l  suffix for long values  user can understand the difference easily.  after this commit  the output will be following:      argument(s) are different! wanted: foo.foo({ hoge =4l})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method) actual invocation has different arguments: foo.foo({ hoge =4})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method)      this will 570;;0;pretty print primitive and wrappers types in maps;"check list-  pr should be motivated ie what does it fix why and if relevant how-  if possible / relevant include an example in the description that could help all readers     including project members to get a better picture of the change-  avoid other runtime dependencies-  meaningful commit history  intention is important please rebase your commit history so that each     commit is meaningful and help the people that will explore a change in 2 years-  read the [contributing guide](  mention `<issue number>` in the description _if relevant_-  at least one commit should mention `fixes #<issue number>` _if relevant_in following case user cant understand the difference between expected and actualcode:```@testpublic void foo() {    foo m  mock(fooclass)    mfoo(new hashmap<string object>(){{        put(""hoge"" 4)    }})    verify(m)foo(new hashmap<string object>(){{        put(""hoge"" 4l)    }})}public static class foo {    void foo(map<string object> map) {    }}```output:```argument(s) are different! wanted:foofoo(() {hoge4})-> at sunreflectnativemethodaccessorimplinvoke0(native method)actual invocation has different arguments:foofoo(() {hoge4})-> at sunreflectnativemethodaccessorimplinvoke0(native method)```if mockito outputs the ""l"" suffix for long values user can understand the difference easilyafter this commit the output will be following:```argument(s) are different! wanted:foofoo({""hoge""4l})-> at sunreflectnativemethodaccessorimplinvoke0(native method)actual invocation has different arguments:foofoo({""hoge""4})-> at sunreflectnativemethodaccessorimplinvoke0(native method)```this will 570";"@tokuhirom for this change to work some existing test have to be updated see  for details || oops i forget to fix these test cases  commit squash it and force pushed ||   571 defined in the java spec for all types:| type signature | java type || --- | --- || z | boolean || b | byte || c | char || s | short || i | int || j | long || f | float || d | double |the type signature can be used to distingish primitive types maybe this is useful in the future when ppl are confused by hex values ( remember 0xe2 is an `int` not `byte`) or cant distinguish ints from shorts || @christianschwarz see #693  || ";;;;1;1;format byte too;
571;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;pretty print primitive and wrappers types in maps;check list -  pr should be motivated  i.e. what does it fix  why  and if relevant how -  if possible / relevant include an example in the description  that could help all readers      including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history   intention is important please rebase your commit history so that each      commit is meaningful and help the people that will explore a change in 2 years -  read the [contributing guide]( -  mention  <issue number>  in the description _if relevant_ -  at least one commit should mention  fixes #<issue number>  _if relevant_  in following case  user can t understand the difference between expected and actual.  code:      @test public void foo() {     foo m = mock(foo.class)      m.foo(new hashmap<string  object>(){{         put( hoge   4)      }})      verify(m).foo(new hashmap<string  object>(){{         put( hoge   4l)      }})  }  public static class foo {     void foo(map<string  object> map) {     } }      output:      argument(s) are different! wanted: foo.foo(() {hoge=4})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method) actual invocation has different arguments: foo.foo(() {hoge=4})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method)      if mockito outputs the  l  suffix for long values  user can understand the difference easily.  after this commit  the output will be following:      argument(s) are different! wanted: foo.foo({ hoge =4l})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method) actual invocation has different arguments: foo.foo({ hoge =4})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method)      this will 570;;0;add comfasterxmljackson to parent-first packages;;;;;;1;1;add comfasterxmljackson to parent-first packages;
571;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;pretty print primitive and wrappers types in maps;check list -  pr should be motivated  i.e. what does it fix  why  and if relevant how -  if possible / relevant include an example in the description  that could help all readers      including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history   intention is important please rebase your commit history so that each      commit is meaningful and help the people that will explore a change in 2 years -  read the [contributing guide]( -  mention  <issue number>  in the description _if relevant_ -  at least one commit should mention  fixes #<issue number>  _if relevant_  in following case  user can t understand the difference between expected and actual.  code:      @test public void foo() {     foo m = mock(foo.class)      m.foo(new hashmap<string  object>(){{         put( hoge   4)      }})      verify(m).foo(new hashmap<string  object>(){{         put( hoge   4l)      }})  }  public static class foo {     void foo(map<string  object> map) {     } }      output:      argument(s) are different! wanted: foo.foo(() {hoge=4})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method) actual invocation has different arguments: foo.foo(() {hoge=4})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method)      if mockito outputs the  l  suffix for long values  user can understand the difference easily.  after this commit  the output will be following:      argument(s) are different! wanted: foo.foo({ hoge =4l})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method) actual invocation has different arguments: foo.foo({ hoge =4})  -> at sun.reflect.nativemethodaccessorimpl.invoke0(native method)      this will 570;;74.0;operation sample with observable v2;issue #74- sample will terminate if either the source or the sampler terminates or throws an error- the sampler now emits values only in its onnext() method therefore if the sampler completes and there is a sampled value available (`valuetaken  false`) it wont emit the value before terminating;#506 ;operator: sample;http://msdnmicrosoftcom/en-us/library/hh211615(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211892(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229742(vvs103)aspx;still have one overload to do:``` c#public static iobservable<tsource> sample<tsource tsample>(    this iobservable<tsource> source    iobservable<tsample> sampler)``` || i can take this || done ||;1;0;operation sample with observable v2;
572;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactor cleanup code;this pr (again) refactors the cleanup department. the motivation was to extract as much logic as possible from the cleanup action to make it easier to use cleanup operations also at different points (like on save).  biggest changes: - move preferences controlling the cleanup process to own data class  cleanuppreset  and the execution of the cleanup process to  cleanupworker . thus starting a cleanup process is reduced to setting up a proper preset and passing it to the worker. - move code displaying and changing a preset to a separate class. hence it is now easy to show and change a preset at a different place (like in the preferences).  - move preferences code to  jabrefpreferences . well  this is the place where it belongs. - add tests for the  cleanupworker . more detailed tests of the different cleanup processes are still missing.  todo s/breaking changes: these are all related to the fact that there is no nice interface to get/set the file field of an entry (all the code is in the gui class filelisttablemodel). - the counting of unsuccessful renames does not work anymore (i vote for removing this completely) - remove cleanuputil and incorperate the code in the respective cleanup classes. currently this code relies on gui code (filelisttablemodel) and thus cannot easily be moved to logic. - test the file related cleanups.;;0;inetaddressesforstring does not throw illegalargumentexception on an invalid ipv6 address; <b>what steps will reproduce the problem?</b>1 inetaddressesforstring(""fe80::aaaaaa"")<b>what is the expected output? what do you see instead?</b>i expect an illegalargumentexceptioninstead i receive a inet6address object with the address ""fe80: aaaa""<b>what version of the product are you using? on what operating system?</b>guava-r08 windows xp professional 32bit<b>please provide any additional information below</b>according to the  this form of a text representation is invalid"; ;;;;0;1;;
572;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactor cleanup code;this pr (again) refactors the cleanup department. the motivation was to extract as much logic as possible from the cleanup action to make it easier to use cleanup operations also at different points (like on save).  biggest changes: - move preferences controlling the cleanup process to own data class  cleanuppreset  and the execution of the cleanup process to  cleanupworker . thus starting a cleanup process is reduced to setting up a proper preset and passing it to the worker. - move code displaying and changing a preset to a separate class. hence it is now easy to show and change a preset at a different place (like in the preferences).  - move preferences code to  jabrefpreferences . well  this is the place where it belongs. - add tests for the  cleanupworker . more detailed tests of the different cleanup processes are still missing.  todo s/breaking changes: these are all related to the fact that there is no nice interface to get/set the file field of an entry (all the code is in the gui class filelisttablemodel). - the counting of unsuccessful renames does not work anymore (i vote for removing this completely) - remove cleanuputil and incorperate the code in the respective cleanup classes. currently this code relies on gui code (filelisttablemodel) and thus cannot easily be moved to logic. - test the file related cleanups.;;0;replace testbase#assertcontainstype(final collection<?> list final c…;…lass<?> clazz) with assertj assertion;     ah but it requires a rebase :( || rebased || thanks @pascalschumacher ! once we can work on mockito 3 we will have java 8 and we can update assertj to version 3x as well and have a richer assertion api in our tests || > thanks @pascalschumacher ! you are welcome thanks for letting me contribute to a great project like mockito :) ||;;;;1;1;replace testbase#assertcontainstype(final collection<?> list final class<?> clazz) with assertj assertion;
572;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactor cleanup code;this pr (again) refactors the cleanup department. the motivation was to extract as much logic as possible from the cleanup action to make it easier to use cleanup operations also at different points (like on save).  biggest changes: - move preferences controlling the cleanup process to own data class  cleanuppreset  and the execution of the cleanup process to  cleanupworker . thus starting a cleanup process is reduced to setting up a proper preset and passing it to the worker. - move code displaying and changing a preset to a separate class. hence it is now easy to show and change a preset at a different place (like in the preferences).  - move preferences code to  jabrefpreferences . well  this is the place where it belongs. - add tests for the  cleanupworker . more detailed tests of the different cleanup processes are still missing.  todo s/breaking changes: these are all related to the fact that there is no nice interface to get/set the file field of an entry (all the code is in the gui class filelisttablemodel). - the counting of unsuccessful renames does not work anymore (i vote for removing this completely) - remove cleanuputil and incorperate the code in the respective cleanup classes. currently this code relies on gui code (filelisttablemodel) and thus cannot easily be moved to logic. - test the file related cleanups.;;0;sort queries in reverse-chronological order;;;;;;1;1;sort queries in reverse-chronological order;
572;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;refactor cleanup code;this pr (again) refactors the cleanup department. the motivation was to extract as much logic as possible from the cleanup action to make it easier to use cleanup operations also at different points (like on save).  biggest changes: - move preferences controlling the cleanup process to own data class  cleanuppreset  and the execution of the cleanup process to  cleanupworker . thus starting a cleanup process is reduced to setting up a proper preset and passing it to the worker. - move code displaying and changing a preset to a separate class. hence it is now easy to show and change a preset at a different place (like in the preferences).  - move preferences code to  jabrefpreferences . well  this is the place where it belongs. - add tests for the  cleanupworker . more detailed tests of the different cleanup processes are still missing.  todo s/breaking changes: these are all related to the fact that there is no nice interface to get/set the file field of an entry (all the code is in the gui class filelisttablemodel). - the counting of unsuccessful renames does not work anymore (i vote for removing this completely) - remove cleanuputil and incorperate the code in the respective cleanup classes. currently this code relies on gui code (filelisttablemodel) and thus cannot easily be moved to logic. - test the file related cleanups.;;551.0;observeon fix for observing the same source on the same scheduler by two;different observersissue #551- cleaned up- added test cases;#507  nice refactor ;observeon and multiple subscribers;"snippet 1:``` scalaval o  observable(1 2 3)println(""x0"")oobserveon(schedulersthreadpoolforcomputation)subscribe(x>println(""a: "" + x) t>println(t) ()>{println(""a: done"")})println(""x1"")oobserveon(schedulersthreadpoolforcomputation)subscribe(x>println(""b: "" + x) t>println(t) ()>{println(""b: done"")})println(""x2"")threadsleep(6000)println(""x3"")```outputs as expected this:```x0a: 1a: 2a: 3a: donex1x2b: 1b: 2b: 3b: donex3```snippet 2:``` scalaval o  observable(1 2 3)observeon(schedulersthreadpoolforcomputation)println(""x0"")osubscribe(x>println(""a: "" + x) t>println(t) ()>{println(""a: done"")})println(""x1"")osubscribe(x>println(""b: "" + x) t>println(t) ()>{println(""b: done"")})println(""x2"")threadsleep(6000)println(""x3"")```sometimes outputs the same as snippet 1 but sometimes only outputs this:```x0a: 1a: 2a: 3x1a: donex2x3```or this```x0x1a: 1a: 2x2a: 3a: donex3```(order between x and a doesnt matter but the problem is that there are no lines with b)snippet 3 ( snippet 2 translated to c#)``` csvar o  new { 1 2 3 }toobservable()observeon(taskpoolschedulerdefault)consolewriteline(""x0"")osubscribe(x > consolewriteline(""a: "" + x) t > consolewriteline(t) () > consolewriteline(""a: done""))consolewriteline(""x1"")osubscribe(x > consolewriteline(""b: "" + x) t > consolewriteline(t) () > consolewriteline(""b: done""))consolewriteline(""x2"")threadsleep(6000)consolewriteline(""x3"")consolereadkey()```always prints something like```x0x1x2b: 1b: 2b: 3b: donea: 1a: 2a: 3a: donex3```(order between a and b doesnt matter but there are always lines with b)so i guess that somehow `observeon` does not properly support multiple subscribers but i couldnt find any clue in the source supporting this claim would be nice if somehow could take look";"what i see is that observeon uses a ""global"" queue id rather move the queue inside the onsubscribe() method so you have one queue per observer and no interference and perhaps parallel observations of independent observers (they dont get into each others queue)one more thing it appears the notifications only add to the ""s"" compositesubscription but never remove an item once done which is a potential memory leak imo || good catch  || ";1;0;observeon fix for observing the same source on the same scheduler by two different observers;
573;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace testbase#assertnotequals with assertj #isnotequalto;;;0;memory leak with pendingevictionnotifications on compute method in computingconcurrenthashmap; the javadoc for processpendingnotifications in customconcurrenthashmap says that ""this should be called every time expireentries or evictentry is called (once the lock is released)""  the compute method in computingconcurrenthashmap calls expire and evict but doesnt call processpendingnotifications after unlock  if you have a map that is computing and you only ever access it using get() then things will pile up in the pendingevictionnotifications queue and will stay retained in memoryhere is a unit test that fails that should succeed```public void testcomputingexpire() throws exception {    final atomiclong count  new atomiclong()    concurrentmap<object object> map  new mapmaker()expireafteraccess(1 timeunitnanoseconds)evictionlistener(new mapevictionlistener<object object>() {        public void oneviction(object key object value) {            countincrementandget()        }    })makecomputingmap(new function<object object>() {        public object apply(object input) {            return 0l        }    })    mapget(0)    threadsleep(1)    mapget(0)    assertequals(1 countget())}```"; this has been  in trunk and will be part of the upcoming release 9--- ;;;;0;1;;
573;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace testbase#assertnotequals with assertj #isnotequalto;;;0;replace testbase#assertnotequals with assertj #isnotequalto;;    ;;;;1;1;replace testbase#assertnotequals with assertj #isnotequalto;
573;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace testbase#assertnotequals with assertj #isnotequalto;;;0;add split queue time to split completion event jmx and full task stats;; ;;;;0;1;;
573;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replace testbase#assertnotequals with assertj #isnotequalto;;;540.0;removed opening and closing historical artifacts;issue #540the build fails due scala compiler error i dont understand:```[ant:scalac] rxjava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\observablescala  error: type mismatch[ant:scalac]  found   : x2type (with underlying type rxobservable[_ <: t])[ant:scalac]  required: t[ant:scalac]       observable[t](x2)[ant:scalac]                     ^[ant:scalac] one error found`````` scala  def window[closing](closings: () > observable[closing]): observable[observable[t]]  {    val func : func0[_ <: rxobservable[_ <: closing]]  closings()asjavaobservable    val o1: rxobservable[_ <: rxobservable[_]]  asjavaobservablewindow[closing](func)    val o2  observable[rxobservable[_]](o1)map((x: rxobservable[_]) > {      val x2  xasinstanceof[rxobservable[_ <: t]]      observable[t](x2)    })    o2  }```could someone help me with this?;#508 #509  #510;purpose of rxutilopening and rxutilclosing interfaces?;is there a particular reason these two interfaces are used by the various buffer() and window() operators instead of allowing arbitrary generic types for opening and closing buffers/windows similar to the duration selectors in join() & groupbyuntil()?;"i think they are historical artifacts less types  better imhoon thu nov 28 2013 at 2:47 pm akarnokd notifications@githubcom wrote:> is there a particular reason these two interfaces are used by the various> buffer() and window() operators instead of allowing arbitrary generic types> for opening and closing buffers/windows similar to the duration selectors> in join() & groupbyuntil()?> > —> reply to this email directly or view it on github  || on a related issue we should move observerbase from rxjoins to rx right next to the observer interface nobody should directly implement observer observerbase ensure that the rx contract is enforcedit is a bit ugly that you need to override xxxcore so we should also add observercreate or a constructor with overloads that take funcs as well as one that takes an observer itself (which can be unsafe)you want to take this?see (did i say already that the msdn docs suck!) || @headinthebox sure i would do the refactorings but i think observerbase should be placed under rxoperators similar to the safeobserver and synchronizedobserver classes || probably yes and there is a lot of duplication between all of these various observers so you may want to have a look at that as well || if its job is to ensure the contract is kept then that is what safeobserver does  || > but i think observerbase should be placed under rxoperators similar to the safeobserver and synchronizedobserver classesyes we have kept the rx package to only the most top-level things so i agree this should be elsewhere however thus far the rxoperators package is not considered part of the public api and is excluded from javadocs if we are to have public observers then it would be an rxobservers package like rxobservables the rxoperators package is internal implementations and can be changed without breaking users  || i did the refactorings but couldnt get the observablescala working with it:  someone help with that part?```rxjava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\observablescala  error: type mismatch   found   : rxlangscalaobservable[closing]   required: rxutilfunctionsfunc0[_ <: rxobservable[closing]]      val f: func0[_ <: rxobservable[closing]]  closings()asjavaobservable                                                                              ^  rxjava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\observablescala  error: type mismatch   found   : opening > rxobservable[_ <: closing]   required: rxutilfunctionsfunc1[opening _ <: rxobservable[closing]]      val closing: func1[opening _ <: rxobservable[closing]]  (o: opening) > closings(o)asjavaobservable                                                                              ^  rxjava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\observablescala  error: type mismatch   found   : rxobservable[_$15] where type _$15 <: opening   required: rxobservable[opening]  note: _$15 <: opening but java-defined class observable is invariant in type t  you may wish to investigate a wildcard type such as `_ <: opening` (sls 3210)      val jobs: rxobservable[_ <: javautillist[_]]  asjavaobservablebuffer[opening closing](opening closing)                                                                                                  ^  rxjava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\observablescala  error: overloaded method window needs result type        asjavaobservablewindow(openingsasjavaobservable (op: opening) > closings(op)asjavaobservable))                               ^  rxjava\language-adaptors\rxjava-scala\src\main\scala\rx\lang\scala\observablescala  error: overloaded method value window with alternatives:    (x$1: int)rxobservable[rxobservable[_$1]] <and>    [tclosing](x$1: rxutilfunctionsfunc0[_ <: rxobservable[tclosing]])rxobservable[rxobservable[_$1]]   cannot be applied to (rxutilfunctionsfunc0[_$44])      val o1: rxobservable[_ <: rxobservable[_]]  asjavaobservablewindow(func)``` || observable is covariant in its type parameter in scala when you use a scala type scalac knows this automatically because its declared where the type is declared (using `trait observable[+t]` `+` means covariant `-` means contravariant) so `rxlangscalaobservable[t]` actually means ""an `rxlangscalaobservable` whose type parameter is `t` or any subclass of `t` however if you use a java type theres no `+` or `-` at declaration site so **whenever** you use `rxobservable` in scala you have to write `rxobservable[_ <: t]` **never** write `rxobservable[t]` || ";1;0;merge pull request #1 from samuelgruetter/openingclosingremovedsamremove package rxlangscalautil since all its contents were removed;
574;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix some rawtype warnings;;;0;splitter should have a limit(int) method like stringsplit( ) has; splitter should have a limit(int) method like stringsplit( ) hasthanks; ;;;;0;1;;
574;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix some rawtype warnings;;;0;fix some rawtype warnings;;    ;;;;1;1;fix some rawtype warnings;
574;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix some rawtype warnings;;;0;add union [all] support;;i also threw in some unit test fixes and support for explicit table query syntax in the last few commits || great stuff! ship it! ||;;;;1;1;fix comments for pull #574;
574;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix some rawtype warnings;;;0;clarify documentation on cache();i lost some time because i didnt read the documentation of `cache()` carefully enough to make it easier for others i tried to make the documentation more explicit here;#511 ;;;;1;1;clarify documentation on cache();
578;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;made some timeouts in verificationafterdelaytest and verificationwith…;…timeouttest more lenient to reduce build failures on travis ci;;0;get a list of files recursively from a directory; hi alli was searching in guava api a method to list recursively the files contained in a directory and i didnt find onethought that i could suggest it as an enhancement !cheersjb; since 17 the method walkfiletree of javaniofilefiles ease the file & directory recursion || javaniofile is not available on android || any news on this? || guava 235 includes [filesfiletraverser()]( and [morefilesfiletraverser()]( which should (i think) answer the original request: is also a variant of this api available in previous versions of guava that uses a similar but now-deprecated api for traversing the file system)if more is needed please reopen this issue ||;;;;0;1;;
578;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;made some timeouts in verificationafterdelaytest and verificationwith…;…timeouttest more lenient to reduce build failures on travis ci;;0;made some timeouts in verificationafterdelaytest and verificationwith…;…timeouttest more lenient to reduce build failures on travis ci;  578   thank you @pascalschumacher  ! ||;;;;1;1;made some timeouts in verificationafterdelaytest and verificationwithtimeouttest more lenient to reduce build failures on travis ci;
578;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;made some timeouts in verificationafterdelaytest and verificationwith…;…timeouttest more lenient to reduce build failures on travis ci;;0;limit size of response based on bytes not pages;;;;;;1;1;limit size of response based on bytes not pages;
578;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;made some timeouts in verificationafterdelaytest and verificationwith…;…timeouttest more lenient to reduce build failures on travis ci;;0;a bug in apply(u:>unit) method of subscription companion object  w;hich may cause multiple invocations of u in a multithreaded multi-unsubscribe situationthreads may be pre-empted after evaluation of condition (!unsubscribedget()) which may result in two or more threads executing the consequent block more than once a code that relies on single evaluation of u will fail if that case happens;#518  this was  by @headinthebox and can be seen here:  you @ugur-zongur for contributing! ||;;;;0;1;;
579;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fix some rawtype warnings;;;0;behavior of mapmakerevictionlistener() on a computingmap; it is not clear from the mapmakerevictionlistener() javadoc if the evictionlistener is called when map entries are evicted from a map that was created using mapmakermakecomputingmap()it turns out that the mapevictionlistener is only called when evicting map entries that are manually put into the mapit seems that the mapevictionlistener is never called when evicting map entries generated via the function passed to the makecomputingmap() functionthis may be ""working as intended"" but in that case it should be documented in the evictionlistener() method javadoc that the listener is not called for when evicting certain (computed) entriesi see no reason however why the mapevictionlistener should not be called whenever any map entry is evicted even those entries computedthe attached junit test case documents the described behavior (evictionlistener being called on entries put into the map but not on entries put by a computedmap function)version of guava: r08"; ;;;;0;1;;
579;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fix some rawtype warnings;;;0;fix some rawtype warnings;;  579   ;;;;1;1;fix some rawtype warnings;
579;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fix some rawtype warnings;;;0;dont use windowlocationorigin to build the uri;not supported by firefox 22; ;;;;0;1;;
579;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fix some rawtype warnings;;;0;crlf issues :-(;cannot believe that it is 2013 and we are still having crlf changesi guess that @akarnokd is using windows and i have trouble with crlf in asyncjava and friends;yes im on windows and using netbeans 74 with default git settings i thought all this line ending is automatically managed by github or the repo [as specified here]( the question is should i create a pr with  crlf or will this be handled on the repo level? || ill play with those github settings to see if i can resolve it there ||;;;;0;1;;
587;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make verificationwithtimeouttest#shouldallowmixingonlywithtimeout mor…;…e lenient to reduce build failures on travis ci  the two recent build failures where both caused by this test:  https://travis-ci.org/mockito/mockito/jobs/154506554;;0;add `iterablesfrequencies()`;j@ i often had to calculate the frequencies of equal objects in various iterables id like to see a method that would do that for me and return pairs that could be as `map<t integer>` `iterable<mapentry<t integer>>` a yet-to-introduce pair/2-tuple instance or even a special value entity classone of the reasons for me to request this besides common utility is that im unsure on how to implement it: atomicinteger with a loop a multimap etcsomewhat related is the common case to calculate the percentage of the totals for each unique element in scala one could just copy the pair into a 3-tuple and add the percentage (or rate ie a float between 0 and 1 inclusively) as third value unfortunately java is not that familiar with tuples but then a (separate?) value entity with both total and percentage could work not super-convicing to me but someone might come up with a better (maybe even common but unknown to me) approach im looking forward to that; multiset already handles this!```immutablemultiset<e> multiset  immutablemultisetcopyof(iterable)int totalsize  multisetsize()for (multisetentry<e> entry : multisetentryset()) {  e element  entrygetelement()  int count  entrygetcount()  }```the percentage can obviously be derived from the count of an element and the total size of the multiset--- ;;;;0;1;;
587;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make verificationwithtimeouttest#shouldallowmixingonlywithtimeout mor…;…e lenient to reduce build failures on travis ci  the two recent build failures where both caused by this test:  https://travis-ci.org/mockito/mockito/jobs/154506554;;0;make verificationwithtimeouttest#shouldallowmixingonlywithtimeout mor…;…e lenient to reduce build failures on travis cithe two recent build failures where both caused by this test //travis-ciorg/mockito/mockito/jobs/154189781https://travis-ciorg/mockito/mockito/jobs/154506554;     thanks again! ||;;;;1;1;make verificationwithtimeouttest#shouldallowmixingonlywithtimeout more lenient to reduce build failures on travis ci;
587;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make verificationwithtimeouttest#shouldallowmixingonlywithtimeout mor…;…e lenient to reduce build failures on travis ci  the two recent build failures where both caused by this test:  https://travis-ci.org/mockito/mockito/jobs/154506554;;0;provides a quick fix for the union ordering issue;;;;;;1;1;short term fix for union ordering expectation;
587;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make verificationwithtimeouttest#shouldallowmixingonlywithtimeout mor…;…e lenient to reduce build failures on travis ci  the two recent build failures where both caused by this test:  https://travis-ci.org/mockito/mockito/jobs/154506554;;60.0;operation longcount;issue #60straightforward version of the regular count() (however i would have implemented it differently so the constant boxing-unboxing could be avoided);#524 ;operator: longcount; we really need count and longcount?perhaps count should just use a long so we only need one of them?;;1;0;operation longcount;
590;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed package org.mockito.internal.listeners;- deleted unused and empty interface  mockingprogresslistener  - moved  notifiedmethodinvocationreport  to  org.mockito.internal.handler;;0;removed package orgmockitointernallisteners;- deleted unused and empty interface `mockingprogresslistener`- moved `notifiedmethodinvocationreport` to `orgmockitointernalhandler`;    ;;;;1;1;removed package orgmockitointernallisteners - deleted dead interface mockingprogresslistener - moved notifiedmethodinvocationreport to orgmockitointernalhandler;
590;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed package org.mockito.internal.listeners;- deleted unused and empty interface  mockingprogresslistener  - moved  notifiedmethodinvocationreport  to  org.mockito.internal.handler;;0;merge chains of projections;; ;;;;0;1;;
590;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed package org.mockito.internal.listeners;- deleted unused and empty interface  mockingprogresslistener  - moved  notifiedmethodinvocationreport  to  org.mockito.internal.handler;;0;serialsubscription is missing isunsubscribed;public class serialsubscription implements subscription {    @override    public void unsubscribe() {}}    public void setsubscription(final subscription subscription) {}      public subscription getsubscription() {}}http://msdnmicrosoftcom/en-us/library/systemreactivedisposablesserialdisposable_properties(vvs103)aspx; in  ||;;;;0;1;;
591;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;pmd-cleanup in groups;;;0;mapmaker size is negative and isempty is false with empty weakkeys/weakvalues map; ""i am getting a negative size() and isempty() of false on a map with weakkeys() and weakvalues() using guava r09-rc2 the map is indeed empty and iterating over the keyset() shows no entries but the size() keyset()size() and entryset()size() all return the same negative value""[originally reported in a comment on issue 552]"; i believe this to be  in the trunk code please let me know if you still see it occur--- ;;;;0;1;;
591;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;pmd-cleanup in groups;;;0;refactored argumentmatchingtool to a static utillity class;relates to #426; ;;;;1;1;refactored argumentmatchingtool to a static utillity class;
591;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;pmd-cleanup in groups;;;0;clear operator in worker after work is completed;;;;;;1;1;clear operator in worker after work is completed;
591;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;pmd-cleanup in groups;;;0;booleansubscription should be properly wired up to allow inheritance;booleansubscription is not properly wired up to allow for inheritancepublic class booleansubscription implements subscription {```private final atomicboolean unsubscribed  new atomicboolean(false)public boolean isunsubscribed() {    return unsubscribedget()}@overridepublic void unsubscribe() {    unsubscribedset(true)}```};what would you like to change? || subclasses may call on the `superisunsubscribed()` to check the state and call the `superunsubscribe()` to complete it i we dont want the ability to revive the booleansubscription with `unsubscribedset(false)` the current implementation is okay with me || unsubscribe should be idempotent i expect to be able to write this:   new booleansubscription () { override void unsubscribe() {  launch the missiles  superunsubscribe() }}and when i call unsubscribe() twice the missiles should only be fired once || you need something like the observerbase?``` javapublic class booleansubscription extends subscription {    private final atomicboolean state  new atomicboolean()    public final boolean isunsubscribed() { return stateget() }    protected void unsubscribecore() { }    @overload    public final void unsubscribe() {        if (statecompareandset(false true)) {            unsubscribecore()        }    }}``` || precisely! || we have re-written subscriptions and agreed to not have `isunsubscribed` added to the `subscription` interface and that we didnt need inheritance for the implementations the `isunsubscribed` method exists on each of the implementations which each have different ways of deciding if something is unsubscribed ||;;;;0;1;;
592;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;pmd-cleanup of jabrefpreferences;;;0;add tpch query 6 to benchmark;;;;;;1;1;add tpch query 6 to benchmark;
592;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;pmd-cleanup of jabrefpreferences;;;0;serialsubscription and singleassignementsubscription naming subscriptions in general;serialsubscription hasprivate static final subscription unsubscribed  new subscription() {singleassignmentsubscription hasprivate static final subscription sentinel  new subscription() {for the same purposealso these use lockfree implementations the other subscriptions use locksperhaps someone can go over all subscriptions and implement them in the same style and using the same naming conventions;i have to rebase my subscription changes anyway so ill do the renaming to unsubscribed_sentinel || i may help again to use lock free strategy in other subscription implementations || @akarnod you should be able to have serialsubscription inherit from multipleassignmentsubscription the difference is that the latter unsubscribes when swapping in a new subscription i think that would show the intent better and make the code more maintanablein fact i think multipleassignmentsubscription itself can inherit from booleansubscription || i dont know i can create many prs for all kinds of variants but at the end @benjchristensen has to decide id rather avoid look-and-feel development ||;;;;0;1;;
592;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;pmd-cleanup of jabrefpreferences;;;552.0;stylesheet-tweaks-for-openjdk6;#589 aimed to fix the javadoc rendering but the assumption was that the javadoc tool of the sun jdk6 will render javadoc the same way as openjdk6unfortunately this is not the same the javadoc rendering of openjdk6 is a pre work that avoid the use of table elements this making the stylesheet incompatiblethis pr aims to fix that and thus 552 bonus i changed the `2*` and `20`  200` in the javadoc this way we have aligned version numbers;;fix again javadoc stylesheet;"previously we had a nice javadoc stylesheet that worked well with jdk6then we used travis that was only allowing oraclejdk7 that came with a better javadoc stylesheet so we dropped oursnow since the release of mockito 2x is using openjdk6 we should reintroduce a better stylesheetcurrent state ❌  width""712"" alt""screen shot 2016-08-13 at 19 41 59"" src"" ✅  width""877"" alt""screen shot 2016-08-13 at 19 45 32"" src""https://cloudentcom/assets/803621/17644722/d71bcd08-618e-11e6-831a-a01c47e8cc61png"">";"is this as simple as turning back on this line?  || probably but i need to check before the file may have been removed and the javadoc tool is _picky_ especially in old version of the jdk || actually we should revert this commit 3a057b3eff2be528a1fed41852a990cff87a72c1 when jdk7 was the only option on travis || it seems the javadoc tool of openjdk6 generates a different html than sun jdk 6 thus the stylesheet is not working properly<img width""748"" alt""screen shot 2016-08-24 at 11 56 56"" src"" again an issue with openjdk6 || ";1;0;replaces 20 / 2x by 200 in javadoc;
600;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;suppressed compiler warning and unchecked collections cast;- suppressed compile time warning - refactor raw collection cast;;0;equivalence from ordering; it would be nice to have a way of getting an equivalence out of ordering the reason is that most orderings resp comparators are consistent with equals and need to be so in order to be used in java collections library so when i create a new class which is comparable i want to derive equals out of the compareto rather than duplicate code it would be nice to have something like  equivalencefrom(ordering ordering) or as described in comparator javadocs ""quotient"" - equivalence orderingquotient()"; sorry i read some documentation and i think now i get itas you said equivalences are not intended for that because they are a way to dynamically choose equals and hashcode behaviour (strategy pattern)hash might be possible if the ordering was explicit nulls(first|last) or usingtostringive just liked the idea behind quotient in javadoc it is math compliant and could be useful ||;;;;0;1;;
600;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;suppressed compiler warning and unchecked collections cast;- suppressed compile time warning - refactor raw collection cast;;0;suppressed compiler warning and unchecked collections cast;- suppressed compile time warning- refactor raw collection cast;    ;;;;1;1;removed compiler warnings;
600;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;suppressed compiler warning and unchecked collections cast;- suppressed compile time warning - refactor raw collection cast;;0;add basic regexp functions;;add a benchmark too || ;;;;1;1;add basic regexp functions;
600;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;suppressed compiler warning and unchecked collections cast;- suppressed compile time warning - refactor raw collection cast;;0;bugfix: replay subject;;#536 ;;;;1;1;544 replaysubject emits items received after onerror;
615;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;497 : returns_deep_stubs may try to mock final classes;497  with deep stubs  it was possible for generic metadata to be lost/unused through nested invocations on non generic types. this could cause  returns_deep_stubs  to try mocking final classes which would result in a  classcastexception .  apparently my other pr (#549) wasn t quite enough to fully fix this problem.  ---  **edited by mockito team**;;0;make more classes serializable; here are some classes that are not serializable that probably should be or at least might be worth making serializablecomgooglecommonbase&nbsp&nbspcharmatcher? (theyre useful in predicates but looks like more effort and apparently hasnt been needed thus far)&nbsp&nbspenumsvalueoffunction&nbsp&nbspequivalencewrapper&nbsp&nbspoptionalcomgooglecommoncollect&nbsp&nbspdiscretedomain (if not the abstract class the provided implementations)&nbsp&nbspminmaxpriorityqueue?&nbsp&nbsprangecomgooglecommonnet&nbsp&nbsphostspecifier&nbsp&nbsphostandport&nbsp&nbspinternetdomainname;bj@ since the majority of these classes have been made serializable and the rest i dont particularly feel the need to make serializable im going close this issue i think it makes sense for future requests for particular classes to be made serializable to be added as separate issues (if this was being kept open for any particular reason feel free to reopen it)--- ;;;;0;1;;
615;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;497 : returns_deep_stubs may try to mock final classes;497  with deep stubs  it was possible for generic metadata to be lost/unused through nested invocations on non generic types. this could cause  returns_deep_stubs  to try mocking final classes which would result in a  classcastexception .  apparently my other pr (#549) wasn t quite enough to fully fix this problem.  ---  **edited by mockito team**;;0;codegen filter to record set;;other than those minor comments it ;;;;1;1;rename byte code block methods for better consistency;
615;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;497 : returns_deep_stubs may try to mock final classes;497  with deep stubs  it was possible for generic metadata to be lost/unused through nested invocations on non generic types. this could cause  returns_deep_stubs  to try mocking final classes which would result in a  classcastexception .  apparently my other pr (#549) wasn t quite enough to fully fix this problem.  ---  **edited by mockito team**;;0;copied the code from operationmerge to fix synchronization;for #614;#549  amazing this made it almost a year (or more?) without us seeing a bug in prod thanks for catching and fixing  ||;;;;1;1;copied the code from operationmerge;
615;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;497 : returns_deep_stubs may try to mock final classes;497  with deep stubs  it was possible for generic metadata to be lost/unused through nested invocations on non generic types. this could cause  returns_deep_stubs  to try mocking final classes which would result in a  classcastexception .  apparently my other pr (#549) wasn t quite enough to fully fix this problem.  ---  **edited by mockito team**;;497.0;497 : returns_deep_stubs may try to mock final classes;497with deep stubs it was possible for generic metadata to be lost/unusedthrough nested invocations on non generic types this could cause `returns_deep_stubs` to try mocking final classes which would result in a `classcastexception`apparently my other pr (#549) wasnt quite enough to fully fix this problem---**edited by mockito team**;  615  **< ;deep_stubs tries to mock final class;    <dependency>        <groupid>orgmockito</groupid>        <artifactid>mockito-core</artifactid>        <version>11019</version>        <scope>test</scope>    </dependency>``````$ java -versionjava version ""180_91""java(tm) se runtime environment (build 180_91-b14)java hotspot(tm) 64-bit server vm (build 2591-b14 mixed mode)``````import static orgjunitassertassertnullimport static orgmockitomockitoreturns_deep_stubsimport static orgmockitomockitomockimport orgjunittestpublic class mockitobug {  public interface supplier<t> {    public t get()  }  public interface stringsupplier extends supplier<string> {}  public interface inheritedsupplier extends stringsupplier {}  @test  public void deepstubs() {    stringsupplier mock  mock(stringsupplierclass returns_deep_stubs)    string s  mockget()    assertnull(s)  }  @test  public void inheriteddeepstubs() {    inheritedsupplier mock  mock(inheritedsupplierclass returns_deep_stubs)    string s  mockget()  // classcastexception    assertnull(s)  }}``````javalangclasscastexception: orgmockitointernalcreationcglibclassimposterizer$classwithsuperclasstoworkaroundcglibbug$$enhancerbymockitowithcglib$$322ebf6e cannot be cast to javalangstring    at mockitobuginheriteddeepstubs(mockitobugjava:26)    at sunreflectnativemethodaccessorimplinvoke0(native method)    at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javalangreflectmethodinvoke(methodjava:498)    at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)    at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)    at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)    at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)    at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)    at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)    at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)    at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)    at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)    at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)    at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)    at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)    at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)    at orgeclipsejdtinternaljunit4runnerjunit4testreferencerun(junit4testreferencejava:86)    at orgeclipsejdtinternaljunitrunnertestexecutionrun(testexecutionjava:38)    at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:459)    at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:678)    at orgeclipsejdtinternaljunitrunnerremotetestrunnerrun(remotetestrunnerjava:382)    at orgeclipsejdtinternaljunitrunnerremotetestrunnermain(remotetestrunnerjava:192)```i expect the behavior for `stringsupplier` and `inheritedsupplier` to be the same: return `null` for `get` however `inheritedsupplier` tries to return a mock `object` for `get`";"i have a hacky workaround using guavas `typetoken`:```  private static final mockutil mockutil  new mockutil()  @suppresswarnings(""unchecked"")  private static <t> t createsmartdeepmock(typetoken<t> mocktype) {    return (t) mock(mocktypegetrawtype() createsmartdeepmockanswer(mocktype))  }  private static answer<?> createsmartdeepmockanswer(typetoken<?> mocktype) {    map<method object> mocks  new linkedhashmap<>()    return invocation -> {      method method  invocationgetmethod()      if (mockscontainskey(method)) {        return mocksget(method)      }      type returntype  methodgetgenericreturntype()      typetoken<?> resolvedreturntype  mocktyperesolvetype(returntype)      class<?> returnclass  resolvedreturntypegetrawtype()      if (!mockutilistypemockable(returnclass)) {        return mockitoreturns_defaultsanswer(invocation)      } else {        object mock  createsmartdeepmock(resolvedreturntype)        mocksput(method mock)        return mock      }    }  }``` || ";1;0;fix returns_deep_stubs which might mock final classes497with deep stubs it was possible for generic metadata to be lost/unusedthrough nested invocations this could cause returns_deep_stubs to mock finalclasses which would result in a classcastexception;
617;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moves arity interfaces of java8 helper answers to public api;the java 8 helper interfaces have been introduced in #338. however the public  additionalanswers.answer  family leak the functional interfaces.  these _parameter arity_ interfaces can be public  hence they are moved next to  answer  in the  org.mockito.stubbing  package.  i m however in favor of adding the  @incubating  annotation on those apis and related objects. thoughts ?  614;;0;convenience for functions on single domain; hiwhen writing anonymous inner functions i found myself often writing function&ltiterable&ltinteger> iterable&ltinteger>> - or other functions with both type arguments the same this adds much unnecessary code which is undesirable especially when defining anonymous inner classesproposed enhancement is super simple add this interface:public interface permutation&ltt> extends function&ltt t> {}as for the name i used math terminology ( but saw function1&ltt> in the wild;bj@ we are not convinced theres nearly enough value in adding an endofunction&ltt> interface just as basically shorthand for function&ltt t>--- ;;;;0;1;;
617;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moves arity interfaces of java8 helper answers to public api;the java 8 helper interfaces have been introduced in #338. however the public  additionalanswers.answer  family leak the functional interfaces.  these _parameter arity_ interfaces can be public  hence they are moved next to  answer  in the  org.mockito.stubbing  package.  i m however in favor of adding the  @incubating  annotation on those apis and related objects. thoughts ?  614;;0;add exception cause before transitioning to failed state;;;;;;1;1;add exception cause before transitioning to failed state;
617;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moves arity interfaces of java8 helper answers to public api;the java 8 helper interfaces have been introduced in #338. however the public  additionalanswers.answer  family leak the functional interfaces.  these _parameter arity_ interfaces can be public  hence they are moved next to  answer  in the  org.mockito.stubbing  package.  i m however in favor of adding the  @incubating  annotation on those apis and related objects. thoughts ?  614;;0;replay() and timer() javadocs: diagrams & wiki links;;#551 ;;;;1;1;replay() and timer() javadocs: diagrams & wiki links;
617;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moves arity interfaces of java8 helper answers to public api;the java 8 helper interfaces have been introduced in #338. however the public  additionalanswers.answer  family leak the functional interfaces.  these _parameter arity_ interfaces can be public  hence they are moved next to  answer  in the  org.mockito.stubbing  package.  i m however in favor of adding the  @incubating  annotation on those apis and related objects. thoughts ?  614;;338.0;moves arity interfaces of java8 helper answers to public api;the java 8 helper interfaces have been introduced in #338 however the public `additionalanswersanswer` family leak the functional interfacesthese _parameter arity_ interfaces can be public hence they are moved next to `answer` in the `orgmockitostubbing` packageim however in favor of adding the `@incubating` annotation on those apis and related objects thoughts ?614;  617   some very small doc comments lgtm also with the `@incubating` ;functional interfaces for java 8 support in mockito 2;relating to issue #337 - these are some changes that would allow more usability from java 8 users id really appreciate feedback on thisit would make some of my callback use cases easier and would provide a richer way of expressing assertions for arguments via argthatone risk introduced by this change is increased use of the type parameter in argumentmatcher - this should be a good thing yet i was left thinking it would surely have been done by someone else if it were easy;  i like this change - how about you guys @bric3 @timvdlippe ? || yes i like it it does require a rebase though to make sure we have enough coverage thanks @ashleyfrieze for spending time on improving java 8 usability! || @ashleyfrieze are you available to update this pr with the feedback or should we take it over from here? thanks for your contribution! || i should be able to do these code review comments - or at the least have a crack at them - in the next 24 hours or so sorry to drop out the loop blame a combination of github notifications and googles inbox for filtering them || @ashleyfrieze no problem whenever you have time :) || mockito2 is intended for version of java pre-java 8 right?it would be great to have a module that has some java 8 examples of the usage of this expressed as unit tests - as per the feedback earlier on - is there a home for that? || @ashleyfrieze yes it compiles with java 5 @raphw are you aware of a method to run unit tests on a separate jdk version? || we could create a module in the build which requires java 8 arguably we could even make it somehow optional for those people still compiling in java 5 depends on how well the build tool will let us do that or i could create a demo project in java 8 that demonstrates these features and we could put it outside the main build? || one potentially larger impact change within this pull request is to the matcher interface making it completely generic typed - this has raised a question (above) about the removing of an instanceof test (which ill double check) it may also have an effect on migration/compatibility is everyone cool with this part of the change?```public boolean matches(object actual)```is now```public boolean matches(t actual)```which makes java8 happier but is also better than the weird thing that hamcrest was allowingwe may be able to relax it to allow subclasses of t if thats preferred? || im going to have to rebase this against master for it to work on merge one issue is that the removal of `invocationonmock::<t> t getargumentat(int index class<t> clazz)` could cause some issues ill try it out its going to be a few days before i get there || are the stacktrace related changes required for this pull request? i would like to reduce the number of side-effect changes in this pull-request as it is already growing quite rapidly i have no problem with a separate pull request to discuss these changes just want to minimize the risk of merging in incorrect changes in an otherwise correct pr || they were stopping me from building the codei know what you meani could pull them into a separate pull request and then rebase this change over that? || lets leave them in for now but i would like to see the comments of @bric3 on these change are you fine with changing the `stacktracefilter` functionality? || just pushed some unit tests for some matchers - mainly to remove the complaint by the coverage report - but also to verify that my change to the interface has worked || @timvdlippe - please note its a refactor rather than a change in outcome the code of the test has been changed the runtime code should have exactly the same behaviour it ever did though i cant see how that test ever passed its possible that in some configurations that test is not run or that it has no impact on some jvms im building on a jdk8 || ah okay if it is backwards compatible then that is fine by me i thought we were making breaking changes here then lets leave the changes here    || @timvdlippe thanks my fear as with any noob contributing to an os project is that any change could surprisingly be a breaking one :) || ive one thing left to deal with - the javadoc for `doanswer` with the new functional interfaces for composing answers i can refine that or i can go a step further and add to `mockito` things like```public static stubber doanswer(answer1 returninganswerwith1parameter) {}public static stubber doanswer(voidanswer1 voidanswerwith1parameter) {}```which has been suggested and would make it a lot easier to usecan people give me thumbs up or down for whether this is a good thing to do or not ive made a lot of line changes in the sacred `mockito` class dare i go further :) || one last comment on the `doanswer` other than that i think this pr lgtm thank you for your continued effort @ashleyfrieze ! || this looks really good let us please merge this soonas for writing tests: in byte buddy i added some precompiled class files to the `resource` folder of the project such that they are not compiled during build for each test i then add a regular test that first checks if the current jvm supports java 8 or higher and if so i explicitly run the test using `class:forname` and then triggering a `runnable::run` that the java 8-specific test implements || landed this pull request in  thank you for your continued effort @ashleyfrieze (and also fixing that nasty test as reported in #435!) ||;1;0;614 : makes functional interfaces incubating;
619;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;548 from now on verification happens always call in other thre…;should fix problems with #548 and #601;;0;add {iterables iterators}{dropwhile takewhile};j@ i miss methods to skip/retrieve the first elements of an iterable according to a predicate (ie the predicate is used to determine the index at which an iterable is partitioned then the first/second partition is returned)on a side note: id welcome a wiki page which maps guavas methods and their names to common names in order to help people easily find methods (also to find them missing as in this case) under names they know (eg from various programming languages or libraries)eg (what i can recall from _guava_ haskell scala python and ruby):&nbsp&nbsp\* _`any`_ `exists`&nbsp&nbsp\* _`all`_ `forall`&nbsp&nbsp\* _`filter`_ `select`&nbsp&nbsp\* _`transform`_ `map` `collect`&nbsp&nbsp\* `fold*` `reduce*` `inject`&nbsp&nbsp\* _`find`_&nbsp&nbsp\* _`limit`_ `take`&nbsp&nbsp\* `takewhile`&nbsp&nbsp\* _`skip`_ `drop`&nbsp&nbsp\* `dropwhile`&nbsp&nbsp\* _`concat`_ `chain`&nbsp&nbsp\* _`zip`_&nbsp&nbsp\* _`partition`_ `grouped`&nbsp&nbsp\* `slice`&nbsp&nbsp\* _`uniqueindex`_ `groupby`etcsome references:&nbsp&nbsp\* [ [ [ [ [ [http://wwwruby-docorg/core/];j@ your basic argument is valid of course excuse my trace of conservatism :)which names are suitable is debatable though ""limit"" can be interpreted as modifying the underlying data too (in the sense of truncation) i think it depends on the point of view one chooses when considering the data to operate with as on-the-fly speaking of ""modifying"" seems very appropriate to mealso ""transform"" ""partition"" and ""reverse"" dont operate in-place in guava too (although one could think so ignoring the return type) actually when it comes to `iterables` only the three methods that deal with `collection`s modify data in-place (ok thats because of the unmodifyable nature of `iterable` but still)however as ""skip"" and ""limit"" are already in place sticking to those imho is the wisest option anyway not my first choice (principle of least surprise is violated here id say from my experience with common naming in this domain) and it might underline the usefulness a mapping like the one i outlined above but hey || ";;;;0;1;;
619;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;548 from now on verification happens always call in other thre…;should fix problems with #548 and #601;;0;refresh hive cached values in background;;;;;;1;1;refresh hive cached values in background;
619;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;548 from now on verification happens always call in other thre…;should fix problems with #548 and #601;;0;unittest to assert thread safety of executor scheduler;- the executor thread-pools hop threads when using observeon so this tests that it is thread-safe when doing so- the test performs non-thread-safe mutations which should fail (or at least be non-deterministic) if memory visibility problems or concurrency is occurring;#553 ;;;;1;1;unittest to assert thread safety of executor scheduler- the executor thread-pools hop threads when using observeon so this tests that it is thread-safe when doing so- the test performs non-thread-safe mutations which should fail (or at least be non-deterministic) if memory visibility problems or concurrency is occurring;
619;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;548 from now on verification happens always call in other thre…;should fix problems with #548 and #601;;548.0;548 from now on verification happens always call in other thre…;should fix problems with #548 and #601;    i am going to restart this build a couple of times to test the robustness || it could take a  while hopefully we have loopsin the meantime try this gist :  || got a failed travis job the culprit seems to be `orgmockitousageverificationverificationafterdelaytest > shouldverifynormallywithspecifictimes` || i have not touched `verificationafterdelaytest` in this pr || yes i know was merely stating that the travis failure we experienced was a different test nonetheless i think it is best if we aggregrate all test fixes in a pr to study the robustness would you be willing to do so? || yup another commit with `verificationafterdelaytest` changes take a look || great thanks will be restarting these changes a couple of times too really nice to have deterministic results now!    || im ok with the change even if the fact that the proposed test implementation is not completely deterministic its definitely an nifty improvement plus the test code is elegant! || @lukasz-szewc also after adding the `timeunit` parameter to `delayedexection` ? could rebase your commits (`added one missing line` is not really the most expressive message) ) || i like the idea of starting the threads and await there readiness this might solve the timing issues an other option is to write an simplified scheduledexecutorservice with the same behavior as the delayedexecution of this pr this way the test can remain untouched and we have still the possibiliy run tasks with individual delay as required by one test  || 1 added `timeunit` to constructor2 reworked one of test in `verificationwithtimeouttest` mentioned above3 rebased and pushed with forcetake a look ||;verificationwithtimeouttest is unstable;see build failure:  stack trace:```orgmockitousageverificationverificationwithtimeouttest > shouldallowtimeoutverificationinorder failed    orgmockitoexceptionsverificationverificationinorderfailure:     verification in order failure    wanted but not invoked:    mockonearg(1)    -> at orgmockitousageverificationverificationwithtimeouttestshouldallowtimeoutverificationinorder(verificationwithtimeouttestjava:161)    wanted anywhere after following interaction:    mockonearg(x)    -> at orgmockitousageverificationverificationwithtimeouttestshouldallowtimeoutverificationinorder(verificationwithtimeouttestjava:155)```;refs #433 #446 and #451 || we may want to look at `verificationafterdelaytest` tooalso see #601i have some ideas ill try them when i have some time ||;1;0;548 changed order of assertions in canignoreinvocationswithjunit test method;
619;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;548 from now on verification happens always call in other thre…;should fix problems with #548 and #601;;601.0;548 from now on verification happens always call in other thre…;should fix problems with #548 and #601;    i am going to restart this build a couple of times to test the robustness || it could take a  while hopefully we have loopsin the meantime try this gist :  || got a failed travis job the culprit seems to be `orgmockitousageverificationverificationafterdelaytest > shouldverifynormallywithspecifictimes` || i have not touched `verificationafterdelaytest` in this pr || yes i know was merely stating that the travis failure we experienced was a different test nonetheless i think it is best if we aggregrate all test fixes in a pr to study the robustness would you be willing to do so? || yup another commit with `verificationafterdelaytest` changes take a look || great thanks will be restarting these changes a couple of times too really nice to have deterministic results now!    || im ok with the change even if the fact that the proposed test implementation is not completely deterministic its definitely an nifty improvement plus the test code is elegant! || @lukasz-szewc also after adding the `timeunit` parameter to `delayedexection` ? could rebase your commits (`added one missing line` is not really the most expressive message) ) || i like the idea of starting the threads and await there readiness this might solve the timing issues an other option is to write an simplified scheduledexecutorservice with the same behavior as the delayedexecution of this pr this way the test can remain untouched and we have still the possibiliy run tasks with individual delay as required by one test  || 1 added `timeunit` to constructor2 reworked one of test in `verificationwithtimeouttest` mentioned above3 rebased and pushed with forcetake a look ||;one test fails probably undeterministically;heycheck console output for this build:  seems that one test from time to time for no apparent reason```orgmockitousageverificationverificationwithtimeouttest > canignoreinvocationswithjunit failed    wanted but not invoked:    mockonearg(1)    -> at orgmockitousageverificationverificationwithtimeouttestcanignoreinvocationswithjunit(verificationwithtimeouttestjava:147)    actually there were zero interactions with this mock        at orgmockitointernalexceptionsreporterwantedbutnotinvoked(reporterjava:329)        at orgmockitointernalverificationcheckersmissinginvocationcheckercheckmissinginvocation(missinginvocationcheckerjava:37)        at orgmockitointernalverificationtimesverify(timesjava:37)        at orgmockitointernalverificationverificationovertimeimplverify(verificationovertimeimpljava:78)        at orgmockitointernalverificationverificationwrapperverify(verificationwrapperjava:15)        at orgmockitointernalverificationmockawareverificationmodeverify(mockawareverificationmodejava:21)        at orgmockitointernalhandlermockhandlerimplhandle(mockhandlerimpljava:73)        at orgmockitointernalhandlernullresultguardianhandle(nullresultguardianjava:32)        at orgmockitointernalhandlerinvocationnotifierhandlerhandle(invocationnotifierhandlerjava:36)        at orgmockitointernalcreationbytebuddymockmethodinterceptordointercept(mockmethodinterceptorjava:36)        at orgmockitointernalcreationbytebuddymockmethodinterceptoraccess$000(mockmethodinterceptorjava:17)        at orgmockitointernalcreationbytebuddymockmethodinterceptor$dispatcherdefaultingtorealmethodinterceptabstract(mockmethodinterceptorjava:113)        at orgmockitousageimethods$mockitomock$1357077317onearg(unknown source)        at orgmockitousageverificationverificationwithtimeouttestcanignoreinvocationswithjunit(verificationwithtimeouttestjava:147)```;well i looked closely to this test and it fails for a very good reasonthere is absolutely no guarantee that executor will start and finish method execution on mock in given time duration (delay value used in test)thats why from time to time this test will fail because verification will be quicker than executor  || yes this is a time related test the only thing we have done now is to augment the timeouttheres ways to make the test deterministic though via some thread synchronisation im thinking about `countdownlatch` especially || yet another undeterministic result```orgmockitousageverificationverificationafterdelaytest > shouldreturnlistofargumentswithsamesizeasgiveninatmostverification failed    orgmockitoexceptionsbasemockitoassertionerror: expected that more than 200ms elapsed! but was: 199ms        at orgmockitoutilstopwatchfail(stopwatchjava:63)        at orgmockitoutilstopwatchassertelapsedtimeismorethan(stopwatchjava:45)        at orgmockitousageverificationverificationafterdelaytestshouldreturnlistofargumentswithsamesizeasgiveninatmostverification(verificationafterdelaytestjava:135)``` || duplicates #548related issues / pr are #433 #446 and #451 ||;1;0;548 changed order of assertions in canignoreinvocationswithjunit test method;
623;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;updated the javadocs;polishing the javadocs  starting with this small pr:  issue #596 - updated @since to 2.1.0 (instead 2.0.0) - added more docs around the verification collector;;0;consider adding joiner overloads taking printwriter; like joinerappendto(stringbuilder iterable) this should not throw ioexceptionfor example the printstream may wrap a chararraywriter or (for quick-and-dirty diagnostics) it may be systemerr; with joiner having as many overloads as it already does im not inclined to add another unless we learn there is very widespread need--- ;;;;0;1;;
623;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;updated the javadocs;polishing the javadocs  starting with this small pr:  issue #596 - updated @since to 2.1.0 (instead 2.0.0) - added more docs around the verification collector;;0;add environment to event objects;;;;;;1;1;add environment to event objects;
623;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;updated the javadocs;polishing the javadocs  starting with this small pr:  issue #596 - updated @since to 2.1.0 (instead 2.0.0) - added more docs around the verification collector;;0;clojure observable/from converts list to to an observable of a single (list) value;"im trying out the [clojure example code]( and the results seem wrongwith the following:``` clojure(defn hello  [& args]  (-> (observable/from args)    (subscribe (rx/action [v] (println (str ""hello "" v ""!""))))))(hello ""ben"" ""george"")```i expected the observable to emit two distinct values ""ben"" and ""george"" before completing resulting in one line of output per namehowever the repl output is:``` clojurehello (""ben"" ""george"")!```so it seems the entire `args` list is emitted as a single value tried 0151 as well as current master at 7ec374c clojure 151"; clojure(defn hello  [& args]  (-> (observable/from  (""ben"" ""george"") )  hardcode the list    (subscribe (rx/action [v] (println (str ""hello "" v ""!""))))))(hello ""ben"" ""george"")```works fine very strange || the clojure compiler has many versions of `observable/from` to choose from and here it picks the wrong one youll need to give it a hint:``` clojure(observable/from ^javalangiterable args)```that should do it || thanks that works not cool though its reasonable to expect it to just work || welcome to java interop with dynamic types || :) || ";;;;0;1;;
623;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;updated the javadocs;polishing the javadocs  starting with this small pr:  issue #596 - updated @since to 2.1.0 (instead 2.0.0) - added more docs around the verification collector;;596.0;updated the javadocs;polishing the javadocs starting with this small pr:issue #596- updated @since to 210 (instead 200)- added more docs around the verification collector;    ;review and update documentation for 210;"-  update the migration guide (should be easy there are not many breaking changes if we miss out we can update in following rc)-  add information about bytebuddy in the migration guide-  mention noteworthy 200 features (should be easy there are not many plus they are already documented :)-  fix odd todo #593-  review/update @since tags so that they say 210final steps i plan doing (by the eod wednesday tomorrow) in order:-  test release from release/test (in progress see travis ci)-  merge/cherry-pick changes from ""release/test"" to master-  move announcement / motivation text ( to top of ""whats new in mockito 2""-  final pass over ""whats new in mockito 2"" make the information exciting and compelling emphasize use cases add missing links-  update the 210 information in main mockito class to link to ""whats new in mockito 2"" see ""todo 596"" in code- [x] review continuous delivery [wiki page]( [x] update the announcement text ( so that instead of tons of text it just links to ""whats new in mockito 2""- [x] review release checklist (mostly done) - #620- [x] optional - add some info in the whats new in mockito 2 about the next steps for engs (eg ask to use the new version and give feedback)";"there were separate issues for these points for example the last point was already  by @brice3 in a recent pr || this list nicely summarizes the incompatible changes:  || @bric3 has started the migration guide:  || migration guide has been updated and i did a small spell check that  thanks @timvdlippe@raphw @szpak @marcingrzejszczak @szczepiq if you want to add other stuff to this migration guide ? || sorry i wont find time for anything before javazone next week is over afterwards i will have a look! || given long weekend coming i can commit to finalize my review / amendments by the end of wed next week (9/7) apologies it is not as fast as the crew would like!keep in mind that you dont need me to pull the trigger!!!guys were so close now! its exciting :))))) || @raphw no problem enjoy javazone also do some advertisement for mockito 2 ) || ive checked out the migration guide and i found it really good i was missing an example of a default method but i think @timvdlippe added thati havent done much (to say the least) with regards to this release so i dont have much to write from myself like i told @szczepiq and @bric3 im overwhelmed with other projects but ill try to be more active in the upcoming months (dont promise anything though :/ )definitely i can take over testing questions and support if there are some! :) || i just remembered this have to add tomorrow: lazy verification || lazy verification mention added:  || cool this morning i tidied up a bit the wiki mostly these two : added side page improved a lot the home page || really like these changes looks a lot nicer!op wo 31 aug 2016 om 14:30 schreef brice dutheil <notifications@githubcom> :> > cool this morning i tidied up a bit the wiki mostly these two : added> side page improved a lot the home page> > —> you are receiving this because you were mentioned> reply to this email directly view it on github>  or mute the thread>   || guys the ""whats new in mockito 2"" is fantastic!!! thanks a lot! || i like the ""whats new in mockito 2"" im reviewing mockito main javadoc i might have some edits to the ""whats new"" wiki will see :) || yep sure ) || @szczepiq i think we can close this issue since you reviewed mockito class :p || i have some edits hold on :) ill finish by tomorrow! || ok we ll monitor the check boxes ) || @szczepiq be sure to check out this wiki page as well  fix or correct issues i think this could be a starting point if you want to extract the _cdd_ || > move announcement / motivation text ( to top of ""whats new in mockito 2""i would rather not do this since it clutters the content that wikipage should be only about ""whats new in mockito 2"" not what is upcoming in mockito 3> final pass over ""whats new in mockito 2"" make the information exciting and compelling emphasize use cases add missing linksnot sure what you mean with ""exciting and compelling"" but i would rather not change the current text of the features lets keep it formal and clear || @timvdlippe migration guide does not mention two bdd enhancements ive developed: #212 and #311 i think its worth sharing it with the world :) || @mkordas yes definitely i have added them! || @timvdlippe thank you! || > i would rather not do this since it clutters the content that wikipage should be only about ""whats new in mockito 2"" not what is upcoming in mockito 3good feedback ill think how to do it best> not sure what you mean with ""exciting and compelling"" but i would rather not change the current text of the features lets keep it formal and clearby compelling i mean ensuring that every feature describes the why well enough (eg ""why should i care about the feature"") perhaps this requirement is already met if thats the case i dont need to make changes :) || ah i didnt finish all i wanted :( im pretty happy though if someone else wants to pick up the work go for it and pull the trigger :) otherwise i can pick up the work tomorrow@timvdlippe i considered your feedback about the whats new page eventually i went ahead and added introduction section i hope its ok ) i added table of contents for people to quickly jump to improvements or incompatibilities i didnt change much of the original text after all its well written @bric3  @timvdlippe great work!!!! you contributed not only great code but also great docs too many times i see that docs are not emphasized enough in software projects docs are part of the product and must be as high quality as code thanks for honoring this principle in mockitodamn im proud of this release and you guys!!!!!!!!!! :))))))))))))))))))))))))))))))))) || the introduction looks good! glad the wording of the changes remainedfairly the same :)on thu 8 sep 2016 06:55 szczepan faber notifications@githubcom wrote:> ah i didnt finish all i wanted :( im pretty happy though if someone> else wants to pick up the work go for it and pull the trigger :)> otherwise i can pick up the work tomorrow> > @timvdlippe  i considered your feedback> about the whats new page eventually i went ahead and added> introduction section i hope its ok ) i added table of contents for> people to quickly jump to improvements or incompatibilities i didnt> change much of the original text after all its well written @bric3>   @timvdlippe  great work!!!! you contributed not only great code but also great docs too> many times i see that docs are not emphasized enough in software projects> docs are part of the product and must be as high quality as code thanks> for honoring this principle in mockito> > damn im proud of this release and you guys!!!!!!!!!!> :)))))))))))))))))))))))))))))))))> > —> you are receiving this because you were mentioned> reply to this email directly view it on github>  or mute the thread>   || made more progress i didnt finish on time my new eta is weekend :) however you dont need me to do the release :) || il just wait for #628 to be merged then ill make this branch `release/2x` || woah im done!t_h_a_n_k_s for patience and for pushing me & all of us to make progress on the release || ";1;0;updated the documentation in verificationcollectoradded more info about scenarios / use cases asked for feedback;
626;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;ensured javadocs are correct;based on feedback from brice.;;0;support for sneaky throwing; it would be nice if the throwables class supported sneaky propagation (a la project lomboks @﻿sneakythrows annotation)  this would mean that checked exceptions would be treated as if they were runtime exceptions without wrapping thempublic void idontdeclarecheckedexceptions() {&nbsp&nbsp&nbsp&nbsptry&nbsp&nbsp&nbsp&nbsp{&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspobjectdosomethingthatthrows()&nbsp&nbsp&nbsp&nbsp}&nbsp&nbsp&nbsp&nbspcatch(ioexception ex)&nbsp&nbsp&nbsp&nbsp{&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspthrowablespropagatesneakily(ex)&nbsp&nbsp&nbsp&nbsp}}; _issue #903 has been merged into this issue_ || the issue is taken care of in  ""durian: guavas spikier (unofficial) cousin"" || ";;;;0;1;;
626;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;ensured javadocs are correct;based on feedback from brice.;;0;ensured javadocs are correct;based on feedback from brice;   ;;;;1;1;ensured javadocs are correct625;
626;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;ensured javadocs are correct;based on feedback from brice.;;0;split url extraction into separate functions;;;;;;1;1;split url extraction into separate functions;
626;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;ensured javadocs are correct;based on feedback from brice.;;59.0;added: bolatest : bonext bomostrecent botoiterable;- implemented latest (issue #59)-  next and mostrecent to connect to the source observable only when the iterator is asked for- fixed toiterablenext() not properly handling the completed status (repeated calls to just the next() would simply block on the empty queue);#557  #559 #560 does this capture the essentials more-or-less or should i draw up a morecomplicated example with hasnext() calls? tue dec 17 2013 at 1:11 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #560 > this pull request looks good> > —> > reply to this email directly or view it on github ## david m grossplp consulting || i imagined something like these: [next]( [latest]( || hmmm it looks like i dont understand latest() i figured the secondnext() call in your latest() illustration would return the pink item sincethat is the latest unreturned item at the time the next() call is madeinstead you have it skip that one and the red item emitted after thenext() call is made and instead pick up the green item i dontunderstand the logic that governs this decisionon tue dec 17 2013 at 12:32 pm akarnokd notifications@githubcom wrote:> i imagined something like these: next latest  > —> reply to this email directly or view it on github ## david m grossplp consulting || @davidmgross i think your diagram is right || the codes look correct and much clearer || @davidmgross this is due to the internal race between placing a value in the `onotif` and removing one so even if the `next()` has woken up it still could be preempted and a new notification placed  onnext` overwrites the previous value technically the red item wakes up `next()` but the green arrives just in time so it is emitted || thank you for these fixes ||;operator: latest;http://msdnmicrosoftcom/en-us/library/hh212115(vvs103)aspx;"is `latest` same as `next` #66? i read  and  in rxnet but i cant find the difference || i believe latest can return a value from the past but falls back the next value if one hasnt been received yet || > i believe latest can return a value from the past but falls back the next value if one hasnt been received yet@abersnaze  do you mean if the next value hasnt arrived the latest will return the old cached value?but there are the following codes in the trymovenext method of latest``` c#            public override bool trymovenext(out tsource current)            {                var kind  default(notificationkind)                var value  default(tsource)                var error  default(exception)#if !no_cds                _semaphorewait()#else                _semaphorewaitone()#endif```so when `trymovenext` is called it will block the thread and wait for the incoming valuei tried the following codes in rxnext:``` c#            iobservable<int> ob                     observablecreate<int>(o >                    {                        consolewriteline(""subscribed: before onnext"")                        oonnext(1)                        threadsleep(2000)                        oonnext(2)                        consolewriteline(""subscribed: after onnext"")                        ooncompleted()                        return disposableempty                    }                    )            var iter  obsubscribeon(schedulernewthread)latest()getenumerator()            consolewriteline(""before movenext"")            while (itermovenext())            {                consolewriteline(""find a value"")                consolewriteline(""got "" + itercurrent)            }            consolewriteline(""after movenext"")```the output is:<pre>before movenextsubscribed: before onnextfind a valuegot 1subscribed: after onnextfind a valuegot 2after movenext</pre> || i did some tests on rxnet about `latest` and `next`i draw two marble diagrams to summary the differences between `latest` and `next`- latest![latest]( `latest` the `next` of `iterator` will check if there is a cached value if so returns the cached value and deleted the cached value if there is not a cached value it will blocks until the next value is emitted from the observable and returns it- next![next]( `next` the `next` method of `iterator` always blocks until the next value is emitted from the observable and returns itplease let me know if you find any mistake || so `next` will return every value emitted by source whereas `latest` only those which were observed just before the `hasnext()` call and only once?looking at `operationnext` i find it strange to have the `waiting` atomic boolean in l132 checked in l147 and set in l162 it appears if there is no one is using `takenext()` the onnext skips an onnext-notification l152 quotes some race condition which i dont really see as the observer ignores onerror and oncompleted and the materialized source should be race-free anyway || sorry that the next diagram is not clear here is a more clear diagram:![next1]( for the `next` operator items will be ignored if they are emitted between two `next` calls || however as the `iterator` has two methods: `hasnext` and `next` its more complicated check the document here:  and the discussion here:  || @zsxwing are you going to implement this? in addition ive looked at the operationmostrecent and if i understand it correctly it shares a single subscription to the source observable ie if i try to iterate the same source twice it wont work the second time:``` javablockingobservable<long> source  observableinterval(100 timeunitmilliseconds)take(10)toblockingobservable()iterable<long> it  sourcemostrecent(-1l)for (long l : it) {   systemoutprintln(l)   threadsleep(50)}systemoutprintln(""----------------------------------------"")for (long l : it) {    systemoutprintln(l)    threadsleep(50)}```same goes for `operationnextnext`i can fix both mostrecent and next and take latest || youre right the `subscribe` action should be created in the `iterator` rather than the `iterable` as im busy at other work now it would be appreciated if you can fix this issue and the `latest` operator || im on it   ";1;0;increased time delay in test;
628;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed javadoc documentation in the main class;checks out line item in #596;;0;mapsunmodifiableconcurrentmap(concurrentmap); you might ask ""why would a map be both concurrent and unmodifiable?""because(1) you have been making incremental changes to the map concurrently(2) it is now frozen and any attempt to modify it further is an error (which you want to trap)(3) you are implementing an interface that is required to return a concurrentmap (not just a map)(4) this method is missing from the jdk (though it is theoretically possible that it will be duplicated later like mapsimmutableentry())"; ;;;;0;1;;
628;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed javadoc documentation in the main class;checks out line item in #596;;0; javadoc documentation in the main class;checks out line item in #596;  628   looks good other wise ||;;;;1;1; wrong href in javadocbased on code review feedback well spotted!;
628;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed javadoc documentation in the main class;checks out line item in #596;;0;fix comparisons of longs as doubles in interpreter;;;;;;1;1;fix comparisons of longs as doubles in interpreter;
628;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed javadoc documentation in the main class;checks out line item in #596;;0;properly wired up synchronizedobserver within mergedelayerror operator;previous pull request for this issue ( missed the step of connecting synchronizedobserver to parentobserver;#558 ;;;;1;1;properly wired up synchronizedobserver within mergedelayerror operator;
635;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cleanup of bibtex;;;0;using mapsnewtreemap(comparator) triggers openjdk bug; <b>what steps will reproduce the problem?</b>1 create treemapexamplejava as follows:import javautilcomparatorimport javautiltreemapimport comgooglecommoncollectmapspublic class treemapexample {&nbsp&nbsppublic static final comparator&ltstring> foo  null&nbsp&nbspprivate treemap&ltstring string> instance  mapsnewtreemap(foo)}1 compile this using openjdk 160_20<b>what is the expected output? what do you see instead?</b>this should compile without errors instead the compiler outputs 7: incompatible types no instance(s) of type variable(s) kv exist so that javautiltreemap&ltkv> conforms to javautiltreemap&ltjavalangstringjavalangstring>found   : &ltkv>javautiltreemap&ltkv>required: javautiltreemap&ltjavalangstringjavalangstring>&nbsp&nbspprivate treemap&ltstring string> instance  mapsnewtreemap(foo)<b>what version of the product are you using? on what operating system?</b>guava r08 on linux<b>please provide any additional information below</b>i believe this is tied to openjdk bug 100167 ( current version of newtreemap has the following signature and comment:&nbsp&nbsppublic static &ltc k extends c v> treemap&ltk v> newtreemap(&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp@﻿nullable comparator&ltc> comparator) {&nbsp&nbsp&nbsp&nbsp// ideally the extra type parameter ""c"" shouldnt be necessary it is a&nbsp&nbsp&nbsp&nbsp// work-around of a compiler type inference quirk that prevents the&nbsp&nbsp&nbsp&nbsp// following code from being compiled:&nbsp&nbsp&nbsp&nbsp// comparator&ltclass<?>> comparator  null&nbsp&nbsp&nbsp&nbsp// map&ltclass<? extends throwable> string> map  newtreemap(comparator)&nbsp&nbsp&nbsp&nbspreturn new treemap&ltk v>(comparator)&nbsp&nbsp}interestingly changing the signature to its old (pre v40 in google-collections) signature:&nbsp&nbsppublic static &ltk v> treemap&ltk v> newtreemap(comparator<? super k> comparator)fixes the problem im not sure what combination of javac and client code was causing issues with the original signature but i cannot reproduce it at this point with any versions (oracle or openjdk) of javac that ive tried"; ok we looked into it  but im not sure what we can do about it  as you note were caught between a rock and a hard place here  we probably cant make any change without negatively affecting some users in some way so its only worth doing if we know the change is to the definite best correct shining perfect signature--- ;;;;0;1;;
635;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cleanup of bibtex;;;0;left join + predicate pushdown;;with these changes a query with a where clause like the following one scans more partitions than necessary because the predicate is not considered for partition pruning:case when f(partition_key) then false when g(non_partition_key) then the key here is that for some values of partition_key the expression may evaluate to false regardless of what non_partition_key is bound to || i just ran all of the benchmarks and there is no noticeable performance degradation in joins or other operators || this is awesome great job! ||;;;;1;1;predicate pushdownincludes equality inference for joins and aggregationsincludes partition pruning;
635;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cleanup of bibtex;;;439.0;unified logic of argument matching and capturing;the logic of argument matching and capturing is the same but can be found in argumentscomparator and invocationmatcher this pr unifies the decision logic how matchers are applied to argument+varargs by introducing a `matcherapplicationstrategy` this strategy can apply an action to an pair of argumentmatcher and argument one action is used to perform the argumentmatchermatches(arg) call and an other is used to perfrom the capturing- 439 argumentcaptor and argumentmatchers can now be mixed in varargs- fixes #583 no more npe when null is passed to an varargs - added 25 regression tests in varargstest (5 are ignored cause they belong to other issues and fail currently) - reduced logic duplication;  the pr! || @bric3 > some adjustments can be made eg getargumenttype can be simplified to read the type arg on the class rather than looking at the method the mechanic remained unchanged in this rp i introduced it with #463 at first i tried to retrieve the type-argument from the class but this turned out to be more complex eg when the type-argument is bound in an upper class or interface or additional type-arguments were introduced on a matcher classanyway if you have an idea how to improve or simplify it let me now!> other improvements can be made later sounds good can you open a new ticket so i can take look || @mockito-core#606 can be closed now || > > other improvements can be made later> > sounds good can you open a new ticket so i can take lookat the moment this works quite well! so no hurry especially given your above remark on mockito 3 (on master atm) we could change the interface to allow reporting the type handled by the matcher and maybe use default method for that || @christianschwarz i have seen an interesting problem with `varargstest` fail on master which is jdk 8 only while the same test passes on release/2x which is compiled and run against 3 jdk 6/7/8 im not sure why at the moment this behavior is different  plus my dev laptop is being  for a few days so im limited in my debug right nowthis happened after a merge of release/2x to master (52df10af105b7e9cd45bf214141c5096db3ecafe)i noticed that `verify(mock)varargs(isnull())` is compiled to invoke `imethodsvarargs(string  string)` im not sure other jdks behave/compile differently though one of the failing test can be fixed by adding the cast statement```    @test    public void shouldmatchvarargs_nullarrayarg() {        object argarray  null        mockvarargs(argarray)        verify(mock)varargs((object) isnull()) // otherwise it is linked against string    }```could it be that something went wrong with the merge regarding this pr ? || @christianschwarz actually the investigation continue see  ||;argumentcaptor and argumentmatcher cant be mixed in varargs;in the given test below the argumentcaptor should captor only the char c:```    @captor    private argumentcaptor<character> argumentcaptor    @test    public void capturesvararg() throws exception {        mockvarargs(42 c)        verify(mock)varargs(eq(42) argumentcaptorcapture())       assertthat(argumentcaptorgetallvalues())containsexactly(c)    }```the test fails with this message:```actual and expected should have same size but actual size was:  <2>while expected size was:  <1>actual was:  <[42 c]>expected was:  <[c]>```note that we see here 2 bugs:- a wrong argument index was captored- an `int`was captored by an  `argumentcaptor<character>` -> #565;yes `argumentcaptor` was not designed to be type aware though i like api with the least surprises it should be thanks for reporting || note to my self: here is the solution [gist ]( || this improvement makes mockito easier to use and more intuitive thats exactly the direction we should take mockito thanks!!! ||;1;0; failing test with vararg-aware matcher;
635;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cleanup of bibtex;;;583.0;unified logic of argument matching and capturing;the logic of argument matching and capturing is the same but can be found in argumentscomparator and invocationmatcher this pr unifies the decision logic how matchers are applied to argument+varargs by introducing a `matcherapplicationstrategy` this strategy can apply an action to an pair of argumentmatcher and argument one action is used to perform the argumentmatchermatches(arg) call and an other is used to perfrom the capturing- 439 argumentcaptor and argumentmatchers can now be mixed in varargs- fixes #583 no more npe when null is passed to an varargs - added 25 regression tests in varargstest (5 are ignored cause they belong to other issues and fail currently) - reduced logic duplication;  the pr! || @bric3 > some adjustments can be made eg getargumenttype can be simplified to read the type arg on the class rather than looking at the method the mechanic remained unchanged in this rp i introduced it with #463 at first i tried to retrieve the type-argument from the class but this turned out to be more complex eg when the type-argument is bound in an upper class or interface or additional type-arguments were introduced on a matcher classanyway if you have an idea how to improve or simplify it let me now!> other improvements can be made later sounds good can you open a new ticket so i can take look || @mockito-core#606 can be closed now || > > other improvements can be made later> > sounds good can you open a new ticket so i can take lookat the moment this works quite well! so no hurry especially given your above remark on mockito 3 (on master atm) we could change the interface to allow reporting the type handled by the matcher and maybe use default method for that || @christianschwarz i have seen an interesting problem with `varargstest` fail on master which is jdk 8 only while the same test passes on release/2x which is compiled and run against 3 jdk 6/7/8 im not sure why at the moment this behavior is different  plus my dev laptop is being  for a few days so im limited in my debug right nowthis happened after a merge of release/2x to master (52df10af105b7e9cd45bf214141c5096db3ecafe)i noticed that `verify(mock)varargs(isnull())` is compiled to invoke `imethodsvarargs(string  string)` im not sure other jdks behave/compile differently though one of the failing test can be fixed by adding the cast statement```    @test    public void shouldmatchvarargs_nullarrayarg() {        object argarray  null        mockvarargs(argarray)        verify(mock)varargs((object) isnull()) // otherwise it is linked against string    }```could it be that something went wrong with the merge regarding this pr ? || @christianschwarz actually the investigation continue see  ||;argumentcaptor: npe when an null array is passed to a varargs method;a nullpointerexception is thrown if an null array is passed to a varargs method```@testpublic void shouldcapturevarargs_nullarrayarg() {        string argarray  null        mockvarargs(argarray)        verify(mock)varargs(captorcapture()) //<- kaboom npe}```since an vararg is simply an array the argumentcaptor should reject it silently this relates to #565```javalangnullpointerexception    at javalangreflectarraygetlength(native method)    at orgmockitointernalinvocationinvocationmatchercapturevarargspart(invocationmatcherjava:142)    at orgmockitointernalinvocationinvocationmatchercaptureargumentsfrom(invocationmatcherjava:122)    at orgmockitointernalinvocationinvocationmarkermarkverified(invocationmarkerjava:24)    at orgmockitointernalinvocationinvocationmarkermarkverified(invocationmarkerjava:18)    at orgmockitointernalverificationcheckersnumberofinvocationscheckercheck(numberofinvocationscheckerjava:43)    at orgmockitointernalverificationtimesverify(timesjava:40)    at orgmockitointernalverificationmockawareverificationmodeverify(mockawareverificationmodejava:21)    at orgmockitointernalhandlermockhandlerimplhandle(mockhandlerimpljava:73)    at orgmockitointernalhandlernullresultguardianhandle(nullresultguardianjava:32)    at orgmockitointernalhandlerinvocationnotifierhandlerhandle(invocationnotifierhandlerjava:37)    at orgmockitointernalcreationbytebuddymockmethodinterceptordointercept(mockmethodinterceptorjava:36)    at orgmockitointernalcreationbytebuddymockmethodinterceptoraccess$0(mockmethodinterceptorjava:32)    at orgmockitointernalcreationbytebuddymockmethodinterceptor$dispatcherdefaultingtorealmethodinterceptabstract(mockmethodinterceptorjava:113)    at orgmockitousageimethods$mockitomock$81506210varargs(unknown source)    at orgmockitousagematchersvarargstestshouldcapturevarargs_nullarrayarg(varargstestjava:182)```;probably related to #567 ||;1;0; failing test with vararg-aware matcher;
635;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cleanup of bibtex;;;634.0;operators: switchcase (case) ifthen (if) dowhile (dowhile) whiledo (w;hile)issue #634no msdn references available;#565 ;more operators in rxnet;i extracted the method names from rxjava and rxnet and compared them i find some operators in rxnet(version 20208230) do not appear in the msdn do we need to implement them before 10? here is the list:-   any (exist isempty)-   **asobservable** (#641)-   **case** (#635)-   ~~catch~~ (onerrorresumenext is what we use this was for f# computation expressions)-   **chunkify** (#636)-   **collect** (#636)-   ~~deferasync~~ (not applicable as we dont have `task` or async/await)-   **delaysubscription** (#638)-   do (dooneach)-   **dowhile** (#635)-   finally (finallydo)-   **firstasync** (#520)- [x]  **firstordefaultasync** (firstordefault)- [x]  **for** (#636)- [x]  foreach (blockingobservableforeach)-   ~~foreachasync~~ (blockingobservableforeach since we dont  have `task` or async/await)-   ~~fromasync~~ (from with schedulers does this)- [x]  ~~fromasyncpattern~~ (wont implement)- [x]  ~~fromevent~~ (wont implement)- [x]  ~~fromeventpattern~~ (wont implement)- [x]  **generate** (#519)- [x]  ~~getenumerator~~ (wont implement)- [x]  **if** (#635)- [x]  lastasync (last)- [x]  lastordefault (blockingobservablelastordefault)- [x]  **lastordefaultasync** (#520)- [x]  **latest** (#626)- [x]  mostrecent (blockingobservablemostrecent)- [x]  next (blockingobservablenext)- [x]  refcount (connectableobservablerefcount)- [x]  **repeat** (#518)- [x]  return (from just)- [x]  select (map)- [x]  selectmany (flatmap)- [x]  single (blockingobservablesingle)- [x]  **singleasync** (#520)- [x]  singleordefault (blockingobservablesingleordefault)- [x]  **singleordefaultasync** (#520)-   ~~startasync~~- [x]  switch (switchonnext)- [x]  **takelastbuffer** (#638)- [x]  throttle (debounce)- [x]  throw (error)- [x]  toarray (unnecessary)- [x]  toasync (asynctoasync)- [x]  todictionary (tomap)- [x]  toenumerable (blockingobservabletoiterable)- [x]  ~~toevent~~ (wont implement)- [x]  ~~toeventpattern~~ (wont implement)- [x]  tolookup (tomultimap)- [x]  toobservable (from)-   ~~wait~~ (blockingobservablelast())- [x]  **while** (#635)**strong** means someone is working on it~~strikethrough~~ means it wont be implememted;"nice listcatch -> onerrorresumenext (?)fromasyncpattern: wont implement (#46)generate -> pr available (#519) still debating on return typelastordefault -> bolastordefault (?)mostrecent -> bomostrecentrepeat -> pr available (#518)startasync -> start  (?)switch -> switchonnext (?)throttle -> debouncei dont recognize the rest || updatedstartasync is not the `start` operator:```    //    // summary:    //     invokes the asynchronous function surfacing the result through an observable    //     sequence  the cancellationtoken is shared by all subscriptions on the resulting    //     observable sequence see the remarks section for more information    //    // parameters:    //   functionasync:    //     asynchronous function to run    //    // type parameters:    //   tresult:    //     the type of the result returned by the asynchronous function    //    // returns:    //     an observable sequence exposing the functions result value or an exception    //    // exceptions:    //   systemargumentnullexception:    //     functionasync is null    //    // remarks:    //      the function is started immediately not during the subscription of the    //     resulting sequence  multiple subscriptions to the resulting sequence can    //     observe the functions result  if any subscription to the resulting sequence    //     is disposed the cancellationtoken is set the observer associated to the    //     disposed subscription wont see the taskcanceledexception but other observers    //     will you can protect against this using the catch operator  be careful    //     when handing out the resulting sequence because of this behavior the most    //     common use is to have a single subscription to the resulting sequence which    //     controls the cancellationtoken state alternatively you can control subscription    //     behavior using multicast operators    public static iobservable<tresult> startasync<tresult>(func<cancellationtoken task<tresult>> functionasync)``` || here is whats missing and what they generally do:-  **asobservable**: ""hides the identity of an observable sequence""-  **case**: ""uses a selector to determine which source to return"" ie in onsubscribe a func0 selector is called and an observable looked up in a map then subscribed to it-  **chunkify**: ""produces an enumerable sequence of consecutive (possibly empty) chunks of the source sequence"" ie implemented as `sourcecollect(() -> new arraylist (lst x) -> {lstadd(x) return lst} u -> new arraylist)`-  **collect**: ""produces an enumerable sequence that returns elements collected/aggregated from the source sequence between consecutive iterations"" for example you start out with an empty list and each onnext adds to the list once the `iteratornext()` takes the current list it is replaced by a fresh list depending on the frequency of `next()` you might get lists with various sizes-  **deferasync**: ""returns an observable sequence that starts the specified asynchronous factory function whenever a new observer subscribes"" implemented as defer(() -> startasync(factory)merge()) where factory is a `func0<task<iobservable<tvalue>>>`-  **delaysubscription**: ""time shifts the observable sequence by delaying the subscription with the specified relative time duration"" does not timeshift the unsubscribe-  **dowhile**: ""repeats the given source as long as the specified condition holds where the condition is evaluated after each repeated source completed"" ie repeat only if condition holds: `do { subscribe & run } while (condition)`-  **for**: ""concatenates the observable sequences obtained by running the resultselector for each element in the given enumerable source"" the difference from a plain concat is that the source iterable is consumed on demand rather than all at once-  **foreachasync**: ""invokes an action for each element in the observable sequence and returns a task object that will get signaled when the sequence terminates"" like making a whole sequence of observations into a big future dual of fromfuture & toasync in some sense-  **fromasync**: ""converts to asynchronous function into an observable sequence each subscription to the resulting sequence causes the function to be started the cancellationtoken passed to the asynchronous function is tied to the observable sequences subscription that triggered the functions invocation and can be used for best-effort cancellation"" implemented as `defer(() -> startasync(functionasync))` where functionasync is `func<task<tresult>>` or `func<cancellationtoken task<tresult>>`- [x] **if**: ""if the specified condition evaluates true select the thensource sequence otherwise select the elsesource sequence"" condition is evaluated on subscription- [x] **groupby** with capacity overloads (v22)- [x] **groupbyuntil** with capacity overloads (v22)- [x] **singleasync**: ""returns the only element of an observable sequence and reports an exception if there is not exactly one element in the observable sequence"" returns an observable with a single element or exception- [x] **singleordefaultasync**: ""returns the only element of an observable sequence or a default value if the observable sequence is empty this method reports an exception if there is more than one element in the observable sequence""- [x] **startasync**: see [comment]( above- [x] **takelast** overload with time window (ie return the last 2 seconds worth of source values once it finishes)- [x] **takelastbuffer**: ""returns a list with the specified number of contiguous elements from the end of an observable sequence"" has time based overloads almost like takelast but emits a single list of elements - [x] **wait**: ""waits for the observable sequence to complete and returns the last element of the sequence if the sequence terminates with an onerror notification the exception is throw"" returns t looks like a `sourcetakelast(1)toblockingobservable()single()`- [x] **while**: ""repeats the given source as long as the specified condition holds where the condition is evaluated before each repeated source is subscribed to"" ie `while(condition) { subscribe }` || @zsxwing or anyone else do you want to do some of these? ill do them in batches do i dont have to rebase and restart from master all the time ill start with `dowhile` `while` `if` `case` || continuing with `chunkify` `collect` `wait` and `for`update: wait is practically bolast() since we dont usually do aliases ill skip wait || next: `defersubscription` `takelast` `takelastbuffer` || i can add singleasync and singleordefaultasync in pr #520 directly || do we really need deferasync foreachasync fromasync startasync? we have no cancellationtoken in java || it appears to me that cancellationtoken is used for cancelling tasks basically a similar way you would use futuretask and check its iscancelled() but since these tokens come from the outside you can signal cancellations to multiple tasks at once since we have the `subscription` infrastructure for that id vote for not implementing those variants || doing `asobservable` `groupby` and `groupbyuntil` variants || anyone want to implement all the testschedulers?(cancellationtoken is really only useful when you have async await) || a can take those as well unless someone else beats me to it while i do the ops mentioned above || doing lastasync and lastordefaultasync || @headinthebox what features do you miss from the current `testscheduler`? im looking at rxnet sources of virtualscheduler testscheduler and historicalscheduler but it is not apparent to me what the functional requirements arenever mind ill start doing it btw im starting to require the enhancements of my prs to avoid feature duplication || these :switch -> switchonnext (?)throttle -> debouncethe ""async"" ones dont use the async suffix in rxjava since the non-async ones are on `blockingobservable` instead thus some of those in the list are already implemented just without the async suffix || @zsxwing how is the `lastasync` operator you say youre doing different than `last` ( that is already implemented? it is non-blockingwe have `last` and `takelast````last()           returns an observable that emits the last item emitted by the source or an illegalargumentexception if the source observable is emptytakelast(int count)           returns an observable that emits only the last count items emitted by the source observable```difference between `takelast(1)` and `last()` just being the `illegalargumentexception` on `take` you were involved in both of these i though so im confused why were pursuing `lastasync` || what is a use case for `asobservable` to ""hide identity""? || rxnet uses it all around the place to hide subjects @headinthebox might explain it better || interesting though what value is there in ""hiding"" it? if it is returned as an `observable` not a `subject` people will use it as an `observable` is it to prevent people reflecting or inspecting a type and then interacting with the `subject`? || yup as @benjchristensen says it is to prevent downcasting etc in net people are pretty paranoid about this say you have a method that returns an iterable<t> but really it is an array<t> now that opens a potential (security) hole since the caller can use the iterable as a an array  || > @zsxwing how is the lastasync operator you say youre doing different than last ( that is already implemented? it is non-blockingsorry forget it we just need to add `lastordefaultasync` hope this comment ( can make these operators clear if no problem i can add this table to the wiki || looking into `deferasync` `startasync` and `singleasync` || > looking into deferasync startasync and singleasyncsingleasync has already done in #520 || doing foreachasync and fromasync and probably will amend pr #645 || the `fromasync` behavior seems to be covered in `from` overloads that take a `scheduler` such as this:  || no this fromasync is a completely different operation: it uses a factory to get a future of a value which is then observed per subscriber || already added the table to the wiki: thu dec 19 2013 at 5:57 pm shixiong zhu notifications@githubcomwrote:> @zsxwing  how is the lastasync operator you> say youre doing different than last (>  that is already implemented? it is non-blocking> > sorry forgot it we just need to add lastordefaultasync hope this> comment (#520 (comment) can make these operators clear if no problem i can add this table to the> wiki> > —> reply to this email directly or view it on github ## david m grossplp consulting || @headinthebox and i reviewed the list all remaining items have been struck out as they should not be implementedgreat work getting all the others done! || ";1;0;operators: switchcase (case) ifthen (if) dowhile (dowhile) whiledo (while);
639;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;replaced while-getnextelement-loops with foreach-loops;;;0;objectstostringhelper has minor bugs now; glad to see tostringhelper just use a stringbuilder internally now i had wanted something like that back in issue 400but two behavior changes were introduced with the change:- if a null name is provided to add() then the separator will be appended prior to the npe being thrown ideally a precondition happens pre anything destructive right?- tostring() cannot be called repeatedly without it adding extra close curlies im not entirely sure why youd want to call it repeatedly but the original implementation seemed to accommodate it perhaps one would want to tostring() some initial details then add more to the same tostringhelper and tostring() it againboth of these are simple to fix see attached diff; ;;;;0;1;;
639;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;replaced while-getnextelement-loops with foreach-loops;;;0;fix reversed precondition that broke aliases;;;;;;1;1;fix reversed precondition that broke aliases;
639;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;replaced while-getnextelement-loops with foreach-loops;;;0;moved the descriptions of some operators to a new wiki page;"""conditional and boolean operators""adjusting the javadoc links accordingly";#568 ;;;;1;1;"moved the descriptions of some operators to a new ""conditional and boolean operators"" wiki page";
639;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;replaced while-getnextelement-loops with foreach-loops;;;520.0;update travis configuration to also build on oraclejdk9;lets see if this actually works testing for #520;"  639 theres a new build || > also shall we update jacoco snapshot theres a new buildi would rather wait for the official 078 release and upgrade to that || ok fair enough ) || shalli merge this one? || yes || ";provide java 9 compatibility;once having mockito 20 out the door it would be good to explore java 9 compatibilitybasic todo list:-  - migration to gradle 30 (2x doesnt support java 9)-  - travis build with java 9-  - successful mockito project build with java 9-  - fix all disabled tests when the new asm version is available - #863open java 9 related [issues](https://githubcom/mockito/mockito/issues?qis%3aissue+is%3aopen+label%3ajava-9);i agree with that however note that mockito 21 should still be java 5 compatible (we still build java 5 binaries with java 6)before that we need to branch mockito 2x to support old jdks and make mockito 3 java 8 min || > we still build java 5 binaries with java 6im afraid we are [not](  16targetcompatibility  16```if java 5 is in fact a target of mockito 20 i could add animal sniffer verification that we dont use java 6 api in the codewe would probably need to decide if 21 is just for things that were able to finish before 20-final (and important bugfixes) or there are plans to keep a serious development of 2x line after 21 (with backporting non java 8 specific changes from 3x branch) || damn i didnt see this change im on my phonehowever thats fine for me || maybe something to mention in the migration guide though || otherwise for  21 i think we will only include few api refactoring like `argumentcaptor` and bugfixes otherwise it will delay serious work on mockito 3also i dont want to backport java 8 code to mockito 2my idea is to have a `2x` branch we can adjust the build script to release on this branch too || just for information the parts mockito uses of byte buddy are already fully java 9 compatible i do not see any problems on migration || i think this is ready now? || asm 6 is still in alpha:  || really dont focus too much on java 9 its still months away  || for your information logback uses mockito version 11019 which is apparently not java 9 compatible it follows that logback build fails under java 9  || mockito 2 is java 9 compatible || great thank you || running on version 195 with jigsaw b162 with --permit-illegal-accessim seeing the following warning  warning: illegal access by orgmockitocglibcorereflectutils$2 (file:gradle_cache/caches/modules-2/files-21/orgmockito/mockito-all/195/79a8984096fc6591c1e3690e07d41be506356fa5/mockito-all-195jar) to method javalangclassloaderdefineclass(javalangstringbyteintintjavasecurityprotectiondomain) maybe related  illegal access by netsfcglibcorereflectutils$1 (file:gradle_cache/caches/modules-2/files-21/cglib/cglib-nodep/324/42c972dee25a436b32c6027e848287ff47ed6750/cglib-nodep-324jar) to method javalangclassloaderdefineclass(javalangstringbyteintintjavasecurityprotectiondomain) is this  in 2x?  or is there handling if this call fails? || it might be fixed with mockito 2 yes as we are not using cglib anymore no promises though 😉  || i confirmed that the orgmockitocglibcorereflectutils is gone in 2x and mockito no longer depends on netsfcglibcore || byte buddy 172 now supports java 9 class files || >byte buddy 172 now supports java 9 class filesshould we just bump bytebuddy to the latest version? cheers! || closing as at last #863 has been fixed as well java 9 woohoo 🎉  ||;1;0;disable test not working on jdk9;
646;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;640 warns user to upgrade if java 8 version is to low;640 warns user to upgrade if java 8 version is to low.  also took the opportunity to log other platform details if mock class cannot be created.;;0;inetaddressestouristring() have to strip scopeid for ipv6; <b>what steps will reproduce the problem?</b><b>1</b>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspenumeration&ltnetworkinterface>  interfaces&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp networkinterfacegetnetworkinterfaces()&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspwhile(interfaceshasmoreelements()) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspnetworkinterface iface  interfacesnextelement()&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspif( !ifaceisup() )&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspcontinue&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspenumeration&ltinetaddress> ifaceaddresses  ifacegetinetaddresses()&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspwhile(ifaceaddresseshasmoreelements()) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspinetaddress ip  ifaceaddressesnextelement()&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspsystemoutprintln(touristring(ip))&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp}&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp}<b>2</b><b>3</b><b>what is the expected output? what do you see instead?</b>expected: [2001 700 0 1:44]see: [2001 700 0 1:44%2]<b>what version of the product are you using? on what operating system?</b>r09 trunk have the same issue<b>please provide any additional information below</b>fix attached; recent changes to that class may fix this if not please reopen with additional details--- ;;;;0;1;;
646;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;640 warns user to upgrade if java 8 version is to low;640 warns user to upgrade if java 8 version is to low.  also took the opportunity to log other platform details if mock class cannot be created.;;0;add boolean support to render() function;; ;;;;1;1;add boolean support to render() function;
646;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;640 warns user to upgrade if java 8 version is to low;640 warns user to upgrade if java 8 version is to low.  also took the opportunity to log other platform details if mock class cannot be created.;;0;operator boforeachfuture;issue #634i tried to find a random place in bo but it is likely this or the other prs will not merge one after another;#578  in rxnet it had clean design with `task` and `async/await` in java we dont this (and other similar pull requests) dont make much sense and are greatly complicating the apiin java the `future`/`futuretask`/`callable`/`runnable`/`completablefuture` set of classes do not play well with the non-blocking/reactive style of rx nor is there good conformity across jvm languages (scala groovy clojure with different concurrency models and libraries) or even java libraries (such as guava and akka)i think that all of these additions you are proposing related to `javautilconcurrent` interop should be pushed into a separate contrib module and not part of core perhaps `rxjava-contrib/rxjava-java-future` or something along those lines?in short the goal is to keep rxjava-core focused on the basics of `observable` and non-blocking operators interop with the various different approaches to concurrency should be kept separate in retrospect even the `asyncjava` stuff should likely be moved out to this new contrib module  || yes a contrib module would be much cleaner || great im glad we agree ill setup the module for you || merge these into  instead ||;;;;0;1;;
646;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;640 warns user to upgrade if java 8 version is to low;640 warns user to upgrade if java 8 version is to low.  also took the opportunity to log other platform details if mock class cannot be created.;;640.0;640 warns user to upgrade if java 8 version is to low;640 warns user to upgrade if java 8 version is to lowalso took the opportunity to log other platform details if mock class cannot be created;"before merging not that automatic release system will release a 210rc2 ||   646   some test for platform would be nice especially too see if the version number extraction works with all known formats eg : - feature -> 180-b24- maintainance -> 141_05-ea-b01- update -> 140_03-b04  140_03-ea-b01 does it work for other jvms like jrockit j9 or excelsior jet? || ok thanks for feedback ill update the code accordingly || beautiful!!! we can push and generate new rc or use the magic incantation in the commit message to prevent release and stack this change to next rc (if there is need for yet another rc) || @christianschwarz we dont care about those as we dont have report on those only oracle / openjdk although i dont know about their version scheme- bea (now oracle) jrockit > discontinued last version is java 6 and oracle migrated features in oracle jdk- ibm j9- excelsior jet - azul zing > ?- azul zulu > based on openjdk || @bric3 what i wanted to say was: the update version mechanism should be aware of version schemes other than the expected  the current implementation throws an indexoutofboundsexception if the jvm_version is eg  ""180b5_u44"" or an numberformatexception if the jvm_version is ""140_03-ea-b01""  || @christianschwarz fantastic review  @christianschwarz yes no problem that was a valuable input i didnt want these exceptions to be thrown !i updated the test case and i did some research as well for future cases like this || wow really nice tests!!   this  ";improve exception message to hint at upgrading java minor version to latest;driven by #636;can be closed ||;1;0;640 warns user to upgrade if java 8 version is below update 45;
647;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;a small fix on mockito javadocs. adding some styling and an anchor to section 12.;better now  right @timvdlippe?;;0;add method to `itera{bletor}s` to transform and concat in one go;j@ quite often i see myself using `iterablesconcat`&nbspand `iterablestransform`&nbspin tandem say to collect all orders of some customers (due to an exemplary business logic reason) also known as `flatmap`&nbspin fpside note: we dont import guavas methods statically (basically because of the ambiguity of `filter`/`partition`/`reverse`/`transform`&nbspfrom `iterables`/`iterators`/`lists`) so the class name prefixes do accumulate some cruftunoptimized implementation:&nbsp&nbsppublic static &ltf t> iterable&ltt> transformandconcat(iterable&ltf> fromiterable&nbsp&nbsp&nbsp&nbsp&nbsp&nbspfunction<? super f ? extends iterable&ltt>> function) {&nbsp&nbsp&nbsp&nbspreturn concat(transform(fromiterable function))&nbsp&nbsp}regarding its name i trust on your experience and yes ""_and_"" screams for violation of the single responsibility principle (a method is an object too isnt it) but then again its a common shortcut"; its fine with me if users who do this often make their own helper method to do it i dont want to start down this road in guava--- ;;;;0;1;;
647;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;a small fix on mockito javadocs. adding some styling and an anchor to section 12.;better now  right @timvdlippe?;;0;a small fix on mockito javadocs adding some styling and an anchor to section 12;better now right @timvdlippe?;    yes thanks a lot! || merge to master? || @szczepiq we will merge `release/2x` to `master` from time to time ||;;;;1;1;a small fix on mockito javadocs adding some styling and an anchor to section 12;
647;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;a small fix on mockito javadocs. adding some styling and an anchor to section 12.;better now  right @timvdlippe?;;0;implement partition pruning for the native store;pruning similar to hive partition pruning; merged as 0ac6bd22548004873d2db6fd23946211f51aaaea ||;;;;0;1;;
647;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;a small fix on mockito javadocs. adding some styling and an anchor to section 12.;better now  right @timvdlippe?;;0;operation generate + timed;issue #49i hope the `func1<tstate long> timeunit` will sufficei kept the absolute time variant in the `operationgenerate` and in tests but havent exposed them in `observable`;#581  as per @headinthebox this is really only used in demos and super complicated and thus should not be added to rxjava anything that can be done via `generate` should instead be done inside `observablecreate(onsubscribefunc f)` optionally with a `scheduler ||;;;;0;1;;
648;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;partly implemented #647;added the possibility to copy the preview panel text. not exactly what is requested in #647  but probably quite useful.  note that the key binding is not working (nor is the print preview key working) so i ll open an issue for that.;;0;minor filebackedoutputstream(int filethreshold) constructor javadoc issue; a minor javadoc comment mistake on the javadoc of filebackedoutputstream(int filethreshold)quote: ""equivalent to thresholdoutputstream(filethreshold false)""should read ""equivalent to filebackedoutputstream(filethreshold false)""see  seems the filebackedoutputstream class started life with a different name"; this will be  in the next release--- ;;;;0;1;;
648;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;partly implemented #647;added the possibility to copy the preview panel text. not exactly what is requested in #647  but probably quite useful.  note that the key binding is not working (nor is the print preview key working) so i ll open an issue for that.;;0;added inlinebytebuddymockmaker which uses the instrumentation api for redefining classes and inlining the mocking logic;inline mocks allow for creating mocks of final types and final methods within any type the inline mock engine also makes the mocking type invisible such that `mock(fooclass)getclass()  fooclass` exceptions need to be made for abstract types and for types with serialization requirements where final methods are still instrumented but where a subclass needs to be created nevertheless there are however few limitations of the inline mock engine that do not apply for the subclass mock engine:1 it is no longer possible to mock `native` methods which do not provide any byte code that can be manipulated2 synchronized methods remain synchronized as the instrumentation api does not allow the changing of modifiersthe final mock engine is activated just like any other custom mock engine by placing an indicator file into the root folder to make this more convenient an alias mechanism was added where the mock type name can be referenced by _inline_;"  ([i wrote here why]( looks like the saga will have a happy end after all :)before it gets merged id like to:-  review the pr-  update the docs a bit and push to the branch  eta next 12 hourspsadding new dependency is a breaking change || i want to write some more tests later today to increase coverage and better understand the feature eta this afternoon || good catch @timvdlippe i built this as a feature something along the lines of ""great if we can also mock super method calls"" but this is not a great default as you cannot call an overridden method outside of a class we should still consider it once we add this to the mockito dsl something like: `withfinals()` or `withsupercalls()` now i think you meant to assert the value being `""foo""` not `""bar""` || great work!!!questions:1 given that were using instrumentation does it open possibilities to mock the unmockable (like static methods)?2 what is the direction of this change? do we want to make it a default behavior or an opt-in / per mock / per project configuration?feedback:1 i didnt get to the review yet will do later today2 i would like to document better what is the direction of this change and what we expect from the users later today :)3 i think its ok to wait few more days and complete reviews tweaks etc || updated steps to get 210 final out at #642 || hi @szczepiq yes i absolutely think about mocking static methods at some point however i would like to avoid mocking them globally instead i would rather mock static calls from within a mock (i think this is the general use case)my plan is to enable something like the following construct at some point:``` javaclass foo {  string foo() { return ""foo"" + barvalue() }}class bar {  static string value() { return ""bar"" }}foo foo  spy(new foo())doreturn(""qux"")when(foo)callsstatic(barclass)value()assertthat(foofoo() is(""fooqux""))```similarly i would like to add support for mocking constructors which are however more difficult to integrate with the dslwhat i would like to do is to refine `foo` to replace all static callsites within the class with `invokedynamic` instructions such that calls that  by this particular mock instance are treated as stubs what i want to avoid is some form of _global_ stubbing of `bar::value` but only instrument calls from within the mock instanceas for the direction i think we should make this feature either the default once we collected sufficient feedback or to make it the default for final and non-visible types which could not be mocked otherwise also we might want to add a dsl feature such as:``` javafoo foo  mock(fooclass withsettings()mocktype(mocktypeinline))```the big drawback of inline mocks is that this approach does not allow to instrument native methods and it is not possible to strip synchronized keywords from methods so there is still a reason to use subclass-type mocks || fyi: i do not think the coverage reports are rerun upon updating the pr locally the coverage is much higher now || @raphw it actually updates since my new commits did trigger a new coverage report however codecov is currently down it seems || code coverage is pretty decent now and i think this feature is fairly stable therefore  lgtm however imho it would be good to have another rc before releasing the final version (more feedback could be useful) in general very nice feature @raphwregarding being a breaking change i agree with @szczepiq that adding a new dependency (**in general**) can **in some very specific circumstances** behave like a breaking change lets assume that a client application uses foolib 100 directly (in addition to mockito 560) after upgrading mockito  to 561 or 570 providing foolib 200 (as a transitive dependency) the foolib version used by gradle will be 200 the client application can have compilation issues or even worse work incorrectly due to incompatible changes between foolib 100 and 200 usually it will not happen but there is a potential risk || @szpak this pr does not change the versionproperties so it will trigger another rc absolutely new rc is needed || i didnt get to this today either i will do it tomorrow and if not dont wait for me and ship this baby! (eg new rc :d) || @szczepiq you raced me to javadoc i was gonna commit a lighter version ill inlcude your change then  ) || @bric3 my pleasure :) || fyi: for extra dependencies theres also a ""runtime check"" approach code checks the presence of required dependency at runtime and informs the user that he needs to add extra dependencies onto the classpath not pushing for this only mentioning for completeness || classes of the additional dependency are only attempted to be loaded if the new optional mock maker is used there is no scenario where an application has worked with rc1 but would fail with these changes as the additional dependency is part of byte buddy and since byte buddy agent has never introduced binary incompatible changes there is no risk in implicit upgrades eitheris this good to merge by this? || > is this good to merge by this?yesthanks so much!!!the final mocks journey does not end here there are many interesting features we can built on top of it :) also we want to implement #657 || great let us merge this then and get out another rc once we collected feedback we make the mock maker available via the mockito api || after my lecture has finished i can push out a new one :) || merge it @raphw ) || hurray! || hi after adding the file src/test/resources/mockito-extensions/orgmockitopluginsmockmaker with text: mock-maker-inline the tests stop runnings from command line (""/gradlew testdebugunittest” and “/gradlew connecteddebugandroidtest"" any suggestions? || the inline mock maker does not work on android || can we print a proper warning in this case? || its already part of the stack trace but probably barried one or two ticks down in the stack || > the inline mock maker does not work on androidany update on this? || there are some efforts by alternative byte code providers to offer such functionaltity:  || ";;;;1;1; test case that assumed specific error message;
648;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;partly implemented #647;added the possibility to copy the preview panel text. not exactly what is requested in #647  but probably quite useful.  note that the key binding is not working (nor is the print preview key working) so i ll open an issue for that.;;0;fix drop alias precondition checks;; merged as 414c899f327f6759760253a6d16274000932fa81 ||;;;;0;1;;
648;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;partly implemented #647;added the possibility to copy the preview panel text. not exactly what is requested in #647  but probably quite useful.  note that the key binding is not working (nor is the print preview key working) so i ll open an issue for that.;;0;reentrant scheduling2;revised version of pr #643- added `schedulerunnable()` overloads to `scheduler` directly to avoid constant wrapping between `runnable` and `action0`- removed the helper interface- reworked `reentrantscheduler` to work with a parent scheduler directly- replaced `forwardsubscription` with `incrementalsubscription` as the first one didnt correctly managed the orderly nature of swapping subscriptions: an unfortunate thread scheduling could have swapped in an older subscription before a new subscriptionin my opinion the `scheduler` and its implementations should use `runnable` as the internal unit of work instead of `action0` since the `executor`s require `runnable` anyway less wrapping means less memory and better performance the `scheduler` interface can retain the `action0` overloads but no other implementation should need to deal with them;"#582  this seems like its a bug inside current schedulers as recursion should work without memory leaks here is the histogram showing the leak:```jvm version is 2445-b08iterating over heap this may take a whileobject histogram:num       #instances    #bytes  class description--------------------------------------------------------------------------1:      1488649 83360752    javalangobject2:      2976652 47626432    javautilconcurrentatomicatomicreference3:      1488325 47626400    rxschedulersdiscardableaction4:      1488324 47626368    javautilconcurrentfuturetask5:      1488330 35719920    javautilarraylist6:      1488324 35719776    rxsubscriptionscompositesubscription$state7:      1488456 23815296    javalanginteger8:      1488326 23813216    javautilconcurrentatomicatomicboolean9:      1488326 23813216    rxoperatorssafeobservablesubscription10:     1488325 23813200    rxsubscriptionscompositesubscription11:     1488324 23813184    rxsubscriptionssubscriptions$312:     7036    905920  * methodklass13:     7036    813896  * constmethodklass14:     499 567648  * constantpoolklass15:     499 348832  * instanceklassklass16:     447 339168  * constantpoolcacheklass17:     2051    148592  char18:     702 106856  byte19:     569 68872   javalangclass20:     830 52568   * system objarray21:     2027    48648   javalangstring22:     769 44128   short23:     124 40800   * methoddataklass24:     785 31400   javautiltreemap$entry25:     53  28408   * objarrayklassklass26:     138 9936    javalangreflectfield27:     218 6976    javautilconcurrentconcurrenthashmap$hashentry28:     192 6568    javalangstring29:     138 4416    javautilhashmap$entry30:     8   4288    * typearrayklassklass31:     178 4272    javautillinkedlist$node32:     116 3712    javautilhashtable$entry33:     97  3104    javautillinkedlist34:     193 3088    javalangobject35:     46  2944    javaneturl36:     30  2848    javautilhashmap$entry37:     66  2704    javautilconcurrentconcurrenthashmap$hashentry38:     66  2640    javautilconcurrentconcurrenthashmap$segment39:     72  2304    javautilconcurrentlocksreentrantlock$nonfairsync40:     11  2288    * klassklass41:     38  1824    sunutillocalelocaleobjectcache$cacheentry42:     36  1728    javautilhashmap43:     5   1696    int44:     36  1440    javautillinkedhashmap$entry45:     18  1296    javalangreflectconstructor46:     16  1280    javautilweakhashmap$entry47:     1   1040    javalanginteger48:     26  1040    javalangrefsoftreference49:     6   992 javautilhashtable$entry[]50:     16  896 javautilweakhashmap51:     21  840 javalangreffinalizer```i will dig in to where this leak is occurring we should not need new subscription or scheduler types to solve this otherwise anything using schedulers is broken code in java 6 for proving the leak as modified from the original java 8 bug report:``` java/**     * generates an observable sequence by iterating a state from an initial     * state until the condition returns false     */    public static <tstate r> onsubscribefunc<r> generate(            final tstate initialstate            final func1<tstate boolean> condition            final func1<tstate tstate> iterate            final func1<tstate r> resultselector            final scheduler scheduler) {        return new onsubscribefunc<r>() {            @override            public subscription onsubscribe(final observer<? super r> observer) {                return schedulerschedule(initialstate new func2<scheduler tstate subscription>() {                    @override                    public subscription call(scheduler s tstate state) {                        boolean hasnext                        try {                            hasnext  conditioncall(state)                        } catch (throwable t) {                            observeronerror(t)                            return subscriptionsempty()                        }                        if (hasnext) {                            r result                            try {                                result  resultselectorcall(state)                            } catch (throwable t) {                                observeronerror(t)                                return subscriptionsempty()                            }                            observeronnext(result)                            tstate nextstate                            try {                                nextstate  iteratecall(state)                            } catch (throwable t) {                                observeronerror(t)                                return subscriptionsempty()                            }                            return sschedule(nextstate this)                        }                        observeroncompleted()                        return subscriptionsempty()                    }                })            }        }    }    public static void main(string[] args) throws exception {//        threadsleep(10000)        observable<integer> source  observablecreate(generate(                0 new func1<integer boolean>() {                    @override                    public boolean call(integer t1) {                        return true                    }                }                new func1<integer integer>() {                    @override                    public integer call(integer t) {                        return t + 1                    }                }                new func1<integer integer>() {                    @override                    public integer call(integer t) {                        return t                    }                } schedulersnewthread()))        final countdownlatch latch  new countdownlatch(1)        subscription s  sourcesubscribe(new observer<integer>() {            @override            public void oncompleted() {                latchcountdown()            }            @override            public void onerror(throwable e) {                eprintstacktrace()                latchcountdown()            }            @override            public void onnext(integer v) {                if (v % 100000  0) {                    systemoutprintln(v)                }                if (v > 10000000) {                    latchcountdown()                }            }        })        latchawait()        systemoutprintln(""wait done"")        sunsubscribe()        systemoutprintln(""unsubscribe done"")    }```@headinthebox will try in net || this memory leak is  in  || ";;;;0;1;;
654;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;renamed failuredetecter to failure detector.;also renamed misspelled issussessful() to issuccessful().  fixes: #653.;;0;finding the relationship between two ranges; could you please add methods to check if 2 ranges intersect or are continuous? the current methods provide no convenient way to perform these checksintersects would look like this:public boolean intersects(range&ltc> other) {&nbsp&nbspcut&ltc> intersectionlower  orderingnatural()max(lowerbound otherlowerbound)&nbsp&nbspcut&ltc> intersectionupper  orderingnatural()min(upperbound otherupperbound)&nbsp&nbspreturn intersectionlowercompareto(intersectionupper) < 0}iscontinuous would look like this:public boolean iscontinuous(range&ltc> other) {&nbsp&nbspreturn upperboundequals(otherlowerbound)}; marking as --- ;;;;0;1;;
654;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;renamed failuredetecter to failure detector.;also renamed misspelled issussessful() to issuccessful().  fixes: #653.;;0;add show schemas function;;;;;;1;1;add show schemas function;
654;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;renamed failuredetecter to failure detector.;also renamed misspelled issussessful() to issuccessful().  fixes: #653.;;0;empty error and never overloads with type witness;witness variants for #653;#587  is it necessary to have such overloads? i just think its weird that passing an unused var || i think this witness trick is common in c# but ive never seen it in java so i would not add these overloads || it depends on how many times you write the following pattern:``` javaimport static rxobservable*concat(from(123) empty()) // incompatible types object vs integer in java < 8concat(from(123) empty(4))concat(from(123) observable<integer>empty())merge(just(4) error(new exception()) // incompatible types object vs integer in java < 8merge(just(4) error(new exception() 5)merge(just(4) observable<integer>error(new exception())``` || instead of adding overloads everywhere we have the `cast` operator that solves this issue so a user can do either of these:``` javaobservable<string> s  observableempty()cast(stringclass)take(1)observable<string> s  observable<string>empty()take(1)```even if we were to use the witness patter it would be better to take `class<t>` rather than `t` so that we dont have to pass random values in``` javaobservable<string> s  observableempty(stringclass)take(1)```this is equally elegant but requires overloads for all similar use casesin net this is essential because you cannot write the type of an anonymous type (as per @headinthebox ) and this isnt a problem in java ||;;;;0;1;;
654;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;renamed failuredetecter to failure detector.;also renamed misspelled issussessful() to issuccessful().  fixes: #653.;;653.0;renamed failuredetecter to failure detector;also renamed misspelled issussessful() to issuccessful()fixes: #653;    thanks oliver! ||;typos in failuredetecter;`failuredetecter` should be `failuredetector` its method `issussessful()` should probably be `issuccessful()`;pr? :) || check see #654 ||;1;0;renamed failuredetecter to failure detectoralso renamed misspelled issussessful() to issuccessful() added missing new line at the end of failuredetectorfixes: #653;
673;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;removed duplicate test;hello again :p   i originally requested this test to be added in #525 after the underlying problem had been resolved. while browsing the code now  i discovered that it had already been added (as  this probably doesn t need to be tested twice  so i ve removed the duplicate test.;;0;iterable returned from transform fails contains criteria; <b>what steps will reproduce the problem?</b>1 create list of files2 create function&ltfile string> that returns file name3 execute liststransform on list of files using function4 call iterablescontains on transformation using a name (string) that should match<b>what is the expected output? what do you see instead?</b>should return true returns false<b>what version of the product are you using? on what operating system?</b>r09redhat<b>please provide any additional information below</b>it appears that transformingrandomaccesslist does not account for abstractcollections implementation of contains which uses the iterator it appears that the iterator returned from transformingrandomaccesslist is an iterator over the pre-transformation type instead of the post-transformation typethe same is true for transformingsequentiallist as it only overrides listiterator but not iterator; ;;;;0;1;;
673;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;removed duplicate test;hello again :p   i originally requested this test to be added in #525 after the underlying problem had been resolved. while browsing the code now  i discovered that it had already been added (as  this probably doesn t need to be tested twice  so i ve removed the duplicate test.;;0;removed duplicate test;hello again :p i originally requested this test to be added in #525 after the underlying problem had been resolved while browsing the code now i discovered that it had already been added (as  this probably doesnt need to be tested twice so ive removed the duplicate test;  673   lgtm travis failure is unrelated to this removal ||;;;;1;1;removed redundant test turns out this is covered by diamondinheritanceisconfusingmockitotest which had been added already;
673;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;removed duplicate test;hello again :p   i originally requested this test to be added in #525 after the underlying problem had been resolved. while browsing the code now  i discovered that it had already been added (as  this probably doesn t need to be tested twice  so i ve removed the duplicate test.;;0;filter active nodes by node version;;"the names ""implementationtitle"" and ""implementationversion"" seem overly long and are only named that way because the java `package` calls them that how about just ""name"" and ""version""? || ";;;;1;1;filter active nodes by node version;
673;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;removed duplicate test;hello again :p   i originally requested this test to be added in #525 after the underlying problem had been resolved. while browsing the code now  i discovered that it had already been added (as  this probably doesn t need to be tested twice  so i ve removed the duplicate test.;;0;api design review: join;should the `rxjoin` behavior remain inside `rxobservable` or should there be a separate home for this functionality?in short is the utility of join functionality common enough to have on `rxobservable` or should it be on something else such as `rxjoinjoins` or `rxjoinjoinobservable` or `rxobservablesjoinobservable`?/cc @headinthebox and @jhusain;this was moved into a separate module in  ||;;;;0;1;;
683;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove url sanitizer as it is malfunctioning and unclear where needed…;also see #667.  @jabref/developers if someone knows a use case where this is needed and why we can try to reimplement it properly. but this way it really makes no sense imho.;;0;updated release process so that mockito can continuously deliver high quality features;when merged this will produce new version 220 and set release/2x to continuously publish 221 222  as new high quality features and enhancements are merged hurray!highlights:- set next version to 220 (arbitrary number)- reworked the conditional complexity to avoid accidental releases- removed custom release version logic because it does not work (not opposed to this feature just cleaned up the code this feature should be implemented in versiongradle file)  - for the time being custom version can be achieved by using gradle env variable: org_gradle_project_version230 (it looks like magic but it is a real feature from the gradle book )- added basic docs around testing the release process (its way too hard now);"  so i understand why szczepan did it (taking into account that he felt this change as ""needed"")maybe we should clarify the workflow when pr can be merged (eg how long to stay in a case more ""controversial "" changes) but i propose to do it offline || hm i thought i was pretty clear in the corresponding issues what my opinion was nonetheless i will discuss with the others to come to a conclusion and to resolve the disagreement we are currently having || @szczepiq dont forget to delete the topic branch once merged ) || > @szczepiq dont forget to delete the topic branch once merged )thanks for reminder and deleting it! is this a standard practice? || yes it isand anyway git / github allows to revive the branch if this is really neededin `git` a branch is not a really branch its rather a reference that points to a commit since this has been merged theres no reason to keep the _branch reference_ || ";;;;1;1;changed javadoc to trigger different publicationsworkaround to issue #684;
683;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove url sanitizer as it is malfunctioning and unclear where needed…;also see #667.  @jabref/developers if someone knows a use case where this is needed and why we can try to reimplement it properly. but this way it really makes no sense imho.;;0;only print wrap indicator for multiple rows;;;;;;1;1;only print wrap indicator for multiple rows;
683;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove url sanitizer as it is malfunctioning and unclear where needed…;also see #667.  @jabref/developers if someone knows a use case where this is needed and why we can try to reimplement it properly. but this way it really makes no sense imho.;;0;api design review: conditionals;discussion with @headinthebox suggests that the conditional operators really dont belong in rxjava (at least not the core) as they were added to rxnet for very specific use cases in f# these include `ifthen` `switchcase` `dowhile` `whiledo`are there reasons to keep these? if so do we move them out of `observable` or should we delete them?/cc @headinthebox and @jhusain; i dont know of anyone using this for real in rxnet || these could be moved into a `rxjava-contrib/rxjava-dotnet-legacy` package along with those ops that have been added just to match rxnet || these can be used for cep scenarios to reason over multiple streams it is best that they stay in some form or other as java does not have anonymous classes like c# where they could be easily avoided by joining fields into a anonymous class they are more needed in the jvm implementation than in netideally the senarios should be expanded in rxjava || @sirinath can you give a concrete example? i dont see the connection between these operators which are intended to overload imperative control structures in f# computation expressions and anonymous types || if this is extended to accept an observable sequence as the condition / selector then it would be more usefulsay i want to buy using signal a if vol is greater than a certain threshold plus some other computationally expensive conditions and signal b otherwise only if i am trading that instrument for the day and i only trade 05% of instrumentsthe current form is somewhat useful if we want to certain set of signals at start of the day but this is something you can do otherwise eagerly at a cost also it would be useful if the conditional is also an observable sequence as you can select between streams than at subscription using linq you can aggregate multiple items into anonymous class and select what is needed at the end from this in a further query this is more difficult though possible in java than c# hence it will be good to have the conditional functionality extended for other use casesmore powerful it would be if you have linq expressions this is also possible through commons jci or directly using janino perhaps at a later stage || also the conditions or index can be extended to a function to take 1 item from each stream and return the appropriate values (boolean / index) for item selection if not subscribers the condition is not evaluated and if possible each item can be discarded from the streamsthis would be a more convinient way to use this functionality || @sirinath could you provide a concrete example? i am not sure that i understand what you are after precisely || migrating conditionals to a contrib module:  || here is a link to documentation on their usage:  || @headinthebox add an extra overload with func<bool tresult tresult> condition for if and func<tvalue tresult> selector  etcif((a b) -> !aequals(obj1) && bequals(obj2)strm1strm2)this case condition is evaluated as needed but for each element coming in || @headinthebox in a nutshell the extension will help combination and generation something you can consider for the main implementation also ||;;;;0;1;;
693;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanup in logic.mods and logic.msbib;additional change: added method  hasfield  to  bibentry .;;0;filesdeletedirectorycontents() does not work reliably in windows with long usernames and temporary directories; <b>what steps will reproduce the problem?</b>1 create temporary directory with filescreatetempdir()2 write some files into it3 try to remove the temp directory with filesdeleterecursively()<b>what is the expected output? what do you see instead?</b>expected output is that first the temp dir is written into c:\users\longusername\appdata\local\temp then the files are written and after that all written files plus temporary directory is deleted from the system instead none of the files are deleted but an access denied error is shown<b>what version of the product are you using? on what operating system?</b>google guava r09 from maven central repo on windows 7 professional x64<b>please provide any additional information below</b>the bug happens since filesdeletedirectorycontents() thinks to be deleted directory to be behind a symbolic link this is due to the fact that in windows filegetabsolutepath() and filegetcanonicalpath() return different strings if the directory is within users home directory and the windows username is longer than 8 characters this is an unfortunate dos remnant; this method could be implemented properly though in java 7 since they added a bunch of methods into nio for example this specific bug could be resolved by using  said limiting guava to work only in java 7 would be a bad decision maybe in the future but right now well have to handle this situation ourselves || ";;;;0;1;;
693;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanup in logic.mods and logic.msbib;additional change: added method  hasfield  to  bibentry .;;0;improved the format of arguments in verification failures when describing short and byte values;currently the code can print some arguments without necessary casts see  the exception message contained : ```imethodsforbyte(0x19)```which is actually not valid java so the exception message now prints ```imethodsforbyte((byte) 0x19)```this pr intends to fix it this especially affects short and byte values;  693  **< ;;;;1;1;prints necessary casts when decribing verification failure relates to #571;
693;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanup in logic.mods and logic.msbib;additional change: added method  hasfield  to  bibentry .;;0;reduce requests;;looks good aside from comments ||;;;;1;1;wait on server side for out buffers to be createdwhen requesting data from an output buffer that doesnt exist yetwait for the buffer to be created on the server side;
693;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanup in logic.mods and logic.msbib;additional change: added method  hasfield  to  bibentry .;;0;kotlin m62;version updated for kotlin m62;#609  ;;;;1;1;kotlin m62;
698;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;new api: mockingdetails.printinvocations() for debugging mock behavior;for motivation  see issue #543;;0;iterablesunmodifiableiterable() should take iterable<? extends t> as parameter; in javautilcollections the method unmodifiablecollection() takes collection<? extends t> as parametermethod unmodifiableiterable() in comgooglecommoncollectiterables should take iterable<? extends t> instead of iterable&ltt>references //downloadoraclecom/javase/6/docs/api/java/util/collectionshtml#unmodifiablecollection(javautilcollection)http://guava-librariesgooglecodecom/svn/trunk/javadoc/com/google/common/collect/iterableshtml#unmodifiableiterable(javalangiterable); what i didnt realize then is that its actually perfectly consistent with the similar methods in javautilcollections  for list and iterable both you would cast-and-suppress _if you could_!  for iterable you can for list you cant  (and for immutablelist you dont need to -- just copyof()!)there have been so many threads on this subject over the past couple years and id be thankful if anyone is up for finding them and pointing xavier to them but i must get back to trying to release this thing--- ;;;;0;1;;
698;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;new api: mockingdetails.printinvocations() for debugging mock behavior;for motivation  see issue #543;;0;new api: mockingdetailsprintinvocations() for debugging mock behavior;for motivation see issue #543; ;;;;1;1;used assertjupdated to use assertj following really good feedback from brice;
698;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;new api: mockingdetails.printinvocations() for debugging mock behavior;for motivation  see issue #543;;0;fix hangs in failing unit tests;;;;;;1;1;fix hangs in failing unit tests;
698;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;new api: mockingdetails.printinvocations() for debugging mock behavior;for motivation  see issue #543;;0;merge of pull 657: average and sum;;"#615  im not crazy about the naming:average() / averageinteger(f)averagedoubles() / averagedouble(f)averagefloats() / averagefloat(f)averagelongs() / averagelong(f)it doesnt seem to have much rhyme or reason to it why are the versionsthat take functions singular and the versions that dont are plural (eg""long"" vs ""longs"")? why is the function paired up with averageinteger(f)just called average() instead of averageintegers() when all the otherfunctions follow that pattern?on fri dec 27 2013 at 1:18 pm cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #615 this pull request looks good> > —> reply to this email directly or view it on github ## david m grossplp consulting || - i wanted to avoid overload problems in other languages and simply named the ops differently- i wondered why `average()` didnt include the type in the name is it more common to average a stream of ints?- i wondered why the originals where plurals in the first place || > i wanted to avoid overload problems in other languages and simply named the ops differentlythis is actually a problem with type-erasure not the language interopthis code ``` javapublic static observable<integer> average(observable<integer> source) {        return operationaverageaverage(source)}public static observable<double> average(observable<double> source) {        return operationaverageaverage(source)}```results in this error:> method average(observable<integer>) has the same erasure average(observable<t>) as another method in type observable<t> || we can rename the methods doing so now || names standardized here:  || ";;;;1;1;rename to reducetest;
704;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;delayedexecution uses now a more precise approach to call a mock async.;new approach to fix flickering async tests.  detail description  coming soon;;0;r10s optional doesnt work with scala;ebow@ because baseholder is package-protected and because of  using an optional from scala causes an illegalaccesserrorwould you be willing to consider making baseholder public?; oops!  thanks for fixing it ||;;;;0;1;;
704;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;delayedexecution uses now a more precise approach to call a mock async.;new approach to fix flickering async tests.  detail description  coming soon;;0;delayedexecution uses now a more precise approach to call a mock async;new approach to fix flickering async testsdetail description coming soon;"we probably need to restart the builds a couple of times to get again a level of certainty ||   ";;;;1;1;delayedexecution uses now a more precise approach to call a mock async;
704;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;delayedexecution uses now a more precise approach to call a mock async.;new approach to fix flickering async tests.  detail description  coming soon;;0;add missing dependency;;;;;;1;1;add missing dependency;
704;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;delayedexecution uses now a more precise approach to call a mock async.;new approach to fix flickering async tests.  detail description  coming soon;;0;new contrib module: rxjava-async-util;- added startfuture deferfuture foreachfuture operators- left out the cancellationtoken resembling overloads as i was in doubt they can be meaningfully used if a task is cancelled it is enough to check the threadcurrentthread()isinterrupted() flag;"#620  why is this changing 7700+ lines of `observable` and most of `observabletests`? || i dont know maybe a line ending anomaly from your branch? somehow these two classes got transformed into crlf on checkout since i havent touched them ive changed them to lf || #622 this pull request merged the master branch instead of rebasing so has lots of unnecessary and unrelated changes i have created a new pull request after cherry picking just the relevant changes and avoiding the ""merge with master"" artifacts:  || ";;;;0;1;;
705;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixes exception typo;this is a simple correction in an error message that can be thrown by mockito.;;0;"simplifypath(""x///b"") is ""b"" instead of ""/b"""; <b>what steps will reproduce the problem?</b>assertequals(""/b"" filessimplifypath(""x///b""))<b>what is the expected output? what do you see instead?</b>expected: ""/b"" is: ""b""<b>what version of the product are you using? on what operating system?</b>&ltdependency>&nbsp&nbsp&nbsp&nbsp&ltgroupid>comgoogleguava&lt/groupid>&nbsp&nbsp&nbsp&nbsp&ltartifactid>guava&lt/artifactid>&nbsp&nbsp&nbsp&nbsp&ltversion>100-rc1&lt/version>&lt/dependency>"; ;;;;0;1;;
705;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixes exception typo;this is a simple correction in an error message that can be thrown by mockito.;;0;fixes exception typo;this is a simple correction in an error message that can be thrown by mockito;@mgaetan89  can you rename the message commit `minor test fix` does not help when looking at the historysomething like `fixes exception message typo in mockmaker` would do it ||  ;;;;1;1;fixes exception message typo in mockmaker;
705;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixes exception typo;this is a simple correction in an error message that can be thrown by mockito.;;0;add async buffer outputstream for interactive mode;;this needs to be revisited closing for now ||;;;;0;1;;
705;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixes exception typo;this is a simple correction in an error message that can be thrown by mockito.;;0;adjust javadocs for new sumfoo()/averagefoo() method names;;#621 ;;;;1;1;adjust javadocs for new sumfoo()/averagefoo() method names;
711;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;remove global sorting functionality;refs #520   global file sorting options are removed. sort functionality is still available but no localized to every file and the file sorting options are stored in the file.;;0;splittersplit() should return a lazy list not iterable;goo@ current the splitting results from splitter can only be obtained as an iterablewhen the expected number of items are known in advance of in an other case where you do not want to iterate over it a list is more convenienta method list&ltstring> list(charsequence sequence) would be very convenient in this caseof course i can use listsnewarraylist() but that adds a lot of clutter; ;;;;0;1;;
711;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;remove global sorting functionality;refs #520   global file sorting options are removed. sort functionality is still available but no localized to every file and the file sorting options are stored in the file.;;0;add set/getconf to forwardingfilesystem;;;;;;0;1;;
711;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;remove global sorting functionality;refs #520   global file sorting options are removed. sort functionality is still available but no localized to every file and the file sorting options are stored in the file.;;0;recursion on executorservice with >1 thread is slow;recursion on newthreadscheduler or executorscheduler with 1 thread is fast as number of threads increase in the pool it increasingly slows down my guess is its adding overhead jumping between threads and/or cpus and thus having cache misses or something along those linesi found this while testing `testrecursionmemoryusage` and trying `schedulersthreadpoolforcomputation()` versus `schedulersnewthread()`i confirmed that this changes the performance: `executorsnewscheduledthreadpool(2)` vs `executorsnewscheduledthreadpool(1)`the real code uses numcores for that value which is worsewe need to look at a way of using a thread-pool sized to the number of threads on the machine so were not launching new threads every time a scheduler is used but that recursion efficiently uses the same thread;removed `executorscheduler` and replaced with `computationscheduler` that has a pool of event loops:  ||;;;;0;1;;
711;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;remove global sorting functionality;refs #520   global file sorting options are removed. sort functionality is still available but no localized to every file and the file sorting options are stored in the file.;;707.0;707 adds throwable to arity answers also improved javadoc;all in the title this should 707;lgtm restarted the build that was failing on an unrelated test ||  ;improve usability of arity answers with regards to checked exceptions;recently introduced answer1 style answers dont declare throwable they should! otherwise the user is forced to add boilerplate code to answerx implementations whenever they use methods that declare checked exceptions plus answerx should behave exactly as good old answer interface!reported via the [mailing-list](https://groupsgooglecom/d/msgid/mockito/82d08ba9-5536-495e-90db-78c1062b6400%40googlegroupscom);given how answer is supposed to be used it is a safe change to do plus it is marked as @incubating :) ||;1;0;707 adds throwable to arity answers also improved javadoc;
719;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;verification listeners;i had the need to be notified when ever a verification happens  this pr implements this.  to do anything useful with this notification the following data is important: - the mock that we are verifying on. - the verification mode we are using. - and what method we wish to verify.  the one place where this data is collectable is in mockawareverificationmode.  what remains is to get the listeners there so we are able to notify them.  the tests i added try to follow those of the invocation listeners  however there might be more cases that are important that i m unaware of.;;0;javalangnosuchmethoderror; use r09 guavaexample:string teststring  ""wbqy1n04  1y""&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp//iterable&ltstring> s  splitteron("""")split(teststring)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspiterable&ltstring> s  splitteron("""")omitemptystrings()trimresults()split(teststring)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspfor (string string : s) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspsystemoutprintln(""["" + string)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp}show follow error  comgooglecommonbaseplatformprecomputecharmatcher(lcom/google/common/base/charmatcher)lcom/google/common/base/charmatcher"; maybe you should use a newest version of guava || > cgdecker** on 2011-09-22 at 04:27 pm_> > you probably have a google-collections jar on your classpath as well as guava make sure to remove thatwould give this +10 if i could || ";;;;0;1;;
719;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;verification listeners;i had the need to be notified when ever a verification happens  this pr implements this.  to do anything useful with this notification the following data is important: - the mock that we are verifying on. - the verification mode we are using. - and what method we wish to verify.  the one place where this data is collectable is in mockawareverificationmode.  what remains is to get the listeners there so we are able to notify them.  the tests i added try to follow those of the invocation listeners  however there might be more cases that are important that i m unaware of.;;0;verification listeners;i had the need to be notified when ever a verification happens this pr implements thisto do anything useful with this notification the following data is important:- the mock that we are verifying on- the verification mode we are using- and what method we wish to verifythe one place where this data is collectable is in mockawareverificationmodewhat remains is to get the listeners there so we are able to notify themthe tests i added try to follow those of the invocation listeners however there might be more cases that are important that im unaware of;"  this pr even though the build has failed (per above comment) thanks a lot @liamclark for your time and effort into this pr! || ";;;;1;1;custom condition in verification listener test;
719;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;verification listeners;i had the need to be notified when ever a verification happens  this pr implements this.  to do anything useful with this notification the following data is important: - the mock that we are verifying on. - the verification mode we are using. - and what method we wish to verify.  the one place where this data is collectable is in mockawareverificationmode.  what remains is to get the listeners there so we are able to notify them.  the tests i added try to follow those of the invocation listeners  however there might be more cases that are important that i m unaware of.;;0;use sql types in error messages;; nice ||;;;;1;1;use sql types in error messages;
719;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;verification listeners;i had the need to be notified when ever a verification happens  this pr implements this.  to do anything useful with this notification the following data is important: - the mock that we are verifying on. - the verification mode we are using. - and what method we wish to verify.  the one place where this data is collectable is in mockawareverificationmode.  what remains is to get the listeners there so we are able to notify them.  the tests i added try to follow those of the invocation listeners  however there might be more cases that are important that i m unaware of.;;0;map doesnt work with random numbers;"this may be specific to the scala adapter or a general issue im not sure it may also be simply disallowed somewhere in the documentation but i couldnt find anything mentioning it``` scalaval o  observableinterval(250 millis)        map(x > mathrandom)        take(10)var id  o map(x > x)osubscribe(n > println(""n  "" + n))idsubscribe(n > println(""id  "" + n))```produces```n  016257918600676124id  0015701253635574397n  065811522451999id  06745847570884935n  008592558068181289id  06761688548540207n  01511738754239501id  037751043543314455n  03335425497156287id  02433811198187099```of course we expect the values of the two observables to be equal but they arent related whatsoever";"this behavior is the expected behavior remove the line `var id  ` and replace the line `idsubscribe()` by a second `osubscribe()` and you will see that the two outputs are still different the reason is that everywhere in rx each subscriber gets its own version of the observable it subscribes to so here each subscriber gets its own ""observableinterval"" so `x > mathrandom` is executed seperately for each subscriber if you want several observers to share the same observable you should use the `publish` operator || you have discovered the distinction between ""hot"" and ""cold"" observables and the evil that is side-effects || following up on a previous comment your code should read something like this: ```val (start o)  observableinterval(250 millis) map {x > mathrandom} take 10 publishval id  o map {x > x}start()o subscribe {x > println(s""n  $x"")}id subscribe {x > println(s""id  $x"")}``` || note that we will be changing the scala bindings to use connectableobservable so while this code work now in the future you would write something like so:val observable  observableinterval(250 millis)map(x > mathrandom)take(10)publishval id  observablemap(x > x)observablesubscribe(x > println(s""n  $x""))idsubscribe(x > println(s""id  $x""))observableconnect || ah gotcha thanks for the clarification! || ";;;;0;1;;
724;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;added new release workflow for release automation;the purpose of this rb is to give you heads-up about the improvements to the release automation that i work on. the algorithm is implemented and will not change much. documentation  edge case unit tests and fixing runnability from gradle are pending (travis ci will fail on this pr).  the goal of the new  release-workflow  plugin is to able to express the release automation in the build.gradle file like that:      groovy releaseworkflow {     step releaseneeded     onlyif { releaseneeded.needed }     step bintrayupload     step pullcommits     step configuregenericgituser  cleanup: restoregituser     step commitreleasenotes  rollback: resetreleasenotes     step tagnewversion  rollback: removenewtag     step bumpversion  rollback: unbumpversion     step pushchanges }      more over  it will be very easy to test out the release locally or even individual release steps:      ./gradlew release -pdryrun ./gradlew pullcommits -psinglestep;;0;compressed bitset; a bitset that compacts present/not-present ranges in into a single bit with an offset mapping this reduces the memory footprint of sparse or dense bitsets in exchange for a small penalty for membership lookup note that this simpler run-length encoding is simpler than more advanced compressed bitset approaches [1] which have different performance trade-offs but assumes immutabilitya rle scheme might work as follows an int array is required for the range markers and a parallel int array for the bit index offset the range array could be binary searched and the index used to lookup the offset this would consume 64-bits giving us a heuristic that uniform ranges greater than 64 can be compacted a slightly higher value might be preferred to reduce the number of ranges since this has o(lg m) lookup complexityan example use-case is inspired from ""programming pearls"" - phone numbers a calling list for telemarketers must be filtered by the do not call listings or risk a hefty fine a bitset per area code would provide an efficient filtering schemefor each area code there are 10m number combinations (10^7) or 12mb the napp assignment rules reduces this to 79m combinations or 10mb sample data [3] indicates that 1m numbers are on the dnc listings per area code in a fairly random distribution we might guess that the rle would reduce this to 200-500kb on average with 275 area codes the total footprint is then reduced from 330mb to 100mb a size small enough to fit in a gae instance (180mb cap)[1]   nanp[3] https://telemarketingdonotcallgov"; were providing a general purpose range set so this seems a bit out of scope--- ;;;;0;1;;
724;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;added new release workflow for release automation;the purpose of this rb is to give you heads-up about the improvements to the release automation that i work on. the algorithm is implemented and will not change much. documentation  edge case unit tests and fixing runnability from gradle are pending (travis ci will fail on this pr).  the goal of the new  release-workflow  plugin is to able to express the release automation in the build.gradle file like that:      groovy releaseworkflow {     step releaseneeded     onlyif { releaseneeded.needed }     step bintrayupload     step pullcommits     step configuregenericgituser  cleanup: restoregituser     step commitreleasenotes  rollback: resetreleasenotes     step tagnewversion  rollback: removenewtag     step bumpversion  rollback: unbumpversion     step pushchanges }      more over  it will be very easy to test out the release locally or even individual release steps:      ./gradlew release -pdryrun ./gradlew pullcommits -psinglestep;;0;added new release workflow for release automation;the purpose of this rb is to give you heads-up about the improvements to the release automation that i work on the algorithm is implemented and will not change much documentation edge case unit tests and fixing runnability from gradle are pending (travis ci will fail on this pr)the goal of the new release-workflow plugin is to able to express the release automation in the buildgradle file like that:``` groovyreleaseworkflow {    step releaseneeded    onlyif { releaseneededneeded }    step bintrayupload    step pullcommits    step configuregenericgituser cleanup: restoregituser    step commitreleasenotes rollback: resetreleasenotes    step tagnewversion rollback: removenewtag    step bumpversion rollback: unbumpversion    step pushchanges}```more over it will be very easy to test out the release locally or even individual release steps:```/gradlew release -pdryrun/gradlew pullcommits -psinglestep```;  release/2x in the branch this keep history a bit cleaner in branches || thanks for the tip @bric3! i assumed that rebase would be tricky given that i have already pushed the branch to github (eg changing history of already-pushed code)next time i will do the rebase || @szczepiq already pushing does not limit you from rebasing it results in a lot cleaner prs || yep github handles flawlessly push forced comment on a branch ||;;;;1;1;merge branch release/2x into release-workflow;
724;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;added new release workflow for release automation;the purpose of this rb is to give you heads-up about the improvements to the release automation that i work on. the algorithm is implemented and will not change much. documentation  edge case unit tests and fixing runnability from gradle are pending (travis ci will fail on this pr).  the goal of the new  release-workflow  plugin is to able to express the release automation in the build.gradle file like that:      groovy releaseworkflow {     step releaseneeded     onlyif { releaseneeded.needed }     step bintrayupload     step pullcommits     step configuregenericgituser  cleanup: restoregituser     step commitreleasenotes  rollback: resetreleasenotes     step tagnewversion  rollback: removenewtag     step bumpversion  rollback: unbumpversion     step pushchanges }      more over  it will be very easy to test out the release locally or even individual release steps:      ./gradlew release -pdryrun ./gradlew pullcommits -psinglestep;;0;update docs for show partitions;;;;;;0;1;;
724;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;added new release workflow for release automation;the purpose of this rb is to give you heads-up about the improvements to the release automation that i work on. the algorithm is implemented and will not change much. documentation  edge case unit tests and fixing runnability from gradle are pending (travis ci will fail on this pr).  the goal of the new  release-workflow  plugin is to able to express the release automation in the build.gradle file like that:      groovy releaseworkflow {     step releaseneeded     onlyif { releaseneeded.needed }     step bintrayupload     step pullcommits     step configuregenericgituser  cleanup: restoregituser     step commitreleasenotes  rollback: resetreleasenotes     step tagnewversion  rollback: removenewtag     step bumpversion  rollback: unbumpversion     step pushchanges }      more over  it will be very easy to test out the release locally or even individual release steps:      ./gradlew release -pdryrun ./gradlew pullcommits -psinglestep;;0;revert use of currentthreadscheduler for observablefrom;use immediatescheduler as performance is 4x faster and currentthreadscheduler currently offers no benefit (it doesn’t solve the unsubscribe problem)performance numbers:``` * observablefrom(arraysaslist(1l 2l 3l 4l 5l 6l 7l 8l 9l 10l) scheduler) * * --- schedulersimmediate() --- * * run: 0 - 1849947 ops/sec * run: 1 - 2076067 ops/sec * run: 2 - 2114688 ops/sec * run: 3 - 2114301 ops/sec * run: 4 - 2102543 ops/sec * * --- schedulerscurrentthread() --- * * run: 0 - 548862 ops/sec * run: 1 - 559955 ops/sec * run: 2 - 581412 ops/sec * run: 3 - 562187 ops/sec * run: 4 - 565723 ops/sec * observablefrom(arraysaslist(1l) scheduler) * * --- schedulersimmediate() --- * * run: 10 - 4113672 ops/sec * run: 11 - 4068351 ops/sec * run: 12 - 4070318 ops/sec * run: 13 - 4161793 ops/sec * run: 14 - 4156725 ops/sec * * --- schedulerscurrentthread() --- * * run: 10 - 1692286 ops/sec * run: 11 - 1765054 ops/sec * run: 12 - 1763100 ops/sec * run: 13 - 1770907 ops/sec * run: 14 - 1732291 ops/sec```;#639];;;;1;1;revert use of currentthreadscheduler for observablefromuse immediatescheduler as performance is 4x faster and currentthreadscheduler currently offers no benefit (it doesn’t solve the unsubscribe problem)performance numbers:     * observablefrom(arraysaslist(1l 2l 3l 4l 5l 6l 7l 8l 9l 10l) scheduler)     *     * --- schedulersimmediate() ---     *     * run: 0 - 1849947 ops/sec     * run: 1 - 2076067 ops/sec     * run: 2 - 2114688 ops/sec     * run: 3 - 2114301 ops/sec     * run: 4 - 2102543 ops/sec     *     * --- schedulerscurrentthread() ---     *     * run: 0 - 548862 ops/sec     * run: 1 - 559955 ops/sec     * run: 2 - 581412 ops/sec     * run: 3 - 562187 ops/sec     * run: 4 - 565723 ops/sec     * observablefrom(arraysaslist(1l) scheduler)     *     * --- schedulersimmediate() ---     *     * run: 10 - 4113672 ops/sec     * run: 11 - 4068351 ops/sec     * run: 12 - 4070318 ops/sec     * run: 13 - 4161793 ops/sec     * run: 14 - 4156725 ops/sec     *     * --- schedulerscurrentthread() ---     *     * run: 10 - 1692286 ops/sec     * run: 11 - 1765054 ops/sec     * run: 12 - 1763100 ops/sec     * run: 13 - 1770907 ops/sec     * run: 14 - 1732291 ops/sec;
734;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;new nullable(class<t>) matcher for convenient matching of nullable arguments;after using mockito  i have found that the new behaviors of matcher are good and indeed show problems in the test code or in the production code. however i have found that i miss an easy way to express a matcher for  nullable  argument when the production code may produce either  null  or value types  typically  stream.of(<mixed values>).map(o -> mapper.map(c))   the current options are :;;0;implement isabsent() on optional; in the source code to the optional datatype in revision 100 there is a //todo for adding a isabsent method call to the implementations please can this be implemented as i believe it conveys the intent better ie if(referenceisabsent()) {&nbsp&nbsp// do something}is clearer (and easier to maintain and less bug prone than):if(!referenceispresent()) {&nbsp&nbsp// do something}it is quite easy to forget to add in the ! conditionthank you-david-; we dont feel this is a clear enough advantage--- ;;;;0;1;;
734;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;new nullable(class<t>) matcher for convenient matching of nullable arguments;after using mockito  i have found that the new behaviors of matcher are good and indeed show problems in the test code or in the production code. however i have found that i miss an easy way to express a matcher for  nullable  argument when the production code may produce either  null  or value types  typically  stream.of(<mixed values>).map(o -> mapper.map(c))   the current options are :;;0;new nullable(class<t>) matcher for convenient matching of nullable arguments;after using mockito i have found that the new behaviors of matcher are good and indeed show problems in the test code or in the production code however i have found that i miss an easy way to express a matcher for `nullable` argument when the production code may produce either `null` or value types typically `streamof(<mixed values>)map(o -> mappermap(c))` the current options are :* `<t> t any()` is nice but dont check the type* theres always `additionalmatchersor()` but this feel more heavy to useim proposing the introduction of the argument matcher `<t> nullable(class<t>)` which is a combination of `isa` and `isnull` im not adding `<t> t nullable()` because this would have the same meaning as `<t> t any()`;  734  **< ;;;;1;1;introduces argumentmatchersnullable(t);
734;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;new nullable(class<t>) matcher for convenient matching of nullable arguments;after using mockito  i have found that the new behaviors of matcher are good and indeed show problems in the test code or in the production code. however i have found that i miss an easy way to express a matcher for  nullable  argument when the production code may produce either  null  or value types  typically  stream.of(<mixed values>).map(o -> mapper.map(c))   the current options are :;;0;add benchmark for sql join queries with predicates on the join clause;;;;;;1;1;add benchmark for sql join queries with predicates on the join clause;
734;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;new nullable(class<t>) matcher for convenient matching of nullable arguments;after using mockito  i have found that the new behaviors of matcher are good and indeed show problems in the test code or in the production code. however i have found that i miss an easy way to express a matcher for  nullable  argument when the production code may produce either  null  or value types  typically  stream.of(<mixed values>).map(o -> mapper.map(c))   the current options are :;;653.0;delay with subscription and item delaying observables;listed in #653note: onerror and oncompleted events of the source are immediately propagated and will prevent emitting any pending values;#648  #660;more operators/overloads;rxnet 222-  ~~aggregate (pr #657)~~  - `aggregate(seed accumulator resultselector)`-  average (pr #657 m)  -  `average(func1<t number> valueselector)`-  buffer (pr #733)  - `buffer(observable<u> bufferboundaries)`-  ~~create async~~  - ~~`create(func1<observer<r> task>)`~~  - ~~`create(func1<observer<r> task<action>>)`~~  - ~~`create(func1<observer<r> task<idisposable>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<action>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<idisposable>>)`~~-  delay (pr #734)  - `delay(func1<t observable<tdelay>>)`  - `delay(func0<observable<d1>> subscriptiondelay func1<t observable<d2>> itemdelay)`-  ~~empty (pr #654)~~  - ~~`empty(t witness)`~~  - ~~`empty(scheduler t witness)`~~-  ~~never (pr #654)~~  - ~~`never(t witness)`~~-  publish (pr #738)  - `publish(func1<observable<tsource> observable<tresult>> sel)`  - `publish(tsource initialvalue)`  - `publish(func1<observable<tsource> observable<tresult>> sel tsource initialvalue)`-  publishlast (pr #738)  - `publishlast(func1<observable<tsource> observable<tresult>> sel)`-  selectmany (flatmap) (pr #736)  - `selectmany(func1<t observable<u>> collection func2<t u r> resultsel)`  - `selectmany(func1<t observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`  - `selectmany(func1<t ienumerable<r>>)`  - `selectmany(func2<t ienumerable<u>> func2<t u r>)`  - ~~----------------------------------~~  - ~~`selectmany(func2<t integer observable<r>>)`~~  - ~~`selectmany(func1<t task<r>>)`~~  - ~~`selectmany(func2<t integer task<r>>)`~~  - ~~`selectmany(func2<t cancellationtoken task<r>>)`~~  - ~~`selectmany(func3<t integer cancellationtokenk task<r>>)`~~  - ~~`selectmany(func1<t integer observable<u>> collection func4<t integer  u integr r> resultsel)`~~  - ~~`selectmany(func1<t task<u>> func2<t u r>)`~~  - ~~`selectmany(func2<t integer task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t ct task<u>> func2<t u r>)`~~  - ~~`selectmany(func3<t integer ct task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t integer observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`~~  - ~~`selectmany(func2<t integer ienumerable<r>>)`~~  - ~~`selectmany(func3<t integer ienumerable<u>> func4<t integer u integer r>)`~~- [x] skip (pr #655 m)  - `skip(timespan)`  - `skip(timespan scheduler)`- [x] skiplast  (pr #655 m)  - `skiplast(timespan)`  - `skiplast(timespan scheduler)`- [x] sum (pr #657 m)  - `sum(func1<t number> valueselector)`- [x] take  (pr #655 m)  - `take(timespan)`  - `take(timespan scheduler)`- [x] takelast  (pr #655 m)  - `takelast(timespan)`  - `takelast(timespan scheduler)`  - `takelast(timespan scheduler duration scheduler drain)`- [x] throttle (debounce) (pr #739)  - `throttle(func1<t observable<void>>)`- [x] timeout (pr #740)  - `timeout(func1<t observable<void>>)`  - `timeout(func1<t observable<void>> observable<t> other)`  - `timeout(func0<observable<void>> func1<t observable<void>>)`  - `timeout(func0<observable<void>> func1<t observable<void>> observable<t> other)`- [x] ~~throw (error) (pr #654)~~  - ~~`error(throwable t t witness)`~~  - ~~`error(throwable t scheduler t witness)`~~- [x] ~~using async~~  - ~~`using(func1<cancellationtoken task<tresource>> func2<tresource cancellationtoken task<observable<t>>>)`~~- [x] ~~where~~  - ~~`where(func2<t integer boolean>)`~~- [x] window (pr #735)  - `window(observable<u> windowboundaries)`- [x] zip (pr #741)  - ~~`zip(ienumerable<observable<s>> sources func1<ilist<s> r> selector)`~~ (already have with funcn)  - `zip(iterable<u> other func2<t u r> result)` (instance method)  - `zip(observable<u> other func2<t u r> result)` (instance method)potential java specific operators/overloads:-  `just(func0<r> factory)` return the value of the factory for the subscriber- [x] ~~`lock(lock lock)` or `synchronize(lock lock)` to support juclocks for synchronization~~- [x] ~~using with javaiocloseable~~  - ~~`using(func0<c> func1<c observable<t>>)`~~  - ~~`usingfuture(func1<booleansubscription future<c>> func2<c booleansubscription future<observable<t>>>)`~~;reviewed by @headinthebox and i for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on || > lock(lock lock) or synchronize(lock lock) to support juclocks for synchronizationwhat is a use case when this would ever be needed? @headinthebox mentioned that its not really used in rxnet so likely not worth us adding  || okay no worries i wont start working on the remaining ones for at least a week || closing this and ignoring `just(func0<r> factory)` ||;1;0;modified to conform rxnet;
735;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improved tests and added a few more;;;0;supplierssupplierfunction should return function<supplier<? extends t> t>; the supplierfunction can safely handle any supplier of type ? extends t so supplierssupplierfunction should really return function&ltsupplier<? extends t> t>  at least i cant think of why you wouldnt; while as stated your signature would be more technically correct i dont think the benefit is clear enough for us to make a change now--- ;;;;0;1;;
735;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improved tests and added a few more;;;0;exposed existing verification api so that it no longer leaks internal api;see motivation and plan in #730;friendly ping || why not reopening #728  what is the difference here it seems to be the same branch ||  ;;;;1;1;cosmetics based on feedback;
735;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improved tests and added a few more;;;0;upgrade to airlift 079-snapshot;;;;;;1;1;upgrade to airlift 079-snapshot;
735;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improved tests and added a few more;;;653.0;window with observable boundary;listed in issue #653;#649 ;more operators/overloads;rxnet 222-  ~~aggregate (pr #657)~~  - `aggregate(seed accumulator resultselector)`-  average (pr #657 m)  -  `average(func1<t number> valueselector)`-  buffer (pr #733)  - `buffer(observable<u> bufferboundaries)`-  ~~create async~~  - ~~`create(func1<observer<r> task>)`~~  - ~~`create(func1<observer<r> task<action>>)`~~  - ~~`create(func1<observer<r> task<idisposable>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<action>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<idisposable>>)`~~-  delay (pr #734)  - `delay(func1<t observable<tdelay>>)`  - `delay(func0<observable<d1>> subscriptiondelay func1<t observable<d2>> itemdelay)`-  ~~empty (pr #654)~~  - ~~`empty(t witness)`~~  - ~~`empty(scheduler t witness)`~~-  ~~never (pr #654)~~  - ~~`never(t witness)`~~-  publish (pr #738)  - `publish(func1<observable<tsource> observable<tresult>> sel)`  - `publish(tsource initialvalue)`  - `publish(func1<observable<tsource> observable<tresult>> sel tsource initialvalue)`-  publishlast (pr #738)  - `publishlast(func1<observable<tsource> observable<tresult>> sel)`-  selectmany (flatmap) (pr #736)  - `selectmany(func1<t observable<u>> collection func2<t u r> resultsel)`  - `selectmany(func1<t observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`  - `selectmany(func1<t ienumerable<r>>)`  - `selectmany(func2<t ienumerable<u>> func2<t u r>)`  - ~~----------------------------------~~  - ~~`selectmany(func2<t integer observable<r>>)`~~  - ~~`selectmany(func1<t task<r>>)`~~  - ~~`selectmany(func2<t integer task<r>>)`~~  - ~~`selectmany(func2<t cancellationtoken task<r>>)`~~  - ~~`selectmany(func3<t integer cancellationtokenk task<r>>)`~~  - ~~`selectmany(func1<t integer observable<u>> collection func4<t integer  u integr r> resultsel)`~~  - ~~`selectmany(func1<t task<u>> func2<t u r>)`~~  - ~~`selectmany(func2<t integer task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t ct task<u>> func2<t u r>)`~~  - ~~`selectmany(func3<t integer ct task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t integer observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`~~  - ~~`selectmany(func2<t integer ienumerable<r>>)`~~  - ~~`selectmany(func3<t integer ienumerable<u>> func4<t integer u integer r>)`~~- [x] skip (pr #655 m)  - `skip(timespan)`  - `skip(timespan scheduler)`- [x] skiplast  (pr #655 m)  - `skiplast(timespan)`  - `skiplast(timespan scheduler)`- [x] sum (pr #657 m)  - `sum(func1<t number> valueselector)`- [x] take  (pr #655 m)  - `take(timespan)`  - `take(timespan scheduler)`- [x] takelast  (pr #655 m)  - `takelast(timespan)`  - `takelast(timespan scheduler)`  - `takelast(timespan scheduler duration scheduler drain)`- [x] throttle (debounce) (pr #739)  - `throttle(func1<t observable<void>>)`- [x] timeout (pr #740)  - `timeout(func1<t observable<void>>)`  - `timeout(func1<t observable<void>> observable<t> other)`  - `timeout(func0<observable<void>> func1<t observable<void>>)`  - `timeout(func0<observable<void>> func1<t observable<void>> observable<t> other)`- [x] ~~throw (error) (pr #654)~~  - ~~`error(throwable t t witness)`~~  - ~~`error(throwable t scheduler t witness)`~~- [x] ~~using async~~  - ~~`using(func1<cancellationtoken task<tresource>> func2<tresource cancellationtoken task<observable<t>>>)`~~- [x] ~~where~~  - ~~`where(func2<t integer boolean>)`~~- [x] window (pr #735)  - `window(observable<u> windowboundaries)`- [x] zip (pr #741)  - ~~`zip(ienumerable<observable<s>> sources func1<ilist<s> r> selector)`~~ (already have with funcn)  - `zip(iterable<u> other func2<t u r> result)` (instance method)  - `zip(observable<u> other func2<t u r> result)` (instance method)potential java specific operators/overloads:-  `just(func0<r> factory)` return the value of the factory for the subscriber- [x] ~~`lock(lock lock)` or `synchronize(lock lock)` to support juclocks for synchronization~~- [x] ~~using with javaiocloseable~~  - ~~`using(func0<c> func1<c observable<t>>)`~~  - ~~`usingfuture(func1<booleansubscription future<c>> func2<c booleansubscription future<observable<t>>>)`~~;reviewed by @headinthebox and i for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on || > lock(lock lock) or synchronize(lock lock) to support juclocks for synchronizationwhat is a use case when this would ever be needed? @headinthebox mentioned that its not really used in rxnet so likely not worth us adding  || okay no worries i wont start working on the remaining ones for at least a week || closing this and ignoring `just(func0<r> factory)` ||;1;0;window with observable boundary;
746;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;a few less nulls;;;0;provide hamcrest / junit matchers for optional; for testing methods that return optionals it would be helpful to have matchers for ispresent !ispresent and ispresent & get  xpublic class isoptional&ltt> extends typesafematcher&ltoptional<? extends t>>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsppublic static isoptional&ltobject> isabsent()```public static isoptional<object> ispresent()public static <t> isoptional<t> isvalue(t value)public static <t> isoptional<t> matches(matcher<t> matcher```; thanks i will use hamcrest then || ";;;;0;1;;
746;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;a few less nulls;;;0;instrument thread pools;;;;;;1;1;instrument thread pools;
746;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;a few less nulls;;;0;proposal:  lift operator (was bind);over the past couple months several sources of inspiration have trigged the idea of adding a `bind` operator to `observable` i have played with an implementation and propose we adopt it for rxjava but want to get feedback on signatures and find out if there are any use cases im completely missing that would negate the ideatldr prototype code >  29th: updated to `lift` instead of `bind` based on discussions in  benefits##### 1) synchronous unsubscribethe primary benefit of this proposal is that synchronous observables can be unsubscribed this means an infinite sequence of integers without a separate thread could now be used a large iterable followed  take(20)` would actually only emit the first 20this is achieved by injecting `subscription` into what we today call `observableonsubscribefunc` instead of it being returned by the functionan observable of this nature would check the subscription inside its loop such as this:``` java        obsurvable<integer> observable_of_infinite_integers  obsurvablecreate(new action2<observer<integer> operatorsubscription>() {            @override            public void call(observer<integer> o operatorsubscription s) {                int i  1                while (!sisunsubscribed()) {                    oonnext(i++)                }                ooncompleted()            }        })```##### 2) custom operator chainingbecause java doesnt support extension methods the only approach to applying custom operators without getting them added to `rxobservable` is using static methods this has meant code like this:``` javamycustomeroperatorsoperate(observablemap()filter()take(5))map()subscribe()```in reality we want:``` javaobservablemap()filter()take(5)mycustomoperator()map()subscribe()```using `bind` we can get quite close to this:``` javaobservablemap()filter()take(5)bind(mycustomoperatoroperate())map()subscribe()```here is how the proposed `bind` method looks if all operators were applied with it:``` javaobsurvable<string> os  observable_of_infinite_integersbind(take_5)bind(map_integer_to_string)```##### 3) simpler operator implementationsthe `bind` operator injects the necessary `observer` and `subscription` instances and eliminates (for most use cases) the need for manual subscription management because the `subscription` is available in-scope there are no awkward coding patterns needed for creating a subscription closing over it and returning and taking into account synchronous vs asynchronousfor example `fromiterable` is simply:``` java    public static <t> obsurvable<t> from(final iterable<t> is) {        return obsurvablecreate(new action2<observer<t> operatorsubscription>() {            @override            public void call(observer<t> o operatorsubscription s) {                for (t i : is) {                    if (sisunsubscribed()) {                        break                    }                    oonnext(i)                }                ooncompleted()                sunsubscribe()            }        })    }```the `take` operator is:``` java    public static class takeoperator<t> implements func2<observer<t> operatorsubscription observer<t>> {        final int limit        takeoperator(int limit) {            thislimit  limit        }        @override        public observer<t> call(final observer<t> o final operatorsubscription s) {            if (limit  0) {                ooncompleted()                sunsubscribe()            }            return new observer<t>() {                int count  0                @override                public void oncompleted() {                    ooncompleted()                }                @override                public void onerror(throwable e) {                    oonerror(e)                }                @override                public void onnext(t i) {                    if (!sisunsubscribed()) {                        oonnext(i)                        if (++count > limit) {                            ooncompleted()                            sunsubscribe()                        }                    }                }            }        }    }```##### 4) eliminate need for currentthreadschedulera side-effect of injecting the `subscription` and handling synchronous execution is we can now use loops instead of trampolining for operators like `repeat` this means we should not need the `currentthreadscheduler` (as far as i can tell) and the ugliness it takes to make synchronous unsubscribes work here is the repeat operator without need for scheduling:``` java    public static class repeatoperator<t> implements func2<observer<t> operatorsubscription observer<obsurvable<t>>> {        repeatoperator() {        }        @override        public observer<obsurvable<t>> call(final observer<t> o final operatorsubscription s) {            return new observer<obsurvable<t>>() {                @override                public void oncompleted() {                    ooncompleted()                }                @override                public void onerror(throwable e) {                    oonerror(e)                }                @override                public void onnext(obsurvable<t> ot) {                    while (!sisunsubscribed()) {                        otfcall(o s)                    }                }            }        }    }```##### 5) recursion/loop performancethe `fromiterable` use case is 20x faster when implemented as a loop instead of recursive scheduler (see  places recursive scheduling were used to avoid stack overflow can be done as a loop instead### drawbacks##### 1) observablecreate signature changecurrently the `observablecreate` method is defined as:``` java public static <t> observable<t> create(onsubscribefunc<t> func)```this is effectively the same as:``` java public static <t> observable<t> create(func1<observer<? super t> subscription> func)```to inject the `subscription` we need it to instead be:``` javapublic static <t> obsurvable<t> create(action2<observer<? super t> subscription> f)```note that there is not return type any longer the `subscription` is injected instead of returnedthen to support operators conditionally attaching themselves to the injected `subscription` the signature is actually:``` javapublic static <t> obsurvable<t> create(final action2<observer<? super t> operatorsubscription> f)```the `operatorsubscription` simply adds `void add(subscription s)` so each operator can register with it as needed### prototype codethe prototype code can be found at  name of the class is `obsurvable` and this code can be dropped into the `rx` package as `obsurvablejava` alongside `observablejava` for testing### design decisionsif we agree that this proposal make sense there are some design decisions to make:##### 1) action2/func2 or new type?right now the prototype code has this:``` javapublic static <t> obsurvable<t> create(final action2<observer<? super t> operatorsubscription> f)public <r> obsurvable<r> bind(final func2<observer<r> operatorsubscription observer<t>> bind) ```should we create types that represent those? i think the `create` one probably should for the same reason as before to simplify the pain of dealing with generics thus it would be `onsubscribefunc` `onsubscribe` or something similarfor the `bind` method im less opinionated though it may be cleaner to provide a type that represents the `func2`i did play with a variant of this that combined `observer` and `operatorsubscription` into a single type `operator` to make the function simpler but it conflated things and was quite troublesome with composition as the `observer` and `subscription` had different lifecycles and intents##### 2) private subscribe for nested observablesif you look at the `mergeoperator` code youll see inside the `onnext(obsurvable<t> innerobservable)` that it has this code:``` javainnerobsurvablefcall(observer s)```this is reaching inside the `obsurvable` to the private field `f` and invoking itthis is equivalent to calling `obsurvablesubscribe` except that it inject the `subscription` rather than returning iti still want the normal `subscription observable subscribe(observer o)` signature for public consumption but am considering whether we should have:a) an alternate public signature for subscription that looks like `void observable othersubscribe(observer o subscription s)`b) a private mechnism that operator implementations can somehow subscribe (not sure yet how without these only being implemented inside `observable` itself)i tend to prefer (b) so we dont leak implementation details but (a) would allow anyone to create even the more complicated nested operators such as `merge` outside of `observablejava`##### 3) operatorsubscription nameis this name okay? where should it live? is its signature correct?##### 4) observablecreateshould we deprecate or keep the current signature?if it exists alongside the new one and both have the `create` name accepting a single function it will break groovy and clojure (and probably jruby) as they wont be able to distinguish between overloads thus it likely is best to just do the breaking change cleanly and have a single `create` method with the new signatureis there any reason to have the old signature that returns `subscription` instead of accepting it as an argument?### operator refactorif we adopt this pattern it will take some time to retrofit all operators to use bindin `observablejava` they would be coded something like this using `bind`:``` java    public <r> obsurvable<r> flatmap(func1<t obsurvable<r>> f) {        return bind(new mapoperator<t obsurvable<r>>(f))bind(new mergeoperator<r>())    }    public obsurvable<t> take(int num) {        return bind(new takeoperator<t>(num))    }```each operator would need to be changed to this new modeli suggest we leverage this to do other cleanup such as:- eliminate unnecessary synchronization (use of volatile atomic_ concurrent_ locking etc)- eliminate unnecessary object allocation (such as `notification` or use of `materialize`)- add a new `/src/perf` folder and add a performance test for each operator implementation similar to  and  rename each operator from `operation*` to `operator*` as a marker of which have been migrated (and to read better and match the package name)- come up with standard approaches for concurrency when it is needed such as state machines recently applied to schedulers and subscriptionsid appreciate feedback and improvement thanks;"for feedback /cc @headinthebox @abersnaze @samuelgruetter @jmhofer @mairbek @zsxwing @akarnokd @michaeldejong @johnhmarks @duarten @rickbw || after the first look it definitely solves the take(n) problem as the downstream take can now access the cancellation token for the upstream (btw loops should exit with return instead of break in case of isunsubscribed) however external users are still unable to cancel the long running operation as subscribe wont return the subscription until it has finished one would need to have an overload where the cancellation token is passed in from the outside as well (or a binding which leaks the operatorsubscription):``` javaoperatorsubscription os  new operatorsubscription()schedulerscomputation()schedule(() -> osunsubscribe() 1 timeunitseconds)obsurvablefrom(1)repeat()subscribe(os new observer<t>() {  }) // void```but it doesnt work at the moment as from(1) unsubscribes the os and repeat cant really repeat it (it prints 1 and two oncompleted) if i remove the unsubscribe and change repeat to not emit oncompleted it works as expected and honors the rxjava contract better (see [8415495]( and [8415517]( the modification it appears to me that we replace one problem with another: now one would need to carefully isunsubscribed almost everywhere and think twice when to call unsubscribe || i like this approach it keeps the user facing behaviour the same while allowing for a simpler implementation after a first look it seems that upstream operators shouldnt be able to unsubscribe downstream operators so bind would change to:``` javapublic <r> obsurvable<r> bind(final func2<observer<r> operatorsubscription observer<t>> bind) {    return new obsurvable<r>(new action2<observer<r> operatorsubscription>() {        @override        public void call(observer<r> o operatorsubscription s) {            operatorsubscription s2  new operatorsubscription()            sadd(s2)            fcall(bindcall(o s) s2)        }    })}```take can unsubscribe from all the upstream operators but these cant unsubscribe take (which would be notified through oncomplete) || we can write merge like so:``` java@overridepublic void onnext(obsurvable<t> innerobsurvable) {    subscription innersubscription  innerobsurvablesubscribe(new observer<t>() {      //     })    outersubscriptionadd(innersubscription)}```we already have to protect against onnext calls arriving after a call to oncompleted and unsubscribe so first subscribing to the inner observable and then adding the inner subscription to the composite wont introduce any new interleavingthis seems to allow for option 2) b) while also allowing people to create arbitrary nested observables or am i missing something? || > we can write merge like soeach of the inner `observable` instances can also be synchronous which would make the call to `subscribe` block and thus we would never receive the `subscription` backi think we may just want to provide a `subscribe` overload or new name such as:``` javapublic final void subscribe(observer<? super t> observer operatorsubscription s)// orpublic final void observe(observer<? super t> observer operatorsubscription s)```i think id prefer the different name `observe` im not super concerned with discoverability as its incredibly rare that someone would need to be building an operator of this type and in that case theyre reading the docs and complying with the `create`/`bind`/`observe` semantics updatethese signatures only work for ""one shot"" unless they create a new `operatorsubscription` each time which is why its beneficial for it to be hidden inside the normal `subscribe` if someone is going to use this though they generally should have a reason (creating a nested operator) so that may be okay or we could change the signature to protect against that by doing it as:``` javapublic final void observe(observer<? super t> observer func0<operatorsubscription> subscriptionfactory)``` || >  external users are still unable to cancel the long running operation as subscribe wont return the subscription until it has finishedi have yet to see actual use code where they use the `subscription` received from `subscribe` its more-or-less a sign they are doing it wrong if they need to as they should instead be using things like `take` and `takeuntil` (particularly `takeuntil` for conditional cases) for ending `observables`the only time im aware of a `subscription` from `subscribe` being used for valid reasons is when building operators to combine `observables` together and in that case we are saying to use `bind` instead see the previous comment for thoughts on exposing the ""private subscribe"" publicly for the rare case of building a new operator beyond `merge`/`concat`/`zip`/`switch`/etc for nested behavior || > after the modification it appears to me that we replace one problem with another: now one would need to carefully isunsubscribed almost everywhere and think twice when to call unsubscribehow is this any different than now? we currently have to very carefully consider where to place a `subscription` what to put within it and what manual cancellation tokens (usually a boolean) we have to check while in loops that will be set by that `subscription` we return i see the consideration exactly the samei also dont see it as any more sensitive about when to call `unsubscribe` it has the same impact as our current approach does as soon as you call it everything is supposed to shut down so how do we have to think twice in one approach but not in the other?on top of that with the current implementation we have to deal with the fact that the approach doesnt work for synchronous use cases and we have to keep answering questions from people as to why their code doesnt behave as they expect and we keep telling them ""use schedulers"" which in effect means rx is only useful if all data sources is async (or small enough to not be a problem  which kind of defeats the purpose) however this is actually only half the answer as in rxnet those synchronous cases work by putting everything on a recursive `currentthreadscheduler` and interweaving through the code base ""hacks"" to modify tokens similar or equal to threadlocal state that then stop the recursion see my benefits (4) and (5) for why this new approach to `create`/`bind` seems far better than that thus if we dont use this `bind` approach we have to accept slower behavior for all recursion and figure out how to make `currentthreadscheduler` work i spent time implementing it and it was basically ""whack-a-mole"" with hacks in multiple places in the codebase to capture an `unsubscribe` and set it on a threadlocal so `currentthreadscheduler` could see that it had been `unsubscribed` and stop recursion this is fairly straight-forward when on a single thread it all becomes far more difficult when crossing over thread boundaries or when nesting `observables` and different `schedulers` in a single `observable` sequence || > after a first look it seems that upstream operators shouldnt be able to unsubscribe downstream operators so bind would change to:i need to play with this a bit to better understand and will then respond  || > each of the inner observable instances can also be synchronous which would make the call to subscribe block and thus we would never receive the subscription backright! i forgot about that case the overload taking a subscription factory seems like the better approach then || the `mergeoperator` would end up like this:``` java                public void onnext(obsurvable<t> innerobsurvable) {                    innerobsurvablesubscribe(new observer<t>() {                        @override                        public void oncompleted() {                            synchronized (o) {                                ooncompleted()                            }                        }                        @override                        public void onerror(throwable e) {                            synchronized (o) {                                oonerror(e)                            }                        }                        @override                        public void onnext(t a) {                            synchronized (o) {                                oonnext(a)                            }                        }                    } new func0<operatorsubscription>() {                        @override                        public operatorsubscription call() {                            operatorsubscription innersubscription  new operatorsubscription()                            outersubscriptionadd(innersubscription)                            return innersubscription                        }                    })                }```using a `subscribe` method like this:``` java    public void subscribe(observer<t> o func0<operatorsubscription> sf) {        fcall(o sfcall())    }```its a little unnecessary for a private operator ""doing the right thing"" and involves closing over the `outersubscription` but it does provide a safe public signature || updated prototype code with `observe` method:  would make the `create`/`bind`/`observe` methods siblings for creating operatorsthus an `observable` is `observed` by an `observer` and the `operatorsubscription` is always injectedthe ""public"" signature of `observablesubscribe` is unchanged || ive implemented zip with this new paradigm and it felt a bit odd:``` javapublic <u r> obsurvable<r> zip(obsurvable<u> other func2<t u r> resultselector) {        obsurvable<t> t  this        return obsurvablecreate((o s) -> {            object guard  new object()            queue<t> leftqueue  new linkedlist<>()            queue<u> rightqueue  new linkedlist<>()            atomicboolean leftdone  new atomicboolean()            atomicboolean rightdone  new atomicboolean()            operatorsubscription tsub  new operatorsubscription()            operatorsubscription usub  new operatorsubscription()            sadd(tsub)            sadd(usub)            action0 stride  () -> {                boolean done  false                synchronized (guard) {                    while (!leftqueueisempty()                             && !rightqueueisempty()                             && !sisunsubscribed()) {                        try {                            oonnext(resultselectorcall(leftqueuepoll() rightqueuepoll()))                        } catch (throwable e) {                            oonerror(e)                            sunsubscribe()                            return                        }                    }                    if (!sisunsubscribed()) {                        if ((leftqueueisempty() && leftdoneget())                                || (rightqueueisempty() && rightdoneget())) {                            done  true                            ooncompleted()                        }                    }                }                if (done) {                    sunsubscribe()                }            }            tobserve(new observer<t>() {                @override                public void onnext(t args) {                    synchronized (guard) {                        leftqueueoffer(args)                    }                    stridecall()                }                @override                public void onerror(throwable e) {                    synchronized (guard) {                        oonerror(e)                    }                    sunsubscribe()                }                @override                public void oncompleted() {                    synchronized (guard) {                        leftdoneset(true)                    }                    stridecall()                }            } () -> tsub)            otherobserve(new observer<u>() {                @override                public void onnext(u args) {                    synchronized (guard) {                        rightqueueoffer(args)                    }                    stridecall()                }                @override                public void onerror(throwable e) {                    synchronized (guard) {                        oonerror(e)                    }                }                @override                public void oncompleted() {                    synchronized (guard) {                        rightdoneset(true)                    }                    stridecall()                }            } () -> usub)        })    }```and a test method:``` javaobsurvablefrom(1)repeat()take(10000)zip(obsurvablefrom(2)repeat()take(5) (a b) -> a + b)take(2)subscribe(systemout::println)```which again doesnt work with the reference repeat() as it should not call oncompleted once its upstream calls it because it will continue with subscribing to it again once  the above example worksthe oddity comes from where and what to call unsubscribe on is this okay?``` javaoperatorsubscription tsub  new operatorsubscription()operatorsubscription usub  new operatorsubscription()sadd(tsub)sadd(usub)```and should i call `tsubunsubscribe()` in the first observeroncompleted() or `sunsubscribe()`? || its probably unrealistic to assume that all of the operations can be rewritten in one pull request  this method will allow existing operators that use `onsubscribefunc` to still work``` java    public static <x> obsurvable<x> create(final onsubscribefunc<x> onsub) {        return create(new action2<observer<x> operatorsubscription>() {            @override            public void call(observer<x> in operatorsubscription s) {                subscription sub  onsubonsubscribe(in)                sadd(sub)            }        })    }``` || @akarnokd here is another implementation of `zip` as comparison:  the only place an `unsubscribe` is invoked is here:  are no places where it must be checkedthe most interesting unit test for this is `testzipinfiniteandfinite()` as it must `unsubscribe` the children:  the thing that makes this work is that whenever a subscription occurs via `observe` the `subscription` is injected into it and applies to the entire lifecycle of that subscription this can be seen here:``` javaos[i]observe((innerobserver) observers[i] new func0<operatorsubscription>() {    @override    public operatorsubscription call() {        return childsubscription    }})```this could be simplified to the following if we want to make a user have to ""do the right thing"" when using it:``` javaos[i]observe((innerobserver) observers[i] childsubscription)```the same `childsubscription` is injected into all `obsurvables` being zipped together so a single `unsubscribe` will cause them all to be unsubscribed as each of them will be looking at the same `subscription` wherever applicable (such as a `obsurvablefromiterable` loop) || @akarnokd i think the root of your zip problems comes from the use of `observablecreate()` and not `thisbind()` || for last couple days ive been working on building on this to build a visual debugger of sorts for rx because of the operatorsubscriptionadd() method it allows the association between inner and outer observers to be discovered (aka merge) here is a sample the raw data that i was able to get with four hooks (on create on bind on add and on observe) for the code`from(135)flatmap({i -> from(i i+1)})take(3)subscribe({ print it })`![obsurdebug]( || in the current api the fundamental thing you do with an observable object is _subscribe_ to it by passing an observer and getting a subscription back you can invoke that behavior on `observable` itself with `subscribe(observer)` or you can inject that behavior _into_ `observable` with `observablecreate` and `onsubscribefunconsubscribe(observer)` either way the signature and the contract are exactly the samein the proposed new api the fundamental thing you do is _observe_ by passing in both an observer and a subscription you can invoke that behavior with `observe(observer<t> func0<operatorsubscription>)` or inject it with `action2<observer<t> operatorsubscription>call` except that youve lost the symmetry of the current api! i would either go with `action2<observer<t> func0<operatorsubscription>>` and `observe(observer<t> func0<operatorsubscription>)` or with `action2<observer<t> operatorsubscription>` and `observe(observer<t> operatorsubscription)` but dont mismatch the signatures otherwise well find ourselves constantly writing closures to convert `operatorsubscription` into `func0<operatorsubscription>` || i think you might be right about the func0 being unnecessary my current workspace is too far removed from the base line its hard to say for sure but i was able to remove the func0 implementations and it still work for my use case || while implementing various operators i ran into `groupby` which required a signature change on `bind` to compose the `subscriptions` its working though im not convinced the signature is as elegant as it can bethe prototype code is still here:  it has grown to include `bind` `map` `flatmap` `merge` `take` `zip` `groupby` and `repeat` there are unit tests for these asserting behavior including handling infinite synchronous streams composed subscriptions and general functionalityi have also split out a simpler example (obsurvablebindjava) with just the `bind` operator and a small number of unit tests for necessary functionality to simplify discussion of and iterating on the `bind` signature:  essential parts of the code are currently:``` javapublic static <t> obsurvablebind<t> create(final action2<observer<t> operatorsubscription> f) {    return new obsurvablebind<t>(f)}public void observe(observer<t> o operatorsubscription sf) {    fcall(o sf)}public subscription subscribe(observer<t> o) {    final operatorsubscription os  new operatorsubscription()    observe(o os)    return os}public static interface operator<t> extends observer<t> {    public operatorsubscription getsubscription()}public <r> obsurvablebind<r> bind(final func2<observer<r> operatorsubscription operator<t>> bind) {    return new obsurvablebind<r>(new action2<observer<r> operatorsubscription>() {        @override        public void call(observer<r> o final operatorsubscription s) {            operator<t> ot  bindcall(o s)            observe(ot otgetsubscription())        }    })}```this achieves the generally desired traits but id like to see if we can come up with a better way of representing the `func` definition of `bind`the `public void testbindunsubscribenested()` unit test represents the `groupby` type functionality that requires nested composition of `subscriptions` || here is another possible variant of the signature:  of `func2<observer<r> operatorsubscription operator<t>>` it uses `func1<operator<r> operator<t>>`:``` javapublic static <t> obsurvablebind2<t> create(final action1<operator<t>> f) {    return new obsurvablebind2<t>(f)}public <r> obsurvablebind2<r> bind(final func1<operator<r> operator<t>> bind) {    return new obsurvablebind2<r>(new action1<operator<r>>() {        @override        public void call(operator<r> o) {            observe(bindcall(o))        }    })}public void observe(operator<t> o) {    fcall(o)}public subscription subscribe(final observer<t> o) {    final operatorsubscription os  new operatorsubscription()    observe(createoperator(o os))    return os}public static interface operator<t> extends observer<t> {    /**     * get the subscription intended to pass up to the source being bound to     * <p>     * in other words the subscription from operator -> source     */    public operatorsubscription getsubscription()}``` || here is another variant:  eliminates the `operatorsubscription` and the `operator` becomes an abstract class instead of interface:``` javapublic static abstract class operator<t> implements observer<t> subscription {        private final compositesubscription cs        operator(compositesubscription cs) {            thiscs  cs        }        operator() {            thiscs  new compositesubscription()        }        /**         * used to register an unsubscribe callback         */        public final void add(subscription s) {            csadd(s)        }        @override        public final void unsubscribe() {            csunsubscribe()        }        public final boolean isunsubscribed() {            return csisunsubscribed()        }    }```the `create`/`bind`/`observe` signatures stay the same:``` java    public static <t> obsurvablebind3<t> create(final action1<operator<t>> f) {        return new obsurvablebind3<t>(f)    }    public <r> obsurvablebind3<r> bind(final func1<operator<r> operator<t>> bind) {        return new obsurvablebind3<r>(new action1<operator<r>>() {            @override            public void call(operator<r> o) {                observe(bindcall(o))            }        })    }    public void observe(operator<t> o) {        fcall(o)    }```@rickbw are these different variants solving your concerns? what improvements would you make to their signatures and which do you prefer?@duarten i believe these new signatures address the problem you brought up regarding the passing of `subscription` the unit tests combining `groupby` and `take` assert the particular use case || public static abstract class operator<t> implements observer<t> subscription {}this i likeon sun jan 19 2014 at 4:44 pm ben christensennotifications@githubcomwrote:> here is another variant:  > this eliminates the operatorsubscription and the operator becomes an> abstract class instead of interface:> > public static abstract class operator<t> implements observer<t> subscription {> > ```>     private final compositesubscription cs> >     operator(compositesubscription cs) {>         thiscs  cs>     }> >     operator() {>         thiscs  new compositesubscription()>     }> >     /**         * used to register an unsubscribe callback         */>     public final void add(subscription s) {>         csadd(s)>     }> >     @override>     public final void unsubscribe() {>         csunsubscribe()>     }> >     public final boolean isunsubscribed() {>         return csisunsubscribed()>     }> }> ```> > the create/bind/observe signatures stay the same:> > ```> public static <t> obsurvablebind3<t> create(final action1<operator<t>> f) {>     return new obsurvablebind3<t>(f)> }> > public <r> obsurvablebind3<r> bind(final func1<operator<r> operator<t>> bind) {>     return new obsurvablebind3<r>(new action1<operator<r>>() {> >         @override>         public void call(operator<r> o) {>             observe(bindcall(o))>         }>     })> }> > public void observe(operator<t> o) {>     fcall(o)> }> ```> > @rickbw  are these different variants solving> your concerns? what improvements would you make to their signatures and> which do you prefer?> > @duarten  i believe these new signatures> address the problem you brought up regarding the passing of subscription> the unit tests combining groupby and take assert the particular use case> > —> reply to this email directly or view it on github  || this thread blessed me with the following insight:if we look at the pull-oriented `iterator```` javainterface iterator<t> {    boolean hasnext()    t next()}```and try to find its push-oriented dual we get something like``` javainterface pushiterator<t> {    boolean wantsnext()    void onnext(t)    void onerror(throwable)    void oncomplete()}```which is basically the same as @benjchristensens``` javapublic static abstract class operator<t> implements observer<t> subscription```where `wantsnext()  !isunsubscribed()`that said i like the `operator` idea but i think the naming can be improved: `operator` is not general enough i can also imagine use cases where id use an `operator` instead of an `observer` without my `operator` really being an operator in the sense that it transforms an observable moreover the name `subscription` makes sense if its returned by a call to `subscribe` but if i create a `subscription` myself and pass it to the `subscribe` method this name is not very intuitive any more ive not yet any good naming suggestion (i do not think `pushiterator` is a good name) but im thinking || samuel the subscription comes from the idispoable which is not in the java iterable interface || yes it solves that problem i like it! || anyone interested in this please take a look at the pull request i just submitted@headinthebox and @samuelgruetter i could use your help fixing the scala module  || thanks everyone for your discussion on this i have merged the implementation next steps are:1) nail down naming and signatures:  document (a readme or wiki page) operator implementation standards guidelines and best practices3) update operator implementations over time || sorry for chiming in late im a bit all over the place these days and some of the latest developments in the project slipped past me ill comment here wrt #770 as welli read the proposal and i like the suggested changes one concern i have is that observers now have to extend an abstract class in java its quite intrusive if a library or a framework forces super classes on you since it lacks multiple inheritance we had a few components in our app that would behave like observers but inherited from android framework classes this was quite nice since they would provide the ""glue"" between the android framework and our rx based client code we now have to convert these to observers first by delegating to an inner class which makes their public api a bit awkwardmore problematic though is test friendliness maybe im missing something but a very common recipe that we adopted in dozens of unit tests is the following:```observer mockobserver  mock(observerclass)objgetobservable()subscribe(mockobserver)argumentcaptor<observer> onnextargs  argumentcaptorof()verify(mockobserver)onnext(onnextargscapture())// do expecations against onnextargs```this is not possible anymore since `safeobserver` into which all external observers get wrapped requires a valid subscription in a private final field something that a mock object cannot providefwiw mockito @spys work but it might not be wise to rely on spies maybe this could at least be mitigated by providing a non-final getter for the subscription which safeobserver queries? at least then wed be able to return a subscription for the mock that safeobserver can acceptben also pointed me to `testobserver` which can be used as a wrapper to query arguments neither solution strikes me as very elegant thoughsorry ill have to work more with the current code base to get a deeper impression just wanted to throw this in as a first impression of sorts || thanks @mttkay for getting involved and providing feedback i too have similar concerns about `observer` become `abstract` and im still considering the pros and cons of the change but thus far have come to see `abstract observer implements subscription` as being the best of the proposed designsfor unit tests your code would need to change like this:``` javaobserver mockobserver  mock(observerclass)objgetobservable()subscribe(new testobserver(mockobserver))argumentcaptor<observer> onnextargs  argumentcaptorof()verify(mockobserver)onnext(onnextargscapture())// do expecations against onnextargs```going back to the discussion on signatures in  the choice is basically to either:a) change `observer` to an `abstract` class and have a single typeb) create a new type that combines `observer` and `subscription` and is used in the `create(onsubscribe)` and `lift` signatures but not `subscribe`at this point the strongest argument has been to keep the public api clean and have a single `observer` type that works in all cases the drawback of this approach though is the impact on multiple-inheritance and unit testingthe current signatures are:``` java// observablecreatepublic final static <t> observable<t> create(onsubscribe<t> f)// observableonsubscribe typed function interfacepublic static interface onsubscribe<t> extends action1<observer<? super t>>// lift functionpublic <r> observable<r> lift(final func1<observer<? super r> observer<? super t>> bind)// observerpublic abstract class observer<t> implements subscription {     public abstract void onnext(t t)     public abstract void onerror(throwable e)     public abstract void oncompleted()     public final void add(subscription s)     public final void unsubscribe()     public final boolean isunsubscribed()}// subjectpublic abstract class subject<t r> extends observer<t> {    public abstract observable<r> toobservable()}```anyone have a better design than this? || this code demonstrates what the new signatures allow:``` java        observablecreate(new onsubscribe<integer>() {            @override            public void call(observer<? super integer> ob) {                for (int i  1 i < 100000 i++) {                    /*                     * the observer communicates whether it is unsubscribed                     * so loops and seqential processing on the same thread                     * can now unsubscribe                     */                    if (obisunsubscribed()) {                        systemoutprintln(""--- unsubscribed at: "" + i)                        return                    }                    obonnext(i)                }                oboncompleted()            }        })subscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln(""completed"")            }            @override            public void onerror(throwable e) {                eprintstacktrace()            }            @override            public void onnext(integer i) {                systemoutprintln(""received: "" + i)                if (i  10) {                    // an observer can now unsubscribe                    unsubscribe()                }            }        })    }```this outputs:```received: 1received: 2received: 3received: 4received: 5received: 6received: 7received: 8received: 9received: 10--- unsubscribed at: 11```note how the source `observable` can check `obisunsubscribed()` and the `observer` can now `unsubscribe()` all within a single-threaded sequential callthis is equally beneficial if the observable is made async by running on a separate thread but still a sequential for-loop instead of trampolining (which is far slower than a loop and both less obvious and more complicated to implement):``` java        observablecreate(new onsubscribe<integer>() {            @override            public void call(observer<? super integer> ob) {                for (int i  1 i < 100000 i++) {                    /*                     * the observer communicates whether it is unsubscribed                     * so loops and seqential processing on the same thread                     * can now unsubscribe                     */                    if (obisunsubscribed()) {                        systemoutprintln(""--- unsubscribed at: "" + i)                        return                    }                    obonnext(i)                }                oboncompleted()            }                  // use subscribeon so it is now async        })subscribeon(schedulersnewthread())subscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln(""completed"")            }            @override            public void onerror(throwable e) {                eprintstacktrace()            }            @override            public void onnext(integer i) {                systemoutprintln(""received: "" + i)                if (i  10) {                    // an observer can now unsubscribe                    unsubscribe()                }            }        })```this means we do want the `observer` to be more intelligent and encapsulate the `subscription` so we achieve these goalsunit testing is doable by using `testobserver` and im okay with that being slightly less elegant the remaining drawback is the inability to `implement observer` since it is now abstract a relevant question is whether classes need to `implement observer` so as to ""be"" an `observer` we do not support this on `observable` classes are not ""an"" `observable` but generally have getters that return an `observable` or a class has a `toobservable()` method on itsimilarly classes do not need to be an `observer` but can encapsulate that logic that said there may still be value in having an interface that represents something that can be turned into an `observer`right now `observable` has that with the `observableonsubscribe` interface should we have something similar for `observer`? if so what should it be called? `observeronobserve`?we either need a new name for `observer+subscription` (the currently modified `observer`) and return `observer` to just the 3 on\* methods and a mechanism for converting from it to the `observer+subscription` or we leave `observer` as `observer+subscription` and come up with a different name to represent the interface of the 3 on\* methods || thanks for the write up ben! i do agree this is very desirableso an observers role is an active one now (it can unsubscribe) rather thanjust a passive one (it receives notifications) thats fine and observeris still a good name (im less happy with the fact that observer ""is a""subscription now just in terms of naming but anyway i see how this makessense implementation wise)i usually name interfaces after the behavior they enable if we reintroducean interface that resembles what observer used to be id vote forsomething along the lines of `notifiable` or `notificationreceiver` toreflect that the interface captures the behavior of being able to receiverx notifications onobserve sounds like a single callback to an observefunction so that might be misleadingjust my thoughts || cant we provide a default implementation of observer like this?``` javapublic abstract class observer<t> implements subscription {     public abstract void onnext(t t)     public abstract void onerror(throwable e)     public abstract void oncompleted()     protected subscription subscription   default implementation for subscription      public final void add(subscription s){ subscriptionadd(s) }     public final void unsubscribe(){ subscriptionunsubscribe() }     public final boolean isunsubscribed(){ return subscriptionisunsubscribed() }}``` || > cant we provide a default implementation of observer like this?that is how it is implemented:  || if we go this path an interface `notifiable` could work since we already have the `notification` type``` javapublic abstract class observer<t> implements subscription notifiable```or we could leave `observer` as the passive object that receives notifications and use `subscriber` to represent the thing that calls `subscribe` and it would implement `observer` and `subscription```` javapublic abstract class subscriber<t> implements observer<t> subscription``` || note that if we went to having `subscriber` and `observer` wed then have the question of whether we allow `observablesubscribe(observer o)` because if we did those implementations could not `unsubscribe` that is probably fine though as most `observer`s dont need to unsubscribethus we could have methods like this in `observable`:``` javavoid subscribe(subscriber s)subscription subscribe(observer o)``` || i did an implementation using `subscriber` to see if it makes sense please provide feedback on issue  || ";;;;0;1;;
746;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;a few less nulls;;;727.0;add missing copyright headers;-  727 -  add missing copyrights using [license-gradle-plugin](  updated only source files test files were skipped existing copyright headers were not modified;unfortunately the plug-in is not compiled for java 6i really would like to avoid as much as possible maintaining 2x too long || however i suppose we can change the jdk that gradle use if this is a separate task in traviswhy a separate task because if gradle runs the under the code under another jdk we may miss specific jdk 6 runtime behavior || per  we can use version 0110 and make it work on jdk6 || good point lets do that instead @dmitriyzaitsev could you amend b27af329e91743e945e5971a3e5b7a4f839d0f03 with the working version? thanks in advance || @dmitriyzaitsev by id like to say you have done a proper pull request thats very nice! ||  ;copyright notice missing on files;lets add automation that will make consistent copyright notice on all source files;if nobodys working on it i can send you a pr || @dmitriyzaitsev looking forward to it 😄  ||;1;0;add missing header copyrights to source files727;
747;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cleanup;more cleanups and logging.;;0;provide optionals; public final class optionals {```public static final predicate<optional<t>> isabsent  new predicate<optional<t>>() {    @override    public boolean apply(optional<t> input) {        return !inputispresent()    }}public static final predicate<optional<t>> issome  new predicate<optional<t>>() {    @override    public boolean apply(optional<t> input) {        return inputispresent()    }}public static final function<optional<t> t> getvalue  new function<optional<t> t>() {    @override    public t apply(optional<t> input) {        return inputget()    }}private optionals() {}```}; i agree with louis  there are some related utilities that may make sense for optional but they should be deal with individually not in a large omnibus bug like this--- ;;;;0;1;;
747;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cleanup;more cleanups and logging.;;0;allow fluent usage of mockitoframework() listeners methods;currently `addlistener` and `removelistener` returns `void` which makes it repetitive to add or remove these :```javamockitoframework()addlistener()mockitoframework()addlistener()mockitoframework()addlistener()```the main change of this pr is to return `mockitoframework` instead thus allowing to chain invocations :```javamockitoframework()addlistener()                   addlistener()                   addlistener()```this improvements is a breaking change however the api is still **incubating** and should be expected to break source wise theres no problem since nothing could be done before due to the `void` return; ;;;;1;1;removes duplicated codesigned-off-by: brice dutheil <bricedutheil@gmailcom>;
747;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cleanup;more cleanups and logging.;;0;use more efficient api for finding split locations;;;;;;1;1;use more efficient api for finding split locations;
747;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cleanup;more cleanups and logging.;;0;organize format alphabetize and finalize;code cleanup after the many new operators that have come in over the past 2 months1) organized imports2) formatted all code for standard whitespace code formatting etc3) sorted methods in `observablejava` alphabetically4) updated all license headers5) made `observable` methods final as they are not intended to be overridden in the rare cases when inheritance makes sense for `observable` this better communicates the inheritance intent of the class and prevents against accidental misuse (such as overriding `subscribe` which breaks it)anyone have issues with any of these changes (i figure (5) will be the most controversial)?;#663 ;;;;0;1;;
748;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;added method getbasepanellist() and used it;seemed like a convenient method considering how often it was used.;;0;consider adding a simple state machine logic; sth like  could be a useful addition in guava a few things that should be improved:- separate construction / usage with a builder pattern- dont abuse cache (comptingmap is deprecated in 100 - where is the alternative?)- allow for an associated state model (effectively allowing predicate instances as guards - much more useful); im going to close this until such time as someone is willing to write up a properly persuasive proposal illustrating how this would be used why its better than the best current alternative users have and why we think the need for it comes up frequentlyjust saying ""this could be useful for guava"" tells us nothing--- ;;;;0;1;;
748;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;added method getbasepanellist() and used it;seemed like a convenient method considering how often it was used.;;0;regroup junit classes in junit packages;this pr proposes to regroup all junit related classes in corrct packages theres two changes :* public : deprecates `orgmockitorunnersmockitojunitrunner` and moves logic over `orgmockitojunitrunnersmockitojunitrunner`  questions :    * should the runner be moved in the subpackage `junitrunner` or regroup the runner along with the rule in the `junit` package? (junit 5 will have neither of those)    * should i do the same for already deprecated runners (console spamming and verbose runner)* private : moves junithackertool to `orgmockitointernaljunitutil`;lower coverable due to the _redirect_ classes (deprecated classes no extends the moved classes) ||  ;;;;1;1;moves mockitojunitrunner to the public junit packagethis change has been made in a way that is not breaking existing codesigned-off-by: brice dutheil <bricedutheil@gmailcom>;
748;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;added method getbasepanellist() and used it;seemed like a convenient method considering how often it was used.;;0;remove mysql driver;;;;;;0;1;;
748;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;added method getbasepanellist() and used it;seemed like a convenient method considering how often it was used.;;0;stackoverflowerror is swallowed;the following code should have thrown stackoverflowerror:``` java        final publishsubject<integer> a  publishsubjectcreate()        final publishsubject<integer> b  publishsubjectcreate()        asubscribe(new observer<integer>() {            @override            public void oncompleted() {            }            @override            public void onerror(throwable e) {                eprintstacktrace()            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })        bsubscribe(new observer<integer>() {            @override            public void oncompleted() {            }            @override            public void onerror(throwable e) {                eprintstacktrace()            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })        asubscribe(new observer<integer>() {            @override            public void oncompleted() {            }            @override            public void onerror(throwable e) {                eprintstacktrace()            }            @override            public void onnext(integer args) {                bonnext(args + 1)            }        })        bsubscribe(new observer<integer>() {            @override            public void oncompleted() {            }            @override            public void onerror(throwable e) {                eprintstacktrace()            }            @override            public void onnext(integer args) {                aonnext(args + 1)            }        })        aonnext(1)```however stackoverflowerror is swallowedthe problem is the following line in safeobserver:  java            rxjavapluginsgetinstance()geterrorhandler()handleerror(e)```when stackoverflowerror is thrown there is few stack space however this line will generate too big stack frame and cause the thread crash if i comment out this line i can observe stackoverflowerrorreported by samuel at https://groupsgooglecom/forum/#!topic/rxjava/eraz-32w1gq;"the proper fix seems to be to immediately re-throw any virtualmachineerror by introducing a more specialized catch || not surprised we ended up with something like this happening after migrating from `exception` to `throwable`:  agree @duarten that `safeobserver` should catch and re-throw at least the `virtualmachineerror` class of errors:  others we should include? `threaddeath` looks fun :-) the `linkageerror` exceptions also seem like we should never catch them:  || maybe its better not to catch any of the `error` [subclasses]( || re-throwing the `error` still has a problem when `schedulersio()` is involved the `error` will be swallowed by the `executorservice` || in general not catching `error` and `throwable` is worse than catching them as in an async system that means they are being thrown on some random thread in the background wont call `onerror` and thus can lock up a system since an `observable` wont be terminated so it may only be the `stackoverflow` case that needs to be special-cased since it is a unique case of an infinite loop that means we wont ever successfully exit || but swallowing them is not good either and then that will put the onus on the users to re-throw those exceptions because theres really no way to handle them if there are uncaught errors wont the jvm shutdown even if there are non-daemon threads?interestingly scala defines a nonfatal exception as:``` scalaobject nonfatal {   def apply(t: throwable): boolean  t match {     case _: stackoverflowerror > true // stackoverflowerror ok even though it is a virtualmachineerror     case _: virtualmachineerror | _: threaddeath | _: interruptedexception | _: linkageerror | _: controlthrowable | _: notimplementederror > false     case _ > true   }}```which they use in their futures library to check if it should be handed to the user for handling || it wont be swallowing them they are or should all be passed via onerror to the user provided observer stackoverflow is swallowed because of a recursive loop  || sorry my point is that users may not be expecting to be handed such exception and may swallow them themselves by for example just logging them the correct behaviour imho would be to let them bring down the jvm asap || background on `throwable` being caught and emitted via `onerror` can be seen here:  scala definition seems good i think we should follow that same logic for defining something `fatal` and immediately re-throwing it as opposed to passing via `onerror` || that sounds good! || ~~just found a potential problem in this method:~~``` java    protected void _onerror(throwable e) {        try {            rxjavapluginsgetinstance()geterrorhandler()handleerror(e)            actualonerror(e)        } catch (throwable e2) {            e2printstacktrace()            if (e2 instanceof onerrornotimplementedexception) {                /*                 * onerror isnt implemented so throw                 *                  *                  *                  * rx design guidelines 52                 *                  * ""when calling the subscribe method that only has an onnext argument the onerror behavior will be                 * to rethrow the exception on the thread that the message comes out from the observable sequence                 * the oncompleted behavior in this case is to do nothing""                 */                try {                    subscriptionunsubscribe()                } catch (throwable unsubscribeexception) {                    rxjavapluginsgetinstance()geterrorhandler()handleerror(unsubscribeexception)                    throw new runtimeexception(""observeronerror not implemented and error while unsubscribing"" new compositeexception(arraysaslist(e unsubscribeexception)))                }                throw (onerrornotimplementedexception) e2            } else {                /*                 * throw since the rx contract is broken if onerror failed                 *                  *                  */                rxjavapluginsgetinstance()geterrorhandler()handleerror(e2)                try {                    subscriptionunsubscribe()                } catch (throwable unsubscribeexception) {                    rxjavapluginsgetinstance()geterrorhandler()handleerror(unsubscribeexception)                    throw new runtimeexception(""error occurred when trying to propagate error to observeronerror and during unsubscription"" new compositeexception(arraysaslist(e e2 unsubscribeexception)))                }                throw new runtimeexception(""error occurred when trying to propagate error to observeronerror"" new compositeexception(arraysaslist(e e2)))            }        }        // if we did not throw about we will unsubscribe here if onerror failed then unsubscribe happens in the catch        try {            subscriptionunsubscribe()        } catch (runtimeexception unsubscribeexception) {            rxjavapluginsgetinstance()geterrorhandler()handleerror(unsubscribeexception)            throw unsubscribeexception        }    }```~~if `rxjavapluginsgetinstance()geterrorhandler()handleerror(e)` throws a throwable `rxjavapluginsgetinstance()geterrorhandler()handleerror(e2)` also may throw one so there may be a recursive loop is it necessary to make a distinction between throwables from `rxjavapluginsgetinstance()geterrorhandler()handleerror(e)` and `actualonerror(e)`~~sorry i made a mistake its not a recursive loop || a thought to solve the swallowed stackoverflowerror: can we call `actualonerror(e)` before `rxjavapluginsgetinstance()geterrorhandler()handleerror(e)`? || just dig deeply and found stackoverflowerror is swallowed by safeobserverin this example there are 4 observers and wrapped by 4 safeobservers here i call them so1 so2 so3 so4 in order when the stackoverflowerror is thrown the thread call stack is something like:```so1onnextso4onnextso3onnextso4onnextso3onnextso4onnext```next```so1onerror(throw a new stackoverflowerror from ""rxjavapluginsgetinstance()geterrorhandler()handleerror(e2)"")so1onnextso4onnextso3onnextso4onnextso3onnextso4onnext```next```so4onnextso3onnextso4onnextso3onnextso4onnext```next```so4onerror(throw a new stackoverflowerror from ""rxjavapluginsgetinstance()geterrorhandler()handleerror(e2)"")so4onnextso3onnextso4onnextso3onnextso4onnext```next```so3onnextso4(isfinished  true)onnextso3onnextso4(isfinished  true)onnext```next```so3onerror(throw a new stackoverflowerror from ""rxjavapluginsgetinstance()geterrorhandler()handleerror(e2)"")so3onnextso4(isfinished  true)onnextso3(isfinished  true)onnextso4(isfinished  true)onnext```next```so4(isfinished  true)onnextso3(isfinished  true)onnextso4(isfinished  true)onnext```next```so4(isfinished  true)onerror (stackoverflowerror is swallowed here)so4(isfinished  true)onnextso3(isfinished  true)onnextso4(isfinished  true)onnext```here stackoverflowerror is sent to so4onerror again so4 will swallow it since isfinished is true || so if `rxjavapluginsgetinstance()geterrorhandler()handleerror(e)` always throw a stackoverflowerror `actualonerror(e)` will be skipped no matter what we do in the catch clause(eg rethrow the stackoverflowerror) it will be swallowed by safeobserver in this example || dealing with in pull request  || should be  in  || ";;;;0;1;;
754;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improved documentation regarding unused stubbing detection;improved documentation regarding unused stubbing detection  609;;0;mapscomputeifabsent(map k supplier); this is yet another recurring pattern that appears in many programs (sometimes the map can be replaced with a cache but not always)the full signatures would be something like:&ltk v>v computeifabsent(concurrentmap&ltk v> map k key supplier&ltv> supp)and&ltk v>v computeifabsent(concurrentmap&ltk v> map k key function&ltk v> func)both @﻿nonnull since unlike concurrentmapputifabsent they would return the new value (always present) rather than the old; weve really opened up the possibilities for what you can do with cache now so i dont feel this is necessary--- ;;;;0;1;;
754;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improved documentation regarding unused stubbing detection;improved documentation regarding unused stubbing detection  609;;0;improved documentation regarding unused stubbing detection;improved documentation regarding unused stubbing detection 609;  754  ;;;;1;1;improved the docs re detecting unused stubbingsbased on great feedback from the community!;
754;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improved documentation regarding unused stubbing detection;improved documentation regarding unused stubbing detection  609;;0;add logging for testexpressioncompiler;;;;;;1;1;add logging for testexpressioncompiler;
754;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improved documentation regarding unused stubbing detection;improved documentation regarding unused stubbing detection  609;;0;androidobservable not work;private static final string tag  ""mainactivity""private subscription subscription@overrideprotected void oncreate(bundle savedinstancestate) {    superoncreate(savedinstancestate)    setcontentview(rlayoutactivity_main)    // worked    subscription  androidobservablefromactivity(this            getobservable()subscribeon(schedulersnewthread()))subscribe(            this)    // not work    // subscription  androidobservablefromactivity(this getobservable())    // subscribeon(schedulersnewthread())subscribe(this)    // worked    // subscription  getobservable()subscribeon(schedulersnewthread())    // observeon(androidschedulersmainthread())subscribe(this)}private observable<integer> getobservable() {    return observablecreate(new onsubscribefunc<integer>() {        @override        public subscription onsubscribe(observer<? super integer> obsever) {            for (int i  0 i < 10 i++) {                obseveronnext(i)            }            obseveroncompleted()            return subscriptionsempty()        }    })}@overrideprotected void ondestroy() {    superondestroy()    subscriptionunsubscribe()}@overridepublic void oncompleted() {    logd(tag ""finished"")}@overridepublic void onerror(throwable error) {}@overridepublic void onnext(integer i) {    logi(tag i + """")}```what i mean of not work is onnext() and oncompleted() not get called";"ill take this one the reason its not working is were doing a check for whether fromfragment is actually called from the main ui thread and terminate the observable if not however this check happens in the onsubscribefunc so will fail if the wrapped observable is scheduled to run elsewhere the check should be moved to the invocation side ie to the fromfragment helper  || i also got this issue when itll be ? || im waiting for 017 to land it contains major changes to the observable api will pick it up after || thank for reply! you and your team made a bunch of great work thanks man! || @mttkay on this subject can you confirm that 017 (master branch) is working for you on android in particular the android scheduler was changed by me and im not setup to test on real devices || ill have a look asap has the scheduler rewrite landed yet? it was stillin a pr last time i checked || yes it has been merged thank you || so i gave this some more thought and im not sure we should actually ""fix"" this the reason is `fromfragment` schedules notifications on the main ui thread if you do not apply this to the final composition of your inner observables then the result might not be what you might expect if you have long running operations they will now be propagated on the main ui thread and this can congest the android message queue for an activity since you unsubscribe in `ondestroy` and since `ondestroy` is triggered  finish` and since `finish` will also post a message to the android message queue you might defer releasing the references the operator holds to the activityafter all these helpers are meant for just one use case: to observe a fully constructed given sequence on the main thread while being able to unsubscribe such that no references to the activity or fragment will leak plus some additional sanity checks for fragments i guess thats why i put that guard in to begin withthat being said i think one problem is the naming i would suggest the following:- rename `operationobservefromandroidcomponent` to `operationobserveonandroidcomponent`- rename `fromfragment` and `fromactivity` to `observeonfragment` and `observeonactivity`- remove the ui thread check from the operator and pull it up into these helpers that way your app will fail immediately with a sanity check rather than obscuring it and piping it through an rx error handler which you might no even have suppliedthoughts on this?@benjchristensen i did some quick testing in a sample app that i use as a sandbox for experiments and it looks good unit tests also look good would like to further test in our application but if theres pressure to release 017 earlier than later id almost say go ahead i didnt see any smoke signals and smaller issues can still be addressed in a minor version bump ship early ship often and so on :-) || @mttkay thanks for doing that testing for me i agree that youll want further testing before production deployment but the fact that its good enough to pass right now means there are no major api signature or fatal issues i am trying to wrap up a few last things so we can release in the next week give or take || sounds good || @mttkay this code sample below is is taken from your blog post [functional reactive programming on android with rxjava]( the code here seems to imply that the `fromfragment` and `fromactivity` methods can be used with `subscribeon(schedulersnewthread())` but from the discussion above it sounds like that is not the intention so im wondering if the blog post is just out of date? please let me know if im misunderstanding something here```class myfragment extends fragment implements observer<file> {  private subscription subscription  @override  protected void oncreate(bundle savedinstancestate) {    subscription  androidobservablesfromfragment(this downloadfileobservable())                          subscribeon(schedulersnewthread())                          subscribe(this)  }  private observable<file> downloadfileobservable() { /* as above */ }  @override  protected void ondestroy() {    subscriptionunsubscribe()  }  public void onnext(file file) {    toastmaketext(getactivity()        ""downloaded: "" + filegetabsolutepath()        toastlength_short)        show()  }  public void oncompleted() {}  public void onerror(throwable error) {    toastmaketext(getactivity()        ""download failed: "" + errorgetmessage()        toastlength_short)        show()  }}``` || yes that code snippet i wrote before adding the `assertuithread` guard like i said ill revisit this soon but want to see 017 land first || @mttkay can you take a look at this pr #880? im worried that deferring the `unsubscribe` action may cause some problems maybe a better solution is:```if(isuithread) {    do unsubscribe}else {    androidschedulersmainthread()schedule( () -> do unsubscribe )}``` || that pr already landed can we maybe agree that a pr gets at least 2 +1s before we merge it back? im not super happy with the changes in there (see my comments in #880) || this can be closed as its fixed in `bindactivity` / `bindfragment` which replace this || ";;;;0;1;;
759;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;updated the verification documentation to correctly use argthat with java8 lambdas;the example for custom argument matchers using a lambda in the main mockito documentation is missing a call to argthat.;;0;cachebuilder generics; cachebuildernewbuilder() has &ltobject object> instead of &ltkv> which makes it impossible to use the class with generics; ;;;;0;1;;
759;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;updated the verification documentation to correctly use argthat with java8 lambdas;the example for custom argument matchers using a lambda in the main mockito documentation is missing a call to argthat.;;0;updated the verification documentation to correctly use argthat with java8 lambdas;the example for custom argument matchers using a lambda in the main mockito documentation is missing a call to argthatthis pr fixes the docs to correctly use argthat;sgtm? cant test it right now but almost certain it is the correct fix ||   @timvdlippe youll have a chance to test the javadoc changes in real ||;;;;1;1;fix the verification documentation to correctly use argthat for lambda matchers;
759;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;updated the verification documentation to correctly use argthat with java8 lambdas;the example for custom argument matchers using a lambda in the main mockito documentation is missing a call to argthat.;;0;table sample implementation;sameer had sent across a pull request for the bernoulli implementation i have built on top of his request tested with presto cli on the presto_test table (4 splits) for several sample percentages for some runs even a 50% sample does not return any results however i guess as the number of splits increases this will even out 100% deterministically returns all the rows;sent out another pull request for this implementation  ||;;;;0;1;;
759;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;updated the verification documentation to correctly use argthat with java8 lambdas;the example for custom argument matchers using a lambda in the main mockito documentation is missing a call to argthat.;;0;rxoperatorsoperationcombinelatest throw null point exception;"null point excpeiton will be thrown in the following case:1 use operationcombinelatestcombinelatest(observable<t0> w0 observable<t1> w1 func2<t0 t1 r> combinefunction)2 and when w0 or w1 emits a null value the null value is a valid valuethe cause is that the member latestvalue of  operationcombinelatestaggregator is concurrenthashmap concurrenthashmap supports neither null key  nor null valueone solution is to user latestvalue  ""collectionssynchronizedmap(new hashmap<combineobserver<? extends r ?> object>())"" instead of ""latestvalue  new concurrenthashmap<combineobserver<? extends r ?> object>()""";"or use a null sentinel like in the zip operator edit: btw which library version are you using? the latest 0161 has my changes which doesnt use hashmap at all and is null-safe || combinelatest has been rewritten again does this issue persist? || looks to be working``` javapublic class combinelatestwithnull {    public static void main(string args) {        observable<integer> o1  observablefrom(1 2 null)subscribeon(schedulerscomputation())        observable<integer> o2  observablefrom(4 5)subscribeon(schedulerscomputation())        observable<integer> o3  observablefrom(null null 5)subscribeon(schedulerscomputation())        observablecombinelatest(o1 o2 o3 (a b c) -> {            return a + ""-"" + b + ""-"" + c        })toblockingobservable()foreach(systemout::println)    }}```emits:```null-5-nullnull-5-nullnull-5-5``` || ";;;;0;1;;
771;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;731 implements retry rule for flaky tests;previous attempts at fixing the time related tests failed. indeed the previous attempts are not bullet proof when the ci can run schedule some threads slower than _expected_.;;0;iterablestransform() with condition (predicate); i think this would be useful for maps lists iterables:transform( iterable&ltt> function<? super f? extends t> predicate<? super t> )this is eqal to:iterable i  i  iterablesremoveif(i predicate)i  iterablestransform(i function)the advantage: just one iterationexample code:public class selectableitemcollection&ltt> {&nbsp&nbspprivate static class selectableitem&ltt> {&nbsp&nbsp&nbsp&nbspt value&nbsp&nbsp&nbsp&nbspboolean selected&nbsp&nbsp}&nbsp&nbsppublic iterable&ltt> getselection() {&nbsp&nbsp&nbsp&nbspreturn iterablestransform( this gettsfunction mustbeselectedpredicate )&nbsp&nbsp}}ps: why has sets no transform method?; hmm stupid me of course filter is lazyhowever im not sure if the combo-method is really unnecessary?!i mean iterablesfilter and iterablestransform will create inner iterators which will create inner instances too so you will have 4 instancesbut you need only two iterablestransform with the additional predicate which will create an equivalent iterator and the viewon the other side how often would you call such a method?! for my needs the upper solution is totally fine!## actually i could call iterators directly or will it harm the iterator-remove-thingy?thanks for the quick responses! ||;;;;0;1;;
771;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;731 implements retry rule for flaky tests;previous attempts at fixing the time related tests failed. indeed the previous attempts are not bullet proof when the ci can run schedule some threads slower than _expected_.;;0;tablesample bernoulli;fixes for sameers pull request (see last commit)sameer feel free to squash this into your commit once its reviewed;this is all merged now ||;;;;0;1;;
771;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;731 implements retry rule for flaky tests;previous attempts at fixing the time related tests failed. indeed the previous attempts are not bullet proof when the ci can run schedule some threads slower than _expected_.;;0;exception rethrown inconsistently with/without flatmap() in 0161;"maybe i just dont understand javarx yet but this seems inconsistentrun this and then re-run without the flatmap() note that the second run passes the unit test```@test(expected  runtimeexceptionclass)public void verifyexceptionisthrownifthereisnoexceptionhandler() {    observableonsubscribefunc < object > creator  new observableonsubscribefunc < object >() {        @override        public subscription onsubscribe(observer < ? super object > observer) {            observeronnext(""a"")            observeronnext(""b"")            observeronnext(""c"")            observeroncompleted()            return subscriptionsempty()        }    }    func1 < object observable < object >> manymapper  new func1 < object observable < object >>() {        @override        public observable < object > call(object object) {            return observablefrom(object)        }    }    func1 < object object > mapper  new func1 < object object >() {        private int count  0        @override        public object call(object object) {            ++count            if (count > 2) {                throw new runtimeexception()            }            return object        }    }    action1 < object > onnext  new action1 < object >() {        @override        public void call(object object) {            systemoutprintln(objecttostring())        }    }    observablecreate(creator)flatmap(manymapper)map(mapper)subscribe(onnext)}```";the problem here is that one of safeobserveronerror is called twice: one is `runtimeexception` the other is `onerrornotimplementedexception` a little to similar to #748  || not sure this is a bug if an observer throws an exception in `onerror` what will happen? i think rx does not guarantee that it always calls `onerror` when an exception is thrown it only guarantees that it at least calls `onerror` once even if there are many exceptions do i misunderstand anything? || the behavior is inconsistent thats the bugdocument that the throwables are silently swallowed or thrown if there is no onerror() errors should probably always be thrown because i want my jvm to terminate before my jvm starts misbehaving and serving wrong data || if an onerror is not implemented it should always be thrown || @benjchristensen  looks some operators do not handle `onerrornotimplementedexception` correctly could you propose a guild about how to handle exception in rxjava? now we have `runtimeexception except onerrornotimplementedexception` `exception` `error` and `onerrornotimplementedexception` || dealing with in pull request  || should be  in  ||;;;;0;1;;
771;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;731 implements retry rule for flaky tests;previous attempts at fixing the time related tests failed. indeed the previous attempts are not bullet proof when the ci can run schedule some threads slower than _expected_.;;731.0;731 implements retry rule for flaky tests;previous attempts at fixing the time related tests failed indeed the previous attempts are not bullet proof when the ci can run schedule some threads slower than _expected_a proper harness should be implemented but in the meantime i implemented the retry rule as proposed in #731 to gain back stability on the build; ;consider rerunning failed tests;consider rerunning failed tests to avoid  options: - rerun test gradle task - rerun test rule http://stackoverflowcom/questions/8295100/how-to-re-run-failed-junit-tests-immediately;"-1 for rerunning the test should be  see #704 || agreed with @christianschwarz we should fix the test instead this test has a behavior difficult to test both locally and in a container previous approach with `countdownlatch` in #619 worked but was imperfect and still broke under the constrained travis environment @christianschwarz approach is different but proved to be working more consistentlyfor reference the original issue is #548  || its classic craftsmanship vs pragmatismi hate re-running builds and tests however i am pragmatic and i hate wasting time even more :) || @szczepiq #704 has landed this ticked can be closed> its classic craftsmanship vs pragmatism vs ""recklessness""   image there is a rare race condition in the code under test possibly the race condition will not appear in a future run who to detect the bug this way?   || closing per #704 || thank you guys for attempting to fix the verification with timeout test! it still seem to fail:  (i merged from release/2x so it contained @christianschwarz fix)> image there is a rare race condition in the code under test possibly the race condition will not appear in a future run who to detect the bug this way?rerun does not have to be dumb it can only allow to rerun tests that we know that are flaky (and need fixing or accepting their imperfection) ||  || agreed theres still not so rare build failures i had to restart the job 177057772 manually ive been seeng this just as often since #704 merge<details><summary>job logs</summary>```worker informationhostname: travis-worker-gce-org-prod2-4:4d952407-384a-4d90-a194-6a04d5b5e251version: v250  testing-gce-e550a994-d659-4a46-bccf-eed57dafea15:travis-ci-jvm-precise-1471814223startup: 2162330554sbuild system informationbuild language: javabuild group: stablebuild dist: precisebuild id: 177057771job id: 177057772travis-build version: 0d606872abuild image provisioning date and timesun aug 21 21 22 utc 2016operating system detailsdistributor id: ubuntudescription:    ubuntu 12045 ltsrelease:    1204codename:   preciselinux version3130-92-genericcookbooks versionf77e708  versiongit version 1856bash versiongnu bash version 4225(1)-release (x86_64-pc-linux-gnu)copyright (c) 2011 free software foundation inclicense gplv3+: gnu gpl version 3 or later < is free software you are free to change and redistribute itthere is no warranty to the extent permitted by lawgcc versiongcc (ubuntu/linaro 463-1ubuntu5) 463copyright (c) 2011 free software foundation incthis is free software see the source for copying conditions  there is nowarranty not even for merchantability or fitness for a particular purposellvm versionclang version 34 (tags/release_34/final)target: x86_64-unknown-linux-gnuthread model: posixpre-installed ruby versionsruby-225pre-installed nodejs versionsv01036pre-installed go versions142mysql --versionmysql  ver 1414 distrib 5550 for debian-linux-gnu (x86_64) using readline 62pre-installed postgresql versions912392189314949redis versionredis-server 306riak version202memcached version1413mongodb versionmongodb 2414couchdb versioncouchdb 161neo4j version194cassandra version209elasticsearch version140installed sphinx versions2010219226default sphinx version226installed firefox versionfirefox 3840esrphantomjs version198ant -versionapache ant(tm) version 182 compiled on december 3 2011mvn -versionapache maven 325 (12a6b3acb947671f09b81f49094c53f426d8cea1 2014-12-14t17 23+00:00)maven home: /usr/local/mavenjava version: 170_80 vendor: oracle corporationjava home: /usr/lib/jvm/java-7-oracle/jredefault locale: en platform encoding: utf-8os name: ""linux"" version: ""3130-92-generic"" arch: ""amd64"" family: ""unix""gradle -version------------------------------------------------------------gradle 221------------------------------------------------------------build time:   2014-11-24 09 35 utcbuild number: nonerevision:     6fcb59c06f43a4e6b1bcb401f7686a8601a1fb4agroovy:       236ant:          apache ant(tm) version 193 compiled on december 23 2013jvm:          170_80 (oracle corporation 2480-b11)os:           linux 3130-92-generic amd64lein1 versionwarning: youre currently running as root probably by accidentpress control-c to abort or enter to continue as rootset lein_root to disable this warningwarning: youre currently running as root probably by accidentpress control-c to abort or enter to continue as rootset lein_root to disable this warningdownloading leiningen nowusing jline for console i/o install rlwrap for optimum experienceleiningen 171 on java 170_80 java hotspot(tm) 64-bit server vmlein2 versionwarning: youre currently running as root probably by accidentpress control-c to abort or enter to continue as rootset lein_root to disable this warningdownloading leiningen to /home/travis/lein/self-installs/home/travis/lein/leiningen-251-standalonejar nowleiningen 251 on java 170_80 java hotspot(tm) 64-bit server vmlein versionwarning: youre currently running as root probably by accidentpress control-c to abort or enter to continue as rootset lein_root to disable this warningdownloading leiningen to /home/travis/lein/self-installs/home/travis/lein/leiningen-251-standalonejar nowleiningen 251 on java 170_80 java hotspot(tm) 64-bit server vm$ export debian_frontendnoninteractivereading package listsbuilding dependency treereading state informationlibc6 is already the newest version0 upgraded 0 newly installed 0 to remove and 102 not upgraded$ git clone --depth50 --branchremove-internal-javadoc-links  mockito/mockitocloning into mockito/mockitoremote: counting objects: 3100 doneremote: compressing objects: 100% (1762/1762) doneremote: total 3100 (delta 1276) reused 2086 (delta 919) pack-reused 0receiving objects: 100% (3100/3100) 117 mib | 0 bytes/s doneresolving deltas: 100% (1276/1276) donechecking connectivity done$ cd mockito/mockito$ git checkout -qf 7a4bee38654b052361153cadc1dda5ede068d0ffset hostname to mockito-cd$ sudo hostname mockito-cd## managed by chef on packer-57ba1a4f-8735-ef55-49ff-0a97bf85bb9dceco-emissary-99515internal  ## cookbook:: travis_build_environment##     file:: templates/default/etc/cloud/templates/hoststmplerb127011 testing-gce-e550a994-d659-4a46-bccf-eed57dafea15 testing-gce-e550a994-d659-4a46-bccf-eed57dafea15 ip4-loopback precise64sudo: unable to resolve host mockito-cd## managed by chef on packer-57ba1a4f-8735-ef55-49ff-0a97bf85bb9dceco-emissary-99515internal  ## cookbook:: travis_build_environment##     file:: templates/default/etc/cloud/templates/hoststmplerb127011 testing-gce-e550a994-d659-4a46-bccf-eed57dafea15 testing-gce-e550a994-d659-4a46-bccf-eed57dafea15 ip4-loopback precise64setting environment variables from repository settings$ export nexus_token_user[secure]$ export nexus_token_pwd[secure]$ export gh_token[secure]$ export mockito_bintray_api_key[secure]$ export test_env_var[secure]setting environment variables from travisyml$ export termdumb$ export gradle_opts""-xx:+usecompressedoops -djavaawtheadlesstrue""$ jdk_switcher use openjdk6switching to openjdk6 (java-160-openjdk-amd64) java_home will be set to /usr/lib/jvm/java-6-openjdk-amd64$ export termdumbsetting up build cache$ export casher_dir$home/casher$ installing caching utilitiesattempting to download cache archivefetching remove-internal-javadoc-links/cache-linux-precise-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855--jdk-openjdk6tgzfound cacheadding /home/travis/gradle/caches to cacheadding /home/travis/gradle/wrapper to cache$ java -xmx32m -versionjava version ""160_39""openjdk runtime environment (icedtea6 11311) (6b39-11311-0ubuntu012041)openjdk 64-bit server vm (build 2325-b01 mixed mode)$ javac -j-xmx32m -versionjavac 160_39$ export travis_commit_message$(git log --format%b -n 1 $travis_commit)$ echo ""$travis_commit_message""disables the testng javadoc taskthis task is not configured and shows errors and warningalso the test-ng project is not released yet$ true$ /gradlew cibuild release -dscanstarting a new gradle daemon for this build (subsequent builds will be faster)support for running gradle using java 6 has been deprecated and will be removed in gradle 30parallel execution is an incubating feature clean up-to-date compilejava up-to-date compilegroovy up-to-date processresources up-to-date classes up-to-date jar assemble compiletestjava up-to-date compiletestgroovy up-to-date processtestresources up-to-date testclasses up-to-date test up-to-date check up-to-date buildversion: 2220 exttest:compilejava up-to-date processresources up-to-date classes up-to-date jar assemble processtestresources processresources up-to-date processtestresourcesnote: some input files use or override a deprecated apinote: recompile with -xlint:deprecation for details:processresources up-to-date jar testng testng testng testng testng testng testng testng testng testng:buildinstalling sw-precache globally sourcesjar licensemainunknown file extension: src/main/java/org/mockito/internal/util/concurrent/licenseunknown file extension: src/main/java/org/mockito/internal/util/concurrent/readmemd:licensemain up-to-date:licensetestmissing header in: src/test/java/org/mockitousage/compilationwarningstestjavamissing header in: src/test/java/org/mockitousage/serialization/deepstubsserializabletestjavamissing header in: src/test/java/org/mockitousage/junitrunner/silentrunnertestjavamissing header in: src/test/java/org/mockitousage/junitrunner/unusedstubsexceptionmessagetestjavamissing header in: src/test/java/org/mockitousage/junitrunner/strictrunnertestjavamissing header in: src/test/java/org/mockitousage/verification/delayedexecutionjavamissing header in: src/test/java/org/mockitousage/junitrule/stubbingwarningsmultithreadingtestjavamissing header in: src/test/java/org/mockitousage/junitrule/stubbingwarningsjunitruletestjavamissing header in: src/test/java/org/mockitousage/junitrule/silentjunitruletestjavamissing header in: src/test/java/org/mockitousage/junitrule/ruletestwithparameterconstructortestjavamissing header in: src/test/java/org/mockitousage/junitrule/verificationcollectorimpltestjavamissing header in: src/test/java/org/mockitousage/junitrule/ruletestwithfactorymethodtestjavamissing header in: src/test/java/org/mockitousage/junitrule/mockitojunitruletestjavamissing header in: src/test/java/org/mockitousage/debugging/invocationsprintertestjavamissing header in: src/test/java/org/mockitousage/junitrule/invalidtargetmockitojunitruletestjavamissing header in: src/test/java/org/mockitousage/internal/junit/unusedstubbingsfindertestjavamissing header in: src/test/java/org/mockitousage/bugs/diamondinheritanceisconfusingmockitotestjavamissing header in: src/test/java/org/mockitousage/bugs/classcastexonverifyzerointeractionstestjavamissing header in: src/test/java/org/mockitousage/constructor/creatingmockswithconstructortestjavamissing header in: src/test/java/org/mockitousage/bugs/confusedsignaturetestjavamissing header in: src/test/java/org/mockitousage/bugs/equalswithdeltatestjavamissing header in: src/test/java/org/mockitousage/bugs/creation/publicmethodinparentwithnonpublictypeinsignaturetestjavamissing header in: src/test/java/org/mockitousage/bugs/comparematchertestjavamissing header in: src/test/java/org/mockitousage/bugs/creation/otherpackage/publicparentclassjavamissing header in: src/test/java/org/mockitousage/bugs/injection/issue353injectionmightnothappenincertainconfigurationtestjavamissing header in: src/test/java/org/mockitousage/bugs/creation/constructorinvokingmethodshouldnotraiseexceptiontestjavamissing header in: src/test/java/org/mockitousage/bugs/deepstubs/deepstubswronglyreportsserializationproblemstestjavamissing header in: src/test/java/org/mockitousage/bugs/creation/api/publicclassjavamissing header in: src/test/java/org/mockitousage/performance/stubonlyavoidmemoryconsumptiontestjavamissing header in: src/test/java/org/mockitousage/basicapi/resetinvocationstestjavamissing header in: src/test/java/org/mockitousage/bugs/deepstubs/deepstubfailingwhengenericnestedasrawtypetestjavamissing header in: src/test/java/org/mockitousage/matchers/varargstestjavamissing header in: src/test/java/org/mockitousage/stubbing/stubbingwithdelegatevarargstestjavamissing header in: src/test/java/org/mockitousage/stubbing/stubbingreturnsselftestjavamissing header in: src/test/java/org/mockitointegration/nojunitdependenciestestjavamissing header in: src/test/java/org/mockitoutil/classloaderstestjavamissing header in: src/test/java/org/mockitoutil/simpleperrealmreloadingclassloaderjavamissing header in: src/test/java/org/mockitoutil/classloadersjavamissing header in: src/test/java/org/mockitoutil/testbasetestjavamissing header in: src/test/java/org/mockitoutil/vmargassumptionsjavamissing header in: src/test/java/org/mockitoutil/simpleclassgeneratorjavamissing header in: src/test/java/org/mockitoutil/stopwatchjavamissing header in: src/test/java/org/mockitoutil/junitresultassertjavamissing header in: src/test/java/org/mockitoutil/simpleserializationutiljavamissing header in: src/test/java/org/mockito/verification/negativedurationtestjavamissing header in: src/test/java/org/mockito/annotationsarecopiedfrommockedtypetestjavamissing header in: src/test/java/org/mockito/internal/util/timertestjavamissing header in: src/test/java/org/mockito/internal/util/platformtestjavamissing header in: src/test/java/org/mockito/internal/util/defaultmockingdetailstestjavamissing header in: src/test/java/org/mockito/internal/util/reflection/genericarrayreturntypetestjavamissing header in: src/test/java/org/mockito/internal/util/reflection/supertypeslastsortertestjavamissing header in: src/test/java/org/mockito/internal/util/reflection/generictypeextractortestjavamissing header in: src/test/java/org/mockito/internal/verification/descriptiontestjavamissing header in: src/test/java/org/mockito/internal/util/io/ioutiltestjavamissing header in: src/test/java/org/mockito/internal/verification/verificationovertimeimpltestjavamissing header in: src/test/java/org/mockito/internal/invocation/typesafematchingtestjavamissing header in: src/test/java/org/mockito/internal/verification/verificationwithdescriptiontestjavamissing header in: src/test/java/org/mockito/internal/junit/junitruletestjavamissing header in: src/test/java/org/mockito/internal/junit/stubbingargmismatchestestjavamissing header in: src/test/java/org/mockito/internal/junit/unusedstubbingstestjavamissing header in: src/test/java/org/mockito/internal/junit/argmismatchfindertestjavamissing header in: src/test/java/org/mockito/internal/creation/delegatingmethodtestjavamissing header in: src/test/java/org/mockito/internal/creation/instance/constructorinstantiatortestjavamissing header in: src/test/java/org/mockito/internal/creation/bytebuddy/abstractbytebuddymockmakertestjavamissing header in: src/test/java/org/mockito/internal/creation/bytebuddy/typecachingmockbytecodegeneratortestjavamissing header in: src/test/java/org/mockito/internal/creation/bytebuddy/subclassbytebuddymockmakertestjavamissing header in: src/test/java/org/mockito/internal/creation/bytebuddy/inlinebytebuddymockmakertestjavamissing header in: src/test/java/org/mockito/internal/configuration/classpathloadertestjavamissing header in: src/test/java/org/mockito/internal/creation/bytebuddy/bytebuddymockmakertestjavamissing header in: src/test/java/org/mockito/internal/configuration/plugins/pluginfindertestjavamissing header in: src/test/java/org/mockito/internal/matchers/instanceoftestjavamissing header in: src/test/java/org/mockito/internal/framework/defaultmockitoframeworktestjavamissing header in: src/test/java/org/mockito/internal/hamcrest/matchergenerictypeextractortestjavamissing header in: src/test/java/org/mockito/internal/matchers/text/matchertostringtestjavamissing header in: src/test/java/org/mockito/internal/matchers/text/valueprintertestjavamissing header in: src/test/java/org/mockito/internal/stubbing/defaultanswers/forwardsinvocationstestjavamissing header in: src/test/java/org/mockito/internal/matchers/stringmatcherstestjavamissing header in: src/test/java/org/mockito/exceptions/stacktrace/stacktracecleanertestjava createtestresources  some input files use or override a deprecated apinote: recompile with -xlint:deprecation for detailsnote: some input files use unchecked or unsafe operationsnote: recompile with -xlint:unchecked for details processtestresources up-to-date test compiletestjava testclasses test check buildorgmockitousageverificationverificationwithtimeouttest > shouldallowmixingothermodeswithtimeoutandfail failed    wanted but not invoked:    mockonearg(c)    -> at orgmockitousageverificationverificationwithtimeouttestshouldallowmixingothermodeswithtimeoutandfail(verificationwithtimeouttestjava:103)    actually there were zero interactions with this mock        at orgmockitointernalexceptionsreporterwantedbutnotinvoked(reporterjava:329)        at orgmockitointernalverificationcheckersmissinginvocationcheckercheckmissinginvocation(missinginvocationcheckerjava:38)        at orgmockitointernalverificationatleastverify(atleastjava:31)        at orgmockitointernalverificationverificationovertimeimplverify(verificationovertimeimpljava:78)        at orgmockitointernalverificationverificationwrapperverify(verificationwrapperjava:19)        at orgmockitointernalverificationmockawareverificationmodeverify(mockawareverificationmodejava:21)        at orgmockitointernalhandlermockhandlerimplhandle(mockhandlerimpljava:73)        at orgmockitointernalhandlernullresultguardianhandle(nullresultguardianjava:32)        at orgmockitointernalhandlerinvocationnotifierhandlerhandle(invocationnotifierhandlerjava:36)        at orgmockitointernalcreationbytebuddymockmethodinterceptordointercept(mockmethodinterceptorjava:41)        at orgmockitointernalcreationbytebuddymockmethodinterceptor$dispatcherdefaultingtorealmethodinterceptabstract(mockmethodinterceptorjava:120)        at orgmockitousageimethods$mockitomock$442824988onearg(unknown source)        at orgmockitousageverificationverificationwithtimeouttestshouldallowmixingothermodeswithtimeoutandfail(verificationwithtimeouttestjava:103)1666 tests completed 1 failed 48 skipped:test failedfailure: build failed with an exception* what went wrong:execution failed for task :test> there were failing tests see the report at: file:///home/travis/build/mockito/mockito/build/reports/tests/indexhtml* try:run with --stacktrace option to get the stack trace run with --info or --debug option to get more log outputbuild failedtotal time: 1 mins 29851 secspublishing build information command ""/gradlew cibuild release -dscan"" exited with 1$ rm -f $home/gradle/caches/modules-2/modules-2lockstore build cachechange detected (content changed file is created or file is deleted):/home/travis/gradle/caches/2141/plugin-resolution/cachepropertieslock/home/travis/gradle/caches/2141/scripts/1q4d2xab9ze2xxke3zazxroc2/cp_dsl/cp_dsl-1646510925884990387/cacheproperties/home/travis/gradle/caches/2141/scripts/1q4d2xab9ze2xxke3zazxroc2/cp_dsl/cp_dsl-1646510925884990387/cachepropertieslock/home/travis/gradle/caches/2141/scripts/1q4d2xab9ze2xxke3zazxroc2/cp_dsl/cp_dsl-1646510925884990387/classes/_buildscript_class/home/travis/gradle/caches/2141/scripts/1q4d2xab9ze2xxke3zazxroc2/cp_dsl/cp_dsl-1646510925884990387/classes/_buildscript_$_run_closure1class/home/travis/gradle/caches/2141/scripts/1q4d2xab9ze2xxke3zazxroc2/cp_dsl/cp_dsl-1646510925884990387/classes/_buildscript_$_run_closure1$_closure2class/home/travis/gradle/caches/2141/scripts/1q4d2xab9ze2xxke3zazxroc2/cp_dsl/cp_dsl-1646510925884990387/classes/_buildscript_$_run_closure1$_closure2$_closure4class/home/travis/gradle/caches/2141/scripts/1q4d2xab9ze2xxke3zazxroc2/cp_dsl/cp_dsl-16changes detected packing new archiveuploading archivedone your build exited with 1```</details> ||  i see this test failing even more frequently than before the recent changes to this test? revert? :) || i dont know it may very well of the travis instances activities anyway i just wrote a retry rule since theres none coming with junitits not perfect but this wrong to restart manually the jobs || ";1;0;731 implements retry rule for flaky testsnever the less those tests should be implemented properly retry attempts are set to 4signed-off-by: brice dutheil <bricedutheil@gmailcom>;
775;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removed private ismockitomock(..) in mockutil;small internal refactoring.;;0;pre-populate cache; pre-populating a cache is a common use case for loading static data from a database this would also be specifically useful where lazy loading is not ideal please see  for a specific case where this would be usefulit would be ideal to create an interface that can pre-load all static data from the database and add it to the cache at start-up such as:cachebuildernewbuilder()populate(new cachepopulator&ltstring element>(){```@overridepublic map<string element> populate() throws exception {    return getallelements()}```})build(new cacheloader&ltstring element>(){```@overridepublic element load(string key) throws exception {           return getelement(key)}```}); first of all kevin thanks secondly if you mean the ""feature request"" from actual stack overflow question then its exactly what i had in mind actually i havent looked into this issue since i wrote my last message so im not sure where we stand now i simply wanted to encapsulate whole loading logic inside the cacheloader interface which just seems more in line with what is already there i dont have any strong feelings for or against it thoughi can make another issue but i dont see the point if youre not sharing my point of view its still a decent api even if i cant pre-populate the cache  michał || but what if i need the data be populated repeatedly on eviction time is over? putall doesnt handle that isnt it? || i am currently in the same situation as abovei dont know all of the possible keys at runtime i have a db table that i do lookups on frequently (>10k requests per minute) the entire db table could be stored in memory and refreshed on a set intervalfor my use case i had started looking at suppliers#memoizewithexpiration however since the cache is so frequently used it would be preferable to have a non blocking refresh at a given intervali have raised  for discussion on an implementation using suppliers but i still wish there was a way to do this in a `loadingcache` || i also have demands for this and like to add another point why i think none of the workarounds really satisfies me:- first of all i dont know if the cache is accessed at all so i dont want to fill the cache at init time- even when this wont be an issue the cache needs to be created as fast as possible (application startup) later on i dont really mind a small delay as the application is up and running and i can show waiting indicator to the user- second (as described with the webservice in comment before) it is equally expensive to retrieve one value or all (current) values- beside that i dont know all keys in advanceso what would be need is some kind of ""preloadkeys(t )"" that behaves the following way:1) if it is passed an empty array and the cache is empty while accessed by a get operation `cacheloaderloadall(iterable<? extends k>)` is called with a null argument or if that is not desireable a special (empty) iterable instance that could be checked eg load_all  collectionsempty_list2) if it is passes a non empty array and any of the kexs is accessed `cacheloaderloadall(iterable<? extends k>)` is called instead of simple load || ";;;;0;1;;
775;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removed private ismockitomock(..) in mockutil;small internal refactoring.;;0;removed private ismockitomock() in mockutil;small internal refactoring; ;;;;1;1;removed private ismockitomock() in mockutil;
775;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removed private ismockitomock(..) in mockutil;small internal refactoring.;;0;"expose number of ""live"" nodes";;;;;;1;1;"expose number of ""live"" nodes";
775;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removed private ismockitomock(..) in mockutil;small internal refactoring.;;0;naming of create/bind/operator functions and types;"changes are being done in  as a result of discussion in  that add a new `bind` operator and change the `create` signature to inject a `subscription` instead of returning it the reasons for this change can be seen at  names have thus far been left as is or as raw functions while achieving the right functionality before releasing and becoming part of the published api id like to finalize the names (some of which have been disputed)### 1) ""source"" function``` javaaction1<operator<? super t>>```this is the single function that exists inside an `observable` that is executed upon subscription (when `subscribe` is invoked)the previous function was called `onsubscribefunc<t>` we could just keep the `action1` signature but the generics are obnoxious to remember type and code-complete having a specific type is for ease of usethis will be the most used of the types discussed in this issue as all `observablecreate` usage will involve this type most users of rxjava will use `observablecreate`a possibility is:``` javapublic static interface onsubscribe<t> extends action1<operator<? super t>> ```or it could more explicitly (and like `onsubscribefunc`) be:``` javapublic static interface onsubscribe<t> extends function {        public void onsubscribe(operator<? super t> op)        }```what other names could this be?### 2) ""bind"" or ""lift"" methodthe new method added to `observable` has a name and signature like this:``` javapublic <r> observable<r> bind(final func1<operator<? super r> operator<? super t>> bind)```the intent is to perform function composition and return a new `observable` representing the composition since my computer science lambda calculus etc is not the greatest i was calling this `bind` but after discussion with others it seems this is probably better called `lift` as per functional programming principles that said there is nothing requiring us to use names such as thesethe intent of this method is to chain together operators for transforming combining filtering and operating on data flowing through an `observable` and each time its chained it returns a new `observable` for example:``` javaobservable<u> ou  observable<t>chain(operatora)observable<v> ov  observable<u>chain(operatorb)observable<w> ow  observable<v>chain(operatorc)```typically this would be used like this:``` javaobservable<w> ow  observable<t>chain(operatora)chain(operatorb)chain(operatorc)```here are possible names:``` javapublic <r> observable<r> bind(function<t r> f)public <r> observable<r> lift(function<t r> f)public <r> observable<r> compose(function<t r> f)```what is the correct name for this?### 3) ""bind"" or ""lift"" functionthe function that the currently named `bind` takes is:``` javafunc1<operator<? super r> operator<? super t>>```this could be left as is and will generally only be used by people implementing operators thus it is not in the ""common path"" for using rx however it could benefit from the clearer communication of a specific type and namepossibilities include:``` javaonbind<r t>onlift<r t>bindfunction<r t>liftfunction<r t>composition<r t>```should we give this a specific type and name? if so what should it be?### 4) operator classas part of the new `bind` and `create` functionality that injects `subscriptions` into the source function a new type `operator` was created that combines `observer` and `subscription` ``` javapublic abstract class operator<t> implements observer<t> subscription```is `operator` the correct name? if not what should it be called?---## possible outcomes``` java// use `onsubscribe` for the ""source"" functionpublic final static <t> observable<t> create(final onsubscribe<t> f)// use `compose` and `composition` as user friendly representations for the `bind`/`lift` functionalitypublic <r> observable<r> compose(final composition<r t> cf)// leave `operator` as ispublic abstract class operator<t> implements observer<t> subscription```or``` java// use `onsubscribe` for the ""source"" functionpublic final static <t> observable<t> create(final onsubscribe<t> f)// use `compose` for the name but leave the functionpublic <r> observable<r> compose(final func1<operator<? super r> operator<? super t>> cf)// leave `operator` as ispublic abstract class operator<t> implements observer<t> subscription```or``` java// use `onsubscribe` for the ""source"" functionpublic final static <t> observable<t> create(final onsubscribe<t> f)// use `lift`public <r> observable<r> lift(final func1<operator<? super r> operator<? super t>> cf)// leave `operator` as ispublic abstract class operator<t> implements observer<t> subscription```etc---my intent is to solidify the naming before releasing 0170 as these are not easy to change once releasedplease provide your suggestions and reasoning either to support one of the options above or for something newthank you!";"how about``` javaobservable<t> o  observable<t>with(operatora)with(operatorb)with(operatorc)``` || > public <r> observable<r> bind(final func1<operator<? super r> operator<? super t>> bind)this is actually an instance of map since it takes (operator<t>->operator<s>) to (observable<s>->observable<t>) so ""lift"" would be the geek name i like @akarnokd proposal to use leverage english to emphasize the fluent style using ""with"" sounds ok  || > func1<operator<? super r> operator<? super t>>for this one i actually like keeping func1 otherwise id have to unfold the synonym that is because i remember```(operator<s>->operator<t>) ->(observable<t>->observable<t>)```that is easier than```(xxx<st>) -> (observable->observable)``` || > public static interface onsubscribe<t> extends action1<operator<? super t>>i like this one with```public static interface onsubscribe<t> extends function {        public void onsubscribe(operator<? super t> op)        }```i need to mentally translate too much || > public abstract class operator<t> implements observer<t> subscriptioncant we just make observer implement subscription? less types is better || this would be my choice as i said not sure the last one works```// use `onsubscribe` for the ""source"" functionpublic final static <t> observable<t> create(final onsubscribe<t> f)// use `with` for the name but leave the functionpublic <r> observable<r> with(final func1<observer<? super r> observer<? super t>> cf)// modify observerpublic abstract class observer<t> implements  subscription {  }``` || note that `with` is a keyword in scala so in scala well need a different name || what would be a good word for ""before"" since ""bind"" is contravariant it chains the transformations in reverse order in my younger days when algol 68 was all the rage if then else fi while do od case esac i would propose neht but i am sure that this would not fly in 2014 -) || im not sure if i like having observer implementing a subscription now you can have the same observer instance subscribed to more than one observable if you so wish and what you unsubscribe is the observable <-> observer association i guess it would be okay if observer were to become only an internal type also there might be some strangeness with subjects || after playing with this last night im beginning to like the idea of changing `observable` to a abstract class that extends `compositesubscription`  the two argument creators on `operator` seem awkward  does it make sense to allow the same `subscription` was used to create two different `operator`s with different `observable`s or vice versa?  if `observable` was the `operator` you wouldnt need any of thatchanging from an interface to an abstract class would minimize the breakiness to just forcing everyone to switch from `implements` to `extends` for just named classes (anonymous inner classes wouldnt need to change)come to think of it are there any other `subscription` types?  should we think of this as renaming `compositesubscription` to `observer` and adding three abstract methods `onnext``onerror``oncompleted`? || i too dont think making `observer` extend `subscription` is a good approach#### 1) conflates responsibilitywhen using an `observable` it is rare that someone needs to concern themselves with the `subscription` unless they are implementing an operator by making `observer` extend `subscription` we would be forcing all users to always concern themselves with itwhat does implementing `unsubscribe` even mean when just providing an `observer` to an `observablesubscribe(observer)` when one just wants to subscribe to the data?this is what we (users) would have to implement:``` java    new observer<string>() {        @override        public void oncompleted() {        }        @override        public void onerror(throwable e) {        }        @override        public void onnext(string args) {        }        public final void unsubscribe() {            // what to do here?        }    }```in most cases i dont know what the `unsubscribe` method should do it certainly wouldnt be implemented correctlycontrast this with the current `observablesubscribe` which handles the subscription:``` javapublic final subscription subscribe(observer<? super t> observer)  {    simplified    operator<t> op  operatorcreate(observer new compositesubscription())   subscribe(op)   return op}```this is not logic that most users of rx should ever have to worry about i feel that `observer` and `subscription` should be kept separate and that we have a type such as the current `operator` that combines them when needed#### 2) major breaking changethis would be a massive breaking change to anyone using rxjava there is no mechanism for making it backwards compatible or providing a deprecation strategy || im not sure if you were replying directly to my statement  what about making `observer` and abstract class where `unsubscribe()` in implemented for you?  in fact it should probably be final so that users would have to `add(subscription)` to register a unsubscribe callback when needed || > im not sure if you were replying directly to my statement i was replying to @headinthebox but it applies to yours as well (we posted within minutes of each other)> what about making observer and abstract class where unsubscribe() in implemented for you?perhaps but its still a pretty major breaking change i can see some limited benefit in an `observer` being able to call `unsubscribe` but that is supported by the `subscribe(operator)` interface and its very rare that people are doing that in the final `observer` since they generally should be using things like `take` and `takeuntil` for controlling when an `observable` is unsubscribedthe problem obviously is that we now have 2 ways of subscribing:``` javapublic subscription subscribe(observer<? super t> observer)```and``` javapublic void subscribe(operator<? super t> o)```so the real question is whether we are willing to have a massive breaking change where we eliminate all of the `subscribe` methods that return `subscription` and if so why are they called `subscribe` anymore? perhaps just `observe`?if we were starting from scratch i wouldnt have the `subscription subscribe(observer)` methods only `void observe(observer)` || another problem i just considered  `subject` must extend from from `observable` and implement `observer` java doesnt support multiple-inheritance so we cant have `observer` be an abstract classthus if we make `observer extend subscription` it can only be an interface which means everyone must implement `unsubscribe()` which we dont want || what exactly is wrong with the name `operator` since everyone casually calls them ""operator"" anyways and the package they all live in is `rxoperators`? || putting the mi part aside i a do not agree with `   what does implementing unsubscribe even mean when just providing an observer to an         observablesubscribe(observer) when one just wants to subscribe to the data?`it just means dont do anything just like now when you do an observablecreate and return a subscription by subscribing to another observable in net enumerator inherits idisposable and in most cases the idisposable just does nothing i see absolutely nothing wrong with thatnow most of the time people do not even pass observers directly but just the onnext onerror or oncompleted functions to most of the time they wont even notice || > what exactly is wrong with the name operator  operator is typically a function3 || i would say keep just one subscribe``` subscription subscribe(observer) ```instead of returning void there is no harm in returning the (augmented) subscription in both bases || > now you can have the same observer instance subscribed to more than one observablethat is not a smart idea anyway not sure if that would always guarantee that calls to onnext are serialized if they get called from tow independ observables || this is the signature that starts the `observable`:``` javavoid subscribe(observer&subscription o)```the `subscription` specifically needs to be of type `compositesubscription` and is the seed for the entire sequence also it must have the `add` and `isunsubscribed` methods:``` java    private final compositesubscription cs    public final void add(subscription s) {        csadd(s)    }    public final void unsubscribe() {        csunsubscribe()    }    public final boolean isunsubscribed() {        return csisunsubscribed()    }```thus a user can not just pass in an empty `unsubscribe` they must pass in the exactly correct implementation which is not at all what a user should have to do this is why `subscribe(observer)` does this internally:``` javaoperator op  operatorcreate(observer new compositesubscription())subscribe(op)```if `observer` implements `subscription` it would not change this as `compositesubscription` is more than the `subscription` interfacethus we would now have users implementing an `unsubscribe` method with no hook to the thing it should unsubscribe from``` java        subscribe(new observerthatextendssubscription<string>() {            @override            public void oncompleted() {            }            @override            public void onerror(throwable e) {            }            @override            public void onnext(string s) {                // receive data                if(s  null) {                     unsubscribe()                }            }            public void unsubscribe() {                // what do i do here?                // i want to do this >                parentsubscriptionunsubscribe()                // but there is no hook to a ""parentsubscription""            }        }```the problem is that if im implementing just an interface there is no ""parentsubscription"" passed in that i can do something with thus what would someone do inside the `unsubscribe` method they implement in their `observer`? there is nothing they can dothe only way i see to make this work is to replace the `observer` interface with the abstract class `operator` this would indeed work as then it is a legit `subscription` backed by a `compositesubscription` but it wont work with `subject` as java doesnt support multiple inheritance and `subject` needs to extend both `observable` and `observer`using this abstract class would work exactly like the current `operator` class does like this:``` java        subscribe(new operatororobserver<string>() {            @override            public void oncompleted() {            }            @override            public void onerror(throwable e) {            }            @override            public void onnext(string s) {                // receive data                if (s  null) {                    unsubscribe() // this will now work                }            }        })```this would work great except for (1) its a massive breaking change and (2) subjects would all break || > that is not a smart idea anyway not sure if that would always guarantee that calls to onnext are serialized if they get called from tow independ observablesagreed but its additional flexibility that comes from separating those ideas and the  `subscription subscribe(observer)` signature would be misleadinganother benefit is that now a subscription can be shared between a chain of observers whereas otherwise each operator would have to cancel the parent observer which in turn would cancel its parent and so forth || > but it wont work with subject as java doesnt support multiple inheritance and > subject needs to extend both observable and observerone way around that would be to make it have a toobservable method || talking with @headinthebox and @abersnaze we have discussed taking these changes all the way instead of part-way as done so far and doing the following:change `interface observer<t>` to an abstract class:``` java// observer & subscription public abstract class observer<t> implements subscription {    public static create(onnext)    public static create(onnext onerror)    public static create(onnext onerror oncompleted)    abstract void onnext(t)    abstract void onerror(throwable)    abstract void oncompleted()    final add(subscription)    final unsubscribe()    final boolean isunsubscribed()}```this would effectively be the same class as is currently `operator`then `subject` would change to:``` javasubject<t> extends observer<t> {    public observable<t> toobservable()}```this would allow `subscribe(operator)` and `subscribe(observer)` to collapse into onethe benefit of this is:- no new types just `observer`- it forces subscribing ""the right way"" where an `observer` can `unsubscribe` even on synchronous dataregarding the naming of `bind` we decided that `bind` is not the correct name as it is not exactly a `monadic bind` it is in fact a `lift` or `transform` we feel it is likely better to stick to proper cs or mathematical names for this functionthus it will be:``` java// lift public <r> observable<r> lift(final func1<observer<? super r> observer <? super t>> cf) or public <r> observable<r> transform(final func1< observer <? super r> observer <? super t>> cf)```this means version 017 will be a significant breaking release we will leverage this to do all of the breaking changes here including removing deprecated methods and changing `scheduler` to explicitly have inner/outer || would it make sense for observer to extend from compositesubscription as it will have those semantics? being able to do observercreate({ })add(observercreate{}) still feels a bit weird i wonder if this approach is just due to a limitation of javas type system as we cant express `observer with subscription` without explicitly introducing a new type || > would it make sense for observer to extend from compositesubscription as it will have those semantics?i dont think we want to expose the `clear` and `remove` methods that `compositesubscription` has also i consider the use of `compositesubscription` inside `observer` an implementation detail we could use something different if it makes sense so i dont want to commit long-term to `compositesubscription`> observercreate({ })add(observercreate{})it looks odd like that but there are actually use cases where i think thats more-or-less what well do (zip groupby merge) albeit with a little more code involved and not directly chained like thatthere are always things we can do that shouldnt be done such as this infinite loop with a `subject`:``` javasubject<string string> s  publishsubjectcreate()ssubscribe(s)```this fits into the ""dont do that"" category similar to `aninfiniteobservabletolist()`> i wonder if this approach is just due to a limitation of javas type systemi dont know regarding this specific decision we are limited in our implementation design though due to things such as lack of extension methods which drives us to use `abstract class` instead of `interface` for `observable` and now `observer` and then that affects `subject` since we cant have multiple inheritance || here is my branch working on this refactor as a preview of the changes:  biggest issue i now have is figuring out how to make the unit tests work since `mock(observerclass)` can no longer be used (the abstract method constructor is not invoked and thus the subscription state is null) probably going to sleep on it  enough carpal tunnel pain on tedious refactoring for one night || i dont quite understand why observer and subscription needs to be merged this way i got pretty ""far"" with one of the previously suggested structures:``` javaprivate final action2<observer<t> compositesubscription> onsubscribe    private obsurvable(action2<observer<t> compositesubscription> onsubscribe) {        thisonsubscribe  onsubscribe    }    public subscription subscribe(observer<t> obsurver) {        compositesubscription token  new compositesubscription()        onsubscribecall(obsurver token)        return token    }    public subscription subscribe(observer<t> obsurver compositesubscription token) {        onsubscribecall(obsurver token)        return token    }    public static <t> obsurvable<t> create(action2<observer<t> compositesubscription> onsubscribe) {        return new obsurvable<>(onsubscribe)    }    public <u> obsurvable<u> bind(func2<observer<u> compositesubscription observer<t>> binder) {        return new obsurvable<>((o t) -> onsubscribecall(bindercall(o t) t))    }```this way both `create((u k) -> { })` and `bind((u k) -> t)` offers a composite subscription `k` which can be naturally closed over with an observer (or that of the operator if one really wants to reduce inner class clutter) the ""when to unsubscribe"" remains largely the same || it definitely works on the previous signatures i was arguing for leaving `observer` as is but @headinthebox and @abersnaze convinced me to pursue changing `observer` the argument was for 1) having a signature that only dealt with `observer` rather than `observer` and some other `subscription` implementationin other words specifically avoiding methods like you show:``` java(observer<t> obsurver compositesubscription token)(action2<observer<t> compositesubscription>)(func2<observer<u> compositesubscription observer<t>>)```that is where i started this journey at and it works just fine as you say making `observer` implement `subscription` is taking it to the extreme possibly end state as i see it allowing the signatures to be simpler like this:``` java(observer<t> obsurver)(action1<observer<t>)(func1<observer<u> observer<t>>)```2) elegance due to simpler signatures while it ends up ""doing the right thing"" in all cases rather than a user having to choose the right signature if they want unsubscribe supportits quite nice now that any `subscribe(observer o)` can call `unsubscribe()` from within an `onnext()` method any user of rx can do that with this `observer implements subscription` design whereas the code on master right now requires them choosing a different `subscribe` overload > the ""when to unsubscribe"" remains largely the sameyes this last set of changes is purely one of semantics and signature design the change in functionality is already what was merged into master that added the `bind`/`lift` function it basically was the discussion with @headinthebox that if we were starting from scratch with this `lift` model we wouldnt have combined `observer` and `subscription` so how about lets try and get it all refactored to that model now before we hit 10 instead of keeping signatures of ""old"" and ""new"" || apparently im too late to the party (just seen the 017 release notes preview) but i wanted to say it anyway: the mathy-sciency-geeky `lift` thing sounds scary to me im a programmer i dont want to care about category theory i want to chain method calls give me `chain` or `with` and im a happy guy i could understand `andthen` or `compose` but i get a little bit nervous with `bind` with `lift` im just put off thanks for listening to this complaint :-) || >  the mathy-sciency-geeky `lift` thing sounds scary to mei understand this sentiment im torn on this one but there is a principle that pushed us towards using `lift` we try hard not to re-invent new names for things when they already have names arbitrarily putting ""plain english"" names on top of things does not really help our industry as then we have multiple synonyms for the same concept or functionality and moving across languages and libraries is made more difficult than it should bepart of the goal for rx is to be consistent across platforms and languages which is why we work with @headinthebox and @mattpodwysocki to try and stay as close as we can as we have pursued this path with `lift` and `subscriber` @headinthebox has mediated across languages another aspiration is to not try and redefine what operators and functions mean if we are using capabilities from ""functional programming"" or ""math"" it is our perspective that it is better for us to learn and use the proper names for things so we can speak the same language take the `map` function for example:  that has become common in imperative languages even though the name originates from functional programming and is not plain english like ""transform""last we have avoided adding new types as much as possible and let the functional interfaces stay as such in most places such as `func1<subscriber<? super r> subscriber<? super t>>` as seen in  we tried very hard to not end up adding the new `subscriber` type but the cost of not having it was worse than adding the typeall that said > with lift im just put off what specifically puts you off about this?despite not liking the concept of alias methods im not against having one if it is truly a blocker for users nor is the name `lift` locked in stone yet as we have not yet released nor was there much feedback (though @headinthebox has a very big say in this matter and i invite his input on this) || ben first let me say that i very much appreciate your detailed explanation i beg to differ though with rxjava you are a bit in a special position as you are bringing rx to masses of java programmers (which is a big deal itself) and you are also innovating on rx at the same time (this `operator`+`lift` thing is new and doesnt exist in other rx implementations afaik) this requires careful api design of which naming things is an important part of course its a highly subjective matter and in the end its your call i just wanted to present a different opinionwhat ive seen is that apis in mainstream-ish languages tend to name things differently from the computer science ""upstreams"" `map` is a bit of an exception as it kinda makes sense as a synonym for `transform` (transformation is a _mapping_ from source to target) though its called `transform` somewhere and even `select` elsewhere (in linq and rxnet/rxjs where `map` is defined as an alias) and looking at monadic `bind` thats called `flatmap` in scala and most other mainstream-ish languages/libraries linq and rxnet/rxjs call it `selectmany` (rx defines a `flatmap` alias) and dart uses `expand` (which is imho almost perfect) `fold` is often called `reduce` (or like in scala `reduce` is a special case of `fold`) or even `aggregate` et cetera so again i believe its common to diverge from functional/cs terminology in mainstream and i guess that the reason is understandabilityregarding `lift`: looking at  it looks like for practical purposes `lift` is a function that is used in function composition eh come on what we have here is a chain of method calls that creates a chain of operators (which is a great name btw!) and what we are looking for is a name of a method that adds a previously-unknown operator to the chain to me `lift` doesnt come even close its more abstract yes but more abstract doesnt necessarily mean more good for me [part of] rxs awesomeness lies in its accessibility to masses abstraction over abstraction is usually an opposite of that || @ladicek your make a strong argument and im willing to concede and make a change that benefits ease of adoption and comprehension id like others to weigh in on this  so /cc @samuelgruetter @jmhofer @zsxwing @mairbek @mattrjacobs @abersnaze @akarnokd @michaeldejong @mttkay @jakewharton @loganj @adriancolethe proposal is to change from:``` javapublic <r> observable<r> lift(final func1<subscriber<? super r> subscriber<? super t>> lift)```to ``` javapublic <r> observable<r> chain(final func1<subscriber<? super r> subscriber<? super t>> chain)```the use is for custom operator chaining such as:``` javaobservable<string> os  observable_of_integerschain(take_5)chain(map_integer_to_string)```more information about the background on this can be found at  in summary form || @benjchristensen thanks for asking  for what its worth i disagree with @ladiceks reasoning if not the proposed changethere are a number of good criteria for choosing a function name but whether or not its ""scary"" because it has the whiff of math about it doesnt strike me as one of them`lift` has the advantage of actually being a well-known name for that function  people familiar with it will immediately know what it is and how to use it  people who are not will have a body of knowledge to draw from if they go searchingthat said `chain` is also a perfectly fine name and you could always make `lift` an alias or just mention it in the javadoc || thanks for your input @loganj i appreciate you taking the time to weigh in and you make good points || thanks @loganj for your input i agree that ""it looks scary"" is a lousy argument however it looks scary enough to make me join this discussion dont underestimate the power of fear :-)anyway let me rephrase an argument im trying to make here i argue that its common for mainstream to have a different terminology from the math/computer science origins i hope you will agree with me on that (we dont necessarily have to agree on whether its a good thing or not) and i argue that we shouldnt deviate from the common practiceone other example of importance of good naming darts core library (dart:async) has a class called stream which is essentially observable and they have these two methods called `map` and `transform` i like the name stream i like their map (its the same as ours map) but i hate their transform its not an alias for map its this exact bind/lift/chain thing tbh id much rather have it called lift than transform :-) || i think this is settled || yup || ";;;;0;1;;
776;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;invocationmatcher internal improvements;invocationmatcher internal improvements;;0;guava 1001 import javaxannotationnullable;pondruska+o@ <b>what steps will reproduce the problem?</b>1 add guava-1001jar guava-gwt-1001jar to build path2 compile gwt module<b>what is the expected output? what do you see instead?</b>compiling module ***&nbsp&nbsp&nbspvalidating newly compiled units&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp[error] errors in jar /***/guava/guava-gwt-1001jar!/com/google/common/base/charmatcherjava&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp[error] line 29: the import javaxannotationcheckreturnvalue cannot be resolved&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp[error] line 871: checkreturnvalue cannot be resolved to a type&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp[error] line 908: checkreturnvalue cannot be resolved to a typealso complains not being able to find javaxannotationnullable<b>what version of the product are you using? on what operating system?</b>guava 1001 gwt 240 java se 16<b>please provide any additional information below</b>there are """" issues against guava r09 but clearly referring to javaxannotationnullable and checkreturnvalue in guava which does not provide them (and not docs mention where to get those)";pondruska+o@ not sure why this was marked obsolete  i just spent over an hour getting guava version 17 to work in gwt and i had to do the annotationgwtxml trick || can anyone upload a project demonstrating this problem? my attempts to reproduce it have failed || ";;;;0;1;;
776;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;invocationmatcher internal improvements;invocationmatcher internal improvements;;0;invocationmatcher internal improvements;invocationmatcher internal improvements * added missing @override annotations to reduce warning count * simplified parameter comparison in hassamemethod() *  compile error due to char conversion in matcherstest; ;;;;1;1;invocationmatcher internal improvements * added missing @override annotations to reduce warnong count * simplified parameter comparison in hassamemethod();
776;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;invocationmatcher internal improvements;invocationmatcher internal improvements;;0;lazily load recordcursor in recordprojectopereator;;whats the benefit of doing this? || this code avoids an out-call while holding a lock  eric ;;;;1;1;lazily load recordcursor in recordprojectopereator;
776;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;invocationmatcher internal improvements;invocationmatcher internal improvements;;0;performance testing;i would like to integrate performance testing as a first-class aspect of rxjava-core in  option is google caliper:  is jmh:  potential interest netty uses jmh:  have placed some very simple manual performance tests in the /src/perf folders for now but id like to establish the tooling and a few solid examples so we have a pattern to follow;/cc @abersnaze as youve been involved in these discussions and youre researching google caliper || i would very much recommend using jmh and not caliper the latter has lots and lots of issues which are addressed in the former heres a great [presentation]( about it || thank you for weighing in and sharing that presentation just read through it very interesting can you  point to anything about the issues with caliper? || @gvsmirnov jmh looks technically pretty impressive but seems not to integrate as nicely as caliper in an ide workflow i could only find some very brief comments about intellij integration on the web do you know more also as @benjchristensen says the presentation is super interesting but does not answer the question why caliper is not a good choicea side question about all his benchmarking stuff is how much it relates to performance in production ie when running the benchmarks you measure things in a very specific way but in production it runs in a completely different environment it sometimes feels to me like measuring calories using a  which does not really correspond to the actual digestion of food to try to state it more formally is benchmarking monotonic in other words does benchmark(a) < benchmark(b) imply that inproduction(a) < inproduction(b)? || @benjchristensen unfortunately there is no article/presentation/whatever which explicitly points out all the pitfalls of caliper that i know of but for most of the common problems (outlined in the presentation) caliper has no built-in means to work around (the last time i checked at least) the most broken thing about caliper is that it falls victim to loop unrolling see [here]( is all about taking the trouble off our shoulders especially the trouble we do not even suspect exists many things that are hard to implement in caliper (like [this]( and [that]( and [that]( are easy to do in jmh@headinthebox now regarding ide support there is indeed next to no of it but i personally hardly ever use ide for things like running tests or working with vcss command-line utilities work fine for me and for jmh they are much better that your average cli tool || i have just started a [mechanical-sympathy thread]( that discusses this subject there will probably be a lot of info there in a couple of days || thank you @gvsmirnov for the information this is something i hope well make a first-class aspect of rxjava in the near future and your information will really help are you interested in helping us bootstrap rxjava with jmh? the rxjava-core/src/perf/ code is wide-open right now to setup correctly || @benjchristensen i most definitely am there are some spare time issues at the moment though so i dont think i will be able to contribute for a couple of weeks afterwards i would be happy to || i understand that problem! once you have some time id appreciate your help to get us started down the right path || some observations on the difference now that ive actually used both of them:caliperpros- it also measures object count+memory usage as well as time- makes it clear that is monitoring jit and gc events during the timing- parameter annotations makes easier to test different configurations without having to generate a method for each combination manuallycons- warm up is a bit a black box  ive seen the warnings that it has detect jit during measurement often enough that it makes me think that it isnt doing enough to warm up the code- it uploads the results!ps im not an expert in either benchmarking tool || @benjchristensen sorry it took me so long but im finally back ive thrown together a sample gradle project with jmh support [here]( hoping to integrate it with rxjava real soon || oh finally! i have sent a pull request ( with the updated jmh benchmarking it features changes both to the gradle setup and to the benchmark itselfthe gradle set up us explained in [this blog post]( benchmark is changed in such a way that prevents most of the caveats (like dce) from happening while also ensuring that more accurate results are attained please consult [these samples]( to gain deeper insight into how benchmarking should be done with jmhhere are the results that i got on my haswell 26 ghz 16 gb ram laptop with java 8:```benchmark                                  (size)   mode   samples         mean   mean error    unitsroobservablebenchmarkmeasurebaseline         1   avgt        10        0003        0000    us/oproobservablebenchmarkmeasurebaseline      1024   avgt        10        2764        0051    us/oproobservablebenchmarkmeasurebaseline   1048576   avgt        10     3104088       49586    us/oproobservablebenchmarkmeasuremap              1   avgt        10        0100        0003    us/oproobservablebenchmarkmeasuremap           1024   avgt        10        5036        0059    us/oproobservablebenchmarkmeasuremap        1048576   avgt        10     6693271      277604    us/op```what we see here is that doing nothing rxjava introduces about a 2x overhead in latency compared to simply doing nothing pretty acceptable if you ask me || this is great @gvsmirnov thank you!is there a way to maintain historical snapshots over time for getting performance diffs?  || @benjchristensen youre very welcomeuh im not exactly sure if there is an established practice with that you can easily get jmh to output its results in csv scsv or json should not be a long way from therewhat im doing is: before merging anything to master run the benchmarks on master and on the branch works fine for me || we have jmh integrated and being used so closing this thank you @gvsmirnov  for your help on this! ||;;;;0;1;;
777;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced objectbox with atomicreference;removed objectbox in favor of atomicreference.;;0;enumsvalues() method; just a small suggestion:add a method to enums:public static &lte extends enum&lte>> immutablelist&lte> values (class&lte> clazz)the method maintains a static weak-key cache mapping the enum class to an immutablelist of the valuesthis can be used instead of the inefficient enumvalues() that returns a newly allocated array every time arrays suck mutability sucks and inefficiency sucks toothe only wrinkle is that base never imports from collect; _issue #1022 has been merged into this issue_ || ";;;;0;1;;
777;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced objectbox with atomicreference;removed objectbox in favor of atomicreference.;;0;replaced objectbox with atomicreference;removed objectbox in favor of atomicreference;please add more description even though the change is easy and better ) ||  ;;;;1;1;replaced objectbox with atomicreference;
777;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced objectbox with atomicreference;removed objectbox in favor of atomicreference.;;0;update to hadoop-cdh4 03 and hive-apache 03;;;;;;1;1;update to hadoop-cdh4 03 and hive-apache 03;
777;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced objectbox with atomicreference;removed objectbox in favor of atomicreference.;;0; testsinglesourcemanyiterators;converted to a single-threaded test;#691  thanks @akarnokd sorry i didnt get around to this sooner ||;;;;1;1; testsinglesourcemanyiterators;
778;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;valueprinter small improvements;* added private construtor;;0;removallisteners semantics bug;nto@ i was looking at the removallistenersasynchronous() method and the javadoc promises that it ""processes all eviction notifications asynchronously"" however the implementation in 1001 calls executorexecute() whose javadoc [1] mentions that ""the command may execute in the calling thread""if i am reading this correctly this would make the eviction notification synchronous should removallistenersasynchronous() be using an executorservice and calling the submit() method instead?[1] http://downloadoraclecom/javase/6/docs/api/java/util/concurrent/executorhtml#execute%28javalangrunnable%29"; ;;;;0;1;;
778;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;valueprinter small improvements;* added private construtor;;0;valueprinter small improvements;" * added private construtor * removed unneccessary else statements * added missing type arguments * replaced `new arrayiterator(new string{""""}) `with `emptyiterator()` in_printvalues()_";   build break for java 16  emptyiterator() -> since 17 ||  ;;;;1;1;valueprinter small improvements * added private construtor * removed unneccessary else statements * added missing type arguments * removed handling of a null iterator in printvalues() if null ispassed a npe is thrown now to indicate a bug;
778;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;valueprinter small improvements;* added private construtor;;0;allow having multiple hive plugins;;;;;;1;1;allow having multiple hive plugins;
778;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;valueprinter small improvements;* added private construtor;;0;fix zip race condition;"the itemobserver collection logic needs to run in both the onnext and oncompleted handlers otherwise you might have values waiting to be emitted and without seeing an oncompleted i couldnt think of an easy unit test for this it actually took a while to narrow down the examplethe only way i could reproduce it on my machine was to use hystrix and it happens somewhat sporadically (10-50 iterations)``` javapublic class test {  public static class dummycommand extends hystrixcommand<integer> {    protected dummycommand() {      super(hystrixcommandgroupkeyfactoryaskey(""dummy""))    }    @override    protected integer run() throws exception {      threadsleep(1)      return 1    }  }  public static void main(string args) throws interruptedexception {    while (true) {      observablezip(tap(new dummycommand()observe()) tap(new dummycommand()observe()) new func2<integer integer integer>() {        @override        public integer call(integer a integer b) {          return a + b        }      })toblockingobservable()single()      systemoutprintln(""\n\n\n"")      threadsleep(5)    }  }  public static observable<integer> tap(observable<integer> observable) {    return observabledooneach(new action1<notification<? super integer>>() {      @override      public void call(notification<? super integer> notification) {        systemoutprintln(""notification  "" + notification)      }    })  }}```";#692 not sure why it failed since it passes locally and zip is not used in that test case is there a way to re-trigger the build? || nice catch basically you need something like t1:onnext (t1: oncompleted t2: onnext) t2: oncompleted where t1 oncompleted wins the lock over t2: onnext then t2 oncompleted just doenst do anything as the queues arent empty i confirm your fix solves this issuewe have a few unreliable tests and rerunning might not produce success closing and reopening the pr might trigger a run but im not sure || @benjchristensen any idea on how to re-trigger ci build? || > any idea on how to re-trigger ci build?only way i know how is updating the pr such as with a new commit :-(  its quite annoying that way || is it possible to demonstrate the race with a unit test perhaps using latches to cause the necessary race?reason is that the `zip` operator will be changing soon to use the new design changes and i want to make sure we have a test to prove correctness || unfortunately its an internal race between acquiring the read lock and trying to acquire the write lock i dont have any good ideas on how to test it without coupling it to the specific implementation || #693 #694 ;;;;1;1;simplify operationzip itemobserverlinkedlist permits null values no need for null_sentinel;
779;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed argument from mockingprogress.stubbingcompleted(..);removed unneccessary argument from internal mockingprogress.stubbingcompleted(..);;0;useful function in list/array implementation; hi alli think today of a function for arrays or list that returns the last index available (eg size(elt) - 1)i know this is very simple but i find that cool!regards; marked as workingasintended since iterablesgetlast answers the use case adequately--- ;;;;0;1;;
779;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed argument from mockingprogress.stubbingcompleted(..);removed unneccessary argument from internal mockingprogress.stubbingcompleted(..);;0;removed argument from mockingprogressstubbingcompleted();removed unneccessary argument from internal mockingprogressstubbingcompleted(); ;;;;1;1;removed unneccessary argument from internalmockingprogressstubbingcompleted();
779;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed argument from mockingprogress.stubbingcompleted(..);removed unneccessary argument from internal mockingprogress.stubbingcompleted(..);;0;allow using hive plugin without discovery;; you can configure the pool in the selector config in the catalog config just like any other config value of course all this stuff will go away when we load plugins dynamically ||;;;;1;1;allow using hive plugin without discovery;
779;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed argument from mockingprogress.stubbingcompleted(..);removed unneccessary argument from internal mockingprogress.stubbingcompleted(..);;0;make operator writing a little less error prone;;#695;;;;0;1;;
782;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;introduce default answers for primitive optionals/streams;i introduced  #invokenullaryfactorymethod  to remove some of the existing code duplication  but am unhappy about the _new_ duplication  especially in the test code. what s your view on introducing deduplicating logic in test code? also  the singleton fields in  javaeightutil  could be replaced with a  concurrentmap<string  object>  (i.e. a map from fqcns to singletons). if you agree  i d love to reduce the size of this pr.;;0;comgooglecommonbaseticker$1 not serializable; when attempting to serialize a cache created withcache  cachebuildernewbuilder()build(cacheloader)where cacheloader is serializable i hitjavaionotserializableexception: comgooglecommonbaseticker$1&nbsp&nbsp&nbsp&nbspat javaioobjectoutputstreamwriteobject0(objectoutputstreamjava:1180)&nbsp&nbsp&nbsp&nbspat javaioobjectoutputstreamdefaultwritefields(objectoutputstreamjava:1528)&nbsp&nbsp&nbsp&nbspat javaioobjectoutputstreamwriteserialdata(objectoutputstreamjava:1493)&nbsp&nbsp&nbsp&nbspat javaioobjectoutputstreamwriteordinaryobject(objectoutputstreamjava:1416)&nbsp&nbsp&nbsp&nbspat javaioobjectoutputstreamwriteobject0(objectoutputstreamjava:1174)&nbsp&nbsp&nbsp&nbspat javaioobjectoutputstreamdefaultwritefields(objectoutputstreamjava:1528)&nbsp&nbsp&nbsp&nbspat javaioobjectoutputstreamwriteserialdata(objectoutputstreamjava:1493)&nbsp&nbsp&nbsp&nbspat javaioobjectoutputstreamwriteordinaryobject(objectoutputstreamjava:1416)&nbsp&nbsp&nbsp&nbspat javaioobjectoutputstreamwriteobject0(objectoutputstreamjava:1174)&nbsp&nbsp&nbsp&nbspat javaioobjectoutputstreamwriteobject(objectoutputstreamjava:346)feel free to merge with issue 615 if appropriate;nto@ thank you ||;;;;0;1;;
782;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;introduce default answers for primitive optionals/streams;i introduced  #invokenullaryfactorymethod  to remove some of the existing code duplication  but am unhappy about the _new_ duplication  especially in the test code. what s your view on introducing deduplicating logic in test code? also  the singleton fields in  javaeightutil  could be replaced with a  concurrentmap<string  object>  (i.e. a map from fqcns to singletons). if you agree  i d love to reduce the size of this pr.;;0;introduce default answers for primitive optionals/streams;i introduced `#invokenullaryfactorymethod` to remove some of the existing code duplication but am unhappy about the _new_ duplication especially in the test code whats your view on introducing deduplicating logic in test code? also the singleton fields in `javaeightutil` could be replaced with a `concurrentmap<string object>` (ie a map from fqcns to singletons) if you agree id love to reduce the size of this pr; ! :) ||;;;;1;1;781 introduce default answers for primitive optionals/streams;
782;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;introduce default answers for primitive optionals/streams;i introduced  #invokenullaryfactorymethod  to remove some of the existing code duplication  but am unhappy about the _new_ duplication  especially in the test code. what s your view on introducing deduplicating logic in test code? also  the singleton fields in  javaeightutil  could be replaced with a  concurrentmap<string  object>  (i.e. a map from fqcns to singletons). if you agree  i d love to reduce the size of this pr.;;0;tablesample system implementation;reworked the system table sample code based on the recent changes sending this as a new pull request as it differs considerably from the original pull request tested this on the benchmark cluster by running select \* from presto_test tablesample system(0) - no rowsselect \* from presto_test tablesample system(50) - anywhere between 0 to 300 rows for mutiple runs select \* from presto_test tablesample system(100) - all rows (300);;;;;0;1;;
782;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;introduce default answers for primitive optionals/streams;i introduced  #invokenullaryfactorymethod  to remove some of the existing code duplication  but am unhappy about the _new_ duplication  especially in the test code. what s your view on introducing deduplicating logic in test code? also  the singleton fields in  javaeightutil  could be replaced with a  concurrentmap<string  object>  (i.e. a map from fqcns to singletons). if you agree  i d love to reduce the size of this pr.;;0;schedulerscheduleperiodically - memory leak;folks this is a pretty bad memory leak  the `scheduleperiodically` methods as currently defined are leakingfor example lets start with the current code in [rxscheduler line 93]( method in question is this:``` java    public <t> subscription scheduleperiodically(t state final func2<? super scheduler ? super t ? extends subscription> action long initialdelay long period timeunit unit) {        final long periodinnanos  unittonanos(period)        final atomicboolean complete  new atomicboolean()        final func2<scheduler t subscription> recursiveaction  new func2<scheduler t subscription>() {            @override            public subscription call(scheduler scheduler t state0) {                if (!completeget()) {                    long startedat  now()                    final subscription sub1  actioncall(scheduler state0)                    long timetakenbyactioninnanos  timeunitmillisecondstonanos(now() - startedat)                    final subscription sub2  schedule(state0 this periodinnanos - timetakenbyactioninnanos timeunitnanoseconds)                    return subscriptionscreate(new action0() {                        @override                        public void call() {                            sub1unsubscribe()                            sub2unsubscribe()                        }                    })                }                return subscriptionsempty()            }        }        final subscription sub  schedule(state recursiveaction initialdelay unit)        return subscriptionscreate(new action0() {            @override            public void call() {                completeset(true)                subunsubscribe()            }        })    }```the problem is that each and every one periodic execution of the given action is creating a new subscription reference that is capturing the reference of the previous subscription and no subscription reference will ever be garbage collected unless unsubscribe() happensits easy to reproduce the effect (ie outofmemoryerror) with a simple test that will end up with an error in a matter of seconds:``` scala  val sch  rxschedulersschedulersexecutor(executorsnewthreadpool(2))  val counter  new atomicinteger(0)  val action  new action0 {    def call(): unit  {      counterincrement()    }  }  val sub  schscheduleperiodically(action 1 1 timeunitnanoseconds)```heres how that looks like in a profiler:( above because it doesnt use a `scheduledexecutorservice` is using the default `schedulerscheduleperiodically` that i pasted above which is pretty heavy the problem is that even with a `scheduledexecutorservice` it still leaks because the [executorscheduler]( is still using a `compositesubscription` and when scheduling an `action0` this basically pushes `subscriptionsempty` over and over again into an `arraylist` thus the code is slower in leaking memory but it still leaksfrom what i can see this affects all `scheduleperiodically` implementations and as a consequence things like `observableinterval` are anything but infinite**update**: i now see that a pull request addressing some issues was made in #712 - in particular it changed the behavior of [executorscheduler]( i havent tested this version i will do so today hopefully however the default `schedulerscheduleperiodically` is still there and something to consider - if something that does periodic scheduling leaks it probably shouldnt be there;i updated the issue multiple times hopefully its helpful || thanks @benjchristensen are you working on this? || ive just been hit by that while implementing a short-period periodic task using an `action0` (hence without explicitly adding new subscriptions to the party) for [cgeo]( using 0161 on android || yes i can as schedulers is on my list for 017 and i  memory leaks in schedulers already obviously missing this one i completely ignored the scheduleperiodically methods  || hey i believe this can be closed no? i saw that schedulers changed the interface || yup it can be  i need to do a pass through all of the issues i bet 1/3 of them are probably ready for me to close || i think the current version doesnt leak but cant be cancelled either this program prints 1 through 6``` javapublic static void main(string args) throws exception {        worker w  schedulerscomputation()createworker()        compositesubscription cs  new compositesubscription()        atomicinteger i  new atomicinteger()        csadd(wscheduleperiodically(() -> {            int j  iincrementandget()            if (j  3) {                csunsubscribe()            }            systemoutprintln(j)            if (j  6) {                wunsubscribe()            }        } 200 200 timeunitmilliseconds))        timeunitsecondssleep(2)    }```the reason this doesnt seem to be an issue because most operators dont mix schedule with scheduleperiodic || memory leak is fixed the cancellation issue is being solved elsewhere ||;;;;0;1;;
783;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;simplify  returnsemptyvaluestest;as [discussed]( in the comments under #782. longer term this approach could be replaced with a proper test parametrization framework  but then at least the foundation has been laid.;;0;eventbus dispatches single event multiple times to most-derived listener if parents are listeners for same event; consider the following:public class main {```static class foo {}static class bar extends foo {}static class baselistener {    @subscribe    public void foo(foo foo) {        systemoutprintln(""base "" + footostring())    }}static class derivedlistener extends baselistener {    @subscribe    public void foo(foo foo) {        systemoutprintln(""derived "" + footostring())    }}public static void main(string args) {    eventbus eventbus  new eventbus(""eventbus"")    derivedlistener d  new derivedlistener()    eventbusregister(d)    eventbuspost(new bar())}```}the output will be:derived foo main$bar@99b5393derived foo main$bar@99b5393i would expect derived foo to be called once"; fix checked in--- ;;;;0;1;;
783;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;simplify  returnsemptyvaluestest;as [discussed]( in the comments under #782. longer term this approach could be replaced with a proper test parametrization framework  but then at least the foundation has been laid.;;0;simplify `returnsemptyvaluestest`;as [discussed]( in the comments under #782 longer term this approach could be replaced with a proper test parametrization framework but then at least the foundation has been laid; ;;;;1;1;simplify `returnsemptyvaluestest`by factoring out duplicated logic into helper methods;
783;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;simplify  returnsemptyvaluestest;as [discussed]( in the comments under #782. longer term this approach could be replaced with a proper test parametrization framework  but then at least the foundation has been laid.;;0;taking care of boundary case conditions in the tablesample operator;changing the comparison expression between `rand()` and `sampleratio` from `<` to `<` `rand()` returns a value between [01) so `rand() < 0` will return no values and `rand() < 1` will return all the values;;;;;1;1;taking care of boundary case conditions in the tablesample operator;
783;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;simplify  returnsemptyvaluestest;as [discussed]( in the comments under #782. longer term this approach could be replaced with a proper test parametrization framework  but then at least the foundation has been laid.;;0;implement some android ui related operators;1 operatorviewclick2 operatoredittextinput3 operatorcompoundbuttoninput;#698  #705;;;;1;1;implement some android ui related operators1 operatorviewclick2 operatoredittextinput3 operatorcompoundbuttoninput;
795;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;deep stubs no longer cause unnecessary stubbing exception with junit runner;756;;0;"futurecallback should have ""finally"" method"; futurecallback has no method that would be executed anyway for example i want to dismiss progress dialog in both fail and success case that is why we need ""finally"" method"; i see  ;;;;0;1;;
795;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;deep stubs no longer cause unnecessary stubbing exception with junit runner;756;;0;deep stubs no longer cause unnecessary stubbing exception with junit runner;756;  795  **< ;;;;1;1;made the test stricterfollowing nice code review feedback!;
795;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;deep stubs no longer cause unnecessary stubbing exception with junit runner;756;;0;scheduling fixes;;;;;;1;1;fix blocked writer leaks in sharedbufferremove old unused buffer apis;
795;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;deep stubs no longer cause unnecessary stubbing exception with junit runner;756;;0;cannot call subscribeon or observeon twice or it wont produce desired behavior;"import rxobservableimport rxobservableonsubscribefuncimport rxobserverimport rxsubscriptionimport rxconcurrencyschedulersimport rxutilfunctionsaction1public class main {```public static void main(string args) {    systemoutprintln(""start 1"")    getnumberedobservable(1)    observeon(schedulersimmediate())    subscribeon(schedulersimmediate())    subscribe(new action1<integer>() {        @override        public void call(integer value) {            systemoutprintln(value + "" returned"")        }    })    systemoutprintln(""finish 1"")    systemoutprintln(""start 2"")    getnumberedobservable(2)    observeon(schedulersimmediate())    subscribeon(schedulersimmediate())    subscribe(new action1<integer>() {        @override        public void call(integer value) {            systemoutprintln(value + "" returned"")        }    })    systemoutprintln(""finish 2"")    systemoutprintln(""start 3"")    getnumberedobservable(3)    observeon(schedulersimmediate())    subscribeon(schedulersimmediate())    subscribe(new action1<integer>() {        @override        public void call(integer value) {            systemoutprintln(value + "" returned"")        }    })    systemoutprintln(""finish 3"")    try {        threadsleep(1000)    } catch (interruptedexception e) {    }}public static observable<integer> getnumberedobservable(final int value) {    return observablecreate(new onsubscribefunc<integer>() {        @override        public subscription onsubscribe(observer<? super integer> observer) {            observeronnext(value)            observeroncompleted()            return null        }    })    subscribeon(schedulersthreadpoolforcomputation())    observeon(schedulersthreadpoolforio())}```}based on the above program you would expect it to output:start 11 returnedfinish 1start 22 returnedfinish 2start 33 returnedfinish 3but instead it outputs:start 1finish 1start 2finish 2start 3finish 32 returned3 returned1 returnedit can be  by removing the subscribeon and observeon setting from the getnumberedobservable function since after that function returns im setting them both to immediate youd think it would go back to normal behavior but it isnt it seems";"this is the expected behavior using subscribeon/observeon with a thread pool will allow the caller thread in main() to complete before the calculation can happen using immediate scheduler afterwards is practically a no-op if you need to wait for the completion of the observables specify the oncompleted handler and use countdownlatchin addition returning `null` subscription can lead to npes so instead return `subscriptionsempty()` || i think there is a misunderstanding if i set subscribeon / observeon to schedulersimmediate() i get output a if i make a new observable set subscribeon / observeon to schedulersio() and then before subscribing set subscribeon / observeon back to schedulersimmediate() i get output b i should be getting output a since i changed the observable back to immediate || it doesnt work like that you are not setting the scheduler ""back"" but routing it again to a no-op immediate scheduler || would there be a way to reset the observable back to the original behavior after a thread pool has been applied? (i realize this is an odd question) || no you need to keep a reference to the chain before the observeon/subscribeon is applied || ";;;;0;1;;
803;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;adds a warning for ibm j9 vms if mock generation fails;related to #801  this pr simply adds a warning for ibm j9 vms if the mock maker fails.;;0;support for custom annotations and/or handlerfindingstrategy in eventbus; since annotations cannot be extended in java it would be nice to support a way to replace the @﻿subscribe and @﻿allowconcurrentevents annotations with a custom ones if that cannot be done or is not desirable then a way to implement ones own handlerfindingstrategy would be a nice addition right now the finder variable is private final and there is no way to set it from the outside also the handlerfindingstrategy interface is not publicthe reason for doing something like this is to be able to create a facade for eventbuses so that the implementation can be substituted if needed and also so that one can define another interface towards the eventbus behaviour that is not possible at the moment because of the annotations; _issue #1210 has been merged into this issue_ ||;;;;0;1;;
803;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;adds a warning for ibm j9 vms if mock generation fails;related to #801  this pr simply adds a warning for ibm j9 vms if the mock maker fails.;;0;rename long->bigint string->varchar;; ;;;;0;1;;
803;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;adds a warning for ibm j9 vms if mock generation fails;related to #801  this pr simply adds a warning for ibm j9 vms if the mock maker fails.;;0;add testmultiplewithsamecause unittest;also make tests capable of failing with timeouts before the constructor would immediately go into an infinite loop and hang the tests;#727 ;;;;1;1;add testmultiplewithsamecause unittestalso make tests capable of failing with timeouts before the constructor would immediately go into an infinite loop and hang the tests;
803;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;adds a warning for ibm j9 vms if mock generation fails;related to #801  this pr simply adds a warning for ibm j9 vms if the mock maker fails.;;801.0;adds a warning for ibm j9 vms if mock generation fails;related to #801 this pr simply adds a warning for ibm j9 vms if the mock maker fails; ;mockito 2 fails when running on ibm j9 (sr1 fp10) vm;"mocking an interface fails when running on ibms jdk with the error attached below works well on oracle jdk 180_91attaching a small project that can be used to reproduce the issue: [mockito-ibm-jdk-testzip]( mailing list post:  from `java -version` of the failing version:```java version ""180""java(tm) se runtime environment (build pwa6480sr1fp10-20150711_01(sr1 fp10))ibm j9 vm (build 28 jre 180 windows 7 amd64-64 compressed references 20150630_255633 (jit enabled aot enabled)j9vm - r28_jvm28_20150630_1742_b255633jit  - trr14java_20150625_9508101gc   - r28_jvm28_20150630_1742_b255633_cmprssj9cl - 20150630_255633)jcl - 20150711_01 based on oracle jdk8u51-b15```error message and stack trace:```orgmockitoexceptionsbasemockitoexception: mockito cannot mock this class: interface serviceservicemockito can only mock non-private & non-final classesif youre not sure why youre getting this error please report to the mailing listjava               : 18jvm vendor name    : ibm corporationjvm vendor version : 28jvm name           : ibm j9 vmjvm version        : pwa6480sr1fp10-20150711_01 (sr1 fp10)jvm info           : jre 180 windows 7 amd64-64 compressed references 20150630_255633 (jit enabled aot enabled)j9vm - r28_jvm28_20150630_1742_b255633jit  - trr14java_20150625_9508101gc   - r28_jvm28_20150630_1742_b255633_cmprssj9cl - 20150630_255633os name            : windows 7os version         : 61underlying exception : javalangillegalargumentexception: object is not an instance of declaring class	at orgmockitointernalrunnerssilentjunitrunner$1withbefores(silentjunitrunnerjava:29)	at orgjunitrunnersblockjunit4classrunnermethodblock(blockjunit4classrunnerjava:276)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orgmockitointernalrunnerssilentjunitrunnerrun(silentjunitrunnerjava:39)	at orgmockitointernalrunnersstrictrunnerrun(strictrunnerjava:39)	at orgmockitojunitmockitojunitrunnerrun(mockitojunitrunnerjava:103)	at orgeclipsejdtinternaljunit4runnerjunit4testreferencerun(junit4testreferencejava:86)	at orgeclipsejdtinternaljunitrunnertestexecutionrun(testexecutionjava:38)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:459)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:678)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerrun(remotetestrunnerjava:382)	at orgeclipsejdtinternaljunitrunnerremotetestrunnermain(remotetestrunnerjava:192)caused by: javalangillegalargumentexception: object is not an instance of declaring class	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:95)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:55)	at javalangreflectmethodinvoke(methodjava:507)	at netbytebuddydescriptiontypetypedescription$generic$annotationreader$fortypeargumentresolve(typedescriptionjava:3843)	at netbytebuddydescriptiontypetypedescription$generic$annotationreader$delegator$chainedresolve(typedescriptionjava:3468)	at netbytebuddydescriptiontypetypedescription$generic$annotationreader$fortypeargumentresolve(typedescriptionjava:3803)	at netbytebuddydescriptiontypetypedescription$generic$annotationreader$delegatoraslist(typedescriptionjava:3439)	at netbytebuddydescriptiontypetypedescription$generic$ofnongenerictype$forloadedtypegetdeclaredannotations(typedescriptionjava:4208)	at netbytebuddyimplementationattributeannotationappender$fortypeannotationsapply(annotationappenderjava:720)	at netbytebuddyimplementationattributeannotationappender$fortypeannotationsonnongenerictype(annotationappenderjava:701)	at netbytebuddyimplementationattributeannotationappender$fortypeannotationsonnongenerictype(annotationappenderjava:415)	at netbytebuddydescriptiontypetypedescription$generic$ofnongenerictypeaccept(typedescriptionjava:4075)	at netbytebuddyimplementationattributeannotationappender$fortypeannotationsonparameterizedtype(annotationappenderjava:682)	at netbytebuddyimplementationattributeannotationappender$fortypeannotationsonparameterizedtype(annotationappenderjava:415)	at netbytebuddydescriptiontypetypedescription$generic$ofparameterizedtypeaccept(typedescriptionjava:4998)	at netbytebuddyimplementationattributemethodattributeappender$forinstrumentedmethodapply(methodattributeappenderjava:195)	at netbytebuddyimplementationattributemethodattributeappender$compoundapply(methodattributeappenderjava:490)	at netbytebuddydynamicscaffoldtypewriter$methodpool$record$fordefinedmethod$withbodyapplybody(typewriterjava:612)	at netbytebuddydynamicscaffoldtypewriter$methodpool$record$fordefinedmethodapply(typewriterjava:533)	at netbytebuddydynamicscaffoldtypewriter$default$forcreationcreate(typewriterjava:3910)	at netbytebuddydynamicscaffoldtypewriter$defaultmake(typewriterjava:1693)	at netbytebuddydynamicscaffoldsubclasssubclassdynamictypebuildermake(subclassdynamictypebuilderjava:172)	at netbytebuddydynamicscaffoldsubclasssubclassdynamictypebuildermake(subclassdynamictypebuilderjava:153)	at netbytebuddydynamicdynamictype$builder$abstractbasemake(dynamictypejava:2568)	at netbytebuddydynamicdynamictype$builder$abstractbase$delegatormake(dynamictypejava:2670)	at orgmockitointernalcreationbytebuddysubclassbytecodegeneratormockclass(subclassbytecodegeneratorjava:84)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$cachedbytecodegeneratorgetorgeneratemockclass(typecachingbytecodegeneratorjava:91)	at orgmockitointernalcreationbytebuddytypecachingbytecodegeneratormockclass(typecachingbytecodegeneratorjava:38)	at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemocktype(subclassbytebuddymockmakerjava:68)	at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemock(subclassbytebuddymockmakerjava:39)	at orgmockitointernalcreationbytebuddybytebuddymockmakercreatemock(bytebuddymockmakerjava:26)	at orgmockitointernalutilmockutilcreatemock(mockutiljava:35)	at orgmockitointernalmockitocoremock(mockitocorejava:63)	at orgmockitomockitomock(mockitojava:1637)	at orgmockitointernalconfigurationmockannotationprocessorprocess(mockannotationprocessorjava:33)	at orgmockitointernalconfigurationmockannotationprocessorprocess(mockannotationprocessorjava:16)	at orgmockitointernalconfigurationdefaultannotationenginecreatemockfor(defaultannotationenginejava:39)	at orgmockitointernalconfigurationdefaultannotationengineprocess(defaultannotationenginejava:63)	at orgmockitointernalconfigurationinjectingannotationengineprocessindependentannotations(injectingannotationenginejava:59)	at orgmockitointernalconfigurationinjectingannotationengineprocess(injectingannotationenginejava:43)	at orgmockitomockitoannotationsinitmocks(mockitoannotationsjava:67)	 19 more```";"hi thanks for the report @grimsa i dont have access to an j9 virtual machine its probably something related to internal types of j9 that affects parts of byte-byddy (like the one show in the [stack trace]( so not sure when this bug can be  || there are some hoops to jump through to get ibms j9 vm (i assume due to some licensing issue) but it can be downloaded with no registration in a [bundle with websphere liberty]( (located in wlp/java/java)running `java -version` on it produces the following:```java version ""180""java(tm) se runtime environment (build pwa6480sr3fp10-20160720_02(sr3fp10))ibm j9 vm (build 28 jre 180 windows 7 amd64-64 compressed references 20160719_312156 (jit enabled aot enabled)j9vm - r28_java8_sr3_20160719_1144_b312156jit  - trr14java_20160629_12028401gc   - r28_java8_sr3_20160719_1144_b312156_cmprssj9cl - 20160719_312156)jcl - 20160719_01 based on oracle jdk8u101-b13```but what is important is that i ran the test on this version and mockito **worked as expected**were running on a fairly old ibm jdk (back from 2015 06) so maybe we brought it on ourselvesif you are still interested in looking into it i could figure out a way to get you that failing version of j9 || ah its possible that early java 8 vm of ibm had issues as well actually @raphw identified issues with early hotspot vm they had bugs that were fixed in 180u45 since its old and a more recent version of the vm appears to fix the issue im not sure its worth the efforteventually we can print a message that can warn j9 users warning on a specific version is possible but the version scheme is confusing to say the least im tempted to label it as _wont fix_anyway thanks for the link im using osx though its always possible to create a virtual box from scratch however it takes time || i see theres some code in `orgmockitointernalutilplatform` that checks for jdk version but i dont see an obvious and clean way to add this j9 version check especially as we dont know an exact version from which it works as expectedid agree with labeling it with _wont-fix_ although you could consider mentioning it in the wiki (eg in [whats new in mockito 2]( || > as we dont know an exact version from which it works as expectedyes exactlysure ill mention it in the wiki closing as wont fix for now || added some info regarding vm in the wiki page and i created a pr that warns the user of early ibm j9 vms || ";1;0;related to #801 : adds a warning for ibm j9 vms if mock generation failssigned-off-by: brice dutheil <bricedutheil@gmailcom>;
805;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;never throw mockito exceptions from a plugin type s constructor;throwing a  mockitoexception  from a mock maker constructor will cause the stack trace cleaning to be applied which itself relies on the plugin registry which is not yet initialized during the mock maker plugin s creation.;;0;invalid boolean expression; in intmath:&nbsp&nbsppublic static boolean ispoweroftwo(int x) {&nbsp&nbsp&nbsp&nbspreturn x > 0 & (x & (x - 1))  0&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp^^^^^^&nbsp&nbsp}should be:&nbsp&nbsppublic static boolean ispoweroftwo(int x) {&nbsp&nbsp&nbsp&nbspreturn x > 0 && (x & (x - 1))  0&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp^^^^^^^&nbsp&nbsp}or i am wrong?; indeed this was quite deliberate and benchmarks supported this choice--- ;;;;0;1;;
805;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;never throw mockito exceptions from a plugin type s constructor;throwing a  mockitoexception  from a mock maker constructor will cause the stack trace cleaning to be applied which itself relies on the plugin registry which is not yet initialized during the mock maker plugin s creation.;;0;never throw mockito exceptions from a plugin types constructor;throwing a `mockitoexception` from a mock maker constructor will cause the stack trace cleaning to be applied which itself relies on the plugin registry which is not yet initialized during the mock maker plugins creation; ;;;;1;1;never throw mockito exceptions from a plugin types constructor;
805;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;never throw mockito exceptions from a plugin type s constructor;throwing a  mockitoexception  from a mock maker constructor will cause the stack trace cleaning to be applied which itself relies on the plugin registry which is not yet initialized during the mock maker plugin s creation.;;0;added tests for ensuring statistical correctness of approx_avg();this diff consists of some additional tests that ensure the statistical correctness of `approx_avg()` function the tests generate a sequence of tuples with a `gaussian` and `uniform` distribution and make sure that the true answer lies within the `approximate answer +/- error bars` produced by a number of 10% samples 99% of the timei have explicitly seeded the distribution and sample generators to make the output of the tests deterministic;rebased and pushed ;;;;0;1;;
805;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;never throw mockito exceptions from a plugin type s constructor;throwing a  mockitoexception  from a mock maker constructor will cause the stack trace cleaning to be applied which itself relies on the plugin registry which is not yet initialized during the mock maker plugin s creation.;;0;fix compositeexception;this fixes possible issues where infinite loops could be created if the right combination of exceptions and causal chains were composed together;#730;;;;1;1;add testmultiplewithsamecause unittestalso make tests capable of failing with timeouts before the constructor would immediately go into an infinite loop and hang the tests;
807;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;new opt-in stubbing strictness implemented in junit rules;new api (for rationale  see #769  for code review history see #770):;;0;weakeventbus that uses a weak reference to registered objects;goo@ eventbus maintains a strong reference to registered objects and objects cant easily be wrapped in a weakreference because that would need to @﻿subscribe to the same eventsweakeventbus would use a weakreference to refer to registered objects and unregister them automatically using a referencequeue; im using guice to register all my injections with the eventbus and using providers to create (swing) dialogs that communicate with a database controller using guava eventbus for dialogs to not need eventbus cleanup id have to write and maintain reset methods for each to go back to their default state and every dialog (or opened dialog if using lazy vals with providers) would stay in memory for the life of the applicationsince my dialogs are confined to a few controllers its not out of the question to wrap their usages in something likedef using[t](prov: provider[t])(f: t > unit) {&nbsp&nbsp&nbsp&nbspval t  provget&nbsp&nbsp&nbsp&nbspultimately(eventbusunregister(t))(f(t))}which i may do ill probably take a look at mbassador at least for some projects where there are few classes that need strong references and those can be specified with class annotations (adding weakregister to eventbus would require guice to register everything weakly and then id have to maintain references to some classes manually) || we are not actively working on eventbus anymore there are modern alternatives including [rxjava]( that are more actively maintained || ";;;;0;1;;
807;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;new opt-in stubbing strictness implemented in junit rules;new api (for rationale  see #769  for code review history see #770):;;0;allow parsing create table as select;;;;;;1;1;allow parsing create table as select;
807;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;new opt-in stubbing strictness implemented in junit rules;new api (for rationale  see #769  for code review history see #770):;;0;operator repeat and other operator fixes;reimplemented repeat() which exposed some other problems- added `queuedrain` based on [this]( added overload of repeat(long n) to repeat a source n times (which is not the same as repeat()take(n) generally) note that bens prototype was not working correctly because it run the re-subscription code in a loop: if subscribeon was used it was constantly resubscribing before the old even finished- for some reason observeon+take didnt work as expected causing repeat tests to fail as well i couldnt determine the cause ive noticed that `take` was unable to unsubscribe the upstream as there was nothing in its `cs` - to fix the problem above ive reimplemented observeon as well it does not use recursive scheduling but the queuedrain - this exposed another problem with groupby: in some cases childobserveroncompleted was sent out twice breaking merge/flatmap ive added a once check but im not 100% certain there isnt anything else wrong with the groupbys staggered behavior- unfortunately `operationparallelmergetest` is broken with this pr i dont quite understand why it doesnt work nor have a clue how to fix it or the new `observeon` maybe the parallel tests relied on thread timing and not expiring too fast so they could continue one themperformancefrom+repeat: 38mops/sfrom+repeat+observeon: 15mops/srange: 318mops/sfrom+observeon+repeat: 15 kops/s;#733 >  ive noticed that take was unable to unsubscribe the upstream as there was nothing in its cswhat is the unit test for this scenario? || > unfortunately `operationparallelmergetest` is broken with this prit breaks because `observeon` is now hopping threads as it always schedulers on the outer schedulerthe fix i pasted above resolves the `operationparallelmergetest` tests || the test case with `take` that caused problems was something like this:``` javaobservablerange(1 20000000)observeon(schedulersnewthread())take(10)subscribe(systemout::println)```it prints 110 but then it doesnt stop and spins up a lot of threads basically the `operationrepeattest` failed for me with timeouts || i merged `repeat` based on the discussion above ill await your work on `observeon`  || >  then it doesnt stop and spins up a lot of threadsisnt that because we havent re-implemented `observeon` yet?this works:``` java        observablerange(1 20000000)take(10)toblockingobservable()foreach(new action1<integer>() {            @override            public void call(integer t1) {                systemoutprintln(t1)            }        })``` || do you intend on submitting updated code soon or should i merge the observeon changes as discussed above? || i skip on this one || okay thanks @akarnokd  || > the test case with take that caused problems was something like this:is the `take` issue resolved for you now based on  ? || the issue was with observeon+take together this fixes take but observeon in its current form doesnt work this spins:``` javaobservablerange(1 20000000)                observeon(schedulersnewthread())                take(10)toblockingobservable()foreach(systemout::println)```i guess i need to revisit the issue once observeon has been updated || that code works on the new `observeon` implementation i just submitted:  || excellent im looking at the new `observeon` right now for speedup options || thanks @akarnokd i would appreciate that my brain is done for the night!  ||;;;;0;1;;
807;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;new opt-in stubbing strictness implemented in junit rules;new api (for rationale  see #769  for code review history see #770):;;770.0;new opt-in stubbing strictness implemented in junit rules;"new api (for rationale see #769 for code review history see #770):```java//existing api:@rule public mockitorule mockito  mockitojunitrule()//proposed improvements:rule()strictness(strictnesslenient)rule()strictness(strictnesswarn)       // <-- is the defaultrule()strictness(strictnessstrict_stubs)  // <-- mockito 30 default```what ""strict stubbing"" means?- improved debuggability: the test fails early when code under test invokes stubbed method with different arguments- cleaner tests without unnecessary stubbings: the test fails when there are any unused stubs declared- cleaner more dry tests (""dont repeat yourself""): if you use mockitoverifynomoreinteractions() you no longer need to explicitly verify stubbed invocations they are automatically verifiedfor background and motivation check out [szczepans article on linkedin](https://wwwlinkedincom/pulse/curious-how-get-even-cleaner-tests-new-mockito-features-faber)";"with interactive rebase you can squash commits away or use `git reset --soft head~2` to reset the last 2 commits    ||   ";opt-in stubbing strictness implemented in junit rules;"new api (for rationale see #769):```java//existing api:@rule public mockitorule mockito  mockitojunitrule()//proposed improvements:rule()strictness(strictnesslenient)rule()strictness(strictnesswarn)       // <-- is the defaultrule()strictness(strictnessstrict_stubs)  // <-- mockito 30 default```what ""strict stubbing"" means?- improved debuggability: the test fails early when code under test invokes stubbed method with different arguments- cleaner tests without unnecessary stubbings: the test fails when there are any unused stubs declared- cleaner more dry tests (""dont repeat yourself""): if you use mockitoverifynomoreinteractions() you no longer need to explicitly verify stubbed invocations they are automatically verifiedfor background and motivation check out [szczepans article on linkedin](https://wwwlinkedincom/pulse/curious-how-get-even-cleaner-tests-new-mockito-features-faber)";"  ";1;0;minor version bump and refactoring- signified an important change (minor version bump)- refactoring - i didnt want to touch the public api (mockcreationsettings) with this so i removed the unused import;
811;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;enable annotation engine as plugin;currently  annotationengine  can be overrriden with the _deprecated_  mockitoconfiguration   in order to be more consistent with the new way  i propose to get the  annotationengine  from the  pluginregistry .;;0;enable annotation engine as plugin;currently `annotationengine` can be overrriden with the _deprecated_ `mockitoconfiguration` in order to be more consistent with the new way i propose to get the `annotationengine` from the `pluginregistry`regarding backward compatible behavior if the `mockitoconfiguration` class exists and can be seen then mockito will select the engine of this configuration instead of the `plugins` one if `mockitoconfiguration` class dont exist then mockito wil chose the `plugins` onebonus i extended the classloader util to support some tests; ;;;;1;1;skip static final copyit could be bypassed by unsafe or other tricks at this moment this is probably enoughsigned-off-by: brice dutheil <bricedutheil@gmailcom>;
811;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;enable annotation engine as plugin;currently  annotationengine  can be overrriden with the _deprecated_  mockitoconfiguration   in order to be more consistent with the new way  i propose to get the  annotationengine  from the  pluginregistry .;;0;parser changes for creating stratified samples with tablesample;this diff adds an optional `stratify on` clause to `tablesample` in the parserexamples:`select * from temp tablesample bernoulli (50) stratify on (col_a)``select * from temp tablesample system (50) stratify on (col_a col_b)`;;;;;1;1;parser changes for creating stratified samples with tablesample;
811;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;enable annotation engine as plugin;currently  annotationengine  can be overrriden with the _deprecated_  mockitoconfiguration   in order to be more consistent with the new way  i propose to get the  annotationengine  from the  pluginregistry .;;0;intellij support;@alkemist loading the current project in intellij is totally broken (not that it ever really worked for me but at least intellij recognized that the scala bindings were in scala no i might as well use textedit)can you take a look?;@headinthebox this works for me are you running `/gradlew idea` and then opening the project in idea (the right way)? or trying to import it in idea? || ok i did not try `/gradlew idea` didnt even know that existed :-) will try that out(and just for my education how could i have discovered _the right way_?) || the docs ) ||;;;;0;1;;
819;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixes bug were previously verified invocations could not capture argu…;since mockito 2 / #380 captured arguments is not anymore done for already verified interactions.;;0;provide some default optional-values; i think it would be nice to have some default optional-values especially for optional&ltboolean>i very often write things like:optional&ltboolean> getbla() {&nbsp&nbsp&nbsp&nbspif (foo)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn optionalof(booleantrue)&nbsp&nbsp&nbsp&nbspif (bar)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn optionalof(booleanfalse)&nbsp&nbsp&nbsp&nbspreturn optionalabsent()}it would prefer to be able to write somthing like optionaltrue and optionalfalse insteadnot sure if this might also be usefull for other types with default values like bigdecimalzerobest regards daniel; i dont see the broad value in thiswhat you have or optionalof(true) is more readable imho--- ;;;;0;1;;
819;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixes bug were previously verified invocations could not capture argu…;since mockito 2 / #380 captured arguments is not anymore done for already verified interactions.;;0;fixes bug were previously verified invocations could not capture argu…;"since mockito 2 / #380 captured arguments is not anymore done for already verified interactions```javaimethods mock  mock(imethodsclass)mockonearg(""first"")argumentcaptor<string> argument  argumentcaptorforclass(stringclass)verify(mock times(1))onearg(argumentcapture())assertthat(argumentgetallvalues())isequalto(1)// additional interactionsmockonearg(""second"")argument  argumentcaptorforclass(stringclass)verify(mock times(2))onearg(argumentcapture())assertthat(argumentgetallvalues())isequalto(2) // fail with mockito 2```the current behavior (mockito 21 - 233) of `numberedinvocationchecker` clears already verified interactions before verifying the remaining interactions so the new argument captor is not populated with previous values which is akward if the times value is different that the lit size"; ;;;;1;1;fixes bug were previously verified invocations could not capture argumentsthe code that is removed here doesnt affect any previous test not even tests to prove the issue of #380 / #379signed-off-by: brice dutheil <bricedutheil@gmailcom>;
819;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixes bug were previously verified invocations could not capture argu…;since mockito 2 / #380 captured arguments is not anymore done for already verified interactions.;;0;updates to presto theme to support the web site (in the root of gh-pages);;;;;;0;1;;
819;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixes bug were previously verified invocations could not capture argu…;since mockito 2 / #380 captured arguments is not anymore done for already verified interactions.;;0;compositesubscription performance increase;- optimized the case when the composite holds only a single element- replaced arrayscopyof with regular arraycopy to avoid the cost of reflective array creation- included perf test where i got 32% increase on my i7 4770k;#739  the things we do for performance :-)very nice changesold code on my machine  10 - 14477981 ops/sec run: 11 - 14028905 ops/sec run: 12 - 14738523 ops/sec run: 13 - 14296743 ops/sec run: 14 - 14643646 ops/sec new code  10 - 20500289 ops/sec run: 11 - 19725110 ops/sec run: 12 - 20433601 ops/sec run: 13 - 19659111 ops/sec run: 14 - 20011446 ops/sec  || like! ||;;;;1;1;compositesubscription performance increase;
821;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;820 returnsargat to handle returning vararg as arrays;attempt at fixing #820;;0;should setfilter return a setview?; itd be reverse-compatible and all but itd support the nice immutablecopy() method and everything; ;;;;0;1;;
821;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;820 returnsargat to handle returning vararg as arrays;attempt at fixing #820;;0;fix for hive bucketed tables;additional checks to ensure that we apply bucketing only when a table is bucketed;;;;;1;1;fix for hive bucketed tables;
821;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;820 returnsargat to handle returning vararg as arrays;attempt at fixing #820;;0;update to use subscriber/subscriptionscreate;master had changed since the pull request;#741 ;;;;1;1;update to use subscriber/subscriptionscreatemaster had changed since the pull request;
821;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;820 returnsargat to handle returning vararg as arrays;attempt at fixing #820;;820.0;820 returnsargat to handle returning vararg as arrays;attempt at fixing #820basically it makes the returnsargumentat answer a bit more smart about varargs but im not satisfied with the fix yet; ;[varargs] unexpected behaviour of returnsargat(int);i stumble about a test that failed after refactoring an array parameter to an varargsthe following test succeed:```javainterface foo{        int getodd(int input)}@testpublic void test() throws exception {    when(foogetodd(any()))then(returnsargat(0))            int odd  mockgetodd(new int{135})    assertthat(odd)contains(135)}```now lets change the parameter _input_ to an varargs```javainterface foo{        int getodd(int input)}```the test fails now with:```orgmockitoexceptionsmisusingwrongtypeofreturnvalue: the argument of type int cannot be returned because the following method should return the type int -> foogetodd()```this is not expected cause the change is source and binary(?) compatible an varargs-parameter is still an array returnsargumentat interprets the vararg array items as real parameters in other words it tries to return an element type where the array type is requiredcan the behaviour of interpreting vararg elements like parameters be changed so an vararg is treated as an array? eg in mockito 3? there are several other cases were the current vararg handling leads to unexpected behaviour;i think your second example has a typo since there are no var args in the example || thanks  || good catch!by the way the mock reference is both foo and mock || while it is source and binary compatible vararg method are different than plain old array method reflection allows to distinguish that the issue is in `returnsargumentatreturnedtypeonsignature` where theres a special handling for varargs || im working on the fix (currently adding some unit tests) || this should be fixed by #821 ||;1;0;820 returnsargat to handle returning vararg as arrayssigned-off-by: brice dutheil <bricedutheil@gmailcom>;
823;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;only resolve instrumented method after validating that an instance is…;this is both a performance improvement and a way of ensuring that no stack overflow error occurs upon looking up a  method  instance which requires using a  hashmap  which causes an infitite loop upon mocking the hash map type. 818.;;0;provide immutable mediatype class;j@ while the java mail api provides a content type class it still has some drawbacks some are that its not immutable (think constants) and it lacks a (static) constructor to create one just from primary and sub type as separate arguments without specifying a(n empty) list of parametersalso  uses mime/content types as well but those projects might not want to depend on an e-mail-related packagemy personal requirements:- immutability- allow explicit addressing of the charset both on construction and as a getter (not just having to find it by key in the list of parameters)- provide matching of the primary type the sub type parameters and combinations of all of those (say primary type and sub type and charset)- maybe support matchers like ""text/*"" ie a wildcard for the sub type (that case might be sufficient) however comparison with/without parameters (or just a selection of those) might require some further thinking- handle case (in)sensivity as appropriate there are different requirements for the parameters of certain mime types on how to interpret their keys and values regarding that¹- provide conversion methods from/to `contenttype`&nbsp(java mail api)- have a thoughtful implementation of `equals` i think everything should be compared including parameters¹) from my own investigation:- according to rfc 2045 section 51 the primary type subtype and parameter names must always be matched case insensitive- according to rfc 2046 section 412 the value of the charset parameter (implicit default: us-ascii) is case insensitive but the values of other parameters might not bei have implemented an immutable content type myself but so far only included specifically the charset parameter of text types but no other parameters (eg filename not to confuse with the parameter of the `content-disposition: attachment`&nbspheader)also a builder-style approach might be useful to optionally add parameters as needed before the immutable instance is createdon a related note the guava class that contains  header keys is quite nice maybe something similar for common content types would make sense? in that case the content type class api should allow for composition of pre-defined primary/sub type combinations (plaintext html csv json octet-stream pdf images etc) with parameters to fit specific needs"; will be very appreciated since it is one of the required mime types in google cloud storage:  || ";;;;0;1;;
823;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;only resolve instrumented method after validating that an instance is…;this is both a performance improvement and a way of ensuring that no stack overflow error occurs upon looking up a  method  instance which requires using a  hashmap  which causes an infitite loop upon mocking the hash map type. 818.;;0;[hdfs] load hdfs files if necessary due to federation;this pr allows the user to specify 0 or more additional configuration files that are necessary for communicating with hdfs this is especially necessary with our configuration as we run hdfs federated without the additional information available in `core-sitexml` and `hdfs-sitexml` presto fails to communicate with hdfs with the ability to load these configuration files presto works splendidly with a federated hdfs;@andykram thanks for submitting our first external pull request! we will need a company cla on file for you before we can accept this:  || it appears my initial attempt simply forgot to overload the setter to also accept a list@electrum ive updated the pr and signed a personal cla im working on getting a company cla filled out for airbnb || thanks for updating this im checking if we need a company cla or if the individual one will suffice  ive been swamped with the preparations for the open source release but well get to this soon || a company cla has been signed for airbnb @electrum: does everything look in order? || thanks andy! i rebased and pushed it with a few minor changes ||;;;;0;1;;
823;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;only resolve instrumented method after validating that an instance is…;this is both a performance improvement and a way of ensuring that no stack overflow error occurs upon looking up a  method  instance which requires using a  hashmap  which causes an infitite loop upon mocking the hash map type. 818.;;0;why do multiple- and serialsubscriptions keep the inner reference after unsubscription?;im looking into performance enhancement options with subscriptions at the moment and im wondering why `multipleassignmentsubscription` and `serialsubscription` keep the inner subscription value after unsubscribing instead of swapping it out with empty() if done so i could use a static final unsubscribed state instead of a per-instance unsubscribed statein addition id rather use getandset(done) instead of the state loop i couldnt measure any significant performance change in swapping out an if check with an empty method call;closing this for now ||;;;;0;1;;
823;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;only resolve instrumented method after validating that an instance is…;this is both a performance improvement and a way of ensuring that no stack overflow error occurs upon looking up a  method  instance which requires using a  hashmap  which causes an infitite loop upon mocking the hash map type. 818.;;818.0;only resolve instrumented method after validating that an instance is…;this is both a performance improvement and a way of ensuring that no stack overflow error occurs upon looking up a `method` instance which requires using a `hashmap` which causes an infitite loop upon mocking the hash map type 818; ;stackoverflow occurs when mocking a hashmap with mockmaker;"as investigated in #752 mocking a `hashmap` halts with a stack overflow when using `mock-maker-inline`:```mockitomock(hashmapclass)exception in thread ""reference handler"" javalangstackoverflowerror	at javalangclassprivategetdeclaredmethods(classjava:2701)	at javalangclassgetdeclaredmethod(classjava:2128)	at javautilhashmapget(hashmapjava:556)	at sunreflectreflectionfiltermethods(reflectionjava:291)	at javalangclassprivategetdeclaredmethods(classjava:2701)	at javalangclassgetdeclaredmethod(classjava:2128)	at javautilhashmapget(hashmapjava:556)	at sunreflectreflectionfiltermethods(reflectionjava:291)	at javalangclassprivategetdeclaredmethods(classjava:2701)	at javalangclassgetdeclaredmethod(classjava:2128)	at javautilhashmapget(hashmapjava:556)	at sunreflectreflectionfiltermethods(reflectionjava:291)	at javalangclassprivategetdeclaredmethods(classjava:2701)	at javalangclassgetdeclaredmethod(classjava:2128)	at javautilhashmapget(hashmapjava:556)	at sunreflectreflectionfiltermethods(reflectionjava:291)```this does not occur when mocking `map`verified against mockito 2228";;1;0;only resolve instrumented method after validating that an instance is a mock;
826;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;introduce validable answers for early validation of stubbing;## overview;;0;document abstractscheduledservice concurrency policy; the use of unguarded fields in the example in the class comment of abstractscheduledservice strongly suggests that runoneiteration will never be executed by more than one thread concurrently and that there are happens-before edges between consecutive calls to runoneiteration i cant find a guarantee of this in the docs however; ;;;;0;1;;
826;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;introduce validable answers for early validation of stubbing;## overview;;0;make sphinx docs consistent with web site but still standalone;css to make docs consistent with website unbinds their dependency and removes links from top bar;we looked at this and decided we like the current look of the docs ||;;;;0;1;;
826;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;introduce validable answers for early validation of stubbing;## overview;;0;return wrapped subscription;- make sure the safesubscriber is included in what is returned- then return as subscription not subscriber so it cant be cast back to a subscriber;;;;;1;1;return wrapped subscription- make sure the safesubscriber is included in what is returned- then return as subscription not subscriber so it cant be cast back to a subscriber;
826;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;introduce validable answers for early validation of stubbing;## overview;;820.0;introduce validable answers for early validation of stubbing;"## overviewcustom answers are now more robust - users can add add validation logic to the answer implementation it can validate the return type early during stubbing in test rather than fail late during execution of code under test mockito team uses this api behind the hood for all custom implementations of answer interface now advanced users can leverage this new api too!```javaclass mycustomanswer implements answer validableanswer { // <-- note extra ""validableanswer"" interface  public object answer(invocationonmock invocation) {    // answer implementation  }  public void validatefor(invocationonmock invocation) {    // throw mockitoexception if answer cannot be applied to given invocation  }}``` ## implementationwhile trying to 820 / #821 i noticed that `answersvalidator` knew too much about other answers to fix the design issue i propose the following design :* introduce `validableanswer` in public api which is a single method interface that doesnt extends `answer`* each answer that wants to be validated hence implement this interfacebenefit reduced visibility of some methods in these answers each new answer that want to be validated can just by implementing the new contractvalidating returned value of a mocks default answer had to be handled differently";"  ";[varargs] unexpected behaviour of returnsargat(int);i stumble about a test that failed after refactoring an array parameter to an varargsthe following test succeed:```javainterface foo{        int getodd(int input)}@testpublic void test() throws exception {    when(foogetodd(any()))then(returnsargat(0))            int odd  mockgetodd(new int{135})    assertthat(odd)contains(135)}```now lets change the parameter _input_ to an varargs```javainterface foo{        int getodd(int input)}```the test fails now with:```orgmockitoexceptionsmisusingwrongtypeofreturnvalue: the argument of type int cannot be returned because the following method should return the type int -> foogetodd()```this is not expected cause the change is source and binary(?) compatible an varargs-parameter is still an array returnsargumentat interprets the vararg array items as real parameters in other words it tries to return an element type where the array type is requiredcan the behaviour of interpreting vararg elements like parameters be changed so an vararg is treated as an array? eg in mockito 3? there are several other cases were the current vararg handling leads to unexpected behaviour;i think your second example has a typo since there are no var args in the example || thanks  || good catch!by the way the mock reference is both foo and mock || while it is source and binary compatible vararg method are different than plain old array method reflection allows to distinguish that the issue is in `returnsargumentatreturnedtypeonsignature` where theres a special handling for varargs || im working on the fix (currently adding some unit tests) || this should be fixed by #821 ||;1;0;renames methodinfo to invocationinfo;
827;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;added test for auxsubgenerator;added a basic test for the auxsubgenerator.;;0;provide bitunit and byteunit (like javautilconcurrenttimeunit); it is very much the same like timeunit but for bits and bytesboth are enums and can be used for:- converting (bits<->bytes) (ie bitunitkbittokib(16000))- converting (betwenn different prefixes) (ie byteunitgbtomb(1))- as a param type for methods etc (ie setcontentlength(int value byteunit unit))enums are using terminology for prefixes from iec 80000-13 (ie kilo is 10^3 and kibi is 2^10)ive already implemented it:  is under apache license 2 and i would be happy to see it in guavathere is a stackoverflow question about this //stackoverflowcom/questions/8495881/is-there-a-java-enum-for-filesize-units-thats-equivalent-to-java-util-concurren; good catchmerging into that issue!--- ;;;;0;1;;
827;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;added test for auxsubgenerator;added a basic test for the auxsubgenerator.;;0;test for verification listeners test can introduces bogus erro in other test cases;"the following test (orgmockitousagedebuggingverificationlistenercallbacktest#should_not_call_listener_when_verify_was_called_incorrectly) was causing non wanted exception in mockito```orgmockitousagemisusecleaninguppotentialstubbingtest > shouldresetongoingstubbingoninorder failed    orgmockitoexceptionsmisusingcannotstubvoidmethodwithreturnvalue:     onverification is a *void method* and it *cannot* be stubbed with a *return value*!    voids are usually stubbed with throwables:        dothrow(exception)when(mock)somevoidmethod()    ***    if youre unsure why youre getting above error read on    due to the nature of the syntax above problem might occur because:    1 the method you are trying to stub is *overloaded* make sure you are calling the right overloaded version    2 somewhere in your test you are stubbing *final methods* sorry mockito does not verify/stub final methods    3 a spy is stubbed using when(spyfoo())then() syntax it is safer to stub spies -        - with doreturn|throw() family of methods more in javadocs for mockitospy() method    4 mocking methods declared on non-public parent classes is not supported        at orgmockitointernalexceptionsreportercannotstubvoidmethodwithareturnvalue(reporterjava:448)        at orgmockitointernalstubbinganswersanswersvalidatorvalidatereturnvalue(answersvalidatorjava:72)        at orgmockitointernalstubbinganswersanswersvalidatorvalidate(answersvalidatorjava:29)        at orgmockitointernalstubbinginvocationcontainerimpladdanswer(invocationcontainerimpljava:63)        at orgmockitointernalstubbinginvocationcontainerimpladdanswer(invocationcontainerimpljava:49)        at orgmockitointernalstubbingongoingstubbingimplthenanswer(ongoingstubbingimpljava:28)        at orgmockitointernalstubbingbasestubbingthenreturn(basestubbingjava:16)        at orgmockitousagemisusecleaninguppotentialstubbingtestassertongoingstubbingisreset(cleaninguppotentialstubbingtestjava:50)        at orgmockitousagemisusecleaninguppotentialstubbingtestshouldresetongoingstubbingoninorder(cleaninguppotentialstubbingtestjava:36)orgmockitousagemisusecleaninguppotentialstubbingtest > shouldresetongoingstubbingonverify failed    orgmockitoexceptionsmisusingcannotstubvoidmethodwithreturnvalue:     onverification is a *void method* and it *cannot* be stubbed with a *return value*!    voids are usually stubbed with throwables:        dothrow(exception)when(mock)somevoidmethod()    ***    if youre unsure why youre getting above error read on    due to the nature of the syntax above problem might occur because:    1 the method you are trying to stub is *overloaded* make sure you are calling the right overloaded version    2 somewhere in your test you are stubbing *final methods* sorry mockito does not verify/stub final methods    3 a spy is stubbed using when(spyfoo())then() syntax it is safer to stub spies -        - with doreturn|throw() family of methods more in javadocs for mockitospy() method    4 mocking methods declared on non-public parent classes is not supported        at orgmockitointernalexceptionsreportercannotstubvoidmethodwithareturnvalue(reporterjava:448)        at orgmockitointernalstubbinganswersanswersvalidatorvalidatereturnvalue(answersvalidatorjava:72)        at orgmockitointernalstubbinganswersanswersvalidatorvalidate(answersvalidatorjava:29)        at orgmockitointernalstubbinginvocationcontainerimpladdanswer(invocationcontainerimpljava:63)        at orgmockitointernalstubbinginvocationcontainerimpladdanswer(invocationcontainerimpljava:49)        at orgmockitointernalstubbingongoingstubbingimplthenanswer(ongoingstubbingimpljava:28)        at orgmockitointernalstubbingbasestubbingthenreturn(basestubbingjava:16)        at orgmockitousagemisusecleaninguppotentialstubbingtestassertongoingstubbingisreset(cleaninguppotentialstubbingtestjava:50)        at orgmockitousagemisusecleaninguppotentialstubbingtestshouldresetongoingstubbingonverify(cleaninguppotentialstubbingtestjava:28)```the issue is that the mentionned test used a mock to create a listener for a test but forgot to remove it so on a next interaction with a mock the listener was called as such the last interaction is `void onverification` so the answer could not be validatedthe case is easy to reproduce :```javainterface foo {    string nonvoid(string param)    void dosomething(string param)}@testpublic void should_not_call_listener_when_verify_was_called_incorrectly() {    //when    foo foo  null    verificationlistener mocklistener  mock(verificationlistenerclass)    mockitoframework()addlistener(mocklistener)    try {        verify(foo)nonvoid("""")        fail(""exception expected"")    } catch (nullinsteadofmockexception expected) {        //then        verify(mocklistener never())onverification(any(verificationeventclass))    }    // mockitoframework()removelistener(mocklistener) // fix    // done in cleaninguppotentialstubbingtest    try {        when(null)thenreturn(""anything"") // throws instead cannotstubvoidmethodwithreturnvalue        assertionsfail(""expected"")    } catch (missingmethodinvocationexception e) {} }```given the conditions to reproduce the bug id say we can keep the code that way";;;;;1;1;quick fix for the verification listeners test where the stubbing in the listener causes an invocation mismatch in the next stub;
827;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;added test for auxsubgenerator;added a basic test for the auxsubgenerator.;;0;add notice file for binary distribution;;;;;;1;1;add notice file for binary distribution;
827;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;added test for auxsubgenerator;added a basic test for the auxsubgenerator.;;0; cut & paster error in io scheduler;thanks @samuelgruetter for pointing this out;#750 builds on my machine  obviouslygithub pull request #827 to netflix/rxjava[envinject] - loading node environment variablesbuilding remotely on 6880a4f9 in workspace /scratch/jenkins/workspace/rxjava-pull-requests$ sudo /opt/jenkins/sbin/mount-webdav  netflixoss alert/private/netflixoss is not a mountpointwebdav mount try 1/private/netflixoss is not a mountpointp11-kit: couldnt read config file: /etc/pkcs11/modules//private/netflixoss is a mountpointfetching changes from the remote git repositoryfetching upstream changes from git://githubcom/netflix/rxjavagitfatal: could not checkout master with start point origin/master ||;;;;1;1; cut & paster error in io scheduler;
830;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;added ordinal formatter;motivated by http://tex.stackexchange.com/questions/292491/numerals-to-ordinals-in-jabref-jstyle-layout-file;;0;messagedigesthashfunctions not thread-safe; ive had a look at the new hash functions in guava 11 and plan on replacing my password hashing code with it since it gives me a nice fluent api without checked exceptionsthe messagedigest hash functions (md5 sha-1 sha-256 and sha-512) however dont seem to work in multi-threaded applications thats because they are stored as class variables in order to make it work the following code public static hashfunction sha256() {&nbsp&nbsp&nbsp&nbspreturn sha_256}should be replaced with public static hashfunction sha256() {&nbsp&nbsp&nbsp&nbspreturn new messagedigesthashfunction(""sha-256"")}a similar change is required for the other messagedigest hash functions even then there should be a comment in the javadoc saying that the resulting hashfunction is not thread-safe (but would work in multi-threaded applications)"; ;;;;0;1;;
830;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;added ordinal formatter;motivated by http://tex.stackexchange.com/questions/292491/numerals-to-ordinals-in-jabref-jstyle-layout-file;;0;added resources to the support page;following the example of reactjs this adds stack overflow irc google group facebook group and a twitter widget  using #prestodb as the tag on both stack overflow and twitter;also fyi i just signed the cla || just commiting these changes to the community page on electrums website branch ||;;;;0;1;;
830;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;added ordinal formatter;motivated by http://tex.stackexchange.com/questions/292491/numerals-to-ordinals-in-jabref-jstyle-layout-file;;0;subscriber linking up for unsubscriptions;if i understand correctly a subscriber should send unsubscriptions only upwards but never downwards so whenever `lift` is used one would need to chain up subscribers like this:```subscriber<u> call(subscriber<t> o) {   subscriber<u> u     oadd(u)   return u}```here `o` comes from the client calling ounsubscribe will propagate to uunsubscribe and up on the chain however if uunsubscribe is called it wont affect os subscriptions ie u should send out oncompleted event to affect downstreamhowever the `operatormap` doesnt do this but basically shares the same compositesubscription between o and u therefore unsubscription will affect both upstream and downstream `operatortake` completely ignores unsubscription coming from `o` as well letting the following example spin trough the 1g values in the background``` javaobservablerange(0 1_000_000_000)take(1_000_000_000)take(1)toblockingobservable()last()threadsleep(5000)```;"yep it was certainly broken  in  for the report || this unit test proved the issue and is now passing:``` java    public void testmultitake() {        final atomicinteger count  new atomicinteger()        observablecreate(new onsubscribe<integer>() {            @override            public void call(subscriber<? super integer> s) {                for (int i  0 !sisunsubscribed() i++) {                    systemoutprintln(""emit: "" + i)                    countincrementandget()                    sonnext(i)                }            }        })take(100)take(1)toblockingobservable()foreach(new action1<integer>() {            @override            public void call(integer t1) {                systemoutprintln(""receive: "" + t1)            }        })        assertequals(1 countget())    }``` || what about operatormap? || what about `map`? it doesnt decouple the subscription chain but just passes it through ``` java    public subscriber<? super t> call(final subscriber<? super r> o) {        return new subscriber<t>(o) {``` || consider this (running on head as of now):``` javapublic static void main(string args) throws exception {        atomicinteger count  new atomicinteger()        observablefrom(1 2)                map(v -> v * 2)take(1)                subscribe(new subscriber<integer>() {            @override            public void oncompleted() {            }            @override            public void onerror(throwable e) {            }            @override            public void onnext(integer t) {                add(schedulersnewthread()schedule(                        i -> countincrementandget() 500 timeunitmilliseconds                ))            }        })        threadsleep(1000)        systemoutprintln(count)    }```it prints 0 for me because once take unsubscribes from map map (or take?) propagates that unsubscription downwards as well disrupting the delayed schedule || yes thats how it behaves but not because `take` unsubscribes its because `oncomplete` happens which then triggers `unsubscribe` from the bottom up to do cleanup inside the `safesubscriber` that is by design> rx design guideline 43 assume resources are cleaned up after an onerror or oncompleted> message> paragraph 41 states that no more messages should arrive after an onerror or oncompleted message this makes it possible to cleanup any resource used by the subscription the moment an onerror or oncompleted arrives cleaning up resources immediately will make sure that any side-effect occurs in a predictable fashion it also makes sure that the runtime can reclaim these resourcesthus adding the `scheduler subscription` to the `subscriber` but wanting it to be run _after_ `oncompleted` wont work you would need to remove the `add` so the scheduling 500ms in the future happens regardless of `oncomplete` happening (fyi that i wont be responding to this further tonight its past midnight and my brain is done) || surprisingly this works:``` javaobservablefrom(1)take(1)delay(v -> observabletimer(500 timeunitmilliseconds))subscribe(s)```even if delay clearly violates the guideline above as take will call unsubscribe before delay even emits its value it seems delay works only because its compositesubscription is disconnected from upstream so safesubscriber cant unsubscribe it before the actions were taken so if i rewrite delay pending onnexts wont get run because safesubscriber between the two will cancel the schedule/subscriptions i think safesubscriber shouldnt force its actual subscriber (which is downstream) to unsubscribe || > even if delay clearly violates the guideline aboveit doesnt violate the guideline `delay` is also delaying the `oncomplete` thus the `unsubscribe` of `safesubscriber` is not triggered until after `delay` completes> surprisingly this works:its not surprising since `delay` is an intermediate operator and thus does not have `safesubscriber` applied to it this is yet another reason why `lift` is actually a clearer representation of what is happening – the intermediate operations are not subscribing their functions are lifted into the `observable` and executed in sequence when the `observable` is subscribed to by the final `subscribe(subscriber)` the only remaining oddity now that we have `lift` that doesnt cleanly match are nested `observable` use cases where an `operator` must subscribe to them (such as `groupby` `merge` `zip` `repeat`) we still rely on the `isinternalimplementation` check to prevent `safesubscriber` from wrapping those that is the intent of this discussion:  during the `lift` prototyping i had considered a private or different method than `subscribe` for operators to use but it makes the public api awkward to do so likely we will end up with an `rxoperatorssubscriber/trustedsubscriber/operatorsubscriber` marker interface > i think safesubscriber shouldnt force its actual subscriber (which is downstream) to unsubscribeif this were to be changed that would mean our current interpretation and implementation of guideline 43 is wrong as per the current interpretation the ""actual subscriber"" is not downstream the `safesubscriber` is the absolute last thing in the sequence and this is because the `subscribe` step is the final in the chain its the exit point ``` javaobservablefrom(1)take(1)delay(v -> observabletimer(500 timeunitmilliseconds))subscribe(s)```the final `subscribe(s)` there is the end thats why it returns `subscription` (or could equally return `void` now) thus once the `oncomplete/onerror` is invoked it is terminated and the full sequence is `unsubscribed` if `safesubscriber` did not `unsubscribe` the actual `subscriber` what would it `unsubscribe`? the intent is to cleanup all resources and the injected `subscriber` is one of the resources that is now terminated and being cleaned upconsidering this interpretation of guideline 43 what code changes would you make?@headinthebox your input would be valuable to correct any misunderstandings or wrong implementations of the guidelines we have the particular line of the guideline that influenced this implementation is:> the rx contract for cleanup ensures that unsubscription will be called automatically once an onerror or oncompleted message is sentspecifically we have interpreted that to mean when `oncompleted/onerror` happens at the very end not to intermediate steps (since that didnt make sense nor does it work) || thanks from implementation perspective i have two concerns:- as an internal implementation the subscriber returned by my lifter method will be unsubscribed from upstream depending on what other operator is there: the case where basically there is a single compositesubscription shared between various lifting subscribers- as an external implementation i cant use the subscribers add() method because safesubscriber will unsubscribe it even if i want different behavior or do something after oncompleted arrived from upstream (ie subscribe to another source)most likely both situation can be bypassed via `nest()` || > will be unsubscribed from upstreamif an operator needs to decouple from this (such as `groupby`) then it passes a different `subscription` up the chain the `map` operator for example doesnt care it just transforms data it receives > as an external implementation i cant use the subscribers add() method sure you can within the lifecycle of that `subscriber` if you dont want to work within the lifecycle then you must decouple just like `groupby` does if you want to do something after `oncomplete` you are by definition working outside the lifecycle of that `subscriber` since youre at the end of the chain you would not have another `subscription` to attach to and thus just fire-and-forget as in the example given above with a `scheduler` inside `onnext`in short the `subscribe` method is not the place to build a chaining operator implementing the `lift` function is and then you decouple the `subscription` as necessary if you use `subscribe(subscriber s)` then it is the end of the chain  || ";;;;0;1;;
830;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;added ordinal formatter;motivated by http://tex.stackexchange.com/questions/292491/numerals-to-ordinals-in-jabref-jstyle-layout-file;;822.0;improves exception message in case a matcher is used for a primitive parameter;this should help for cases like #822 npe can be raised by the jvm on the callsite of a matcher returning object like `any()`the thing is that the jvm does several thing like to allows a type to match a signature like `<t> t any()` type inference with java 8 cast and unboxing however `any()` can only return `null` so the jvm raises an npe on the cast opcode of course the problem isnt new but more possible due to java 8 flexibility thats why mockito had for a long time the primitivewhen mockito is used with the junit runner or the junit rule theres a `invaliduseofmatchersexception` raised **after** the npe with a message about misplaced matchers this exception is raised because the matchers were not consumed by the mock since the npe is raised first so this exception is correct and can help the neophyte to discover the primitive variant like `anyint()`;i love this change! the description of the pr is really good i immediately was able to understand the use case mockito is great because we never stop improving the ux - the exception messages and suchbig ;bogus npe if any() is used with primitive type arguments;"mockito: 230 java 8when mocking a method invocation if any() is used instead of anyint() for exampe in the when method call a bogus npe is thrown there is quite a lot of explanations to the root cause of that but it does not contain this hinti would expect either a compilation error or a more explanatory exceptioncode:  at xxxwtftesttestcasenpe(wtftestjava:34)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)	at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orgmockitointernalrunnerssilentjunitrunnerrun(silentjunitrunnerjava:39)	at orgmockitointernalrunnersstrictrunnerrun(strictrunnerjava:39)	at orgmockitojunitmockitojunitrunnerrun(mockitojunitrunnerjava:103)	at orgjunitrunnerjunitcorerun(junitcorejava:137)	at comintellijjunit4junit4ideatestrunnerstartrunnerwithargs(junit4ideatestrunnerjava:68)	at comintellijrtexecutionjunitideatestrunner$repeaterstartrunnerwithargs(ideatestrunnerjava:51)	at comintellijrtexecutionjunitjunitstarterpreparestreamsandstart(junitstarterjava:237)	at comintellijrtexecutionjunitjunitstartermain(junitstarterjava:70)you cannot use argument matchers outside of verification or stubbingexamples of correct usage of argument matchers:    when(mockget(anyint()))thenreturn(null)    dothrow(new runtimeexception())when(mock)somevoidmethod(anyobject())    verify(mock)somemethod(contains(""foo""))also this error might show up because you use argument matchers with methods that cannot be mockedfollowing methods *cannot* be stubbed/verified: final/private/equals()/hashcode()mocking methods declared on non-public parent classes is not supported```";"there is also some weirdness that the mockfoos value is set to null between the invocation of when() and foo() on line 33 || @axos88 this behaviour cant be avoided cause java doesnt allow return type overloads like `int any()` `t any()`    therefore mockito provides `any<primitve>()` methods   || **tldr**this cannot be avoided as @christianschwarz has just wrote thats one of corner area of java itself where cant really do something **long story**with the signature of `any()` `javac` thinks * that `any()` can return an `integer` > insert cast object to integer* that the `integer` can be unboxed > invoke `intvalue`however `any`* has return type `t` whose implicit upper bound is `object` > `integer` matches for `javac`* returns `null` reference > ok for `integer`the npe is raised on the callsite by code that wasnt explicitly written and we cant really do something here note the javadoc of `any()` do say to use the primitive variants :```for primitive types use {@link #anychar()} family``` || i understand but a note about this in the output of the exception about this possibility would be welcome:```you cannot use argument matchers outside of verification or stubbingexamples of correct usage of argument matchers:    when(mockget(anyint()))thenreturn(null)    dothrow(new runtimeexception())when(mock)somevoidmethod(anyobject())    verify(mock)somemethod(contains(""foo""))also this error might show up because you use argument matchers with methods that cannot be mockedfollowing methods *cannot* be stubbed/verified: final/private/equals()/hashcode()mocking methods declared on non-public parent classes is not supported``` || im not sure this is related what fails is a nullpointerexception that is raised by the jvm on the callsite of the matcherthe mockito exception message seems related to another issue and the exception type that have this message can only be `invaliduseofmatchersexception` || it seems like the npe has an invaliduseofmatchersexception as its cause || ah i see whats happening junit runner performs an additional check after a test and then report a matcher misuse because the matchers were not _consumed_ byt the mock the npe is raised firstindeed we can mention that in the messagethanks for insisting on this ! || closing this one since theres now the pr #830  || hi @bric3  i believe this issue is appearing again please see my below junit example:```public class mockitotest {    @test    public void testdoathing() {        final testthing thing  mockitomock(testthingclass)        mockitowhen(thingdoathing(mockitoany() mockitoany()))            thenreturn(""asd"")    }    public static class testthing {        public string doathing(string foo boolean second) {            return second ? foo + ""asd"" : foo        }    }}```when running this test i get the following output:```javalangnullpointerexception	at commytestmockitotesttestdoathing(mockitotestjava:12)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:47)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:44)	at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:271)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:70)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:50)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:238)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:63)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:236)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:53)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:229)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:309)	at orgjunitrunnerjunitcorerun(junitcorejava:160)	at comintellijjunit4junit4ideatestrunnerstartrunnerwithargs(junit4ideatestrunnerjava:68)	at comintellijrtexecutionjunitideatestrunner$repeaterstartrunnerwithargs(ideatestrunnerjava:47)	at comintellijrtexecutionjunitjunitstarterpreparestreamsandstart(junitstarterjava:242)	at comintellijrtexecutionjunitjunitstartermain(junitstarterjava:70)```no mention of the above error or any real indication what is happening - i ended up using trial and error to determine what was going wrong || ";1;0;boyscout test improvement;
831;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;test clean up according to discussions for rememberinglisteners;according to issue @719 we wanted to clean up the tests for rememberinglisteners.;;0;multiple hash iterations; once issue 830 is  i intend to use guavas hashing api for creating password hashes at the moment the code would look something like this:public static string encodepassword(string password string salt) {&nbsp&nbsphashfunction func  hashingsha256()&nbsp&nbsphashcode result  funchashstring(password + salt utf_8)&nbsp&nbspfor (int i  0 i < iteration_count i++) {&nbsp&nbsp&nbsp&nbspresult  funchashbytes(resultasbytes())&nbsp&nbsp}&nbsp&nbspreturn salt + resulttostring()}i was wondering if the possibility of hashing a hash n times could be added to the api? also a salt generator that generates random hexadecimal values of a given length would be very useful; it doesnt seem clear that guava needs to add anything i think a user could pretty easily create a hashfunction implementation that delegates to another hashfunction and feeds the result through itself n times if not please let us know--- ;;;;0;1;;
831;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;test clean up according to discussions for rememberinglisteners;according to issue @719 we wanted to clean up the tests for rememberinglisteners.;;0;make interpreter stateless;;;;;;1;1;make interpreter stateless;
831;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;test clean up according to discussions for rememberinglisteners;according to issue @719 we wanted to clean up the tests for rememberinglisteners.;;0;race condition in rxoperatorsoperationjoin;i just picked up rxjava for the first time and was experimenting with observablejoin() i discovered a race condition when both sides of the join are publishing in parallel - they will both emit each others itemeg    1---2---**3**---4    --a---b-**c**--d-could result in:1a2a1b2b3a3b**3c**1c2c**3c**1d2d3d4a4b4c4di have a patch for this on my fork - ill submit a pull request;i really appreciate you finding the fix for this  ||;;;;0;1;;
831;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;test clean up according to discussions for rememberinglisteners;according to issue @719 we wanted to clean up the tests for rememberinglisteners.;;825.0;test clean up according to discussions for rememberinglisteners;according to issue @719 we wanted to clean up the tests for rememberinglistenersthe tests should follow the same style and conventionsset up should not contain variables used by all the testswe previously had another pr for this in #825 that build was failing for some reason not obvious and had 1 merge commit that we wanted to remove in an attempt to rebase and reset the history github lost the connection to the remote fork instead of spending time investigating i just created a new pr;    @bric3 @timvdlippe sorry for this new pr with the same code previously we were discussing #825 in an attempt to fix the pr github lost the link and i couldnt reconnect it this pr is building and has only one commit message and no merge || looks good to me thanks for the improvement ||;#719 test clean up according to discussions for rememberinglisteners;according to issue @719 we wanted to clean up the tests for `rememberinglistener`sthe tests should follow the same style and conventionsset up should not contain variables used by all the tests;"    @bric3 ive inlinded `fooclassgetdeclaredmethod(""dosomething"" stringclass)`regarding putting the method `notifiedfor` into orgmockitoutilconditionsthe method is not same between `invocationlistenercallbacktest` and `verificationlistenercallbacktest` and they both use a different implementation of `rememberinglistener`i would like to wait for more test classes wanting to do the same thing and then move it else we need to move also the class and find new suitable names for the classesunless you have another idea to improve this? || i just tried the webview to resolve conflicts its ok but limited and it creates a commit named like `merge branch release/2x into verification-listeners-cleanup` id rather have more control on this || > regarding putting the method notifiedfor into orgmockitoutilconditionsthe method is not same between invocationlistenercallbacktest and verificationlistenercallbacktest and they both use a different implementation of rememberinglisteneri would like to wait for more test classes wanting to do the same thing and then move it else we need to move also the class and find new suitable names for the classesunless you have another idea to improve this?ok fair enough :) || ";1;0;"""#719 test clean up according to discussions for rememberinglisteners""";
839;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;838 : adds a matches(pattern);following discussion in #838 it is sensible to add a mockito matcher that can take a  pattern  as an argument.;;0;eventbus package doc incorrect; the eventbus package javadoc specifies that theres no way to unregister handlers from the eventbus  this contradicts well the existence of eventbusunregister; ;;;;0;1;;
839;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;838 : adds a matches(pattern);following discussion in #838 it is sensible to add a mockito matcher that can take a  pattern  as an argument.;;0;publish binary artifacts to sonatype oss;;;;;;0;1;;
839;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;838 : adds a matches(pattern);following discussion in #838 it is sensible to add a mockito matcher that can take a  pattern  as an argument.;;0;error handling: onerrornotimplemented and javalangerror;special handling of javalangerror and onerrornotimplemented-   https://githubcom/netflix/rxjava/issues/789;this represents a possible approach to handling `onerrornotimplementedexception` and `javalangerror` im not convinced its the right approach for all `javalangerror` to be caught for `onerrornotimplementedexception` and `stackoverflow` i think they must be thrown from wherever they are caught the reason for it not being obvious to throw is that by throwing on a background thread instead of sending via `onerror` the terminal states of an `observable` will never be triggered and thus will deadlock many `javalangerror` should result in the system shutting down but probably not all it could possibly be limited to these:  advice or insight on what is considered to be the right approach for everything else? || after thinking about it further i decided i didnt like my previous approach and have replaced it with this one that is more generic and doesnt make any specific operators do anything special i found the issue was the `synchronizedobserver` was taking on more responsibility than it should have been and was capturing errors and then ignoring everything after a terminal state occurred which became a problem when `onerror` was called resulted in an exception of its own which invoked `onerror` again this resulted in me doing 3 specific changes:1) `safesubscriber` manages safety and error handling `synchronizedobserver` only does synchronization2) new method `exceptionsthrowiffatal(e)` checks for special handling ``` java    public static void throwiffatal(throwable t) {        if (t instanceof onerrornotimplementedexception) {            throw (onerrornotimplementedexception) t        }        // values here derived from         else if (t instanceof stackoverflowerror) {            throw (stackoverflowerror) t        } else if (t instanceof virtualmachineerror) {            throw (virtualmachineerror) t        } else if (t instanceof threaddeath) {            throw (threaddeath) t        } else if (t instanceof linkageerror) {            throw (linkageerror) t        }    }```3) the `throwiffatal` call is invoked _before_ the terminal state check so even if `onerror` was already invoked and throws only to end up again passed to `onerror` the `throwiffatal` will catch it on the outside of the `isfinished` check so it will still throw``` java    public void onerror(throwable e) {        // we handle here instead of another method so we dont add stacks to the frame        // which can prevent it from being able to handle stackoverflow        exceptionsthrowiffatal(e)        if (isfinishedcompareandset(false true)) {            _onerror(e)        }    }```these changes appear to have resolved the `onerrornotimplemented` and `stackoverflow` issues reported in  and  || local build is passing  merging> build successful> > total time: 2 mins 36851 secs || #761 ;;;;1;1;special handling of javalangerror and onerrornotimplemented-    synchronizedobserver is for synchronization not error handling or contract enforcements thats the job of safesubscriber- removed some unit tests that were asserting unsubscribe behavior that relied on synchronizedobserver they were testing something they are not responsible for;
839;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;838 : adds a matches(pattern);following discussion in #838 it is sensible to add a mockito matcher that can take a  pattern  as an argument.;;838.0;838 : adds a matches(pattern);"following discussion in #838 it is sensible to add a mockito matcher that can take a `pattern` as an argumentthe usage is the same as `matches(string)````javawhen(mockonearg(matches(patterncompile(""[a-z]+\\d\\d""))))thenreturn()```although it allows to build more complex regex especially with regular expression flags";@mockito/core since the pr is fairly in scope amd fairly straightforward limited ill merge it right away || >@mockito/core since the pr is fairly in scope amd fairly straightforward limited ill merge it right awayabsolutelyupdating the public api needs review from other team mates but in this case its best to move fast its an overloaded method very natural complement to the existing one thanks @bric3! || yes exactly :) ||;feature request: argumentmatchersmatches(pattern regex);you ladies and gentlemen are geniuses by the wayargumentmatchersmatch( string regex ) exists but wouldnt it be slightly better if it were match( pattern regex )? (ie catering for multi-line strings etc)also devising a regex which distinctly does not match a given string is non-trivial  and yet not atypical of a mocking use case  hence i suggest you clever people take the heavy lifting away from grunts like me by offering argumentmatchersdoesnotmatch( pattern regex )i posed this question today on stack overflow [here](  ------**edit 1** by @bric3 : removed the issue guidelines**edit 2** by @bric3 : renamed the issue title previous title was `feature request: argumentmatchersdoesnotmatch( pattern regex )`;"as the question is answered in so you can negate matchers using `additionalmatchersnot()`i think i can close this issue || ok but this question highlights the fact that the online documentation and tutorials are not optional they are essential  and they are currently inadequate  people who are willing to learn shouldnt have to pose a question for such an obvious use case on so || hii closed the issue because it is about a feature request that is not valid since the feature is already present in a different form now documentation and tutorial is another thing`additionalmatchers` is mentionned on the first line of the [argumentmatchers javadoc]( the mockito javadoc gives plenty of code examples on the public api which is already more than most javadoc in almost every project im not saying it cant improved or we wont improve it it can and we will! on the matter at hand those matchers can be promoted a bit more to enhance discoverabilityregarding tutorials i believe it is the responsibility of respective blog authorsin the mean time pull requests are welcome and the wiki can be edited by any benevolent soul || also it seems i skipped the part on the `pattern` class reopening for the `matches(pattern)` matcher || oh good  no really!  the multi-line challenge has me foxed indeed  :) || the builds should propagate within an hour (note that badges or searchmavenorg may not be up to date) || hi brice thanks for doing this so quickly  i have upgraded my gradlebuild and got hold of your new build  but i am still having problems using ""not"" with this if you have a moment maybe you might look at my new edit at [so]( || it looks like an import issue either for `not` or `matches` ive tested it yesterday when i added the api || yes youre right: its an assertj confusion: eclipse imported notfilternot() automatically  apologies || ";1;0;838 : adds a matches(pattern);
842;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed #492: all text is copied if nothing is marked and preview of pa…;fixed #492  when nothing is selected the whole field is copied. if the field is empty  the right click copy item is disabled.  preview of text to be pasted in tool tip. now maximum 20 characters. should it be longer?;;0;new stopwatch() throws exception javalangincompatibleclasschangeerror on ubuntu; <b>what steps will reproduce the problem?</b>1 stopwatch stopwatch  new stopwatch()<b>what is the expected output? what do you see instead?</b>it should create new instance of stopwatchwhat i get is  found interface comgooglecommonbaseticker but class was expected&nbsp&nbsp&nbsp&nbspat comgooglecommonbasestopwatch&ltinit>(stopwatchjava:84)<b>what version of the product are you using? on what operating system?</b>guava 1001 ubuntu 10 java 160_26<b>please provide any additional information below</b>; yeah you were absolutely right i didnt notice that intellij idea adds own pack of libraries (including guava r09) to dependencies i removed that and issue is solved thank you for help ||;;;;0;1;;
842;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed #492: all text is copied if nothing is marked and preview of pa…;fixed #492  when nothing is selected the whole field is copied. if the field is empty  the right click copy item is disabled.  preview of text to be pasted in tool tip. now maximum 20 characters. should it be longer?;;0;added missing javadoc and few other tidy-ups;1 no api / no behavior changes2 publicly visible changes:  - added missing javadoc and updated an existing one for mockitoexception and mockitoassertionerror classes3 remaining changes refactoring: - rename job for consistency - removed some unnecessary code - made the tests more stable; ;;;;1;1;documented the need to avoid static linking;
842;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed #492: all text is copied if nothing is marked and preview of pa…;fixed #492  when nothing is selected the whole field is copied. if the field is empty  the right click copy item is disabled.  preview of text to be pasted in tool tip. now maximum 20 characters. should it be longer?;;0;adding a reference to the facebook presto page  adding a like button;adding a like button to the index and community pages  also adding a section to the community page that links to the facebook presto page and the facebook engineering page;this is a duplicate of martins pull requests #848 - closing ||;;;;0;1;;
842;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed #492: all text is copied if nothing is marked and preview of pa…;fixed #492  when nothing is selected the whole field is copied. if the field is empty  the right click copy item is disabled.  preview of text to be pasted in tool tip. now maximum 20 characters. should it be longer?;;0;test unsubscribe;- also cleaned up some stuff i remembered after merging last commits;;;;;1;1;test unsubscribe- also cleaned up some stuff i remembered after merging last commits;
843;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;junit rule strictness can be tweaked per test method;see the design and rationale at #840;;0;improvement request: cacheput(k v) should return previous cache value; guava api version: 11the current signature of the cacheput method does not allow to atomically determine if the call to the put method caused a change to the cache as the return type is voidwould it not be more appropriate to let the cacheput(k key v value) return the previous value mimicking the mapput() operation ie```v put(k key v value)```i assume the cacheput method is placed in the cache api merely as a convenience method for```cacheasmap()put(k key v value)``` which does indeed return the previously cached value (atomically)if this change is not desired i suggest the javadoc is extended to cover the more elaborate put operation via the map view; ok this all boils down to the question whether the cache api should require from all implementations that they provide the previous value of a cache entryfor reference i can mention that infinispan (a widely used distributed cache implementation) uses a cache interface that supports a javautilmap like put method with return value see  have no problem in using cacheasmap()put() for my current implementation but as it is an optional operation i cannot be sure that it will be supported in future implementations and i feel that map and cache semantics actualy have quire a lot in common> googlecom> do you mind elaborating on why you have a cache which requires an atomic ""put and get""? the only > cases i can come up with for something like that could be better solved with a removallistenerwith regards to my concrete use case for requiring the previously stored cache value (atomically) i have a message processing application (100 messages/second peak) that requires a component to remove redundant messages (defined as consecutive  messages with a certain semantic id-key that has identical content (digest/hash)) since processing is done concurrently the only way to determine if the most recent message that was processed with the id-key has identical content and thus needs to be removed from the message stream would be (pseudocode):class redundantmessagefilter implements predicate {&nbsp&nbspcache&ltkey digest> cache // configured with expiry&nbsp&nbsppublic boolean accept(message message) {&nbsp&nbsp&nbsp&nbspdigest thisvalue  messagegetdigest()&nbsp&nbsp&nbsp&nbspdigest previousvalue  cacheasmap()put(messagegetkey() thisvalue)&nbsp&nbsp&nbsp&nbspreturn !thisvalueequals(previousvalue)&nbsp&nbsp}}the above code needs to be able to atomically ""get and put"" to avoid race conditionsit may not be the most typical use of a cache but its a cache nonetheless> i think that part of our concern may have been that for remote caches this could force put() to be a blocking operation?the infinispan api which is distributed (lan/wan) does support the put with return value as mentioned earlier without blocking> i think its best that cacheput() doesnt return the old value and users should use the asmap()put() alternative if they need itpossibly so it is obviously a balance between providing a (guaranteed) cache api functionality to cache clients and requiring atomic update capability from future cache implementations || ";;;;0;1;;
843;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;junit rule strictness can be tweaked per test method;see the design and rationale at #840;;0;adding analytics to sphinx documentation;;we dont want to include this in the generated documentation as that should be usable by anyone we could add the tracking code to the docs when they are added to the website ||;;;;0;1;;
843;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;junit rule strictness can be tweaked per test method;see the design and rationale at #840;;0;updating stringobservable;updating stringobservable to use liftand added from(inputstream) and from(reader);#764 #765 this is failing to merge and can the debug stuff be separated out from stringobservable? || nevermind i manually merged it in || is this in a snapshot release yet? || yes 0170-rc1 it was released yesterday || :-) ||;;;;1;1;updating stringobservable to use liftand added from(inputstream) and from(reader);
843;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;junit rule strictness can be tweaked per test method;see the design and rationale at #840;;840.0;junit rule strictness can be tweaked per test method;see the design and rationale at #840please review!;  tomorrow morning unless theres feedback thanks @timvdlippe for review! ||;tweak junit rule strictness at the method level;team i would really appreciate feedback about this enhancementthere is a feature request reported - a way to exempt from unnecessary stubbing at method level (#792) the feature request makes sense to me currently if the user wants to opt-out from junit rule or junit runner strictness he needs to do it at the scope of the entire class ideally we can opt-out from strictness at finer granularity level (method or even at mock level)inspired by @bric3 [idea]( id like to get your feedback about this api enhancement for strict junit rulesexample test class:```javapublic class mytest {    //mockito stubbing is strict in the entire test class    @rule public mockitorule mockito  mockitojunitrule()strictness(strictnessstrict_stubs)    @test public void lenient_mockito() throws throwable {        //making mockito lenient only for this test method        //below api already exist but it does not have any effect inside of the test method        mockitostrictness(strictnesslenient)        //rest of the test    }}```pros: - we already have strictness method in the mockitorule api so its not adding any new api - least surprise principle - users might expect this behavior to work but currently strictness method _creates_ new instance of the rule and _not_ change the state of the rulecons: - its slightly not intuitive that strictness method actually changes state (its not a setter);instead of a call to the rule (which i would expect to cause side-effects when i see the code) i think it is clearer to use an annotation on the method something like `@mockitostrictness(lenient)` || annotations are clearer and they are a good idea we discussed it in #792 @bric3 was not in favor of annotationscall to the rule is something we would offer in the meantime before we have annotations long term i think annotations are a way forwardim waiting for more feedback and im leaning to implement this new rule behavior regardless if we decide to do annotations or not :) || yes im not in favor of annotation but im not totally against either however annotation api is to be carefully designed as there is way less flexibility override argument types etc**pros*** i believe a programtic way offers more choice for users and framework developers including mockito> * least surprise principle - users might expect this behavior to work but currently strictness method creates new instance of the rule and not change the state of the rulethats maybe the biggest issue here to bypass this the code will need to have some way to define a global state in spseudo code :```java// formockitojunitrule()strictness(strictnessstrict_stubs)public mockitorule strictness(strictness strictness) {    return new junitrule(internalruleref logger strictness)}private junitrule(atomicreference<junitrule> internalref mockitologger logger strictness strictness) {    thisinternalruleset(new junitrule(logger strictness)) // existing constructor but should be another class ideally}public statement apply(statement base frameworkmethod method object target) {    return internalruleapply(base method target)}```**cons**> * its slightly not intuitive that strictness method actually changes state (its not a setter)nowadays people understand fluent api outside javabeans setters or getters i dont think thats really an issue there especially if theres code example in the javadoc || great feedback @bric3ill take a stab at making strictness() method working for us i should be able to use a single test listener inside a rule and make this listener mutable so that it can have different behavior between test runs || a solution could be that the rule also watches for annotations and calls the corresponding method that would require a follow-up pr of #843 wdyt? || >a solution could be that the rule also watches for annotations and calls the corresponding method that would require a follow-up pr of #843 wdyt?i like this idea a lot there are 2 main reasons i like it: - annotation looks nice and clean in test code - annotation would also work with junit runner (when we make it work with runner :) for the runner we cannot change its state programmatically because it is a static instance attached to the test class via @runwith annotation with junit rule the situation is different - we have an instance of a rule during test execution || theres also another option like : ```javarule  mockitojunitrule()strictness(strictnessstrict_stubs)// in some code blockrulehandler  rulehandler() // no argument  getterrulehandlerstrictness(stritnesslenient) // takes arg  modify behavior``` || thanks @bric3 for feedback! id rather stick to strictness() method instead of introducing handler() it feels the api is simpler and more intuitive to use ||  by #843  ||;1;0;updated the javadocs;
854;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;more cleanups while trying codacy;;;0;cachebuilder javadoc should specify defaults;cow@ the cachebuilder javadoc should specify the default values for all properties its not clear what the expected behavior is for the following cache:cachebuildernewbuilder()build(); the class javadoc already says ""entries are automatically evicted from the cache when any of maximumsize maximumweight expireafterwrite expireafteraccess weakkeys weakvalues or softvalues are requested"" i am satisfied with that being sufficiently explicit here--- ;;;;0;1;;
854;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;more cleanups while trying codacy;;;0;mockito junit runner supports strict stubbing;"background:- mockito ""strictness"" is explained in #769 - since 23x mockito junit rules already provide opt-in ""strict stubbing"" capability [see the javadoc]( change adds new opt-in ""strict stubbing"" support for mockito junit runner this behavior is tentatively planned to be the default in mockito v3 example usage:```java//note ""strictstubs"" inner class:@runwith(mockitojunitrunnerstrictstubsclass)public class exampletest {    // }      ```the behavior added by the strictstubs runner is documented in the [javadoc]( see also javadoc improvements in code changes for this pr the general direction of mockito ""strictness"" is documented in #769"; ;;;;1;1;updated version;
854;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;more cleanups while trying codacy;;;0;duration serialization relies on locale-dependent float formatting;"deserialization is not local-dependent and thus fails if the float contains a """" instead of a """" several comfacebookprestooperatortest*stats are failing due to this reason";this is dependent on  || its also impossible to query the presto-server via jdbc or the presto executable if the server is started on a machine that uses a decimal comma localethe jvm should be started with -duserlanguageen as long as this is not  in airlift || this is fixed in 060 ||;;;;0;1;;
854;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;more cleanups while trying codacy;;;0;the oncreate hook disappeared;i think in the merging this hook disappeared from the original pull request for the debug hooks;#778 ;;;;1;1;the oncreate hook disappeared;
858;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;tab for remaining fields;see #454.;;0;maps created via loadingcacheasmap() always return null upon calling get(key); we upgraded guava in our project to version 11 and refactored the code make use of mapmaker to cachebuilder in one instance we used mapmakermakecomputingmap() we followed the advice given in the javadoc to use cachebuilderbuild(cacheloader)asmap() unfortunately the map does not load values upon calling get heres a small unit test that illustrates the behaviour```@testpublic void testcacheloadernotworkinginmap() throws exception{    final loadingcache<string integer> cache  cachebuildernewbuilder()build(new cacheloader<string integer>()    {        @override        public integer load(final string key) throws exception        {            return integervalueof(keylength())        }    })    final map<string integer> map  cacheasmap()    assertnull(mapget(""one""))    assertequals(integervalueof(3) cacheget(""one""))}```maps created with mapmakermakecomputingmap(function) were returning results correctly"; thanks everyone for clarifying this so quickly! || ";;;;0;1;;
858;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;tab for remaining fields;see #454.;;0;safeguard for mockitolistener api;"reminds user if he forgets about ""removelistener()"" when working with [mockitolistener api]( added a safeguard that reminds users to clean up mockitolisteners via removelistener() method the implementation is very simple checking if the type of the listener is already added i found out about this problem when working on strict stubbing support without junit runner- this change makes mockitolistener api safer its easy to leak state which we have encountered in our own test suite- if we encounter legit use cases for adding the same listener type we can remove the safeguard or updated itthe pr also contains a couple of refactorings and tidy-ups i hope its ok";what if two libraries are used which add the same listener for their respective usecase? i dont think we can make this change eventually someone will hit this ||  ;;;;1;1;updated documentation- based on feedback from tim i updated the documentation and exception message- updated @since tag;
858;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;tab for remaining fields;see #454.;;0;add support for implicit cross joins;presto:default> select pfoo ibar from pokes p invites i query 20131115_215838_00012_89y4z failed: cross joins not yet supportedany plan to support this important sql feature?thanks;we support explicit cross joins now: `select pfoo ibar from pokes p cross join invites i` || hii use presto with prestogres( and bi tool(for example cognos pentaho)access flowbi tools -> prestogres -> presto bi tool issues an implicit join query when it executes an olap cube procedurefor example```selectfrom  fact f dimension dwhere  fkey  dkey```but presto error occurs```implicit cross joins are not yet supported use cross join```unfortunately i cant change the query that bi tool issuesso i think that it would be very nice if presto would support the implicit join || i agree i have the same problem currently im using a modified version of presto to enable implicit joinbut i think a parameter to allow it would be greati dont have time to create the pr@wyukawa see here >  ||;;;;0;1;;
858;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;tab for remaining fields;see #454.;;0;generics help please?;generics have me stumped on the `merge` operator the functionality is fine but only if i leave it untypedall other operators im using `lift` with are okay but i cant get this one``` java// this doesnt compile    public final static <t> observable<t> merge(observable<? extends observable<? extends t>> source) {        return sourcelift(new operatormerge<t>())     }// this compiles with untyped warnings (no generic) and functions    public final static <t> observable<t> merge(observable<? extends observable<? extends t>> source) {        return sourcelift(new operatormerge())     }// this compiles (but is only merging itself so not very helpful)    public observable<t> mergeself() {        return from(this)lift(new operatormerge<t>())    }// this doesnt compile    public observable<t> mergeselfwithanother(observable<? extends t> other) {        return from(this other)lift(new operatormerge<t>())    }```here is the compilation error:```/users/bechristensen/development/github/rxjavafork/rxjava-core/src/main/java/rx/observablejava  error: method lift in class observable<t#1> cannot be applied to given types        return sourcelift(new operatormerge<t>())                     ^  required: operator<rcap#1>  found: operatormerge<t#2>  reason: no instance(s) of type variable(s) r exist so that argument type operatormerge<t#2> conforms to formal parameter type operator<rcap#1>  where rt#1t#2 are type-variables:    r extends object declared in method <r>lift(operator<rt#1>)    t#1 extends object declared in class observable    t#2 extends object declared in method <t#2>merge(observable<? extends observable<? extends t#2>>)  where cap#1 is a fresh type-variable:    cap#1 extends observable<? extends t#2> from capture of ? extends observable<? extends t#2>```;"thank you to @abersnaze for fixing the generics! || i am getting the same compilation error now  using `ioreactivex 1010`  what is the solution? || @igorganapolsky what is the code exactly that doesnt compile? || @akarnokd i have this code:`return plugshareservicegetlocationinfo(locationid)                map(new plugshareresponsetolocation())                subscribeon(schedulersio())                observeon(androidschedulersmainthread())`and i get this error:> error:(28 60) error: method map in class observable<t> cannot be applied to given types> required: func1<? super evgolocation? extends r>> found: plugshareresponsetolocation> reason: cannot infer type-variable(s) r> (argument mismatch plugshareresponsetolocation cannot be converted to func1<? super evgolocation? extends r>)> where rt are type-variables:> r extends object declared in method <r>map(func1<? super t? extends r>)> t extends object declared in class observable || nevermind i solved it  i have to use this in my retrofit observable interface:`@post(""/locations/{id}"")    observable<plugshareresponse> getlocationinfo(@path(""id"") string id)`instead of `@post(""/locations/{id}"")    observable<evgolocation> getlocationinfo(@path(""id"") string id)` || ";;;;0;1;;
861;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;backport  release/2.x  changes to master (20161231) + fix for #860;backport  release/2.x  changes to master + the fix for #860.;;0;additional constructor methods for immutablemap/multimaps; would it be possible to add the following static methods (or similar) to immutablemap/multimap etc:immutablemultimapof(iterable&ltmapentry&ltkv>>)immutablemultimapbuilderputall(iterable&ltmapentry&ltkv>>)use case would be where you want to transform a multimap&ltk1v> to multimap&ltk2v>im imagining something like:```    multimap<object string> in      immutablemultimap<string string> out              immutablemultimapof(                    iterablestransform(inentries()                             new function<mapentry<objectstring> mapentry<stringstring>>() {                                @override                                public mapentry<string string> apply(mapentry<object string> input) {                                    return new abstractmapsimpleentry(inputgetkey()tostring() inputgetvalue())                                }}))```; ;;;;0;1;;
861;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;backport  release/2.x  changes to master (20161231) + fix for #860;backport  release/2.x  changes to master + the fix for #860.;;0;fix logging for full code cache condition;;;;;;1;1;fix logging for full code cache condition;
861;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;backport  release/2.x  changes to master (20161231) + fix for #860;backport  release/2.x  changes to master + the fix for #860.;;0;proposed solution to the time gap using unbounded buffering;this is a solution to the time gap problem for #844- currently it uses an unbounded buffer ill think about a bounded approach later on- ive added an subscribeon overload where the user can explicitly request a buffering behavior in addition subscribeon checks the type of the observable and enters buffering mode for groupedobservable and publishsubject i think these code options should be mutually exclusive:   1 either we only check for observable type but then new kinds of observables or hidden observables wont work  2 or ask the programmer in the documentation/tutorial to explicitly request buffering in certain operator compositionsi personally favor option 2);#785 ;;;;0;1;;
861;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;backport  release/2.x  changes to master (20161231) + fix for #860;backport  release/2.x  changes to master + the fix for #860.;;860.0;backport release/2x changes to master (20161231) + fix for #860;backport release/2x changes to master + the fix for #860;reported also #862 for broken inlinebytebuddymockmakertest test with java 9 ||   861   its green anyone willing to approve/provide further feedback? || lgtm! ||;jacoco 078 breaks tests for the new plugin mechanism;"jacoco 078 breaks the tests for the new plugin mechanism (#811) with:```:testorgmockitoutilclassloaderstest > cannot_load_runnable_in_given_classloader_if_some_type_cant_be_loaded failed    javalangassertionerror:     expecting a throwable with cause being an instance of:     <javalangnoclassdeffounderror>    but was an instance of:     <javalangillegalstateexception: javalangillegalaccessexception: class orgmockitoutilclassloaders$classloaderexecutor can not access a member of class orgmockitoutilclassloaderstest$2 with modifiers ""private static transient"">        at orgmockitoutilclassloaderstestcannot_load_runnable_in_given_classloader_if_some_type_cant_be_loaded(classloaderstestjava:324)orgmockitoutilclassloaderstest > can_run_in_given_classloader failed    javalangillegalstateexception: given task could not be loaded properly in the given classloader orgmockitoutilclassloaderstest$1@46dcdf84 error javalangillegalaccessexception: class orgmockitoutilclassloaders$classloaderexecutor can not access a member of class orgmockitoutilclassloaderstest$1 with modifiers ""private static transient""        caused by:        javalangillegalstateexception: javalangillegalaccessexception: class orgmockitoutilclassloaders$classloaderexecutor can not access a member of class orgmockitoutilclassloaderstest$1 with modifiers ""private static transient""            caused by:            javalangillegalaccessexception: class orgmockitoutilclassloaders$classloaderexecutor can not access a member of class orgmockitoutilclassloaderstest$1 with modifiers ""private static transient""orgmockitointernalconfigurationglobalconfigurationtest > returns_mockito_annotation_engine_of_plugins_if_no_mockitoconfiguration failed    javalangillegalstateexception: given task could not be loaded properly in the given classloader orgmockitointernalconfigurationglobalconfigurationtest$1@5adb485 error javalangillegalaccessexception: class orgmockitoutilclassloaders$classloaderexecutor can not access a member of class orgmockitointernalconfigurationglobalconfigurationtest$1 with modifiers ""private static transient""        caused by:        javalangillegalstateexception: javalangillegalaccessexception: class orgmockitoutilclassloaders$classloaderexecutor can not access a member of class orgmockitointernalconfigurationglobalconfigurationtest$1 with modifiers ""private static transient""            caused by:            javalangillegalaccessexception: class orgmockitoutilclassloaders$classloaderexecutor can not access a member of class orgmockitointernalconfigurationglobalconfigurationtest$1 with modifiers ""private static transient""1701 tests completed 3 failed 42 skipped:test failed```the corresponding travis build: https://travis-ciorg/mockito/mockito/jobs/187043982#l431";@bric3 can you identify the minimal scenario that reproduce this issue to be able to report it to the jacoco team? ||;1;0;862] disable bb test broken with java 9due to a lack of the new asm versionthe umbrella issue to reenable disabled tests: #863;
864;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;add dialog to show all preferences in their raw form plus some filtering;relates to #859. - adds a dialog which shows all preferences in a table by their type  key  value and default value.  - table can be sorted - table can be filtered to show only the preferences which deviate from their default value. this is the most helpful one - and it revealed various bugs when having a closer look. :) - count is shown as well - reachable through options -> preferences -> show preferences (button is below import/export preferences) - converts default values of null to empty string -  ? -   -  ?  -  ?;;0;doubles/float: methods with error margin; i think a few new methods would make a small but nice addition to the primitive api its often useful not to compare two doubles but check if they have similarities up to a degree this is based on the fact that the double and floats are not precise enough and after some computing the values may be different from what we expect such as the following methods:double d  00for (int i  0 i < 10 i++) {&nbsp&nbspd - 01}asserttrue(10  d) // failssuggested methods:int doublescompare(double a double b double errormargin)boolean doublescontains(double array double target double errormargin)boolean doublesequal(double a double b double errormargin)int floatscompare(float a float b float errormargin)boolean floatscontains(float array float target float errormargin)boolean floatsequal(float a float b float errormargin)there is still the question about which double/float-comparison to use: the primitive one or the wrapper one (which are different from a nan point of view); a dup every now and then is _really_ not a big problem :-) || ";;;;0;1;;
864;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;add dialog to show all preferences in their raw form plus some filtering;relates to #859. - adds a dialog which shows all preferences in a table by their type  key  value and default value.  - table can be sorted - table can be filtered to show only the preferences which deviate from their default value. this is the most helpful one - and it revealed various bugs when having a closer look. :) - count is shown as well - reachable through options -> preferences -> show preferences (button is below import/export preferences) - converts default values of null to empty string -  ? -   -  ?  -  ?;;0;updated to byte buddy 160;updated byte buddy several performance and api improvements also with much better android support; ;;;;1;1;updated to byte buddy 160;
864;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;add dialog to show all preferences in their raw form plus some filtering;relates to #859. - adds a dialog which shows all preferences in a table by their type  key  value and default value.  - table can be sorted - table can be filtered to show only the preferences which deviate from their default value. this is the most helpful one - and it revealed various bugs when having a closer look. :) - count is shown as well - reachable through options -> preferences -> show preferences (button is below import/export preferences) - converts default values of null to empty string -  ? -   -  ?  -  ?;;0;maven dependency missing;i have download  the source and opened the project using root level pomxml the required libraries are automatically downloaded into my maven folder but when i tried to build the project it turn out that 3 libraries are missing :<b>1 maven: comfacebookpresto:presto-main:test-jar 054-snapshot</b><b>2 maven: comfacebookpresto:presto-parser:test-jar 054-snapshot</b><b>3 maven: comfacebookpresto:presto-server:test-jar 054-snapshot</b>i have re-downloaded and re-opened the projectscreenshot:( help me out thank you in advance;you need to make sure youve compiled the grammar first and built some of the artifacts (intellij doesnt seem to be able to resolve some inter-module dependencies in a multi-module project) to do so run `mvn install -dskiptests` once from the command line and then refresh your project in intellij || thank you for your response i will try it for now i solved this problem by using  <b>presto-server presto-parser and presto-main</b> jars from the presto server tarball package although the expected version in the project was 054 and the libraries provided the the tarball is 052 but still it seems to work for now i also have another request for your consideration it would be really helpful if you officially provide a presto-jdbc jar apart from with the executable presto-client jar for now i have built the artifact from source and it seems to work perfectly thank you ||;;;;0;1;;
864;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;add dialog to show all preferences in their raw form plus some filtering;relates to #859. - adds a dialog which shows all preferences in a table by their type  key  value and default value.  - table can be sorted - table can be filtered to show only the preferences which deviate from their default value. this is the most helpful one - and it revealed various bugs when having a closer look. :) - count is shown as well - reachable through options -> preferences -> show preferences (button is below import/export preferences) - converts default values of null to empty string -  ? -   -  ?  -  ?;;0;blocking buffer until experiment;this is a solution to the time gap problem for #844ive added an subscribeon overload where the user can explicitly request a buffering behavior in addition subscribeon checks the type of the observable and enters buffering mode for groupedobservable and publishsubject i think these code options should be mutually exclusive:1 either we only check for observable type but then new kinds of observables or hidden observables wont work2 or ask the programmer in the documentation/tutorial to explicitly request buffering in certain operator compositionsi personally favor option 2)a drawback is that this blocking subscribeon deadlocks on pools with a single thread we can of course check for trampoline test and immediate schedulers but not schedulers created via `schedulersexecutor` or the computation scheduler on a single-core machine;#792 #793  test `testrepeattakewithsubscribeon` passed locally i guess there is a race issue with repeat() as it schedules a new repeat after take unsubscribes i guess adding a `childisunsubscribed` test before l85 should do the trick || reviewing code  considering the drawbacks what do you think is worse possibility of (deterministic?) deadlock with this solution? or possibility of non-deterministic data-loss when using `subscribeon` on hot observables?is the deadlock deterministic (it would always happen in dev so it gets found) or could it happen if a scheduler becomes saturated or the buffer size is higher than available threads? || non-deterministic data loss is definitely worse deadlock due to the computation scheduler being single threaded is worrying but might affect other concurrent operators as well regardless i think the documentation could mention that if pushback or blocking behavior is expected one should use newthread or io scheduler for the unblocking operation || > non-deterministic data loss is definitely worsei agree so lets continue down this path :-) ill review through your code in a bit || first pass through reading this code it seems good and mature enough to handle the different scenarios we could throw against it im going to spend some more time playing but nothing right now suggests that this should not be the path we take || i added some things on top of this at  || work on this is picked up in  ||;;;;0;1;;
865;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;deleted code related to the pdf and ps fields;dropping the support for ps and pdf fields (which seems dropped already as hardcoding a pdf-field in a .bib-file doesn t even show up in the entry editor) seemed to remove quite a bit of code.;;0;replaysubject time and capacity;the various `replay` overloads ended up getting implemented in a private `subject` implementation inside `operationreplay` ( this functionality needs to live on `replaysubject` itselfthis was brought up with some of the functionality added in:  related to this are:-  operator: replay-  pull request: replay additional overloads;hi guys ill begin working on this || does it need to solve issue #658 as well? || yes it does thanks for reminding me of that one || this item is open to be worked on as @katzseth22202 has been pulled away to something else || this is being done as part of  || merged in  ||;;;;0;1;;
865;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;deleted code related to the pdf and ps fields;dropping the support for ps and pdf fields (which seems dropped already as hardcoding a pdf-field in a .bib-file doesn t even show up in the entry editor) seemed to remove quite a bit of code.;;898.0;new strict stubbing api - mockitosession;see proposed design at #857the code is reviewable especially new public api please give feedback! more work is pendingcurrent status:-   address @bric3 feedback  -  getter  -  javadoc-  review documentation for consistency  -  mockitosession()  -  mockitosessionbuilder  -  strictness  -  mockitohint  -  potentialstubbingproblem  -  unnecessarystubbingexception  - [x] mockitojunitrunner and subclasses  - [x] mockitosession  - [x] mockitorule- [x] add / update mentions in the main mockito class- [x] add validate mockito usage (should be very easy)- [x] try making rules/runner use the session they already reuse the code they just dont use the api directly created #898 to track this work- [x] address @timvdlippe feedback- [x] create concurrent test (multiple sessions active in different threads)- [x] (non-code change not blocking merge) github tickets linked from source code should be better documented #769 #384 alternatively create ticket for tracking;"  ";design mockitosession api improvements for unit test frameworks;"it is desired that junit rule / runner uses mockitosession api (#865) so that they dogfood our public api in order to do that we need to do more design workmockito session api (#865) is geared towards using it in setup and tear down methods of the unit test framework in tear down method the user does not have access to the exception (test failure) in junit rule we do have access to the exception and we can leverage it for better user experience we can prevent dual failure when validating mockito usage fails on top of the actual test failure dual failure could be confusing to the user when mockito session api is used we cannot really avoid dual failure dual failure is relatively minor problem the test failure is reported by junit first before any potential framework validation problemjunit runner is even more interesting unlike the rule the runner has access to extra test lifecycle events like ""before all tests"" and ""after all tests""this ticket is a placeholder for design work on growing mockitosession api so that it can be used by runner and the rule while growing mockitosession api we can potentially expose mockitotestlistener all that work has lower priority than getting the mockitosession api released i suggest we even wait for users feedback before we start growing mockitosession api";this was  in #865 ||;1;0;improved assertion messagei noticed this test failed on ci i cannot reproduce it locally;
865;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;deleted code related to the pdf and ps fields;dropping the support for ps and pdf fields (which seems dropped already as hardcoding a pdf-field in a .bib-file doesn t even show up in the entry editor) seemed to remove quite a bit of code.;;857.0;new strict stubbing api - mockitosession;see proposed design at #857the code is reviewable especially new public api please give feedback! more work is pendingcurrent status:-   address @bric3 feedback  -  getter  -  javadoc-  review documentation for consistency  -  mockitosession()  -  mockitosessionbuilder  -  strictness  -  mockitohint  -  potentialstubbingproblem  -  unnecessarystubbingexception  - [x] mockitojunitrunner and subclasses  - [x] mockitosession  - [x] mockitorule- [x] add / update mentions in the main mockito class- [x] add validate mockito usage (should be very easy)- [x] try making rules/runner use the session they already reuse the code they just dont use the api directly created #898 to track this work- [x] address @timvdlippe feedback- [x] create concurrent test (multiple sessions active in different threads)- [x] (non-code change not blocking merge) github tickets linked from source code should be better documented #769 #384 alternatively create ticket for tracking;"  ";new strict mocking api - mockitosession;### background- mockito strictness (improved debuggability cleaner tests) is described in [a blog post]( and in issue #769- strict stubbing is already supported with junit rules - #807- open pr for supporting strict stubbing with junit runners - #854- this ticket intends to discuss the goals and implementation of strict stubbing without junit rules / runner### initial design```javapublic class sampletest {       @mock imethods mock        //initialize mocks similar to mockitoannotationsinitmocks(this) also configures strictness    mockitosession mockito  mockitomockitosession()initmocks(this)strictness(strictnessstrict_stubs)startmocking()    @after public void after() {        //after the test has completed we detect unused stubs and validate mockito usage        mockitofinishmocking()    }    //start and finish mocking invocations can be hidden in a common test base class    //or abstracted out in unit test framework specific way (custom rule etc)    @test public void some_test() {        //    }}    ```### alternative new public api methods(no longer considered since the feature is merged)```java//1mockitomocking mockito  mockitostartmocking(this strictnessstrict_stubs)mockitofinishmocking()//2mockitosession mockito  mockitomockitosession()initmocks(this)strictness(strictnessstrict_stubs)startmocking()mockitofinishmocking()//3mockitosession mockito  mockitosessionbuildermockitosession()testclassinstance(this)strictness(strictnessstrict_stubs)start()mockitostop()```### discussion- other ideas to meet the goal (better debuggability / cleaner tests without junit)- good naming / api for the feature- consistency with existing support for strictness with runner and the rulewe would love to hear your feedback!;heres my opinion :* regarding alternative 1/2/3 i prefer the api with an actual variable using static methods requires a hidden thread local state while its ok for stubbing i think this could be bad design choice for the mockiting session also without `mockitosession` variable its hard to interact with and always requires some static method* not in favor of option 1 as it kinda dismiss the builder style api and its probably harder to evolve such api in a non breaking way* not in favor of option 3 regarding the `testclassinstance` as it does not explain what it does with the test class instance while `initmocks` suggests the behavior behind this* i dont mind having the static factory method on either `mockitosession` or `mockito` both are good a `mockito` start point would probably be more discoverable though and will get along other lifecycle mockito methods like `reset` `validateusage` etc while `mockitosession` could be an opportunity to have a more focused api || @bric3 great feedback!!!i summarized my pov in ( alternative 1/2/3 i prefer the api with an actual variableall options are using variable i removed it for clarity (but it became less clear :) i will update the ticket>i dont mind having the static factory method on either mockitosession or mockito both are good a mockito start point would probably be more discoverable though and will get along other lifecycle mockito methods like reset validateusage etc while mockitosession could be an opportunity to have a more focused apiyes both approaches have pros and cons lets go ahead with mockitomockitosession() at this time || > all options are using variable i removed it for clarity (but it became less clear :) i will update the ticketok > yes both approaches have pros and cons lets go ahead with mockitomockitosession() at this timethats fine by me :) || closed via #865 ||;1;0;improved assertion messagei noticed this test failed on ci i cannot reproduce it locally;
865;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;deleted code related to the pdf and ps fields;dropping the support for ps and pdf fields (which seems dropped already as hardcoding a pdf-field in a .bib-file doesn t even show up in the entry editor) seemed to remove quite a bit of code.;;384.0;new strict stubbing api - mockitosession;see proposed design at #857the code is reviewable especially new public api please give feedback! more work is pendingcurrent status:-   address @bric3 feedback  -  getter  -  javadoc-  review documentation for consistency  -  mockitosession()  -  mockitosessionbuilder  -  strictness  -  mockitohint  -  potentialstubbingproblem  -  unnecessarystubbingexception  - [x] mockitojunitrunner and subclasses  - [x] mockitosession  - [x] mockitorule- [x] add / update mentions in the main mockito class- [x] add validate mockito usage (should be very easy)- [x] try making rules/runner use the session they already reuse the code they just dont use the api directly created #898 to track this work- [x] address @timvdlippe feedback- [x] create concurrent test (multiple sessions active in different threads)- [x] (non-code change not blocking merge) github tickets linked from source code should be better documented #769 #384 alternatively create ticket for tracking;"  ";junit rule logs warnings about unsued / misused stubs;"### whywhen test fails the failure might be caused by misused stubs hence it might be worth to log out debugging information to the system out (eg misused stubs unused stubs) for more details see documentation for [mockitohint]( plan-  document 2x change-  tweak the warning message-  add behavior to the runner-  add silent runner-  add silent setting to the rule (or warnings level for all / exception only / none)-  deprecate/remove console spamming runner### implthe junit rule or the runner will potentially include following info in the output (somehow):  wondering if ""mockitovalidatemockitousage()"" should automatically print warnings we could provide boolean parameter to control printing of the warnings";"on it || i like the feature! what do you think about a `rule()strict()` that doesnt emit logs but fails asap?a note to the api:- how do we prevent misuse like -> `rule()strict()strict()` ? what about `rule(log_warnings)` aka `rule()` `rule(silent)` `rule(fail_fast)` || christian very cool ideas!!! im not sure ill have time for it before 20 however i want the new default behavior in rule / runner in 20 so that users see what it is doing then we can grow and add strict mode || @szczepiq: i like this feature very much also that the `mockitojunitrunner` fails by default is good i think a note in the javadoc of `unnecessarystubbingexception` to use `mockitojunitrunnersilent` would be helpfulwe often have quite complex test fixtures and its cumbersome to switch absolutely each and every stub on or off some methods simply have to be there its also not necessary to verify if theyve been invoked so it would be great to be able to disable it for some stubs but leave it on for others || @t1 that seems like a reasonable idea want to make a pr for that? || good feedback i think that mockitohint class should also mention that it is possible to silence the new mechanism || #609 || the [mockitohint]( documentation seems to indicate that this will give you warnings about mismatched arguments when using the mockitojunitrunner  however from my experience this doesnt seem to work with mockito 21heres the source im trying:``` javafoo foo  mock(fooclass)when(foobar(""baz""))thenreturn(""bar"")foobar(""baz"")foobar(""test"") // expected to get a warning here```is there something else i need to do to enable this functionality? || thank you for feedback!> is there something else i need to do to enable this functionality?this is how they were implemented runner should also report mismatches because it helps with debugging the reason it does not do it today is because i wanted to limit the noisewe will fix this issue also we will consider always printing warning when stub args mismatch even if one does not use runner / ruledo you want to open a separate ticket to track this improvement?thanks for reporting! || ive opened #725 to track this || came across this after running into this in my test :```[mockitohint] mytestchecksomething (see javadoc for mockitohint):[mockitohint] 1 unused -> at mytesttest1(mytestjava:584)```it is complaining about this (line 584):```   when(mockobjectgetpeerhost())thenreturn(""peer-host-from-mock"")```now my issue is this: this particular method `getpeerhost()` is indeed not called when the code works as expected eg something like this:```   if (newmethod()) {             string peerhost  mockobjectgetpeerhost()       // use peerhost in further processing         }````newmethod()` is the new code being added and should correctly return `false` however if there is a bug in `newmethod()` and it returns `true` then i want `getpeerhost()` to return some value which will cause a failure that i can detect so this requires me to mock a method even if it is not called in normal processing and there is no bug in the code i think that should not generate a warning has this been addressed? || do i need to open a new issue as i cannot reopen this? || > do i need to open a new issue as i cannot reopen this?yes please> has this been addressed?yes for example you can use ```lenient()when()``` stubbing to avoid reporting an unused stubbing however in your test case i would simply write ```verify(mockobject never())getpeerhost()```hope that helps! || > yes for example you can use `lenient()when()` stubbing to avoid reporting an unused stubbing thanks for the `lenient` tip - that helps> however in your test case i would simply write `verify(mockobject never())getpeerhost()`> thats more work and more white box testing than i want lets say this is for testing the ssl logic where peerhost (of a connection) is matched (or not matched) against ""subject-name"" in a cert under various conditions but i have common setup/initialization where i ""mock"" the peerhost of the connection in one of the conditions the host-name match is suppressed (ie `newmathod()` returns `false`) but because of the common setup code i get the unused warning from `mockitohint` for that test || my recommendation is to use lenient() + strict stubbing for this use caseif you feel we should still discuss the use case ``verify(never())`` vs ``when()thenthrow()`` then please open a separate tickethope that helps and thank you for feedback! || ";1;0;improved assertion messagei noticed this test failed on ci i cannot reproduce it locally;
865;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;deleted code related to the pdf and ps fields;dropping the support for ps and pdf fields (which seems dropped already as hardcoding a pdf-field in a .bib-file doesn t even show up in the entry editor) seemed to remove quite a bit of code.;;0;add hive plugin for apache hadoop 1x;;;;;;1;1;add hive plugin for apache hadoop 1x;
865;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;deleted code related to the pdf and ps fields;dropping the support for ps and pdf fields (which seems dropped already as hardcoding a pdf-field in a .bib-file doesn t even show up in the entry editor) seemed to remove quite a bit of code.;;0;consider providing binary backwards compatibility for @beta features; would the guava team consider when feasible providing backwards compatibility for changes made to classes even when they are marked as @﻿beta? i recently shifted a librarys use of mapmakers makecomputingmap to cachebuilder due to deprecation warnings but failed to notice the @﻿beta annotation on cachebuilder my library was built against 100 and now fails when run against 110 with a nosuchmethoderror because the return type for cachebuilderbuild(cacheloader loader) was changed from cache to loadingcache (a subtype of cache)would the guava team be open to considering using something kohsukes bridge method injector ( to provide binary backwards compatibility in such cases? i understand i broke the rules by (accidentally!) using a @﻿beta method in a library but it would make life easier for developers without adding much tax; what we almost never hear are impassioned pleas by owners of cool java library x to please take apis abc out of beta as soon as we can  so when we look at all the work we have to do taking things out of beta tends to not feel very importantunfortunately i really dont think we can raise our level of commitment to compatibility for @﻿beta features without creating a much sharper cliff for getting @﻿beta features added in the first place  and keeping more things out completely is a net loss for everyone  i appreciate the request though || ";;;;0;1;;
867;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;removed some more warnings;;;0;document behavior of multisetsize(); multisetsize() returns the total number of occurrences of all elements in the multiset as described in the wiki this is not documented in the multiset interface itselfi think this should be documented because:- if you think about a multiset in terms of a map&lte integer> you might guess wrongly that size() behaves like mapsize()- if the behavior of size() is not specified in the interface implementations could implement it in different ways; i notice now that the type of clarification i suggested in comment 4 is in fact _exactly_ analogous to a recent round of clarifications i made to multimap || this was addressed in  ||;;;;0;1;;
867;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;removed some more warnings;;;0;failed to select any array element from data of array type using jdbc;"i created a table with data of array type   create table x (    reasons array&ltstring&gt      ) row format delimited fields terminated by  escaped by \ collection items terminated by \002 stored as textfileloaded data into it and use hive to query all work fine with queries such as   select reasons[0] from xusing jdbc to query the array-typed data by  ""select reasons from hivedefaultx"" it works fine:[""no_week""""geo""""lg mismatch""]but it fails when using jdbc to query any array element such as ""reasons[0]""   stmtexecutequery(""select reasons[0] from hivedefaultx"")exception in thread ""main"" javasqlsqlexception: query failed (#20131120_222414_00032_89y4z): line 1  no viable alternative at character [    at comfacebookprestojdbcprestoresultsetresultsexception(prestoresultsetjava:1568)    at comfacebookprestojdbcprestoresultsetgetcolumns(prestoresultsetjava:1519)    at comfacebookprestojdbcprestoresultset<init>(prestoresultsetjava:78)    at comfacebookprestojdbcprestostatementexecutequery(prestostatementjava:48)";apologies for the late reply presto does not yet have syntax for accessing structured types the hive connector converts such types into json and presents them to presto as strings you can access them using the json functions:  can make your query work by writing it like this: `select json_array_get(reasons 0) from hivedefaultx` ||;;;;0;1;;
867;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;removed some more warnings;;;0;zip back-pressure;"currently the `zip` operator has an unbounded queue for each `observable` it is combining together this makes it async and susceptible to buffer-bloat when fast-producer/slow-consumer issues occur but even worse with `zip` it can occur when it has fast-producer/slow-producer consider you can have _n_ producers all it takes is one producer to cause all the rest to buffersimilar to recent changes to `observeon` ( we want `zip` to default to blocking `onnext` (""non-blocking on the outside blocking on the inside"") so that each `observable` can only `onnext` when the previous `onnext` was consumedoverloads should exist to allow buffering if desired the goal is for normal use of rx to provide natural back-pressure that only gets lost when consciously choosing to do so or using explicit operators that do queueing (such as `buffer` and `window`)on the current `zip`implementation making the internal queues block at size 1 will not work as it deadlocks anytime 2 synchronous `observable`s are zipped together (common)an alternative approach is to start treating `zip` as an operator that requires concurrency to behave correctly (similar to `window` `buffer` `interval`) with concurrency it can `subscribe` to each `observable` and block them as needed the problem with this is that it could result in many blocking threads this could potentially be reduced by conditionally removing the concurrency if it is seen that the `observable` is already running on another thread the other problem is likely performance impactyet another proposal (unknown if it would work) is a scheme that would require changes to `subscriber` (highly unwanted) to allow pausing/resuming of `observable`s that `zip` could control it may not be possible to achieve the goal of `zip` with back-pressure with reasonable trade-offs but wed like to pursue it";closing as this is encompassed by #1000 ||;;;;0;1;;
867;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;removed some more warnings;;;866.0;866 should not throw npe when custom exception fillinstacktrace returns null;866;@wuwen5 can you rebase this commit on the latest `release/2x`also thanks for the contribution || the build is failingthe reason is `please export gh_token env variable first expression: javalangsystemenv[it] values: it  gh_token`@timvdlippe that sound familiar however i believe this was  a couple of weeks ago ||;when custom exception fillinstacktrace() returns null exception mock cannot work properly;```javapublic class customexception extends exception {    public customexception() {        super()    }    @override    public exception fillinstacktrace() {        return null    }}```testcase like this```java when(demoprocess())thenthrow(new customexception())// test code``````javalangnullpointerexception	at orgmockitointernalexceptionsstacktraceconditionalstacktracefilterfilter(conditionalstacktracefilterjava:23)	at orgmockitointernalstubbinganswersthrowsexceptionanswer(throwsexceptionjava:32)	at orgmockitointernalstubbingstubbedinvocationmatcheranswer(stubbedinvocationmatcherjava:35)	at orgmockitointernalhandlermockhandlerimplhandle(mockhandlerimpljava:95)```;this is a bug in the user code yet mockito should handle that gracefullythanks for reporting ||;1;0;866 should not throw npe when custom exception fillinstacktrace() return null;
868;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored menus and small components;moved menu classes and small utility components to gui.menus and gui.util.component  respectively.  moved special copy command to  copy special  submenu of right-click menu (to make it shorter).;;0;event informing about exceptions in listener methods; hi there i like the guava event bus system cause its simple and clear one thing i do not like though is the way exceptions disappear in the framework i know it is stated in the documentation that handler methods should not throw exceptions but they always will do at some point we also want to know if a handler method executed correctly so we end up writing catch all blocks around all handler methods not so niceso how about instead of just logging about an exception also post an event? it should wrap both the original event and the exception object plus possibly an identifier for the handler involved just like the meta event that no listeners are registered for a certain event (deadevent) this can give extra information about the state of the system as feedback to the interested listeners it also prevents us from wrapping every handling method in a catch all blockonly downside might be some extra semantics about the exception event namely that any exceptions for listeners to exception events are not re-posted but this is not any different from the fact that there is no new event if no-one listens to the deadevent :)in my eyes this would be a really nice and useful extra feature thanks for consideringkind regards erikthe netherlands; ;;;;0;1;;
868;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored menus and small components;moved menu classes and small utility components to gui.menus and gui.util.component  respectively.  moved special copy command to  copy special  submenu of right-click menu (to make it shorter).;;0;support of  custom or third party serde;i have some of the previously created hive external tables which are created with <code>row format serde combizohiveserdecsvcsvserde </code>now while i was using hive to query on those tables i placed the csvserde library inside <b>hive lib</b> and as hive uses map reduce job to query tables i also had to put jar inside hadoopcurrently i want to query those table with presto but it giving me a :<code>metaexception(message:orgapachehadoophiveserde2serdeexception serde combizohiveserdecsvcsvserde does not exist)</code> exception i already tried by putting the csvserdejar & hiveserdejar inside the presto server lib but still getting the same error thank you in advance;if you put the jars in the plugin directory (plugin/hive-cdh4) it should work || thank you very very much it worked  i put the jar in the plugin directorybut it dont work  i already restart  ||;;;;0;1;;
868;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored menus and small components;moved menu classes and small utility components to gui.menus and gui.util.component  respectively.  moved special copy command to  copy special  submenu of right-click menu (to make it shorter).;;0;zip bug unittest: never completes when zero observables (obsolete);hey guys  i discovered this issue today in rx  im not sure if its a bug or as designed  ive added the test  can you let me know if it is in fact a bug then ill correct the issue?;#795 that failure is expected my test currently fails to prove the issue || #796 yup thats a bug the `operatorzip` code assumes it will always receive `observables` to zipthe line in question is here:  || see #917 for pr  i had to move this fix on master to its own branch so i can continue to track the main master  #917 supersedes this pr   || #855 ;;;;0;1;;
868;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored menus and small components;moved menu classes and small utility components to gui.menus and gui.util.component  respectively.  moved special copy command to  copy special  submenu of right-click menu (to make it shorter).;;860.0;860 jacaco synthetic fields are not anymore final in 078;860 this internal assumed jacoco fields will always be `static final` obviously not jacoco 078 changed that the simple fix was to make the source field _accessible_ instead of skipping this fieldhence removing the test exclusion;;jacoco 078 breaks tests for the new plugin mechanism;"jacoco 078 breaks the tests for the new plugin mechanism (#811) with:```:testorgmockitoutilclassloaderstest > cannot_load_runnable_in_given_classloader_if_some_type_cant_be_loaded failed    javalangassertionerror:     expecting a throwable with cause being an instance of:     <javalangnoclassdeffounderror>    but was an instance of:     <javalangillegalstateexception: javalangillegalaccessexception: class orgmockitoutilclassloaders$classloaderexecutor can not access a member of class orgmockitoutilclassloaderstest$2 with modifiers ""private static transient"">        at orgmockitoutilclassloaderstestcannot_load_runnable_in_given_classloader_if_some_type_cant_be_loaded(classloaderstestjava:324)orgmockitoutilclassloaderstest > can_run_in_given_classloader failed    javalangillegalstateexception: given task could not be loaded properly in the given classloader orgmockitoutilclassloaderstest$1@46dcdf84 error javalangillegalaccessexception: class orgmockitoutilclassloaders$classloaderexecutor can not access a member of class orgmockitoutilclassloaderstest$1 with modifiers ""private static transient""        caused by:        javalangillegalstateexception: javalangillegalaccessexception: class orgmockitoutilclassloaders$classloaderexecutor can not access a member of class orgmockitoutilclassloaderstest$1 with modifiers ""private static transient""            caused by:            javalangillegalaccessexception: class orgmockitoutilclassloaders$classloaderexecutor can not access a member of class orgmockitoutilclassloaderstest$1 with modifiers ""private static transient""orgmockitointernalconfigurationglobalconfigurationtest > returns_mockito_annotation_engine_of_plugins_if_no_mockitoconfiguration failed    javalangillegalstateexception: given task could not be loaded properly in the given classloader orgmockitointernalconfigurationglobalconfigurationtest$1@5adb485 error javalangillegalaccessexception: class orgmockitoutilclassloaders$classloaderexecutor can not access a member of class orgmockitointernalconfigurationglobalconfigurationtest$1 with modifiers ""private static transient""        caused by:        javalangillegalstateexception: javalangillegalaccessexception: class orgmockitoutilclassloaders$classloaderexecutor can not access a member of class orgmockitointernalconfigurationglobalconfigurationtest$1 with modifiers ""private static transient""            caused by:            javalangillegalaccessexception: class orgmockitoutilclassloaders$classloaderexecutor can not access a member of class orgmockitointernalconfigurationglobalconfigurationtest$1 with modifiers ""private static transient""1701 tests completed 3 failed 42 skipped:test failed```the corresponding travis build: https://travis-ciorg/mockito/mockito/jobs/187043982#l431";@bric3 can you identify the minimal scenario that reproduce this issue to be able to report it to the jacoco team? ||;1;0;860 jacaco synthetic fields are not anymore final in 078;
870;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanups in fetchers;;;0;remove redundant defaultanswer(returns_defaults);`withsettings()` invokes `defaultanswer(returns_defaults)` as follows:```    public static mocksettings withsettings() {        return new mocksettingsimpl()defaultanswer(returns_defaults)    }```so invoking it again is redundantthis pr simply removes the redundant invocation;@izeye please verify items on the checklist ) || @bric3 i checked them all 😄  || by the way @izeye if they were not checked and the issue messaage was not removed at firstsomething is obviously wrong with the template as a lot of people just dont fill or ignore the messagewhy didnt you do it at first ? how can we improve the issue / pr template ?  || also the build is failing due to #871  your code is fine || @bric3 sorry i noticed them at first but i was thinking its okay with this trivial change without them and they looked like quite burden but after read carefully they dont much   || no problem too many people ignore the text so theres definitely something wrong in the message or burden ||;;;;1;1;remove redundant defaultanswer(returns_defaults)`withsettings()` invokes `defaultanswer(returns_defaults)` as follows:```    public static mocksettings withsettings() {        return new mocksettingsimpl()defaultanswer(returns_defaults)    }```so invoking it again is redundantthis commit simply removes the redundant invocation;
870;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanups in fetchers;;;0;fix test;;;;;;1;1;fix test;
870;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanups in fetchers;;;0;add the selector variants of timeout in rxscala;this pr added the selector variants of the `timeout` operator in the scala and also added two examples;#798 ;;;;1;1;add the selector variants of timeout in rxscala;
872;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;prepare android library for publication and bump version to 2.6.0;references first step of #848;;0;prepare android library for publication and bump version to 260;references first step of #848; ;;;;1;1;merge branch release/2x into android-release-notes;
872;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;prepare android library for publication and bump version to 2.6.0;references first step of #848;;0;add release notes for 054;;![screen shot]( || can we add a link from readmemd? otherwise  ill add the link after we release and push the docs ||;;;;1;1;add release notes for 054;
872;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;prepare android library for publication and bump version to 2.6.0;references first step of #848;;0;synchronizedobservertesttestmultithreadedwithnpeinmiddle fails;if i run just the test file it succeeds if i run a complete build it fails due to receiving 9 onnext calls most of the time shouldnt synchronizedobserver also ensure event semantics as well as synchronization?(tested on i7 4770k @ 35ghz 4/8 cores);its a good safety-net to keep but it shouldnt do any of the error handling or unsubscribe logic of `safesubscriber` thanks for pointing it out  ||;;;;0;1;;
875;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;1;fix bug in parsing custom entry types;fix unreported bug which prevented the parsing of custom entry types. also move the custom entry type parsing logic to the parser. -  ? - no  the bug was not present in 3.2. -   -  ? -  ?;;0;make eventbus an interface?; hiis it possible for eventbus to implement an interface containing its public api (or just the post method) so that i can mock it more easilycheerstim; to correct myself: i tried using eventbus from guava 1001 -- this old version does not respect annotations on interfaces the behaviour has changed: if you use current guava 140 the solution in comment #﻿1 does workthe behaviour/implementation of annotatedhandlerfinder has dramatically changed between 1001 and 140 || ";;;;0;1;;
875;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;1;fix bug in parsing custom entry types;fix unreported bug which prevented the parsing of custom entry types. also move the custom entry type parsing logic to the parser. -  ? - no  the bug was not present in 3.2. -   -  ? -  ?;;0;update byte buddy and enable injecting loading strategy for android;this enables byte buddys new injection strategy for android which loads types within a target class loader instead of creating a new one also this updates byte buddy with a few bug fixes; ;;;;1;1;update byte buddy and enable injecting loading strategy for android;
875;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;1;fix bug in parsing custom entry types;fix unreported bug which prevented the parsing of custom entry types. also move the custom entry type parsing logic to the parser. -  ? - no  the bug was not present in 3.2. -   -  ? -  ?;;0;shade dependencies for jdbc standalone jar;we need some way to test that the standalone jar is complete but this is tricky because the presto test server will include the dependencies that might be missing from the jar maybe have the tests load it via a separate classloader that skips directly to the system classloader for anything that it doesnt have in itself;;;;;1;1;shade dependencies for jdbc standalone jar;
875;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;1;fix bug in parsing custom entry types;fix unreported bug which prevented the parsing of custom entry types. also move the custom entry type parsing logic to the parser. -  ? - no  the bug was not present in 3.2. -   -  ? -  ?;;0;bounded replay subject proposal;proposal for #865 (not really for merging)subscription and unsubscription is serialized with the regular events so this implementation should solve #658 as well a property of this implementation due to queue/drain approach is that a new subscribers thread might steal the processing loop to mitigate this scheduler overloads are provided to capture the processing loopunfortunately the performance is 2-3 times worse in unbounded mode compared against current replaysubject implementation when run with a simple 1m onnext calls the replay after completion is about 10% sloweri would guess the enqueue/dequeue operation adds quite a substantial overhead;#806  closing out we cant block threads thus to achieve bounding we need a continuation (async/await) style solution an experiment to that end is happening at  if youre interested in getting involved ||;;;;0;1;;
880;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;879: argumentmatchers javadoc grammar improvement;fixed grammar issue in  argumentmatchers :;;0;runnablesemptyrunnable();cow@ following the null object design pattern it would be useful to have a no-op runnable this is similar to collectionsemptycollection(); ;;;;0;1;;
880;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;879: argumentmatchers javadoc grammar improvement;fixed grammar issue in  argumentmatchers :;;0;enhanced ide configuration steps in readmemd;added some clarifications about setting up the project in ideai just submitted my signed individual cla via e-mail minutes before this pull request;thanks! rebased and pushed ||;;;;0;1;;
880;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;879: argumentmatchers javadoc grammar improvement;fixed grammar issue in  argumentmatchers :;;0;force viewobservable be subscribed and unsubscribed in the ui thread;according to #869  `unsubscribe` can run in any thread however that will cause some concurrent issues in rxjava-androidthis pr schedules the `unsubscribe` action to run in the ui thread to solve the problem;#811  #812 seems like a good change do you agree with the assessment in #869 that we cant guarantee a `subscription` is called from the correct thread? || yes i agree with it since we can not give the guarantee its better to require users write a thread-safe subscription || cool then yes i also agree that `subscription` implementations need to be thread-safe since they dont have the same guarantees as `onnext` `onerror` and `oncompleted` || @zsxwing take a look at  to see if it would change anything you did in this pull request || i was wondering can we simply make the component refs volatile instead? i mean you control the subscription so scheduling on the ui thread just to maintain correctness wrt visibility seems wasteful || > can we simply make the component refs volatile instead? yes i think this is better and we can remove the `assertuithread` for `operationobservefromandroidcomponent` || @mttkay  i feel uncomfortable that the `observable`s from `operationobservefromandroidcomponent` can not be subscribed more than once any thoughts? || i had a local branch where i did all the changes but i had to drop it like 2 times due to all the things that happened on master to the core apis thats why i suggested to hold off with changes to this looking at master it seems things have stabilized and the release will go out soonmy suggestion again is:- declare all refs that need to be cleared volatile we merely need to ensure visibility when unsubscribing- remove the ui thread assertion from the operator and either leave it out altogether or i guess make it a static call in `androidobservablefromfragment` and `androidobservablefromactivity` so that we fail instantly if were attempting to bind a ui object from a background threaddoes that make sense? || wrt subscribing more than once: what would you expect instead? i havent thought about this to be honest || eg```observable o  androidobservablefromfragment()s  osubscribe()sunsubscribe()s1  osubscribe() // not work``` || what doesnt work exactly? || > remove the ui thread assertion from the operator and either leave it out altogether or i guess make it a static call in androidobservablefromfragment and androidobservablefromactivity so that we fail instantly if were attempting to bind a ui object from a background threadso the following will fail if it runs in a background thread?```viewobservableclicks()subscribeon(androidschedulersmainthread())subscribe()``` || ```observable o  androidobservablefromfragment()s  osubscribe()sunsubscribe() // componentref will be set to nulls1  osubscribe() // not work as componentref is null``` || another case is:```observable o  androidobservablefromfragment()s  osubscribe(observer1)s1  osubscribe(observer2) // observer1 will not receive any further message``` || i see what you mean because `componentref` is bound at time of constructioni agree in general it should behave in the same way as the underlying sequence so if the underlying sequence is re-subscribable (not all are depending on the subscription i guess) we should probably reflect thatim not sure how you would solve that though any ideas? ||;;;;1;1;force viewobservable be subscribed and unsubscribed in the ui thread;
880;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;879: argumentmatchers javadoc grammar improvement;fixed grammar issue in  argumentmatchers :;;879.0;879: argumentmatchers javadoc grammar improvement; grammar issue in `argumentmatchers`:> this implementation is due static type safety imposed by java compilershould be:> this implementation is due to static type safety imposed by java compilerthis pr fixes issue #879;  880   ;grammar issue in argumentmatchers javadoc;[`argumentmatchers` javadoc]( states that:> this implementation is due static type safety imposed by java compiler theres a word missing there it should read:> this implementation is due **to** static type safety imposed by java compiler version info:- first noticed this on 255- confirmed it still existed in 256 257 and 261- probably also existed in previous versions;@timvdlippe should this issue be closed now that the pr is merged or should this fix be backported to the 2x branch too? || @mureinik oh right it was to the wrong branch 😭 thats my mistake i will backport it manually ||;1;0;" ##879: argumentmatchers grammar fiximproved the grammar in argumentmatchers - ""due"" should be followed by a""to"" but isnt";
881;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanup in labelpatternutil and quite a bit more;;;0;removal of mapmakermaximumsize makes upgrading to guava 11 difficult; while i understand that the intent is to encourage people to move to the new cache api but the removal of mapmakermaximumsize in 110 make it very difficult to upgrade a project if there are other dependencies that use an older version of guava essentially every library in a project has to make the move from 10 to 11 togetherthere is no version that supports both the old and new apis concurrently which makes upgrading very difficulti would like to request that mapmakermaximumsize be left in but remain deprecated for the 110 versions; ;;;;0;1;;
881;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanup in labelpatternutil and quite a bit more;;;0;make columnmetadata serializable;this simple change makes prestospicolumnmetadata class serializablei needed this so that tablehandle can have columnmetadata fieldsdo you have plan or ideas how to write test code for spi package?;columnmetadata tablemetadata etc are not meant to be serializable thats what tablehandle columnhandle and friends are for -- they are opaque objects that can be used to resolve the corresponding metadata if necessarythe metadata objects are used by the query engine for analysis planning and optimization whereas the handles are used for encoding references to the corresponding tables and columns in the query plan and need to be sent to nodes across the network stored in data structures for diagnostics etcone of the reasons for this split is that over time well add more fields to the metadata objects and we dont want all that information to be carried along in the serialized forms of the query plan  || thank you for the description it makes sensei thought thats good to make it serializable because i (and hive connector) implements connectormetadatagetcolumnmetadata to extract columnmetadata from columnhandle but i understand that its plugin-developers choice whether it embeds all information in columnhandle to rebuild connectormetadata or embed only an identifier of column information so that getcolumnmetadata can build columnmetadata from external resource ||;;;;0;1;;
881;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanup in labelpatternutil and quite a bit more;;;0;lift performance;using `flift()` directly instead of `subscribe` improves ops/second on the included test from 5907721 ops/sec to 10145486 ops/sec;"#813 @abersnaze what about the debug hooks depends on subscribe vs fcall behavior? || i like it as it reduces the call stack depth and i dont need to step though the hooks and internal implementation checks all the time but isnt this lack of safeguards dangerous? || i had always intended it to call `fcall` directly (as in the prototypes) i think it was inadvertent that it became `subscribe` as for safety we never have wrapped internal operators (see  so we are not losing safety the only place the `safesubscriber` wrapper should happen is at the end when a user provides an `observer` or `subscriber` this is actually important we dont do this otherwise any `onerror`/`oncompleted` in the middle of a sequence would invoke `unsubscribe` and we dont want thatsince `lift` is now public for placing operators in the chain perhaps we want to conditionally wrap them but i tend to think that if someone is adding an operator it should be a considered an ""unsafe"" thing and that operators need to comply with the rx contract if we do choose to wrap it would be a conditional check similar to the link i posted above i dont think its worth the cost though the code would become this:``` java    public <r> observable<r> lift(final operator<? extends r ? super t> lift) {        return new observable<r>(new onsubscribe<r>() {            @override            public void call(subscriber<? super r> o) {                if (!isinternalimplementation(o)) {                    o  new safesubscriber<r>(o)                }                fcall(hookonlift(lift)call(o))            }        })    }```and the perf drops from ~10m ops/second to ~9mwith conditional check:```run: 10 - 9113444 ops/sec run: 11 - 8603038 ops/sec run: 12 - 8891892 ops/sec run: 13 - 8548031 ops/sec run: 14 - 8928571 ops/sec ```without:```run: 10 - 10167354 ops/sec run: 11 - 10169422 ops/sec run: 12 - 10065222 ops/sec run: 13 - 10705950 ops/sec run: 14 - 10996019 ops/sec ``` || i personally refer to ""f"" as ""unsafesubscribe"" and agree with ben it should do nothing except chaining lift only at the end you insert checks if you add an operator you are responsible to make sure it does not mess things up || #822 ";;;;1;1;fix debughooktest as per direction from @abersnaze;
881;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanup in labelpatternutil and quite a bit more;;;879.0; #879: argumentmatchers grammar fix;cherry-pick pr #880 to the 2x branchthis pr should  #879 on this branch too;;grammar issue in argumentmatchers javadoc;[`argumentmatchers` javadoc]( states that:> this implementation is due static type safety imposed by java compiler theres a word missing there it should read:> this implementation is due **to** static type safety imposed by java compiler version info:- first noticed this on 255- confirmed it still existed in 256 257 and 261- probably also existed in previous versions;@timvdlippe should this issue be closed now that the pr is merged or should this fix be backported to the 2x branch too? || @mureinik oh right it was to the wrong branch 😭 thats my mistake i will backport it manually ||;1;0;" ##879: argumentmatchers grammar fiximproved the grammar in argumentmatchers - ""due"" should be followed by a""to"" but isnt";
885;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;spy annotation reports better error message if instance creation is impossible;this simple piece of code prevents the  spyannotationengine  to try create a spy instance for a some inner private class with different set of modifiers.;;0;cant build current git repo with maven; <b>what steps will reproduce the problem?</b>1 git clone  mvn -e -x test<b>what is the expected output? what do you see instead?</b>see attached file the main error is:[error] failed to execute goal orgapachemavenplugins:maven-dependency-plugin copy-dependencies (prep-guava-bootstrap) on project guava: error copying artifact from /users/keith/code/guava-libraries/guava-bootstrap/target/classes to /users/keith/code/guava-libraries/guava/target/dependency/guava-bootstrap-latestjar: /users/keith/code/guava-libraries/guava-bootstrap/target/classes (no such file or directory)<b>what version of the product are you using? on what operating system?</b>apache maven 303 (r1075438 2011-02-28 12 09-0500)maven home: /usr/share/mavenjava version: 160_29 vendor: apple incjava home: /library/java/javavirtualmachines/160_29-b11-402jdk/contents/homedefault locale: en_us platform encoding: macromanos name: ""mac os x"" version: ""1072"" arch: ""x86_64"" family: ""mac"""; because of some oddity of how we set things up you cant test directly try running mvn install instead please reopen if that still doesnt work (sometimes you have to run it twice to get it to work right)--- ;;;;0;1;;
885;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;spy annotation reports better error message if instance creation is impossible;this simple piece of code prevents the  spyannotationengine  to try create a spy instance for a some inner private class with different set of modifiers.;;0;implement show schemas from syntax;allows you to show schemas from a specific catalog tested by runningshow schemas and show schemas from multifeed;looks good but you should a test to abstracttestqueries (see testshowschemas) ||;;;;1;1;implement show schemas from syntaxallows you to show schemas from a specific catalog added a unit test;
885;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;spy annotation reports better error message if instance creation is impossible;this simple piece of code prevents the  spyannotationengine  to try create a spy instance for a some inner private class with different set of modifiers.;;0; an issue with the from(reader) added a bunch of unit tests; a problem @fommil noticed in #840;#819 @abersnaze please let me know when this is available as a  snapshot release as id like to play around with it :-) || ill release 0170-rc2 later today after a few more fixes are merged in ||;;;;1;1; an issue with the from(reader) added a bunch of unit tests;
885;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;spy annotation reports better error message if instance creation is impossible;this simple piece of code prevents the  spyannotationengine  to try create a spy instance for a some inner private class with different set of modifiers.;;878.0;spy annotation reports better error message if instance creation is impossible;this simple piece of code prevents the `spyannotationengine` to try create a spy instance for a some inner private class with different set of modifierswhile preventing execution it reports slightly better error messages before some time the cause was `null`  this should 878; ;@spy dosnt report the correct error when it cant instantiate abstract class;the annotation engine doesnt inform the user correctly when the spying an inner `private static abstract class````orgmockitoexceptionsbasemockitoexception: unable to initialize @spy annotated field anull	at orgmockitointernalconfigurationspyannotationengineprocess(spyannotationenginejava:70)	at orgmockitointernalconfigurationinjectingannotationengineprocessindependentannotations(injectingannotationenginejava:59)	at orgmockitointernalconfigurationinjectingannotationengineprocess(injectingannotationenginejava:41)```indeed when the class is private javac still generates a synthetic 1-arg constructor taking the enclosing classthat should be easy to improve as the `spyannotationengine` just needs to report an error message for this case;;1;0;spy annotation engine internal refactoringsigned-off-by: brice dutheil <bricedutheil@gmailcom>;
891;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;some cleanups;;;0;prevent recursive removal notifications?;m@ what steps will reproduce the problem?when using a removallistener on a cache adding the same key back into the cache when the notification was not an eviction notification yields a recursive call stack which can sometimes blow out to a stackoverflow  when running this test code locally the code completes successfully but consistently calls the removallistener 618/619 times for each cyclethe following sample code demonstrates the behavior:package smx3reportingsubscriptionsqueueimport comgooglecommoncachecacheimport comgooglecommoncachecachebuilderimport comgooglecommoncacheremovallistenerimport comgooglecommoncacheremovalnotificationimport orgtestngannotationstestimport javautildateimport javautilconcurrenttimeunitpublic class removallistenertest {```cache<string integer> cache@testpublic void teststackoverflowonremovallistener() {    cache  cachebuildernewbuilder()            expireafterwrite(100 timeunitmilliseconds)            removallistener(new removallistener<string integer>() {                @override                public void onremoval(removalnotification<string integer> notification) {                    systemoutprintln(stringformat(""removal of %s with value %s was it evicted: %s"" notificationgetkey() notificationgetvalue()notificationwasevicted()))                    cacheput(notificationgetkey() notificationgetvalue() + 1)                }            })            build()    final long start  new date()gettime()    systemoutprintln(""initial item - "" + start)    cacheput(""foo"" 1)    systemoutprintln(""replacement item"")    cacheput(""foo"" 1000)    systemoutprintln(""ended after "" + (new date()gettime() - start) + "" ms"")}```}the output of the above is posted to  were doing is somewhat nasty in that were wanting to modify the behavior of expireafterwrite if we only re-add the key if notificationwasevicted() is true the problem should go awaywhen thinking about what im doing ideally i want someway of saying ""roll back this eviction"" something like ""notificationrollback()"" which the cache could handle appropriatelywhat version of the product are you using? on what operating system?os/x and redhat linux guava 110"; given that its easy for you to work around this were inclined to leave the code as is instead of consuming resources to check for this edge case--- ;;;;0;1;;
891;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;some cleanups;;;0;add empty strings to hive integration test;;looks good  the test tables should be updated before this is pushed || i updated all the test tables ||;;;;1;1;add empty strings to hive integration test;
891;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;some cleanups;;;0;eliminate rxutil* dumping grounds;move all classes into proper homes rather than having `rxutil` as the miscellaneous dumping groundsi have attempted to make rxutilfunctions\* have deprecated proxies to ease the migration im doing this in 017 instead of waiting since 017 already has breaking changes;;;;;1;1;rxutilfunctions deprecated proxies;
891;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;some cleanups;;;874.0;update to byte buddy 164: fixes bridge method resolution for generic types;874;;overridden abstract methods using generics are not longer called for partial mock (working with mockito 11019);"hiwe migrated to mockito 2x not so long ago and we came across a test that used to works back in mockito 1 (11019) and no longer works with the latest 2x version (256)here is the sscce to replicate the issue:```package comsomecompanyimport static orgjunitassert*import static orgmockitomockito*import javaioioexceptionimport javalangreflectinvocationtargetexceptionimport javaxswingjbuttonimport orgjunittestpublic class mockito2issue{	public abstract class someabstractclass<t>	{		protected abstract string getrealvalue(t value)		public string getvalue(t value)		{			return getrealvalue(value)		}	}	public class someconcreteclass<t extends javaawtcomponent> extends someabstractclass<t>	{		@override		protected string getrealvalue(t value)		{			return ""realvalue""		}	}	@test	public void testbug() throws ioexception instantiationexception illegalaccessexception invocationtargetexception	{		someconcreteclass<javaawtcomponent> testbug  spy(new someconcreteclass<javaawtcomponent>())		assertequals(""realvalue"" testbuggetvalue(new jbutton()))	}}```**before (11019):**used to works**after (256)**```javalangassertionerror: expected:<realvalue> but was:<null>	at orgjunitassertfail(assertjava:91)	at orgjunitassertfailnotequals(assertjava:645)	at orgjunitassertassertequals(assertjava:126)	at orgjunitassertassertequals(assertjava:145)	at comsomecompanymockito2issuetestbug(mockito2issuejava:43)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:44)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:15)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:41)	at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:20)	at orgjunitrunnersblockjunit4classrunnerrunnotignored(blockjunit4classrunnerjava:79)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:71)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:49)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:193)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:52)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:191)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:42)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:184)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:236)	at orgeclipsejdtinternaljunit4runnerjunit4testreferencerun(junit4testreferencejava:86)	at orgeclipsejdtinternaljunitrunnertestexecutionrun(testexecutionjava:38)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:459)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:678)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerrun(remotetestrunnerjava:382)	at orgeclipsejdtinternaljunitrunnerremotetestrunnermain(remotetestrunnerjava:192)```we performed a few side tests and here are the results:- if we change the method `getrealvalue` in class `someabstractclass` to be non-abstract but rather throw an exception the test pass:```		protected string getrealvalue(t value)		{			throw new unsupportedoperationexception()		}```- if we no longer use generic on the method (eg using object rather than t) the test passcan you take a look at this?environment details:component | version--------- | ------os | ubuntu 1610java | oracle java(tm) se runtime environment (build 180_101-b13)eclipse | neon2junit | 482mockito | 11019 (before) 256 (after)";this is probably a regression after adopting byte-buddy @raphw did you encounter such issues with byte-buddy? || it is indeed a problem in byte buddy when processing raw types (mockito extends the generic type without implementing the type variable) in the method graph compiler i already added a test case to byte buddy and i will try to fix the problem some time next weeki do now understand the problem mockito extends `someconcreteclass` as a raw type as it does not define any type variables by this any type is considered as raw in alignment with the java specification therefore `getrealvalue(object)` and `getrealvalue(component)` are not merged in the graph and the attempt to invoke `getrealvalue(object)` results in returning `null` via the default answer as it is no longer considered a bridgethis is actually a bit tricky but i will think of something || tracked in:  || thanks @domtoupin for the sscce !thanks @raphw for the quick tracking of the issue ||;1;0;update to byte buddy 164: fixes bridge method resolution for generic types;
893;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add detection for android environments and give warnings if used incorrectly. corrected documentation.;the documentation gave an incorrect configuration example. also  warnings were added for using android on a non-android environment.;;0;request for navigabletable; we have table in which everything is unsortedand we have rowsortedtable which gives us sorted lookup-access to rows but not to columns (even though the column maps are sorted)im after something that provides sorted lookup through columns perhaps in the sense that i could get a navigablemap&ltc v> for a row and be able to do things like tablerow(rowkey)floorentry(columnkey)getvalue() obviously this generalises to full navigable access over the rows and columnsthe use case here is to represent data that changes through time so c is date for example im effectively storing key-value (r-v) pairs where the value depends on the time i cant represent this as rowsortedtable&ltdate k v> because the values for all keys dont change at the same timeis this something that fits into current plans for table?; ;;;;0;1;;
893;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add detection for android environments and give warnings if used incorrectly. corrected documentation.;the documentation gave an incorrect configuration example. also  warnings were added for using android on a non-android environment.;;0;add detection for android environments and give warnings if used incorrectly corrected documentation;the documentation gave an incorrect configuration example also warnings were added for using android on a non-android environment; merging 893 ;;;;1;1;add detection for android environments and give warnings if used incorrectly corrected documentation;
893;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add detection for android environments and give warnings if used incorrectly. corrected documentation.;the documentation gave an incorrect configuration example. also  warnings were added for using android on a non-android environment.;;0;extend json path syntax to support field names containing reserved characters;"theres currently no way to extract values for fields in json structures whose names contain any of the special json path characters (`$` `[` `]` `` etc)the syntax for json path expressions (for `json_extract` and friends) should be extended one possible option is to allow bracket notation for field references (see  for example to wanted to get the value for key ""10"" from the following structure:```{ ""10"": ""apple"" ""20"": ""banana"" }```the corresponding json path expression would be `$[""10""]` note that the expression uses `""` instead of `` to make it fit more naturally within sql strings"; by #1466 ||;;;;0;1;;
893;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add detection for android environments and give warnings if used incorrectly. corrected documentation.;the documentation gave an incorrect configuration example. also  warnings were added for using android on a non-android environment.;;0;change parallel to use long instead of int;;#824 ;;;;1;1;change parallel to use long instead of int;
896;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;clarify documentation for consecutive stubbing;895;;0;cache bug - wrong removal; <b>what steps will reproduce the problem?</b>1test the following source```public static void main(string args) throws exception{    cachebuilder cachebuilder  cachebuildernewbuilder()    cachebuildermaximumsize(5)    cachebuilderremovallistener(new removallistener() {        public void onremoval(removalnotification notification) {            systemoutprintln(""\t * onremoval # ""+ notification)                        }    })    cache<integerinteger> cache  cachebuilderbuild()    for(int i0i<10i++)    {        cacheput(ii)        systemoutprintln("">>> i:cache # ""+ i +"":""+ cachesize() +"":""+ cachestats() +"":""+ cacheasmap())        threadsleep(5000)    }```<b>what is the expected output? what do you see instead?</b>> > > i:cache # 0 cachestats{hitcount0 misscount0 loadsuccesscount0 loadexceptioncount0 totalloadtime0 evictioncount0}:{00}> > > i:cache # 1 cachestats{hitcount0 misscount0 loadsuccesscount0 loadexceptioncount0 totalloadtime0 evictioncount0}:{00 11}> > > &nbsp&nbsp&nbsp&nbsp&nbsp\* onremoval # 11(****\* why remove ?)> > > i:cache # 2 cachestats{hitcount0 misscount0 loadsuccesscount0 loadexceptioncount0 totalloadtime0 evictioncount1}:{00 22}> > > i:cache # 3 cachestats{hitcount0 misscount0 loadsuccesscount0 loadexceptioncount0 totalloadtime0 evictioncount1}:{00 22 33}> > > i:cache # 4 cachestats{hitcount0 misscount0 loadsuccesscount0 loadexceptioncount0 totalloadtime0 evictioncount1}:{00 22 33 44}> > > i:cache # 5 cachestats{hitcount0 misscount0 loadsuccesscount0 loadexceptioncount0 totalloadtime0 evictioncount1}:{55 00 22 33 44}> > > &nbsp&nbsp&nbsp&nbsp&nbsp\* onremoval # 55(****\* not remove by lru)> > > i:cache # 6 cachestats{hitcount0 misscount0 loadsuccesscount0 loadexceptioncount0 totalloadtime0 evictioncount2}:{66 00 22 33 44}> > > &nbsp&nbsp&nbsp&nbsp&nbsp\* onremoval # 00(****\* not remove by lru)> > > i:cache # 7 cachestats{hitcount0 misscount0 loadsuccesscount0 loadexceptioncount0 totalloadtime0 evictioncount3}:{66 77 22 33 44}> > > &nbsp&nbsp&nbsp&nbsp&nbsp\* onremoval # 77(****\* not remove by lru)> > > i:cache # 8 cachestats{hitcount0 misscount0 loadsuccesscount0 loadexceptioncount0 totalloadtime0 evictioncount4}:{66 88 22 33 44}> > > &nbsp&nbsp&nbsp&nbsp&nbsp\* onremoval # 22(****\* not remove by lru)> > > i:cache # 9 cachestats{hitcount0 misscount0 loadsuccesscount0 loadexceptioncount0 totalloadtime0 evictioncount5}:{66 88 99 33 44}<b>what version of the product are you using? on what operating system?</b>1101windows xp<b>please provide any additional information below</b>1 cachesize less than maximumsizeonremoval happened2 removal order is not lru order"; _issue #1629 has been merged into this issue_ || ";;;;0;1;;
896;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;clarify documentation for consecutive stubbing;895;;0;presto - inclusion of varchar(64) etc in hive table causes error;i have an hdfs/hive instance set up using mysql as a metastorerunning the following version of hadoop: hadoop-121running the following version of hive: hive-0120running the following version of presto server: presto-server-054running the following version of discovery server: discovery-server-116 using the following presto cli: presto-cli-054-executablejari have a hive table created as follows:```[localhost:10001] hive> describe statsa int                     noneb smallint             nonec tinyint               noned tinyint                nonee varchar(64)         nonef smallint                noneg int                     noneh bigint                  nonei int                     nonej bigint                  nonek int                     nonel bigint                  nonehour                    int                     none# partition information# col_name              data_type               commenthour                    int                     none```the table appears to work well in hive  it is correctly populated with data  however when i attempt to query the table via presto i see errors:```presto:default> describe statsquery 20131205_215319_00040_y5j69 failed 1 nodesplits: 2 total 0 done (000%)0:00 [0 rows 0b] [0 rows/s 0b/s]query 20131205_215319_00040_y5j69 failed: metaexception(message:javalangillegalargumentexception error: type expected at the position 29 of int tinyint varchar(64) int int int:bigint but varchar is found)presto:default> select count(1) from statsquery 20131205_215340_00041_y5j69 failed: metaexception(message:javalangillegalargumentexception error: type expected at the position 29 of int tinyint varchar(64) int int int:bigint but varchar is found)```there is not a lot of debug information:```2013-12-05t21 59748+0000    debug   query-scheduler-33      comfacebookprestoexecutionquerystatemachine query 20131205_215459_00042_y5j69 is planning2013-12-05t21 59749+0000    debug   query-scheduler-34      comfacebookprestoexecutionquerystatemachine query 20131205_215459_00042_y5j69 is failed```presto appears to work correctly with tables that do not contain varchar types:```presto:default> select count(1) from other_stats _col0-------  2916(1 row)query 20131205_224304_00043_y5j69 finished 1 nodesplits: 730 total 730 done (10000%)0:05 [292k rows 102kb] [563 rows/s 197kb/s]```does presto not support varchar field types?;issue is that presto is not compatible with hive > 0100  varchar introduced with 0120 ||;;;;0;1;;
896;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;clarify documentation for consecutive stubbing;895;;0;removing java 7 dep;;#828  thanks george ||;;;;1;1;removing java 7 dep;
896;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;clarify documentation for consecutive stubbing;895;;895.0;clarify documentation for consecutive stubbing;895as of now the documentation does not clarify the difference of behaviour between chaining multiple thenreturn() statements and using multiple when/thenreturn statements when someone attempts to perform consecutive stubbingi added a warning/clarification in the documentation with a corresponding example so that its more clear (especially for new users of mockito); ;documentation missing clarification for consecutive stubbing;the [documentation]( for consecutive stubbing is missing a clarificationwhen multiple when/thenreturn statements are being used instead of chaining thenreturn() statements each stubbing overrides the existing one;i am going to submit a pull request adding an additional clarification with code example in the docs ||;1;0;rephrased documentation clarification;
897;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;cleansempty value returns empty arrays;876 and do a bit more cleanup;;0;add orderinglessthan atleast; issue 638 asked for these methods for &ltt extends comparable&ltt>> and with comparator<? super t> overloading the former were resolved with ranges but the latter are still unavailable formally these are the signatures im requesting to be added in ordering&ltt>:predicate&ltt> lessthan(t)predicate&ltt> atmost(t)predicate&ltt> atleast(t)predicate&ltt> greaterthan(t)predicate&ltt> equalto(t)the equalto(t) method is for cases like bigdecimal where exists ab such that aequals(b) ! acompareto(b)  0; ;;;;0;1;;
897;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;cleansempty value returns empty arrays;876 and do a bit more cleanup;;0;cleansempty value returns empty arrays;876 and do a bit more cleanup* moves returning empty array from `returnsmoreemtpyvalues` to `returnsemptyvalues`* cleans up javadoc* removes reflection for java8 types (implementation and tests)best to review commit by commit;"thats weird theres a failure in this test orgmockitointernalcreationbytebuddytypecachingmockbytecodegeneratortestwhich has nothing to do with my change other jdk 8 builds are fine it looks like a race condition```$ java -xmx32m -versionjava version ""180_111""java(tm) se runtime environment (build 180_111-b14)java hotspot(tm) 64-bit server vm (build 25111-b14 mixed mode)``````orgconcurrentmockitothreadsrunalltestshalfmanualtest > shouldruninmultiplethreads failed    junitframeworkassertionfailederror: run in multiple thread failed for tests expected:<> but was:<[class orgmockitointernalcreationbytebuddytypecachingmockbytecodegeneratortest]>        at junitframeworkassertfail(assertjava:57)        at junitframeworkassertfailnotequals(assertjava:329)        at junitframeworkassertassertequals(assertjava:78)        at junitframeworktestcaseassertequals(testcasejava:244)        at orgconcurrentmockitothreadsrunalltestshalfmanualtestshouldruninmultiplethreads(threadsrunalltestshalfmanualtestjava:147)1752 tests completed 1 failed 58 skipped:test failed``` ||   897   ";;;;1;1;cleans up returnsmoreemptyvalues;
897;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;cleansempty value returns empty arrays;876 and do a bit more cleanup;;0;add an info-only  query endpoint;presto currently combines the ability to fetch query progress info with the fetching of the results presto should add another  end point that allows fetching of query progress info but without returning data and without counting as a heartbeat;;;;;0;1;;
897;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;cleansempty value returns empty arrays;876 and do a bit more cleanup;;0;automatic unsubscribing in operatormerge;it seems to me `observablemerge()` doesnt unsubscribe its inputs one by one as they complete but only when unsubscribed manually or when all of the inputs have completed it seems counter-intuitive is that intentional?;generally the cleanup `unsubscribe` does not occur until the final `subscribe` not for intermediate operators there is precedent for eagerly unsubscribing such as in `take` so as to not delay unsubscribing until some point in the future and `merge` is a gray area for being an intermediate operator as it is the terminal state for the observables it is merging we can look at doing so for `merge` assuming there is not some unconsidered edge-case if we do `merge` we should look at the other combinatorial operators as well including `zip` and `concat`curious what is the use case where the `observable` emits `oncompleted` and at that point is not cleaned up and needs to wait until `unsubscribe`? || im playing with long-running (hours not weeks) streams… not sure if rxjava is ready for that though! i have a long-running input stream `observable<observable<a>> xs` of short-running input streams that i eventually want to flatten to `observable<a>` however small their footprint may be im concerned with the idea that when `observablemerge(xs)` is unsubscribed i can see as many calls to `unsubscribe` of the nested `observable<a>`s as there were elements in `xs`of course i can try to make sure that i free up everything i can in their `oncompleted` method but _something_ is worse than _nothing_my understanding is as soon as an `observable` completes its of no use and thus should be unsubscribed by its subscriber i cant see an edge-case where it would be otherwise || fwiw `zip` `concat` and `mergemap`/`flatmap` should definitely follow the same guideline: as soon as an input `observable` completes its `unsubscribe` is called for a toy example: `xsmap(f)` should have the same effect as `xsflatmap(x > observablewithjust(x))` but with the current behavior the latter has an accumulating memory footprint whereas the former doesnt || good points if were retaining subscriptions thats a bad thing ill take a look and resolve this> long-running (hours not weeks) streams… not sure if rxjava is ready for thatthis has not been the area where we (netflix) have used it in production thus far so it is definitely not battle-tested and im not surprised there are bugs we are starting to and have found bugs and expect to find more as it gets the same level of use and testing for long-running streamsthank you for the bug report || thanks ill try to write a reproducing test when the hurry settles down a bit || can you take a look at this:  have only spent a few minutes on this so not 100% certain it is done || both the implementation and the tests look alright on a first glance ill try it out in a minutethanks a lot for such a quick reaction! || this is released in rc4 || nice! ||;;;;0;1;;
902;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;fix typecache dead lock;i could trace the problem to more eager resolution of types in java u31 upon loading where concurrent mock creation with locking on the class level causes a dead lock. this can happen in other vm implementations but can be solved with a more granular lock on our type cache.;;0;fix typecache dead lock;i could trace the problem to more eager resolution of types in java u31 upon loading where concurrent mock creation with locking on the class level causes a dead lock this can happen in other vm implementations but can be solved with a more granular lock on our type cachethis fixes https://githubcom/mockito/mockito/issues/892;@raphw could that be the issue that i saw in #897 see travis log :  || no that is a flaky test as we rely on triggering a garbage collection which is something we do not controll on a vm even though there is a good chance to we should ideally rerun this test multiple times upon a failure@timvdlippe i  the accidental pre-commit || ok agreed ||;;;;1;1;use less granular lock on class creation to avoid dead-lock on recursive types;
902;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;fix typecache dead lock;i could trace the problem to more eager resolution of types in java u31 upon loading where concurrent mock creation with locking on the class level causes a dead lock. this can happen in other vm implementations but can be solved with a more granular lock on our type cache.;;0;error starting presto server on worker;i have an hdfs/hive instance set up using mysql as a metastorerunning the following version of hadoop: hadoop-220running the following version of hive: hive-0120running the following version of presto server: presto-server-054running the following version of discovery server: discovery-server-116 using the following presto cli: presto-cli-054-executablejari have a presto coordinator setup on a system:```[root@viper etc]# cat configpropertiescoordinatortruedatasourcesjmx etc]# cat nodepropertiesnodeidc2a9dd40-43f6-4088-9cea-ebd6b9ee923cnodeenvironmentproductionnodedata-dir/hadoop/presto/data``````[root@viper etc]# ping -c 1 viperping viper (1721610019) 56(84) bytes of data64 bytes from viper (1721610019): icmp_seq1 ttl64 time0057 ms--- viper ping statistics ---1 packets transmitted 1 received 0% packet loss time 0msrtt min/avg/max/mdev  0057/0057/0057/0000 ms```the server starts fine and (if there is a datanode configured) runs well  i try to start the presto server on my worker with the following configuration:```[root@defiance etc]# cat configpropertiescoordinatorfalsedatasourcesjmxhive etc]# cat nodepropertiesnodeidb948a821-f4e6-49c8-92f2-94dfcd5d407dnodeenvironmentproductionnodedata-dir/hadoop/presto/data``````[root@defiance etc]# ping -c 1 viperping viper (1721610019) 56(84) bytes of data64 bytes from viper (1721610019): icmp_seq1 ttl64 time0178 ms--- viper ping statistics ---1 packets transmitted 1 received 0% packet loss time 0msrtt min/avg/max/mdev  0178/0178/0178/0000 ms```i notice the following in the log output:  ```2013-12-10t15 57509+0000     info   main    orgeclipsejettyserverabstractconnector      started selectchannelconnector@0000:8081```i get a bunch of errors (see stack trace below)  it appears that the presto server is attempting to connect and failing  any idea why?stack trace:```2013-12-10t15 59563+0000    error   main    comfacebookprestoserverprestoserver guice creation errors:1) error in custom provider orgjbossnettychannelchannelexception: failed to create a selector  while locating ioairlift  at ioairlift  while locating ioairlift  at ioairlift  at ioairlift  while locating ioairlift annotated with @ioairliftdiscoveryclientfordiscoveryclient()    for parameter 3 at ioairliftdiscoveryclient  while locating ioairliftdiscoveryclient  at ioairliftdiscoveryclientdiscoverymoduleconfigure(discoverymodulejava:51)  while locating ioairliftdiscoveryclientdiscoverylookupclient    for parameter 0 at ioairliftdiscoveryclientcachingserviceselectorfactory<init>(cachingserviceselectorfactoryjava:32)  at ioairliftdiscoveryclientdiscoverymoduleconfigure(discoverymodulejava:65)  while locating ioairliftdiscoveryclientcachingserviceselectorfactory  at ioairliftdiscoveryclientdiscoverymodulecreatemergingserviceselectorfactory(discoverymodulejava:117)  at ioairliftdiscoveryclientdiscoverymodulecreatemergingserviceselectorfactory(discoverymodulejava:117)  while locating ioairliftdiscoveryclientmergingserviceselectorfactory  at ioairliftdiscoveryclientdiscoverymoduleconfigure(discoverymodulejava:66)  while locating ioairliftdiscoveryclientserviceselectorfactory    for parameter 0 at ioairliftdiscoveryclientserviceselectorprovidersetserviceselectorfactory(serviceselectorproviderjava:49)  at ioairliftdiscoveryclientdiscoverybinderbindselector(discoverybinderjava:64)1 errorcomgoogleinjectcreationexception: guice creation errors:1) error in custom provider orgjbossnettychannelchannelexception: failed to create a selector  while locating ioairlift  at ioairlift  while locating ioairlift  at ioairlift  at ioairlift  while locating ioairlift annotated with @ioairliftdiscoveryclientfordiscoveryclient()    for parameter 3 at ioairliftdiscoveryclient  while locating ioairliftdiscoveryclient  at ioairliftdiscoveryclientdiscoverymoduleconfigure(discoverymodulejava:51)  while locating ioairliftdiscoveryclientdiscoverylookupclient    for parameter 0 at ioairliftdiscoveryclientcachingserviceselectorfactory<init>(cachingserviceselectorfactoryjava:32)  at ioairliftdiscoveryclientdiscoverymoduleconfigure(discoverymodulejava:65)  while locating ioairliftdiscoveryclientcachingserviceselectorfactory  at ioairliftdiscoveryclientdiscoverymodulecreatemergingserviceselectorfactory(discoverymodulejava:117)  at ioairliftdiscoveryclientdiscoverymodulecreatemergingserviceselectorfactory(discoverymodulejava:117)  while locating ioairliftdiscoveryclientmergingserviceselectorfactory  at ioairliftdiscoveryclientdiscoverymoduleconfigure(discoverymodulejava:66)  while locating ioairliftdiscoveryclientserviceselectorfactory    for parameter 0 at ioairliftdiscoveryclientserviceselectorprovidersetserviceselectorfactory(serviceselectorproviderjava:49)  at ioairliftdiscoveryclientdiscoverybinderbindselector(discoverybinderjava:64)1 error        at comgoogleinjectinternalerrorsthrowcreationexceptioniferrorsexist(errorsjava:435) ~[guice-30jar:na]        at comgoogleinjectinternalinternalinjectorcreatorinjectdynamically(internalinjectorcreatorjava:175) ~[guice-30jar:na]        at comgoogleinjectinternalinternalinjectorcreatorbuild(internalinjectorcreatorjava:109) ~[guice-30jar:na]        at comgoogleinjectguicecreateinjector(guicejava:95) ~[guice-30jar:na]        at ioairliftbootstrapbootstrapinitialize(bootstrapjava:277) ~[bootstrap-084jar:084]        at comfacebookprestohivehiveconnectorfactorycreate(hiveconnectorfactoryjava:91) ~[na:na]        at comfacebookprestoconnectorconnectormanagercreateconnection(connectormanagerjava:92) ~[presto-main-054jar:054]        at comfacebookprestometadatacatalogmanagerloadcatalog(catalogmanagerjava:79) ~[presto-main-054jar:054]        at comfacebookprestometadatacatalogmanagerloadcatalogs(catalogmanagerjava:64) ~[presto-main-054jar:054]        at comfacebookprestoserverprestoserverrun(prestoserverjava:87) [presto-server-054jar:054]        at comfacebookprestoserverprestoservermain(prestoserverjava:47) [presto-server-054jar:054]caused by: orgjbossnettychannelchannelexception: failed to create a selector        at orgjbossnettychannelsocketnioabstractnioselectoropenselector(abstractnioselectorjava:337) ~[netty-362finaljar:na]        at orgjbossnettychannelsocketnioabstractnioselector<init>(abstractnioselectorjava:95) ~[netty-362finaljar:na]        at orgjbossnettychannelsocketnioabstractnioworker<init>(abstractnioworkerjava:51) ~[netty-362finaljar:na]        at orgjbossnettychannelsocketnionioworker<init>(nioworkerjava:45) ~[netty-362finaljar:na]        at orgjbossnettychannelsocketnionioworkerpoolcreateworker(nioworkerpooljava:45) ~[netty-362finaljar:na]        at orgjbossnettychannelsocketnionioworkerpoolcreateworker(nioworkerpooljava:28) ~[netty-362finaljar:na]        at orgjbossnettychannelsocketnioabstractnioworkerpoolnewworker(abstractnioworkerpooljava:99) ~[netty-362finaljar:na]        at orgjbossnettychannelsocketnioabstractnioworkerpoolinit(abstractnioworkerpooljava:69) ~[netty-362finaljar:na]        at orgjbossnettychannelsocketnionioworkerpool<init>(nioworkerpooljava:39) ~[netty-362finaljar:na]        at ioairlift ~[        at ioairlift ~[        at ioairlift ~[        at comgoogleinjectinternalboundproviderfactoryget(boundproviderfactoryjava:55) ~[guice-30jar:na]        at comgoogleinjectinternalprovidertointernalfactoryadapter$1call(providertointernalfactoryadapterjava:46) ~[guice-30jar:na]        at comgoogleinjectinternalinjectorimplcallincontext(injectorimpljava:1031) ~[guice-30jar:na]        at comgoogleinjectinternalprovidertointernalfactoryadapterget(providertointernalfactoryadapterjava:40) ~[guice-30jar:na]        at comgoogleinjectscopes$1$1get(scopesjava:65) ~[guice-30jar:na]        at comgoogleinjectinternalinternalfactorytoprovideradapterget(internalfactorytoprovideradapterjava:40) ~[guice-30jar:na]        at comgoogleinjectinternalinjectorimpl$4$1call(injectorimpljava:978) ~[guice-30jar:na]        at comgoogleinjectinternalinjectorimplcallincontext(injectorimpljava:1031) ~[guice-30jar:na]        at comgoogleinjectinternalinjectorimpl$4get(injectorimpljava:974) ~[guice-30jar:na]        at comgoogleinjectinternalinjectorimplgetinstance(injectorimpljava:1013) ~[guice-30jar:na]        at ioairlift ~[        at ioairlift ~[        at comgoogleinjectinternalinternalfactorytoprovideradapterget(internalfactorytoprovideradapterjava:40) ~[guice-30jar:na]        at comgoogleinjectinternalprovidertointernalfactoryadapter$1call(providertointernalfactoryadapterjava:46) ~[guice-30jar:na]        at comgoogleinjectinternalinjectorimplcallincontext(injectorimpljava:1031) ~[guice-30jar:na]        at comgoogleinjectinternalprovidertointernalfactoryadapterget(providertointernalfactoryadapterjava:40) ~[guice-30jar:na]        at comgoogleinjectscopes$1$1get(scopesjava:65) ~[guice-30jar:na]        at comgoogleinjectinternalinternalfactorytoprovideradapterget(internalfactorytoprovideradapterjava:40) ~[guice-30jar:na]        at comgoogleinjectinternalsingleparameterinjectorinject(singleparameterinjectorjava:38) ~[guice-30jar:na]        at comgoogleinjectinternalsingleparameterinjectorgetall(singleparameterinjectorjava:62) ~[guice-30jar:na]        at comgoogleinjectinternalconstructorinjectorconstruct(constructorinjectorjava:84) ~[guice-30jar:na]        at comgoogleinjectinternalconstructorbindingimpl$factoryget(constructorbindingimpljava:254) ~[guice-30jar:na]        at comgoogleinjectinternalfactoryproxyget(factoryproxyjava:54) ~[guice-30jar:na]        at comgoogleinjectinternalprovidertointernalfactoryadapter$1call(providertointernalfactoryadapterjava:46) ~[guice-30jar:na]        at comgoogleinjectinternalinjectorimplcallincontext(injectorimpljava:1031) ~[guice-30jar:na]        at comgoogleinjectinternalprovidertointernalfactoryadapterget(providertointernalfactoryadapterjava:40) ~[guice-30jar:na]        at comgoogleinjectscopes$1$1get(scopesjava:65) ~[guice-30jar:na]        at comgoogleinjectinternalinternalfactorytoprovideradapterget(internalfactorytoprovideradapterjava:40) ~[guice-30jar:na]        at comgoogleinjectinternalsingleparameterinjectorinject(singleparameterinjectorjava:38) ~[guice-30jar:na]        at comgoogleinjectinternalsingleparameterinjectorgetall(singleparameterinjectorjava:62) ~[guice-30jar:na]        at comgoogleinjectinternalconstructorinjectorconstruct(constructorinjectorjava:84) ~[guice-30jar:na]        at comgoogleinjectinternalconstructorbindingimpl$factoryget(constructorbindingimpljava:254) ~[guice-30jar:na]        at comgoogleinjectinternalprovidertointernalfactoryadapter$1call(providertointernalfactoryadapterjava:46) ~[guice-30jar:na]        at comgoogleinjectinternalinjectorimplcallincontext(injectorimpljava:1031) ~[guice-30jar:na]        at comgoogleinjectinternalprovidertointernalfactoryadapterget(providertointernalfactoryadapterjava:40) ~[guice-30jar:na]        at comgoogleinjectscopes$1$1get(scopesjava:65) ~[guice-30jar:na]        at comgoogleinjectinternalinternalfactorytoprovideradapterget(internalfactorytoprovideradapterjava:40) ~[guice-30jar:na]        at comgoogleinjectinternalinjectorimpl$4$1call(injectorimpljava:978) ~[guice-30jar:na]        at comgoogleinjectinternalinjectorimplcallincontext(injectorimpljava:1031) ~[guice-30jar:na]        at comgoogleinjectinternalinjectorimpl$4get(injectorimpljava:974) ~[guice-30jar:na]        at comgoogleinjectspiproviderlookup$1get(providerlookupjava:89) ~[guice-30jar:na]        at comgoogleinjectinternalprovidermethodget(providermethodjava:98) ~[guice-30jar:na]        at comgoogleinjectinternalinternalfactorytoprovideradapterget(internalfactorytoprovideradapterjava:40) ~[guice-30jar:na]        at comgoogleinjectinternalprovidertointernalfactoryadapter$1call(providertointernalfactoryadapterjava:46) ~[guice-30jar:na]        at comgoogleinjectinternalinjectorimplcallincontext(injectorimpljava:1031) ~[guice-30jar:na]        at comgoogleinjectinternalprovidertointernalfactoryadapterget(providertointernalfactoryadapterjava:40) ~[guice-30jar:na]        at comgoogleinjectscopes$1$1get(scopesjava:65) ~[guice-30jar:na]        at comgoogleinjectinternalinternalfactorytoprovideradapterget(internalfactorytoprovideradapterjava:40) ~[guice-30jar:na]        at comgoogleinjectinternalfactoryproxyget(factoryproxyjava:54) ~[guice-30jar:na]        at comgoogleinjectinternalprovidertointernalfactoryadapter$1call(providertointernalfactoryadapterjava:46) ~[guice-30jar:na]        at comgoogleinjectinternalinjectorimplcallincontext(injectorimpljava:1031) ~[guice-30jar:na]        at comgoogleinjectinternalprovidertointernalfactoryadapterget(providertointernalfactoryadapterjava:40) ~[guice-30jar:na]        at comgoogleinjectscopes$1$1get(scopesjava:65) ~[guice-30jar:na]        at comgoogleinjectinternalinternalfactorytoprovideradapterget(internalfactorytoprovideradapterjava:40) ~[guice-30jar:na]        at comgoogleinjectinternalsingleparameterinjectorinject(singleparameterinjectorjava:38) ~[guice-30jar:na]        at comgoogleinjectinternalsingleparameterinjectorgetall(singleparameterinjectorjava:62) ~[guice-30jar:na]        at comgoogleinjectinternalsinglemethodinjectorinject(singlemethodinjectorjava:83) ~[guice-30jar:na]        at comgoogleinjectinternalmembersinjectorimplinjectmembers(membersinjectorimpljava:110) ~[guice-30jar:na]        at comgoogleinjectinternalmembersinjectorimpl$1call(membersinjectorimpljava:75) ~[guice-30jar:na]        at comgoogleinjectinternalmembersinjectorimpl$1call(membersinjectorimpljava:73) ~[guice-30jar:na]        at comgoogleinjectinternalinjectorimplcallincontext(injectorimpljava:1024) ~[guice-30jar:na]        at comgoogleinjectinternalmembersinjectorimplinjectandnotify(membersinjectorimpljava:73) ~[guice-30jar:na]        at comgoogleinjectinternalinitializer$injectablereferenceget(initializerjava:147) ~[guice-30jar:na]        at comgoogleinjectinternalinitializerinjectall(initializerjava:92) ~[guice-30jar:na]        at comgoogleinjectinternalinternalinjectorcreatorinjectdynamically(internalinjectorcreatorjava:173) ~[guice-30jar:na]         9 common frames omittedcaused by: javaioioexception: too many open files        at sunniochioutilmakepipe(native method) ~[na:170_45]        at sunniochepollselectorimpl<init>(epollselectorimpljava:65) ~[na:170_45]        at sunniochepollselectorprovideropenselector(epollselectorproviderjava:36) ~[na:170_45]        at javaniochannelsselectoropen(selectorjava:227) ~[na:170_45]        at orgjbossnettychannelsocketnioabstractnioselectoropenselector(abstractnioselectorjava:335) ~[netty-362finaljar:na]         85 common frames omitted2013-12-10t15 59565+0000     info   thread-48       ioairliftbootstraplifecyclemanager   life cycle stopping```;noticing that the 8081 seems to be binding to an ipv6 address```[root@viper conf]# netstat -an | grep 8081tcp        0      0 :::8081                     :::*                        listen``` || the problem is the file descriptor limit on your installation is too low  we typically run our servers with a 64k descriptor limit  if you search google you will find instructions on how to increase this limit  for example this post looks like a good start  || we have file limit set to 66k still seeing the same issue```[kore@installer-tst ~]$ netstat -lnt |grep 7001tcp6       0      0 :::7001                 :::*                    listen[kore@installer-tst ~]$ ulimit -acore file size          (blocks -c) 0data seg size           (kbytes -d) unlimitedscheduling priority             (-e) 0file size               (blocks -f) unlimitedpending signals                 (-i) 119924max locked memory       (kbytes -l) 64max memory size         (kbytes -m) unlimitedopen files                      (-n) 66000pipe size            (512 bytes -p) 8posix message queues     (bytes -q) 819200real-time priority              (-r) 0stack size              (kbytes -s) 8192cpu time               (seconds -t) unlimitedmax user processes              (-u) 4096virtual memory          (kbytes -v) unlimitedfile locks                      (-x) unlimited[kore@installer-tst ~]$``` ||;;;;0;1;;
902;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;fix typecache dead lock;i could trace the problem to more eager resolution of types in java u31 upon loading where concurrent mock creation with locking on the class level causes a dead lock. this can happen in other vm implementations but can be solved with a more granular lock on our type cache.;;0; nullpointerexception that may happen on timeout;an unhandled nullpointerexception is thrown in the releaseresources method in rxapache if a timeout occur if a timeout occur then onresponsereceived is never called and thus consumer is null;#834  thank you  ||;;;;1;1; nullpointerexception that may happen on timeout;
905;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;made sure all importformat classes never return null  but collections…;….emptylist() instead - importformat.importentries now never return null (still not propagated to calling code) - all(?) importformat readers are handled with try-with - replaced stringbuffer with stringbuilder where possible - used interface where applicable -  ? not relevant -   -  ? not relevant -  ?;;0;part of table; i want to get a part of the table if i specify the start and end of row and colum index is there any api or this would be an enhancement?; ;;;;0;1;;
905;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;made sure all importformat classes never return null  but collections…;….emptylist() instead - importformat.importentries now never return null (still not propagated to calling code) - all(?) importformat readers are handled with try-with - replaced stringbuffer with stringbuilder where possible - used interface where applicable -  ? not relevant -   -  ? not relevant -  ?;;0;add unit tests for rc binary and rc text;;;;;;1;1;add unit tests for rc binary and rc text;
905;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;made sure all importformat classes never return null  but collections…;….emptylist() instead - importformat.importentries now never return null (still not propagated to calling code) - all(?) importformat readers are handled with try-with - replaced stringbuffer with stringbuilder where possible - used interface where applicable -  ? not relevant -   -  ? not relevant -  ?;;0;rxjavaschedulers plugin;allow setting different default schedulers for use by system;;;;;1;1;rename rxjavaschedulers to rxjavadefaultschedulersclearer semantic naming;
905;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;made sure all importformat classes never return null  but collections…;….emptylist() instead - importformat.importentries now never return null (still not propagated to calling code) - all(?) importformat readers are handled with try-with - replaced stringbuffer with stringbuilder where possible - used interface where applicable -  ? not relevant -   -  ? not relevant -  ?;;814.0;814 : a elements were missing the name attribute;meaningful links probably never worked as expectedthe `a` elements were missing the `name` attribute so the browser couldnt find the matching part of the documentfor reference : [598 navigating to a fragment identifier]( for html documents (and the text/html mime type) the following processing model must be followed to determine what the indicated part of the document is> > 1 parse the url and let fragid be the <fragment> component of the url> 2 if fragid is the empty string then the indicated part of the document is the top of the document> 3 if there is an element in the dom that has an id exactly equal to fragid then the first such element in tree order is the indicated part of the document stop the algorithm here> 4 if there is an a element in the dom that has a name attribute whose value is exactly equal to fragid then the first such element in tree order is the indicated part of the document stop the algorithm here> 5 otherwise there is no indicated part of the document;i am merging this one as this is very simple || hm dont want a quick review? i try to never self-merge as it got me numerous times already || the change is damn simple (its just adding `name` attribute)  with a simple regexp ||  ;javadoc links in main mockito doc are not linkable;the links to line items in the main [mockito documentation]( are not linkable eg i cannot create a link to item no 40 in the list;i dont see what you mean i have no problem for that : *   || at first it seems to be working but the actual issue is that the first link of @bric3 does work but the second does not the problem is that the headers have the second link so they must be updated to use numbers instead ||;1;0;814 : a elements were missing the name attributesigned-off-by: brice dutheil <bricedutheil@gmailcom>;
907;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;more tests for oobibstyle;testing of a few more methods in oobibstyle.;;0;make equivalencewrapper implement supplier; since equivalencewrapper already defines the get() method it seems reasonable to me to have it implement supplieri have a use case where id like to take a collection of equivalencewrapper&ltfoo> and transform/copy it to a collection of foo if equivalencewrapper implemented supplier i could use supplierssupplierfunction() for that as it is i have to either do it manually or write a function for it myself; ;;;;0;1;;
907;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;more tests for oobibstyle;testing of a few more methods in oobibstyle.;;0;implement some functions in presto jdbc driver;got basic queries running in squirrel sql client;"minor nit: no need to say ""presto"" in the commit message || aside from minor comments  `testcatalogtablecolumnnames` failed in the travis ci build || aside from failing test (see inline comment) and minor nits @electrum any chance to have this in the next release? || ";;;;1;1;implement some functions in jdbc driver;
907;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;more tests for oobibstyle;testing of a few more methods in oobibstyle.;;0;deprecate direct access to scheduler implementations;this enforces the convention of using `schedulers*` and then makes the rxjavadefaultschedulers plugin more reliable;#839 no idea why this doesnt want to be merged  other than that thoughts on this idea based on `rxjavadefaultschedulers` plugin added in  ? ||;;;;0;1;;
907;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;more tests for oobibstyle;testing of a few more methods in oobibstyle.;;426.0;unified all number of invocations checker in numberofinvocationschecker;426this pr unifies the functionality of `nongreedynumberofinvocationschecker` `numberofinvocationscheckerinorder `and `numberofinvocationschecker `in static methods of the type `numberofinvocationschecker` this saves ~50 lines of code and increases readability on the call sides; ;refactor instance based utility classes to static utility classes;the internal implementation of mockito contains numerous helper classed that serve as a container for useful methods by its nature these classes dont have a state currently some them are instance based in other word you need to create the utility class to call a helper method this not only pollutes the heap but also the code cause instance methods cant be imported statically here is an example:```javahelper helper  new helper()if (helperisinputvalid(input)){   }```vs static import of helperisinputvalid```javaif (isinputvalid(input)){   }```the aim of this ticket is to identify canidates that can be refactored to static utility classes if you like to refactoring and mockito feel free to send a pr and reference this issuerefactoring canidates:-  `accessibilitychanger`-  `beanpropertysetter`-  `conditionalstacktracefilter`-  `fieldcopier`-  `fieldreader`-  `genericmaster` should be integrate into `generictyperesolver`-  `junitfailurehacker` can be removed when the deprecated `verbosemockitojunitrunner` is removed-  `lenientcopytool`-  `matcherbinder`-  `mockitocore` should better be a singleton-  `mockcreationvalidator`- [ ] `removefirstline`-  #591 `argumentmatchingtool`-  #515 `allinvocationsfinder`-  #502 `argumentscomparator`-  #540 `arrayutils`-  #490 `atleastxnumberofinvocationschecker`-  #490 `atleastxnumberofinvocationsinorderchecker`- [ ] #912 `constructors`-  #427 `fieldsetter`-  #908 `friendlyexceptionmaker`-  #431 `handyreturnvalues` - [x] #432 `invocationmarker`- [x] #462 `invocationsfinder`- [x] #908 `junitdetecter`- [x] #490 `missinginvocationchecker`- [x] #490 `missinginvocationinorderchecker`- [x] #514 `mockutil`- [x] #503 `nongreedynumberofinvocationsinorderchecker`- [x] #907 `numberofinvocationsinorderchecker`- [x] #907 `numberofinvocationschecker`- [x] #547 `objectmethodsguru`- [x] #427 `reporter`- [x] #535 `supertypeslastsorter`- [x] #501 `testmethodfinder`- [x] #515 `verifiableinvocationsfinder`;"@raphw thanks for merging the pr that fast!  would you mind reopening this ticket? there are more classes that can be refactored that way i would like to extend the list || big :+1: for me btw but please keep the pull requests managable and as small as possible preferably refactoring 1 method at a time that way it is a lot easier to review || i agree there is nothing wrong with multiple prs the quick merge is a reaction to an easy overview (and being stuck at an ukrainian airport without access to the eurocup) || there are still two unit tests failing could you have a look @christianschwarz - i just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `reporter`i should have checked more thoroughly before merging hopefully you can fix the problem soon alternatively i will just rollback the one commit (the first one is good) and we can reapply the patch once you  the two unit tests thank you really this was great clean-up || i fixed the one test error i push it tonightps: i also fixed a bug in the stack trace cleaner not a biggy but please do not `@ignore` tests especially in big commits it is easy to miss that single annotation || @raphw which test(s) is/are failing? i will fix it asap! too bad that some test fail on a regulare base is it possible to ignore them in the ide only? || you can see the build output here:  advise you to run the tests with `/gradlew build` this should work || @timvdlippe know what you mean! the next prs include only one refactored class at a time || i have it all fixed on local but i did not have access to wifi without 22 blocked will commit soon || @raphw can you please reopen this issue  || sorry github automatically closes issues that reference a pr || @christianschwarz if a commit contains a comment like ""426"" the mentioned issue is automatically closed by github || @pascalschumacher good to know! i will leave it out for the upcoming prs  now that we are pulling in static methods i would like to propose a new (linter) rule to make it easier to read a file i would like that all methods invoked in the current class are referenced with `this` (and `super` for that matter) therefore if we see `thisverify` we know it is in the current class and the same object whereas `verify` references a static method in this class or an imported static method do you agree @mockito/developers ? || > i would like that all methods invoked in the current class are referenced with this (and super for that matter)to me it feels like unnecessary/duplicate code cause `this` is implicit adding `this` before every instance call would create a lot more text and would imho reduce readability eg:`thisdosometing(thiswithprivatemethod())` vs `dosomething(withprivatemethod())`> therefore if we see thisverify we know it is in the current class and the same object whereas verify references a static method in this class or an imported static methodan other option avoid ambiguity is to qualify static methods via its class name  this way you can also distinguish which verify() is called ( `mockitocoreverify()` / `mocktioverify()`)  which is not an easy task when a static import is used || im not coding too much in mockito atm (hopefully now after springone conference ill have more time) but i fully agree with @christianschwarz  imo the best solution is to: - omit `this` before method calls - if necessary provide the class for static method call || respectful -1i like when the class formally declares collaborators instead of calling out to static methods this makes it easy to reason about the code i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etc another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too proceduralthe benefits for converting to static utilities have minimal significance to me yet there is a downside i care about (eg maintainability of procedural code static methods that consume static methods that consume static methods)hence i down vote this sort of changes going down this path all stateless classes in mockito would become static utilities :)you can get +1s from other maintainers and have your changes merged - im not here to block your changes but to give honest feedback i see merit in arguments for static utilities they do not outweigh the cost in my opinion || im mitigated about this as well i understand well that mockito creates garbage but they are short lived and **most probably** wont go in the old generation especially in the test phase yet the faster the tests are the more developers will run them it **may** have impacts on big projects also design wise i dont like much static methods toohowever i dont totally agree with the above points : > i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etccoupling appears also in the import section  static methods are visible there and modern ide usually highlight this intellij even have a warning if import section is too big just as theres warning if theres too many fields this point should not be the reason to avoid static methods> maintainability of procedural code static methods that consume static methods that consume static methodshaving instance methods does not protect again procedural code---i believe theres middle ground there : - mockito project contains a lot of small utility stateless objects that are supporting mockito features these are usually collections tools reflection tools those could are good candidate for static methods objects like `fieldsetter` `fieldcopier` `lenientcopytool` could be nice candidate for static methods- mockito features could be backed by object instances objects like `mockitocore` `mockcreationvalidator` `argumentmatchingtool` are candidate to stay objects || exactly the middle ground described by brice is my motivation for merging most of the prs this is also the reason i have not yet merged the mockitocore pr for this exact reasonif an object is not a attribute or parameter but an internal creation and immediately dismissed i value a pure function more || thought: when we switch to java 8 we can use interfaces with defaultmethods the switch from static utility to interface is very easy now (justa couple of text replaces no method reference modifications)on fri 12 aug 2016 17:23 brice dutheil notifications@githubcom wrote:> im mitigated about this as well i understand well that mockito creates> garbage but they are short lived and _most probably_ wont go in the old> generation especially in the test phase yet the faster the tests are the> more developers will run them it _may_ have impacts on big projects> also design wise i dont like much static methods too> > however i dont totally agree with the above points :> > i dont need to read every line of code in the class to find out external> couplings realized via static methods i can see the couplings via fields> i can easily query how the field variable is used etc> > coupling appears also in the import section  static methods are visible> there and modern ide usually highlight this intellij even have a warning> if import section is too big just as theres warning if theres too many> fields this point should not be the reason to avoid static methods> > maintainability of procedural code static methods that consume static> methods that consume static methods> > ## having instance methods does not protect again procedural code> > i believe theres middle ground there :> >    -> >    mockito project contains a lot of small utility stateless objects that>    are supporting mockito features these are usually collections tools>    reflection tools those could are good candidate for static methods>    objects like fieldsetter fieldcopier lenientcopytool could be nice>    candidate for static methods>    -> >    mockito features could be backed by object instances objects like>    mockitocore mockcreationvalidator argumentmatchingtool are candidate>    to stay objects> > —> you are receiving this because you modified the open/close state> reply to this email directly view it on github>  or mute the thread>   || this feels like a misuse of the default methods || i think you mean static-methods in interfaces here? default-methods require an instance to be called onanyway i dont think that it is a good idea  it would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods imho a class with private constructor is the best construct to do this || > > thought: when we switch to java 8 we can use interfaces with default> > methods> > default-methods require an instance to be called oni was thinking exactly that default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface) || @christianschwarz what do you think to continue the work here with the middle ground described [here]( ? || i am attempting to refactor the matcherbinder class to a static utility class and am having trouble refactoring the following from mockhandlerimpltestjava: `handlermatchersbinder  new matchersbinder() {            public invocationmatcher bindmatchers(argumentmatcherstorage argumentmatcherstorage invocation invocation) {                throw new invaliduseofmatchersexception()            }} `how can i maintain the abstract class definition when i am not able to create an object of matcherbinder?any help is appreciated!  || lets close this ticket refactorings can be done as needed as we work with the code || ";1;0;unified all number of invocations checker in static utilitynumberofinvocationschecker;
908;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;simplified the creation of argumentsaredifferent-exceptions.;relates to #426;;0;"ensure ""lexicographical"" order in setscartesianproduct"; hithe current implementation of setscartesianproduct returns lists where the first value changes most quickly and last value most slowlyif ordering inside set matters (in case of some ordered set implementation) and one makes the cartesian product of set with itself the iteration order is not stablemy use case:i have to find a best hamiltonian path in a (not so large) graph given a restriction that the first and last node must be in specified subsets of nodes the algorithm tries all nonequal pairs of possibly-first and possibly-last nodes evaluates quality of a path and in case of a tie the minimal ordering should decide example: (for simplicity edges dont matter and assume all possible paths have same quality)let g1 be graph with nodes abc possiblyfirst[abc] possiblylast[c]cartesian products: [[ac][bc][cc]]first successful: [ac]result: [abc]let g2 be graph with nodes ab   possiblyfirst[ab] possiblylast[ab]cartesian products: [[aa][ba][ab][bb]first successful: [ba]result: [ba]so removing node c breaks order between a and bi am aware of javadoc of cartesianproduct method  stating the order is not guaranteed should it rather do? other methods (difference union intersection) do it toomoreover in the javadoc example setscartesianproduct(immutablesetof(1 2)immutablesetof(""a"" ""b"" ""c"")) the state result is in different order that in reality which is little confusing however i admit the ""returns a set containing six lists:"" statement is preciseif guava team is open to such a change i would try to add a patch of setscartesianset the current workaround is setscartesianproduct(originallistreverse()) and reverse resulting lists backthank youtomas zalusky"; we  this back in september we just forgot to mention it  `fixed` ;;;;0;1;;
908;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;simplified the creation of argumentsaredifferent-exceptions.;relates to #426;;0;no support for __hive_default_partition__;"presto 054 lacks support for dynamically partitioned tables that have a  `__hive_default_partition__`query fails with:```presto:tpcds_rcfile> select * from store_sales limit 100query 20131213_161730_00003_eaeq3 failed: for input string: ""__hive_default_partition__"";basically `__hive_default_patition__` represents null: || completely understand how and why `__hive_default_partition__` gets created but as of 054 one can not even query a partitioned table with presto if the `__hive_default_partition__` partition exists even if the partition key is specified -- the query fails out of the gate || dain was just adding some detail from his investigation it is definitely a bug well add this to our test cases and fix it thanks for the report || the meaning behind dains comment wasnt exactly clear to me but no worries ||  in trunk (078) ||;;;;0;1;;
908;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;simplified the creation of argumentsaredifferent-exceptions.;relates to #426;;0;rxjava clojure bindings;_please dont merge this - for review only_heres a pull request for clojure bindings to give people a place to provide feedback;#840  #841 #842 [rxjava-pull-requests #843 looks good || [rxjava-pull-requests #846 [rxjava-pull-requests #847]( successthis pull request looks good || [rxjava-pull-requests #848]( successthis pull request looks good || [rxjava-pull-requests #849]( successthis pull request looks good || [rxjava-pull-requests #850]( successthis pull request looks good || [rxjava-pull-requests #851 [rxjava-pull-requests #854]( successthis pull request looks good || [rxjava-pull-requests #859]( successthis pull request looks good || [rxjava-pull-requests #861]( successthis pull request looks good || replaced by  ||;;;;0;1;;
908;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;simplified the creation of argumentsaredifferent-exceptions.;relates to #426;;426.0;simplified the creation of argumentsaredifferent-exceptions;relates to #426 this pr simplifies the creation of argumentsaredifferent-exceptions saving 2 classes and ~40 lines of code;   no coverage uploaded for pull request base (`release/2x@1cbc7f8`) [click here to learn what that means]( ` ;refactor instance based utility classes to static utility classes;the internal implementation of mockito contains numerous helper classed that serve as a container for useful methods by its nature these classes dont have a state currently some them are instance based in other word you need to create the utility class to call a helper method this not only pollutes the heap but also the code cause instance methods cant be imported statically here is an example:```javahelper helper  new helper()if (helperisinputvalid(input)){   }```vs static import of helperisinputvalid```javaif (isinputvalid(input)){   }```the aim of this ticket is to identify canidates that can be refactored to static utility classes if you like to refactoring and mockito feel free to send a pr and reference this issuerefactoring canidates:-  `accessibilitychanger`-  `beanpropertysetter`-  `conditionalstacktracefilter`-  `fieldcopier`-  `fieldreader`-  `genericmaster` should be integrate into `generictyperesolver`-  `junitfailurehacker` can be removed when the deprecated `verbosemockitojunitrunner` is removed-  `lenientcopytool`-  `matcherbinder`-  `mockitocore` should better be a singleton-  `mockcreationvalidator`- [ ] `removefirstline`-  #591 `argumentmatchingtool`-  #515 `allinvocationsfinder`-  #502 `argumentscomparator`-  #540 `arrayutils`-  #490 `atleastxnumberofinvocationschecker`-  #490 `atleastxnumberofinvocationsinorderchecker`- [ ] #912 `constructors`-  #427 `fieldsetter`-  #908 `friendlyexceptionmaker`-  #431 `handyreturnvalues` - [x] #432 `invocationmarker`- [x] #462 `invocationsfinder`- [x] #908 `junitdetecter`- [x] #490 `missinginvocationchecker`- [x] #490 `missinginvocationinorderchecker`- [x] #514 `mockutil`- [x] #503 `nongreedynumberofinvocationsinorderchecker`- [x] #907 `numberofinvocationsinorderchecker`- [x] #907 `numberofinvocationschecker`- [x] #547 `objectmethodsguru`- [x] #427 `reporter`- [x] #535 `supertypeslastsorter`- [x] #501 `testmethodfinder`- [x] #515 `verifiableinvocationsfinder`;"@raphw thanks for merging the pr that fast!  would you mind reopening this ticket? there are more classes that can be refactored that way i would like to extend the list || big :+1: for me btw but please keep the pull requests managable and as small as possible preferably refactoring 1 method at a time that way it is a lot easier to review || i agree there is nothing wrong with multiple prs the quick merge is a reaction to an easy overview (and being stuck at an ukrainian airport without access to the eurocup) || there are still two unit tests failing could you have a look @christianschwarz - i just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `reporter`i should have checked more thoroughly before merging hopefully you can fix the problem soon alternatively i will just rollback the one commit (the first one is good) and we can reapply the patch once you  the two unit tests thank you really this was great clean-up || i fixed the one test error i push it tonightps: i also fixed a bug in the stack trace cleaner not a biggy but please do not `@ignore` tests especially in big commits it is easy to miss that single annotation || @raphw which test(s) is/are failing? i will fix it asap! too bad that some test fail on a regulare base is it possible to ignore them in the ide only? || you can see the build output here:  advise you to run the tests with `/gradlew build` this should work || @timvdlippe know what you mean! the next prs include only one refactored class at a time || i have it all fixed on local but i did not have access to wifi without 22 blocked will commit soon || @raphw can you please reopen this issue  || sorry github automatically closes issues that reference a pr || @christianschwarz if a commit contains a comment like ""426"" the mentioned issue is automatically closed by github || @pascalschumacher good to know! i will leave it out for the upcoming prs  now that we are pulling in static methods i would like to propose a new (linter) rule to make it easier to read a file i would like that all methods invoked in the current class are referenced with `this` (and `super` for that matter) therefore if we see `thisverify` we know it is in the current class and the same object whereas `verify` references a static method in this class or an imported static method do you agree @mockito/developers ? || > i would like that all methods invoked in the current class are referenced with this (and super for that matter)to me it feels like unnecessary/duplicate code cause `this` is implicit adding `this` before every instance call would create a lot more text and would imho reduce readability eg:`thisdosometing(thiswithprivatemethod())` vs `dosomething(withprivatemethod())`> therefore if we see thisverify we know it is in the current class and the same object whereas verify references a static method in this class or an imported static methodan other option avoid ambiguity is to qualify static methods via its class name  this way you can also distinguish which verify() is called ( `mockitocoreverify()` / `mocktioverify()`)  which is not an easy task when a static import is used || im not coding too much in mockito atm (hopefully now after springone conference ill have more time) but i fully agree with @christianschwarz  imo the best solution is to: - omit `this` before method calls - if necessary provide the class for static method call || respectful -1i like when the class formally declares collaborators instead of calling out to static methods this makes it easy to reason about the code i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etc another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too proceduralthe benefits for converting to static utilities have minimal significance to me yet there is a downside i care about (eg maintainability of procedural code static methods that consume static methods that consume static methods)hence i down vote this sort of changes going down this path all stateless classes in mockito would become static utilities :)you can get +1s from other maintainers and have your changes merged - im not here to block your changes but to give honest feedback i see merit in arguments for static utilities they do not outweigh the cost in my opinion || im mitigated about this as well i understand well that mockito creates garbage but they are short lived and **most probably** wont go in the old generation especially in the test phase yet the faster the tests are the more developers will run them it **may** have impacts on big projects also design wise i dont like much static methods toohowever i dont totally agree with the above points : > i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etccoupling appears also in the import section  static methods are visible there and modern ide usually highlight this intellij even have a warning if import section is too big just as theres warning if theres too many fields this point should not be the reason to avoid static methods> maintainability of procedural code static methods that consume static methods that consume static methodshaving instance methods does not protect again procedural code---i believe theres middle ground there : - mockito project contains a lot of small utility stateless objects that are supporting mockito features these are usually collections tools reflection tools those could are good candidate for static methods objects like `fieldsetter` `fieldcopier` `lenientcopytool` could be nice candidate for static methods- mockito features could be backed by object instances objects like `mockitocore` `mockcreationvalidator` `argumentmatchingtool` are candidate to stay objects || exactly the middle ground described by brice is my motivation for merging most of the prs this is also the reason i have not yet merged the mockitocore pr for this exact reasonif an object is not a attribute or parameter but an internal creation and immediately dismissed i value a pure function more || thought: when we switch to java 8 we can use interfaces with defaultmethods the switch from static utility to interface is very easy now (justa couple of text replaces no method reference modifications)on fri 12 aug 2016 17:23 brice dutheil notifications@githubcom wrote:> im mitigated about this as well i understand well that mockito creates> garbage but they are short lived and _most probably_ wont go in the old> generation especially in the test phase yet the faster the tests are the> more developers will run them it _may_ have impacts on big projects> also design wise i dont like much static methods too> > however i dont totally agree with the above points :> > i dont need to read every line of code in the class to find out external> couplings realized via static methods i can see the couplings via fields> i can easily query how the field variable is used etc> > coupling appears also in the import section  static methods are visible> there and modern ide usually highlight this intellij even have a warning> if import section is too big just as theres warning if theres too many> fields this point should not be the reason to avoid static methods> > maintainability of procedural code static methods that consume static> methods that consume static methods> > ## having instance methods does not protect again procedural code> > i believe theres middle ground there :> >    -> >    mockito project contains a lot of small utility stateless objects that>    are supporting mockito features these are usually collections tools>    reflection tools those could are good candidate for static methods>    objects like fieldsetter fieldcopier lenientcopytool could be nice>    candidate for static methods>    -> >    mockito features could be backed by object instances objects like>    mockitocore mockcreationvalidator argumentmatchingtool are candidate>    to stay objects> > —> you are receiving this because you modified the open/close state> reply to this email directly view it on github>  or mute the thread>   || this feels like a misuse of the default methods || i think you mean static-methods in interfaces here? default-methods require an instance to be called onanyway i dont think that it is a good idea  it would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods imho a class with private constructor is the best construct to do this || > > thought: when we switch to java 8 we can use interfaces with default> > methods> > default-methods require an instance to be called oni was thinking exactly that default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface) || @christianschwarz what do you think to continue the work here with the middle ground described [here]( ? || i am attempting to refactor the matcherbinder class to a static utility class and am having trouble refactoring the following from mockhandlerimpltestjava: `handlermatchersbinder  new matchersbinder() {            public invocationmatcher bindmatchers(argumentmatcherstorage argumentmatcherstorage invocation invocation) {                throw new invaliduseofmatchersexception()            }} `how can i maintain the abstract class definition when i am not able to create an object of matcherbinder?any help is appreciated!  || lets close this ticket refactorings can be done as needed as we work with the code || ";1;0;simplified the creation of argumentsaredifferent-exceptions;
914;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored removefirstline to a static utility class.;relates to #426;;0;patch for /guava/src/com/google/common/collect/multimapjava; add size(k key) to the interface so we dont have to do get(k key)size()0 can be returned if the key is not found; ;;;;0;1;;
914;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored removefirstline to a static utility class.;relates to #426;;0;prune the table scan assignments just before plan finalization;this will cut down on the size of the assignments map when logging;;;;;0;1;;
914;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored removefirstline to a static utility class.;relates to #426;;0;any reason for rxlangscalasubjectspublishsubject to be private?;title explains it all; in  ||;;;;0;1;;
914;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored removefirstline to a static utility class.;relates to #426;;426.0;refactored removefirstline to a static utility class;relates to #426 refactored `removefirstline` to a static utility classi would like to unifiy `removefirstline` `decamelizer` and `stringjoiner` to a new type `stringutil` they all manipulate strings and contain only a few methods that are not worth to live in a dedicated classes any thoughts?; ;refactor instance based utility classes to static utility classes;the internal implementation of mockito contains numerous helper classed that serve as a container for useful methods by its nature these classes dont have a state currently some them are instance based in other word you need to create the utility class to call a helper method this not only pollutes the heap but also the code cause instance methods cant be imported statically here is an example:```javahelper helper  new helper()if (helperisinputvalid(input)){   }```vs static import of helperisinputvalid```javaif (isinputvalid(input)){   }```the aim of this ticket is to identify canidates that can be refactored to static utility classes if you like to refactoring and mockito feel free to send a pr and reference this issuerefactoring canidates:-  `accessibilitychanger`-  `beanpropertysetter`-  `conditionalstacktracefilter`-  `fieldcopier`-  `fieldreader`-  `genericmaster` should be integrate into `generictyperesolver`-  `junitfailurehacker` can be removed when the deprecated `verbosemockitojunitrunner` is removed-  `lenientcopytool`-  `matcherbinder`-  `mockitocore` should better be a singleton-  `mockcreationvalidator`- [ ] `removefirstline`-  #591 `argumentmatchingtool`-  #515 `allinvocationsfinder`-  #502 `argumentscomparator`-  #540 `arrayutils`-  #490 `atleastxnumberofinvocationschecker`-  #490 `atleastxnumberofinvocationsinorderchecker`- [ ] #912 `constructors`-  #427 `fieldsetter`-  #908 `friendlyexceptionmaker`-  #431 `handyreturnvalues` - [x] #432 `invocationmarker`- [x] #462 `invocationsfinder`- [x] #908 `junitdetecter`- [x] #490 `missinginvocationchecker`- [x] #490 `missinginvocationinorderchecker`- [x] #514 `mockutil`- [x] #503 `nongreedynumberofinvocationsinorderchecker`- [x] #907 `numberofinvocationsinorderchecker`- [x] #907 `numberofinvocationschecker`- [x] #547 `objectmethodsguru`- [x] #427 `reporter`- [x] #535 `supertypeslastsorter`- [x] #501 `testmethodfinder`- [x] #515 `verifiableinvocationsfinder`;"@raphw thanks for merging the pr that fast!  would you mind reopening this ticket? there are more classes that can be refactored that way i would like to extend the list || big :+1: for me btw but please keep the pull requests managable and as small as possible preferably refactoring 1 method at a time that way it is a lot easier to review || i agree there is nothing wrong with multiple prs the quick merge is a reaction to an easy overview (and being stuck at an ukrainian airport without access to the eurocup) || there are still two unit tests failing could you have a look @christianschwarz - i just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `reporter`i should have checked more thoroughly before merging hopefully you can fix the problem soon alternatively i will just rollback the one commit (the first one is good) and we can reapply the patch once you  the two unit tests thank you really this was great clean-up || i fixed the one test error i push it tonightps: i also fixed a bug in the stack trace cleaner not a biggy but please do not `@ignore` tests especially in big commits it is easy to miss that single annotation || @raphw which test(s) is/are failing? i will fix it asap! too bad that some test fail on a regulare base is it possible to ignore them in the ide only? || you can see the build output here:  advise you to run the tests with `/gradlew build` this should work || @timvdlippe know what you mean! the next prs include only one refactored class at a time || i have it all fixed on local but i did not have access to wifi without 22 blocked will commit soon || @raphw can you please reopen this issue  || sorry github automatically closes issues that reference a pr || @christianschwarz if a commit contains a comment like ""426"" the mentioned issue is automatically closed by github || @pascalschumacher good to know! i will leave it out for the upcoming prs  now that we are pulling in static methods i would like to propose a new (linter) rule to make it easier to read a file i would like that all methods invoked in the current class are referenced with `this` (and `super` for that matter) therefore if we see `thisverify` we know it is in the current class and the same object whereas `verify` references a static method in this class or an imported static method do you agree @mockito/developers ? || > i would like that all methods invoked in the current class are referenced with this (and super for that matter)to me it feels like unnecessary/duplicate code cause `this` is implicit adding `this` before every instance call would create a lot more text and would imho reduce readability eg:`thisdosometing(thiswithprivatemethod())` vs `dosomething(withprivatemethod())`> therefore if we see thisverify we know it is in the current class and the same object whereas verify references a static method in this class or an imported static methodan other option avoid ambiguity is to qualify static methods via its class name  this way you can also distinguish which verify() is called ( `mockitocoreverify()` / `mocktioverify()`)  which is not an easy task when a static import is used || im not coding too much in mockito atm (hopefully now after springone conference ill have more time) but i fully agree with @christianschwarz  imo the best solution is to: - omit `this` before method calls - if necessary provide the class for static method call || respectful -1i like when the class formally declares collaborators instead of calling out to static methods this makes it easy to reason about the code i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etc another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too proceduralthe benefits for converting to static utilities have minimal significance to me yet there is a downside i care about (eg maintainability of procedural code static methods that consume static methods that consume static methods)hence i down vote this sort of changes going down this path all stateless classes in mockito would become static utilities :)you can get +1s from other maintainers and have your changes merged - im not here to block your changes but to give honest feedback i see merit in arguments for static utilities they do not outweigh the cost in my opinion || im mitigated about this as well i understand well that mockito creates garbage but they are short lived and **most probably** wont go in the old generation especially in the test phase yet the faster the tests are the more developers will run them it **may** have impacts on big projects also design wise i dont like much static methods toohowever i dont totally agree with the above points : > i dont need to read every line of code in the class to find out external couplings realized via static methods i can see the couplings via fields i can easily query how the field variable is used etccoupling appears also in the import section  static methods are visible there and modern ide usually highlight this intellij even have a warning if import section is too big just as theres warning if theres too many fields this point should not be the reason to avoid static methods> maintainability of procedural code static methods that consume static methods that consume static methodshaving instance methods does not protect again procedural code---i believe theres middle ground there : - mockito project contains a lot of small utility stateless objects that are supporting mockito features these are usually collections tools reflection tools those could are good candidate for static methods objects like `fieldsetter` `fieldcopier` `lenientcopytool` could be nice candidate for static methods- mockito features could be backed by object instances objects like `mockitocore` `mockcreationvalidator` `argumentmatchingtool` are candidate to stay objects || exactly the middle ground described by brice is my motivation for merging most of the prs this is also the reason i have not yet merged the mockitocore pr for this exact reasonif an object is not a attribute or parameter but an internal creation and immediately dismissed i value a pure function more || thought: when we switch to java 8 we can use interfaces with defaultmethods the switch from static utility to interface is very easy now (justa couple of text replaces no method reference modifications)on fri 12 aug 2016 17:23 brice dutheil notifications@githubcom wrote:> im mitigated about this as well i understand well that mockito creates> garbage but they are short lived and _most probably_ wont go in the old> generation especially in the test phase yet the faster the tests are the> more developers will run them it _may_ have impacts on big projects> also design wise i dont like much static methods too> > however i dont totally agree with the above points :> > i dont need to read every line of code in the class to find out external> couplings realized via static methods i can see the couplings via fields> i can easily query how the field variable is used etc> > coupling appears also in the import section  static methods are visible> there and modern ide usually highlight this intellij even have a warning> if import section is too big just as theres warning if theres too many> fields this point should not be the reason to avoid static methods> > maintainability of procedural code static methods that consume static> methods that consume static methods> > ## having instance methods does not protect again procedural code> > i believe theres middle ground there :> >    -> >    mockito project contains a lot of small utility stateless objects that>    are supporting mockito features these are usually collections tools>    reflection tools those could are good candidate for static methods>    objects like fieldsetter fieldcopier lenientcopytool could be nice>    candidate for static methods>    -> >    mockito features could be backed by object instances objects like>    mockitocore mockcreationvalidator argumentmatchingtool are candidate>    to stay objects> > —> you are receiving this because you modified the open/close state> reply to this email directly view it on github>  or mute the thread>   || this feels like a misuse of the default methods || i think you mean static-methods in interfaces here? default-methods require an instance to be called onanyway i dont think that it is a good idea  it would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods imho a class with private constructor is the best construct to do this || > > thought: when we switch to java 8 we can use interfaces with default> > methods> > default-methods require an instance to be called oni was thinking exactly that default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface) || @christianschwarz what do you think to continue the work here with the middle ground described [here]( ? || i am attempting to refactor the matcherbinder class to a static utility class and am having trouble refactoring the following from mockhandlerimpltestjava: `handlermatchersbinder  new matchersbinder() {            public invocationmatcher bindmatchers(argumentmatcherstorage argumentmatcherstorage invocation invocation) {                throw new invaliduseofmatchersexception()            }} `how can i maintain the abstract class definition when i am not able to create an object of matcherbinder?any help is appreciated!  || lets close this ticket refactorings can be done as needed as we work with the code || ";1;0;unified decamelizer stringjoiner and removefirstline in stringutil;
920;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added subproject for configuration-free inline mock making.;added a preconfiguration for using the inline mock maker as a convenience artifact that can be included instead of creating the plugin file. this is very helpful when creating multi-module projects where the mock maker file has to repeated many times.;;0;issue with interpretation of @nullable for parameters; upgrading my toolset to using findbugs 200 now is identifyng erros because of the use of the @﻿nullable on the parameter of this interfacefrom my reading of the annotation meaning and the javadoc for the functionapply() function they seem in conflictmy understanding of @﻿nullable as a parameter is ""an element annotated with @﻿nullable claims the null value is perfectly valid to return (for methods) pass to (for parameters) and hold (for local variables and fields)"" - from   to me this means that the method with a nullable parameter should handle a null input cleanly and not npe because of itthe functionapply() is documented as ""    throws:      nullpointerexception - if input is null and this function does not accept null arguments"" which seems to mean that the contract for the method in fact not in accordance with what @﻿nullable would mean for the parameter  i wrote my functions based on the allowed npe behavior being oki have static private anonymous uses of function that i know are npe safe because i know i pass non nulls so i dont do any assert level checking or have null input handling  now with the newest findbugs it is identifying potential npe problems herei dont want to add warning suppression for finbugs np errors that would be a pattern that i dont want new people on my project to see and copy wrongly  i think that the root of the problem however is the @﻿nullable in the function interface definition and unfortunately from the definition of these annotations i cannot override this setting either in my implementations of the interface<b>what steps will reproduce the problem?</b><b>1</b><b>2</b><b>3</b><b>what is the expected output? what do you see instead?</b><b>what version of the product are you using? on what operating system?</b><b>please provide any additional information below</b>"; > possibly we luck out because we happen to call checknotnullthis doesnt work for me findbugs still complains when it encounters checknotnull that ""this parameter is always used in a way that requires it to be nonnull but the parameter is explicitly annotated as being nullable either the use of the parameter or the annotation is wrong"" || ";;;;0;1;;
920;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added subproject for configuration-free inline mock making.;added a preconfiguration for using the inline mock maker as a convenience artifact that can be included instead of creating the plugin file. this is very helpful when creating multi-module projects where the mock maker file has to repeated many times.;;0;added subproject for configuration-free inline mock making;added a preconfiguration for using the inline mock maker as a convenience artifact that can be included instead of creating the plugin file this is very helpful when creating multi-module projects where the mock maker file has to repeated many timesonce we choose to change the mock maker to be default or enable programmatic access we can decide to drop this artifact similar to `mockito-all` from version one; merging 920 ;;;;1;1;added subproject for configuration-free inline mock making;
920;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added subproject for configuration-free inline mock making.;added a preconfiguration for using the inline mock maker as a convenience artifact that can be included instead of creating the plugin file. this is very helpful when creating multi-module projects where the mock maker file has to repeated many times.;;0;fix hash distributed aggregations;split distribution strategy and output buffer partition strategy;;;;;1;1;fix hash distributed aggregationssplit distribution strategy and output buffer partition strategy;
920;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added subproject for configuration-free inline mock making.;added a preconfiguration for using the inline mock maker as a convenience artifact that can be included instead of creating the plugin file. this is very helpful when creating multi-module projects where the mock maker file has to repeated many times.;;0;delete deprecated onsubscribestart that doesnt work;- its messy to make this work so deleting it instead- better to move forward in the 017 release than try and make this work for the very small percentage (probably only netflix) that uses it;#860 ;;;;1;1;delete deprecated onsubscribestart that doesnt work- its messy to make this work so deleting it instead- better to move forward in the 017 release than try and make this work for the very small percentage (probably only netflix) that uses it;
923;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;smartprintertest tostirng() calls;calling  tostirng()  on a string just returns the same instance  making;;0;`mediatypeparse(string)` is very strict wrt parameter separators;j@ said method requires exactly a single space character after the semicolon that follows the type and subtype can this be backed up with some specs?multiple spaces may occur in folded e-mail headers (ie lines separated  \r\n` and lines after the first one are indented with spaces and/or tabulator characters) and even java mails `mimeutilityunfold`&nbspocassionally leaves more than a single space in front of the parameters (not to mention that a `mimemessage`&nbspinstance doesnt unfold header[ value]s themselves in the first place likely for a good reason though)can and should parsing be slightly more lenient?just for the record: my comparison object is java mails `contenttype` as thats what im trying to replace with `mediatype`&nbspwhereever possible of course the focus is slightly different but im pretty sure that class is what many people use even outside the context of e-mail; ;;;;0;1;;
923;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;smartprintertest tostirng() calls;calling  tostirng()  on a string just returns the same instance  making;;0;smartprintertest tostirng() calls;calling `tostirng()` on a string just returns the same instance makingthis call quite uselessthis patch removes those calls in order to clean up the code a bit;;;;;1;1;smartprintertest tostirng() callscalling tostirng() on a string just returns the same instance makingthis call quite uselessthis patch removes those calls in order to clean up the code a bit;
923;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;smartprintertest tostirng() calls;calling  tostirng()  on a string just returns the same instance  making;;0;fix json_array_get throws npe;;;;;;0;1;;
923;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;smartprintertest tostirng() calls;calling  tostirng()  on a string just returns the same instance  making;;0;observable creation from subscriber[t]>unit for scala;this pr adds the `subscriber` type and `observableapply[t](subscriber[t] > unit)`additionally i made some tweaks in `rxscalademo` and i could remove all comments of the kind `todo something behaves weirdly here` because now the weird behavior was gone seems like there was some progress in rxjava core :-)sorry that this pr mixes several topics let me know if you want me to split it by topic/cc @headinthebox @vjovanov;"#863  #864 > seems like there was some progress in rxjava core :-)good to hear :-) || is this intended as fixes for the 0170 release candidate or for 0171?  || looking at this made me wonder why we deprecate `public final static <t> observable<t> create(final onsubscribefunc<t> f) {}``observablecreate(observer > subscription)` is a common case when you hook up to event-based apis deprecating the above overload will force me to basically repeat the implementation:`public void call(subscriber<? super t> observer) {                subscription s  fonsubscribe(observer)                if (s ! null && s ! observer) {                    observeradd(s)                }            }` || what use case are you referring to? || like this:```def mousedrag: observable[mouseevent]  observablecreate(observer > {        val handler  eventhandler[mouseevent](m > {         observeronnext(m)        })        targetaddeventhandler(mouseeventmouse_dragged handler)        subscription {          targetremoveeventhandler(mouseeventmouse_dragged handler)        }      })``` || it would just be like this where the `subscription` is registered instead of returned:``` scaladef mousedrag: observable[mouseevent]  observablecreate(subscriber > {        val handler  eventhandler[mouseevent](m > {         subscriberonnext(m)        })        targetaddeventhandler(mouseeventmouse_dragged handler)        subscriberadd( {          targetremoveeventhandler(mouseeventmouse_dragged handler)        })      })```if we do decide we want an overload it wont be the `onsubscribefunc` overload which is the wrong name it makes no sense to have `onsubscribe` as the `subscriber -> unit` version and `onsubscribefunc` as the `observer -> subscription` one || that looks so imperative to me  || dont fully understand your comment about the overloads java can handle overloading both`subscription create(action<subscriber<t>>)` and `subscription create(func<observer<t>subscription)`right? || not sure why being ""imperative"" is such a big deal here:``` scalasubscriberadd( {    targetremoveeventhandler(mouseeventmouse_dragged handler)})```versus```subscription {     targetremoveeventhandler(mouseeventmouse_dragged handler)}``` but i can understand a preference one direction versus the other ---updated  by the way we have lots of operators where it is ""imperative"" on the inside while ""functional"" on the outside thats part of the nature of rxjava residing on an imperative platform so i dont see this as being an issue || this is the current signature:``` javapublic final static <t> observable<t> create(onsubscribe<t> f)```and `onsubscribe` is defined as:``` javapublic static interface onsubscribe<t> extends action1<subscriber<? super t>>``` || thus with overloads youd end up with two things looking exactly the same:``` javapublic final static <t> observable<t> create(onsubscribe<t> f)public final static <t> observable<t> create(onothersubscribe<t> f)```their types would be:``` javapublic static interface onsubscribe<t> extends action1<subscriber<? super t>>public static interface onothersubscribe<t> extends func1<observer<? super t> subscription>``` || isnt `onothersubscribe` already `onsubscribefunc`? hence`public final static <t> observable<t> create(onsubscribefunc<t> f)`looks fine with me (and it avoid breaking all existing explanations/articles about rx that use the _legacy_ signature ) || yes and were killing it because the name is wrong (and we intended on having only a single `create` method) we named `onsubscribe` what we did purposefully as `onsubscribefunc` was going away were not going to have two methods with different signatures with basically the same name || ???? ""were not going to have two methods with different signatures with basically the same name"" isnt that the very definition of overloading? || not when they are exactly the same :-)put these two next to each other without reading the docs which one should i use?``` javapublic final static <t> observable<t> create(onsubscribe<t> f)public final static <t> observable<t> create(onsubscribefunc<t> f)``` || that does not bother me just as `add(intint)` vs `add(longlong)` of course it would be simpler if the aliases `onsubscribe` and `onothersubscribe` were not needed and we could just have```public final static <t> observable<t> create(action1<subscriber<? super t>> f)public final static <t> observable<t> create(func1<observer<? super t> subscription> f)``` || the `int` and `long` examples are not good ones as those are primitive types that are clear in their types and all languages can disambiguate between themhaving both an `action` and a `function` as overloads causes problems for dynamic languages the reason the `onsubscribefunc` behavior has those null checks is because to make groovy work during the deprecation phase we had to write a plugin for groovy that forces all executions against `create` to use the new one and then we look for a return value and if we got one behave one way or behave the other if we got null back >  for the aliases they  because of the complexity of co/contr-variant generics that people must deal with every time they use `create`if we were to give up on ease of use for that problem and on the challenges of dynamic languages disambiguating between the overloads then yes the `action` and `func` overloads work well:``` java    public final static <t> observable<t> create(action1<subscriber<? super t>> f) {        return new observable<t>(f)    }    public final static <t> observable<t> create(final func1<observer<? super t> subscription> f) {        return new observable<t>(new action1<subscriber<? super t>>() {            @override            public void call(subscriber<? super t> subscriber) {                subscription s  fcall(subscriber)                if (s ! null && s ! subscriber) {                    subscriberadd(s)                }            }        })    }``` || another consideration  my understanding of the event listeners on `android` and `swing` are that they typically need to be far more involved that this example anyways due to thread scheduling logic for example take a look at this code:  99 uses `subscriberadd`:  that `subscription` instead of using `add` does not seem to significantly alter the fact that inside a function a lot of often imperative behavior happensalso common event listeners end up with cover libraries such as `rxjava-android` and `rxjava-swing` because they are non-trivial and need to just be done correctly oncetherefore i dont think the need of an overload is worth confusing the api by having two different ways of doing things with nuanced differences between them (how they behave with synchronous sources) for example in the version with `subscriber` passed in a `subscription` can be registered at the beginning so even if the rest of the function is synchronous and never returns the `subscription` is registered and will still work i think its better to have a single mechanism for `create` that pushes people to using the model in a way that works for both `sync` and `async` sources the side-benefit is we dont have ambiguous methods or generics issues as we can stick with the `onsubscribe` cover type we have || > is this intended as fixes for the 0170 release candidate or for 0171? id say 0170 the earlier people can use it the better -)fyi this pr has no breaking changes || ";;;;1;1;deprecate rxlangscalaobservablecreate[t](observer[t]>subscription);
926;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;key bindings are now working in preview panel;649. until now the toolbar within the preview panel held the key bindings which weren t active when the toolbar wasn t created. now the preview panel itself carries the key bindings. -  ? -   -  ? -  ?;;0;implement an optionalfunction that would allow for a chain-of-responsibility pattern; public interface optionalfunction&ltt u>{&nbsp&nbsp&nbsp&nbspoptional<? extends u> apply(t)}this would allow for:public static &lttu> optional<? extends u> findfirst(t value iterable&ltoptionalfuntion&lttu>> handlers)the implementation would iterate through the handlers passing the value until a handler returns a non-absent value and then returns this value if no non-absent value returned absent is returnedpublic static &lttu> u findfirst(t value iterable&ltoptionalfuntion&lttu>> handlers u defaultvalue); the workaround in comment 3 seems acceptable  if this interface could support all chain-of-responsibility users this method would be a better candidate for inclusion but there will always be edge cases:  do the functions need 0 1 or 2+ inputs?  are the functions easily traversable as an iterable or are we following parent-component links in a gui library?  do the functions implement function or is there a custom event-handler class?  is it permissible for more than one handler to take action (eg a mouse moves onto a window and over a button and the window takes focus while the button lights up)?  is the action taken ""return a value"" or something with side effects?  we can write adapters for most of these but the adapters would require more code than it would take to rewrite the method  this is i suppose the reason that chain of responsibility is a pattern rather than a single library--- ;;;;0;1;;
926;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;key bindings are now working in preview panel;649. until now the toolbar within the preview panel held the key bindings which weren t active when the toolbar wasn t created. now the preview panel itself carries the key bindings. -  ? -   -  ? -  ?;;0;remove string concatination inside an append call;concatinating strings creates a temporary stringbuilder which is thenconverted to a string having such an argument inside astringbuilder#append call thus pointless using a chained append callwill have the exact same outcome and would profit a slight [probablyunnoticeable in this instance] performance benefit; merging 926  - ;;;;1;1;remove string concatination inside an append callconcatinating strings creates a temporary stringbuilder which is thenconverted to a string having such an argument inside astringbuilder#append call thus pointless using a chained append callwill have the exact same outcome and would profit a slight [probablyunnoticeable in this instance] performance benefit;
926;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;key bindings are now working in preview panel;649. until now the toolbar within the preview panel held the key bindings which weren t active when the toolbar wasn t created. now the preview panel itself carries the key bindings. -  ? -   -  ? -  ?;;0;full support for distinct in aggregations;- change hash partitioning to support multiple channels- add operator to mark rows that are unique on a set of fields- add support in aggregations for masking out certain rows and use this with the mark operator to implement distinct for all aggregations;this needs more tests for different plan types including group by where clause ordering window functions we can discuss this tomorrow || id like to see this after the changes  also @erichwang can you review the planner changes? || ok i think i addressed everyones comments let me know if you spot anything else || other than the comments the execution bits look good to me@erichwang and @electrum can you take a look at the planning bits and maybe give the code a quick once over? || a few ideas for optimizations we can do later:- coalesce consecutive markdistinct nodes on the same set of symbols - remove aggregationnodes with no aggregation functions (this is how we plan a select distinct) followed by markdistinct- plan select distinct using a markdistinct node and add support for the mask channel to projections filter sort etc || i think it already coalesces mark distinct on the same symbols thats what the argumentmarkers map in queryplanner is for or is there another way that we could end up with two markdistinct nodes that do the same thing? || ok i think i addressed everyones latest round of comments || other than the one minor change and the part that determines if a subplan is already partitioned correctly (which martin and/or eric should look at) this  make sure to also test that you can do an explain query as well as print the graphviz stuff in planprinterjava || you also need to add something to the limitpushdown optimizer for markdistinctnodethe optimizers currently sometimes have default behavior for unmentioned nodes but we really should be getting rid of that and force every node to be explicitly mentioned in each optimizer || ok i addressed all @erichwang s comments thanks for catching the optimizer and plan printer stuff! let me know if theres anything else || other than the above comments this ;;;;0;1;;
926;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;key bindings are now working in preview panel;649. until now the toolbar within the preview panel held the key bindings which weren t active when the toolbar wasn t created. now the preview panel itself carries the key bindings. -  ? -   -  ? -  ?;;0;testsubscriber: default onerror and terminal latch behavior;;;;;;1;1;testsubscriber: default onerror and terminal latch behavior;
928;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fix whitespace issues throughout the code;this patch applies de-facto standards the codebsae currently has regarding whitespaces on all the java files in the project:;;0;binary encodings (base 64 32 16 etc); encoding and decoding base64 and hex are such extremely common tasks that it seems like they should be in guava  needing an extra dependency on commons-codec just for base64 or hex feels wrong; _issue #1363 has been merged into this issue_ || ";;;;0;1;;
928;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fix whitespace issues throughout the code;this patch applies de-facto standards the codebsae currently has regarding whitespaces on all the java files in the project:;;0;fix whitespace issues throughout the code;this patch applies de-facto standards the codebsae currently has regarding whitespaces on all the java files in the project:- newlines were added at the end of files that didnt have them- whitespaces at the end of source lines were removedall these changes were done by running `sed` on the codebase the exact details can be found in the individual commit messages; merging 928 !could you open a new pr after this one with the checkstyle config? we can continue the discussion there regarding the rules we want to enforce and how thanks for your time and effort! || @timvdlippe agreed ill open a new pr for the checkstyle stuff after this one is merged so i can easily rebase on top of it@szczepiq sure ill take a look at #685 - looks interesting || great work! we discussed it on slack clean whitespace / checkstyle will help with git workflows for cleaner history@timvdlippe do we want this also in release/2x for easier merges? || @szczepiq i am cherry-picking it into release/2x atm ||;;;;1;1;"remove whitespaces at the end of source linesthis patch takes the de-facto standard of not having any whitespacesat the end of source lines and applies it to all the source files inthe projectbesides improving standardization another contributing considerationis the fact that many editors/ides remove such whitespaces at end oflines using such an ide will remove these whitespaces in the editedfile adding ""noise"" to the patch and confusing potential reviewersby explicitly removing all of them in a single patch this problem canbe avoidedthese changes were done automatically by applying the following shellcommand:$ find  -name ""*java"" -exec sed -i s/[ \t]*$// {} \";
928;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fix whitespace issues throughout the code;this patch applies de-facto standards the codebsae currently has regarding whitespaces on all the java files in the project:;;0;bound the total number of threads used by hiveclient;;;;;;0;1;;
928;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fix whitespace issues throughout the code;this patch applies de-facto standards the codebsae currently has regarding whitespaces on all the java files in the project:;;0;fix deadlock in subscribeonbounded;swap the subscription and the scheduling of pass-through to allow progress of a bounded synchronous source;#868  merging but `subscribeonbounded` will likely be deleted as a result of work in  ||;;;;1;1;fix deadlock in subscribeonbounded;
933;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;test for encrypted pdf does not throw an exception;i don t know if this sufficies the requirements  but for me it does not throw the strange exception.;;0;allow functionsconstantfunction to use a templated input type as well as a templated output type; the current implementation of functionsconstantfunction assumes that the input type of the function is object this makes for ugly casting and/or warning suppressions throughout code if your input type is not object attached is an slightly modified implementation that uses two type variables for the class definition also included are the same tests used for the existing constantfunction implementation to verify it still behaves the same way; thats exactly why we used functionsconstant() to begin withideal readability it works fine too i didnt mean to imply it didnt its just a question of whether the casts should be necessary and that seems to boil down to tastes || ";;;;0;1;;
933;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;test for encrypted pdf does not throw an exception;i don t know if this sufficies the requirements  but for me it does not throw the strange exception.;;0;add 056 release notes;; id also mention that inner joins that result in cross joins due to the join criteria evaluating to constant true are also now supported ||;;;;1;1;add 056 release notes;
933;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;test for encrypted pdf does not throw an exception;i don t know if this sufficies the requirements  but for me it does not throw the strange exception.;;0;implemented skip using lift in observable and operatorskip;deleted non-time part from operationskipmoved tests to operatorskiptest;following template of operatorfilter || #872  and add unit tests to expose all the above as well as boundary conditions such as n-1 n0 empty stream stream with exceptions  (ill add some more unit tests as i address the issues) ||;;;;0;1;;
933;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;test for encrypted pdf does not throw an exception;i don t know if this sufficies the requirements  but for me it does not throw the strange exception.;;927.0;support for return type void in doesnothinganswer;927 this pr allows to use `donothing()` for methods with return type `javalangvoid` like void-methods  to solve this `invocationinfoisvoid()` checks now the return type for the pseudo-type of the keyword `void` or `void`;   no coverage uploaded for pull request base  ;mockito cant unbox void;hithe following [bug]( was created for powermock:  > powermockito doesnt seem to unbox javalangvoid> i am writing a test for my code that uses google cloud storage api to delete a file google api returns void for deleting a file code works fine but when i instruct my test as powermockitodonothing()when(delete)execute() it complains that execute has a return value of voidbut powermock just delegates call to mockito in this case and mockito throws exception: ```orgmockitoexceptionsbasemockitoexception: only void methods can donothing()!example of correct use of donothing():    donothing()    dothrow(new runtimeexception())    when(mock)somevoidmethod()above means:somevoidmethod() does nothing the 1st time but throws an exception the 2nd time is called```i have doubts about expected behaviour for one side method return something but it return a `void` which always is just `void` and nothing could be changed anyway it could be  only on mockito side (without dirty hacks);;1;0;merge branch release/2x into answer_do_nothing;
935;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;new feature - enable mocking using constructor arguments;## motivation and design - see #685;;0;optionalof(t) to be changed to optionalof(? extends t);m@jakub- similarly to optionalor(optional<? extends t> secondchoice) optionalof(t) should probably accept an extended t otherwise if i have an interface:interface someinterface {}and implementation:public class someinterfaceimpl implements someinterface {}declaring a variable as:optional&ltsomeinteface> option  optionalof(new someinterfaceimpl())does not compile and i have to do a cast:optional&ltsomeinteface> option  optionalof((someinterface) new someinterfaceimpl())unless there is some reason for this behaviour in which case i apologise for raising this up it would be nice not to have to do the cast; man i remember this now yuck  ";;;;0;1;;
935;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;new feature - enable mocking using constructor arguments;## motivation and design - see #685;;0;guarantee that semaphore is always released;;934  || other then the one comment ;;;;1;1;guarantee that semaphore is always released;
935;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;new feature - enable mocking using constructor arguments;## motivation and design - see #685;;0;non-deterministic test abstractschedulerconcurrencyteststestunsubscribeforscheduler;ci reported a pull request build failure below that was unrelated to the pull request but rather from a non-deterministic unit test abstractschedulerconcurrencyteststestunsubscribeforschedulerci report: increasing the latchawait timeout on line 88 or removing the timeout;i have seen similar failures many times in the cloudbee however its hard to change them to be deterministic || depends on the test ive looked around the test codebase and latchawait() is used without a timeout in many places in theory dropping the timeout could mean that a test never finishes if a commit busts something but jenkins can be configured to fail a build if it takes say 50% longer than normal i dont know if the netflix jenkins ci is configured this way for the pull requests job but might be worthwhile if it is configured in this way i wouldnt mind seeing the timeout dropped from tests that are generally stable (ignoring the timeout problem) || schedulers have been changed significantly and i havent seen these failures in a while so closing out this is a non-deterministic issue though so if it comes back we can re-open or start a new issue ||;;;;0;1;;
935;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;new feature - enable mocking using constructor arguments;## motivation and design - see #685;;685.0;new feature - enable mocking using constructor arguments;## motivation and design - see #685to quote the requirement (see in-depth design in #685):> we already support spying on abstract classes by allowingparameterless constructor however there is no support forconstructor parametersthis has been asked about long time ago mockito api is not robustenough if it supports mocking with constructor but not when one hasany constructor parametersthis patch enhances the `mocksettings#useconstrctor()` method (as suggested in the alternative api comment in the issue) and addsoptional ellipsis arguments that are passed to the constructorthe patch streamlines the creation of mocks via constructors to asingle flow where using a no-arg constructor or an enclosing classare just private cases of this flow and dont require their ownspecial treatment;wow! thank you for swift contribution! i will review once i have a bandwidth || apologies the previous push had a couple of failing tests due to a missed file ive updated it and it should work now ||  merging 935 ;support constructor parameters for spying on abstract classes;"nice self-contained enhancement that makes mockito api more robust the implementation does not require proficiency with mockito codebase### featurewe already support spying on abstract classes by allowing parameterless constructor however there is no support for constructor parameters this has been asked about long time ago mockito api is not robust enough if it supports mocking with constructor **but** not when one has any constructor parameters``` java//current api:foo spy  mock(fooclass withsettings() useconstructor()defaultanswer(calls_real_methods))//existing method (will remain):mocksettings useconstructor()//new api (change existing method):foo spy  mock(fooclass withsettings() useconstructor(""somearg"")defaultanswer(calls_real_methods))//changed method:mocksettings useconstructorargs(object  args)```### open questions- in case we find multiple matching constructors do we just use the 1st matching (option 1) or throw an exception (option 2)?id say we go for option 1 because its simpler to implement and seems more convenient (works out of the box for certain use cases) if we go for option 2 we need to inform the user what to do to resolve the problem (for example document and suggest @fluentfuture idea of creating an inner implementation)- do we add new method or add vararg to existing useconstructor() method?we decided that using existing method is simpler keeps the api small and is easy to discover### implementation notes- the main complexity is to identify and detect the right constructor to use based on types of parameters supplied by the user- we already deal with detecting constructors for the @injectmocks functionality - there should be code to reuse### test coverage- see existing tests that cover ""useconstructor"" method for- ensure decent informative exception messages  - if user supplies wrong constructor args (wrong types we cannot find matching constructor)  - if the constructor throws some exception (constructors of some types have code that can fail)  - when one uses existing parameter-less ""useconstructor"" method but the mocked class requires constructor args the exception message should tell the user about new ""useconstructorargs"" method- what if arguments supplied by the user match more than 1 constructor - either we fail gracefully with decent message or we pick one of the constructors- update documentation to describe new feature update documentation for existing parameter-less ""useconstructor"" method update documentation in main mockito class if it references “useconstructor”- other use cases?";ive thought about some variant of this feature for a while so heres some feedbackitd be nice if we have some concrete use cases to studyin my own experience i have mostly managed to avoid needing this feature by spying non-static abstract classfor example if the abstract class im spying on needs two constructor parameters i do this:```javapublic class footest {  @spy private mockabstractfoo foo  private final bar bar    private baz baz() {}  abstract class mockabstractfoo extends abstractfoo {    mockabstractfoo() {      super(bar baz())    }  }}```fwiw:1 this is static type safe and refactoring friendly so i find it preferable when it meets my needs2 the constructor can use instance fields or instance methods of the enclosing test object3 the main drawback is that you cant easily construct difference instances with different constructor parameters on the other hand i strive to keep my abstract classes stateless so i rarely need to pass constructor parameters anyway || i forgot to mention that it is possible with todays api to pass different constructor parameters through mocksettings like the following:```javaclass mockfoofactory {  private final bar bar  private final baz baz  mockfoofactory(bar bar baz baz) {}  public abstractfoo create() {    return mockitomock(mockfooclass withsettings()        useconstructor()outerinstance(this)defaultanswer(calls_read_methods))  }  abstract class mockfoo extends abstractfoo {    mockfoo() {      super(bar baz)    }  }}```then just call it with:```javanew mockfoofactory(bar baz)create()```again this is static type safe and ide friendly compared to reflection-based apithe `withsettings()` thing has a bit of discoverability problem and i suppose not many people know they can do this alternatively i would love to have a simpler api like:```javamockitospy(outerinstance mockfooclass)``` || i think that overloading `useconstructor()` is a much cleaner approach than adding a new `useconstructorargs(object)` methodit also makes the method much easier to discover as its right there and the users ide will offer the argument listive coded this approach in pr #935 feedback is more than welcome! || agreed that ```usecontructor(args)``` reads nicerpersonally im not convinced that the dynamic type support is worth the effort it seems to be a slippery slope toward defeating java static type safety which reminds me of the ancient jmock vs easymock comparison where the former relied on type-less reflection while the latter is static type safe if java doesnt allow you to call `new foo(object object)` does mockito have to open that back door (when the enclosing class trick could be used to achieve the goal albeit slightly indirectly)?that said if you do decide to add this feature there are a few implementation caveats that we need to be careful about:* overload resolution its not hard to imagine passing an arg whose static type suggests constructor overload1 to be invoked but the runtime type actually invokes overload2 in other words `new foo(a b) {}` and `useconstructor(a b)` result in different constructor being invoked* generics there is no way to verify that the passed in `list<something>` is actually a `list<string>` even at runtime risking unchecked type errors* visibility what happens if the constructor has both public constructor and package-private constructor both could have been chosen for the given args? || i happened to need to dig up the history of @spy abstractclass in #106 and i found that all my concerns against constructor-args were already stated in that thread and it was clear that @szczepiq is fine with the trade-offso while i disagree with the design decision my apologies for repeating myself over again :) || thank you very much for contribution its really nice work! ||;1;0;685: ability to mock constructors with argsto quote the requirement:we already support spying on abstract classes by allowingparameterless constructor however there is no support forconstructor parametersthis has been asked about long time ago mockito api is not robustenough if it supports mocking with constructor but not when one hasany constructor parametersthis patch enhances the mocksettings#useconstrctor() method and addsoptional ellipsis arguments that are passed to the constructorthe patch streamlines the creation of mocks via constructors to asingle flow where using a no-arg constructor or an enclosing classare just private cases of this flow and dont require their ownspecial treatment;
942;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;allow spying on interfaces so that it is convenient to work with java 8 default methods;680;;0;sortedmultisetelementset should return navigableset; related to issue 664  id prefer not to go down the route of the jdk in having separate sorted/navigable interfaces but id like sortedmultisetelementset to return navigablesetwould this break anyones code?  how can we migrate users?; ;;;;0;1;;
942;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;allow spying on interfaces so that it is convenient to work with java 8 default methods;680;;0;specify canonical page url;;;;;;1;1;specify canonical page url;
942;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;allow spying on interfaces so that it is convenient to work with java 8 default methods;680;;0;mathobservable;moving the average/sum/min/max functionality to the mathobservable similar to stringobservablesimilar to the rxjava-string module this is seeking to achieve the goal of keeping rxjava-core focused on core functionality;"#879  hi being a fan of method chaining id like to see more operator implementations of for example the math operations and many more moreover id like to have an idiom tested and confirmed by you experts to do this easily for my own stuff to that end do you think it would be of value to include in the library something like the class below? one possibility would be to add the tooperator static method to the observable class``` javaimport rxobservableimport rxobservableoperatorimport rxsubscriberimport rxfunctionsfunc1import rxsubjectspublishsubject/** * converts an operation (a function converting one observable into another) * into an {@link operator} *  * @param <r> *            to type * @param <t> *            from type */public class operatorfromoperation<r t> implements operator<r t> {    public static <r t> operator<r t> tooperator(func1<observable<t> observable<r>> operation) {        return new operatorfromoperation<r t>(operation)    }    /**     * the operation to convert     */    private final func1<observable<t> observable<r>> operation    /**     * constructor     *      * @param operation     *            to be converted into {@link operator}     */    public operatorfromoperation(func1<observable<t> observable<r>> operation) {        thisoperation  operation    }    @override    public subscriber<? super t> call(subscriber<? super r> subscriber) {        final publishsubject<t> subject  publishsubjectcreate()        subscriber<t> result  createsubscriber(subject)        subscriberadd(result)        operationcall(subject)subscribe(subscriber)        return result    }    /**     * creates a subscriber that passes all events on to the subject     *      * @param subject     *            receives all events     * @return     */    private static <t> subscriber<t> createsubscriber(final publishsubject<t> subject) {        return new subscriber<t>() {            @override            public void oncompleted() {                subjectoncompleted()            }            @override            public void onerror(throwable e) {                subjectonerror(e)            }            @override            public void onnext(t t) {                subjectonnext(t)            }        }    }}``` || what could you do with operation that couldnt be done with `map(func1<t r>)` or `flatmap(func1<t observable<r>>)`? || an operation acts upon the observable as a whole not on the individualitems like map and flatmap do  for example map and flatmap themselvescould be considered as operations/operatorson 9 mar 2014 04:41 ""george campbell"" notifications@githubcom wrote:> what could you do with operation that couldnt be done with map(func1<t> r>) or flatmap(func1<t observable<r>>)?> > ## > > reply to this email directly or view it on github  || i dont understand what use cases are trying to be solved by that code can you provide some examples please? || so for instance if i want to use suminteger in the middle of a chain ofmethod calls i need to use lift so i need an operator form of it i make an operator form of it by implementing a call to suminteger in afunc1<observable<integer>observable<integer>> and then calltooperator(func) as described in my example to give me an operator  iwould prefer if there were operator forms of all the static observablemethods i suppose but it least this conversion was part of the codebasethat would make life easieri should mention that method chained calls are important to me because thefunctional attractiveness of rxjava is weakened significantly every time ihave to break the chain with some wrapper call in communicating theelegance of rxjava to my colleagues my case is weakened by those breaks inthe chain im a big fan of lift for this reasonim still new to rxjava so let me know if im missing something obviousherecheersdaveon 11 march 2014 03:26 ben christensen notifications@githubcom wrote:> i dont understand what use cases are trying to be solved by that code> can you provide some examples please?> > ## > > reply to this email directly or view it on github  || to add an explicit example ive found the method rxutiltooperator asdescribed above useful when i want to use an operation like suminteger inan operator form with lift()  to use it i write: private final operator<integerinteger> sum_integer     rxutiltooperator(new func1<observable<integer>observable<integer>>() {@overridepublic observable<integer> call(observable<integer> source) {return mathobservablesuminteger(source)}})then i can write:observablefrom(aslist(123))lift(sum_integer)on 11 march 2014 08:07 dave moten davidmoten@gmailcom wrote:> so for instance if i want to use suminteger in the middle of a chain of> method calls i need to use lift so i need an operator form of it> >  i make an operator form of it by implementing a call to suminteger in a> func1<observable<integer>observable<integer>> and then call> tooperator(func) as described in my example to give me an operator  i> would prefer if there were operator forms of all the static observable> methods i suppose but it least this conversion was part of the codebase> that would make life easier> > i should mention that method chained calls are important to me because the> functional attractiveness of rxjava is weakened significantly every time i> have to break the chain with some wrapper call in communicating the> elegance of rxjava to my colleagues my case is weakened by those breaks in> the chain im a big fan of lift for this reason> > im still new to rxjava so let me know if im missing something obvious> here> cheers> dave> > on 11 march 2014 03:26 ben christensen notifications@githubcom wrote:> > > i dont understand what use cases are trying to be solved by that code> > can you provide some examples please?> > > > ## > > > > reply to this email directly or view it on github >  || i think perhaps i should simplify my original question suppose i have astatic function likepublic static <rt> observable<t> something(observable<r> source) {    //anything here of course    return sourcemap(sometransform)retry()take(100)}what is the simplest way to make an operator out of it so that i can use itwith lift()? if the answer is longer than the tooperator method usage thatim proposing then id be interested in having tooperator in the libraryon 12 march 2014 11:35 dave moten davidmoten@gmailcom wrote:> to add an explicit example ive found the method rxutiltooperator as> described above useful when i want to use an operation like suminteger in> an operator form with lift()  to use it i write:> >  private final operator<integerinteger> sum_integer >     rxutiltooperator(new> func1<observable<integer>observable<integer>>() {>  @override> public observable<integer> call(observable<integer> source) {>  return mathobservablesuminteger(source)> }})> then i can write:> > observablefrom(aslist(123))lift(sum_integer)> > on 11 march 2014 08:07 dave moten davidmoten@gmailcom wrote:> > > so for instance if i want to use suminteger in the middle of a chain of> > method calls i need to use lift so i need an operator form of it> > > >  i make an operator form of it by implementing a call to suminteger in a> > func1<observable<integer>observable<integer>> and then call> > tooperator(func) as described in my example to give me an operator  i> > would prefer if there were operator forms of all the static observable> > methods i suppose but it least this conversion was part of the codebase> > that would make life easier> > > > i should mention that method chained calls are important to me because> > the functional attractiveness of rxjava is weakened significantly every> > time i have to break the chain with some wrapper call in communicating the> > elegance of rxjava to my colleagues my case is weakened by those breaks in> > the chain im a big fan of lift for this reason> > > > im still new to rxjava so let me know if im missing something obvious> > here> > cheers> > dave> > > > on 11 march 2014 03:26 ben christensen notifications@githubcom wrote:> > > > > i dont understand what use cases are trying to be solved by that code> > > can you provide some examples please?> > > > > > ## > > > > > > reply to this email directly or view it on github > >  || we should add an overload for lift that takes an observable > observable function very much like  this is on the todo list or you can try to build it yourself and submit a pull request note it should allow subscribing more than once in the lambda hence ""publish"" in net || > we should add an overload for lift that takes an observable > observable function +1 || ill make a pull request with the lift method overload as suggesteddaveon 13 march 2014 13:41 shixiong zhu notifications@githubcom wrote:> we should add an overload for lift that takes an observable > observable> function> > +1> > ## > > reply to this email directly or view it on github  || i think we already have that publish() method: [observablejava:5428]( which relies on operationmulticast if you could reimplement it to operatormulticast we would gain a lot of operators || im a bit lost about the reference to publish() method that started with headintheboxs comment i am not talking about adding a publish method i am talking about adding a tooperator method or overload on lift method that does the same thingdave || @benjchristensen what do you think about the addition of an overload for lift that takes a func1<observable<t>observable<r>>? should i go ahead with a pull request? || ";;;;1;1;math-modulemoving the average/sum/min/max functionality to the mathobservable similar to stringobservable;
942;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;allow spying on interfaces so that it is convenient to work with java 8 default methods;680;;680.0;allow spying on interfaces so that it is convenient to work with java 8 default methods;680; merging 942 ;allow spying on interfaces so that it is convenient to work with java 8 default methods;"## problemwhile mockito supports and stubs by default the _default methods_ in interfaces the stubbing code can be a bit non intuitive eg``` javainterface dm {    int contract()    default int default_contract() { return contract() + 1 }}dm dm  mock(dmclass)given(dmcontract())willreturn(2)// necessary otherwise default method is stubbedgiven(dmdefault_contract())willcallrealmethod()assertthat(dmdefault_contract())isequalto(3)```this behavior is unintuitive to users who expect the default methods to trigger real implementation (callrealmethod() by default) see also user report at #940## suggested plan  contributions are welcome!-  relax validation and allow interfaces to be spied this way users can invoke spy(someinterface) or use @spy with interfaces this way we dont need to mark default methods with ""callrealmethod""-  ensure test coverage for mocking  - interfaces with and without default methods  - concrete classes that extend interface with default methods (perhaps already covered)-  document this use case on main mockito javadoc the use can search for ""default"" and find information about default methods behavior suggested by user at #940-  create a separate ticket for mockito 3 (""2* incompatible"" label) to discuss whether we should change the default behavior for defender/default methods perhaps they should automatically call real method regardless if someone uses spy() or mock() with the interface also we should consider mocking/spying on concrete classes that extend from interface with default methods## discontinued ~~original plan~~below idea was discontinued:replace `dm`  map` `default_contract()`  getordefault()` `contract()`  get()` or `containskey()` and you have a problem with designs that are used in the jdk itselfi think mockito can improve on this by configuring the mock to invoke concrete default methods rather than stubbing them this could be done the following way (_api naming in progress_) : - `mock(dmclass use_default_methods)`    the issue with that approach is that a default answer is mutually exclusive with other answers eg if one wants to use `returns_smart_nulls` and default methods this cannot work with the current design- `mock(dmclass withsettings()usedefaultmethods())`    this approach is interesting as it allows to configure the behaviour with possibly any answer however this may require some changes with our internal answers not a deal breaker though";"> mock(dmclass withsettings()usedefaultmethods())i like that spydefaultmethods?btw whats better/more intuitive default for default methods? real method invocation or empty/unstubbed value? || i think that depends on the mocked type id say :- interface > use default methods by default- concrete > im not sure id rather not make those default`spydefaultmethod` is wrong because the primary objective is not to spy them || so potentially this is mockito 3 backwards incompatible change (when changing defaults) thanks for bringing this up! || for this thing only this could be potntially backward incompatible yet for this thing only im not yet sure we should change the default between 2x and 3x whatever the introduction or not of `usedefaultmethods` in `2x` im a bit undecided at that moment i may have a better opinion when the code is actually done right now the code base of mockito 2x runs java6 so we dont have java 8 tests mockito 3 (master) is java 8 and well introduce java 8 specific tests || makes perfect sensewe already have code in 2x that detects java 8 up to you how to push that further ) || if starting from scratch i couldnt think of a use case thatd benefit from stubbing the default methods by defaultbut maybe that use case does exist or at least for backward compatibility its too late to change?either way i propose we do not need to add a default answer or anything to mock() default methods in interfaces are much like concrete methods in abstract classes `spy(anabstractclassclass)` today already _by default_ invokes concrete methods unless they are explicitly stubbed it seems natural to me that we just relax the restriction on `spy(someinterfaceclass)` to accept interface as a parameter instead of throwing illegal usage exception as it does today || @fluentfuture can you elaborate on that : > it seems natural to me that we just relax the restriction on `spy(someinterfaceclass)` to accept interface as a parameter instead of throwing illegal usage exception as it does todayyes backward compatiblity is a primary concern yet if the change makes sense and doesnt impact users in a bad way it can be discussedalso maybe we could backport behavior and api from master to release/2x || suretoday if javautilconsumer were an abstract class defined as:```javapublic abstract class consumer<t> {  public consumer<t> andthen(consumer<? super t> that) {    return v -> {accept(v) thataccept(v)}  }  public abstract void accept(t value)}```i can `@spy` it to have `andthen()` called by default:```java@spy private final consumer<string> consumer1@spy private final consumer<string> consumer2@test public void testcompose() {  consumer1andthen(consumer2)accept(""hi"")  verify(consumer1)accept(""hi"")  verify(consumer2)accept(""hi"")}```it doesnt work with consumer being interface with `andthen()` being an equivalent default method:```javapublic interface consumer<t> {  default consumer<t> andthen(consumer<? super t> that) {    return v -> {accept(v) thataccept(v)}  }  void accept(t value)}```but that is just because we are having a validation that rejects spy(consumerclass) that validation can be removed because it doesnt hurt even if you spy(aninterfaceclass) and even if that interface has no default method because it will just work the same way as mock(aninterfaceclass)heres a [commit]( in my fork that removes the validation and the above test passesby the way i retract my suggestion to make `mock(aninterfaceclass)` to call default methods because then it would break the symmetry with `mock(anequivalentabstractclassclass)` which can be surprising || ah i seeimho spying an interface `spy(interfaceclass)` is wrong even when theres default methods it doesnt feel like a a spy as spy have more meaning to spy concrete codeinstead mocking an interface `mock(interfaceclass)` to call default methods only seems ok and maybe backward compatible although i would like opt-in/out mechanismbut mocking an abstract class `mock(anequivalentabstractclassclass)` should never call concrete code || i agree that the spy() name is kinda misleading for the behavior of ""mock only abstract methods""i originally proposed fake() or other names but spy() was chosen none-the-lessi dont defend the spy() name but its what we have so there may be some value to consistency || `spy` is a specialized mock that seems to _speak_ for everyone maybe `fake` can be another compelling specilizationat this moment not sure if we will but maybe in the future || heres how i found peace with the spy() name:yes it calls the non-abstract methods which isnt spying (more like fake) but it also allows you to explicitly stub them with `when()` or to `verify()` them so in that sense it can still be called a spy || regarding ""interface"" vs ""abstract class"" i personally think we should try not to be picky about the differencesome project scoped or company scoped apis out there arent designed to be implemented/subclassed directly by users for these apis going from an abstract class to interface or vice versa is reserved as an implementation detail changethe worst that should happen with changing abstract class to interface is that a handful of direct subclasses break compilation and need to be  to use the ""implements"" keyworditd be a much bigger burden if all the sudden a lot of tests that used to spy() on the abstract class fail just because of the abstract -> interface changespecifically now with java 8 id expect some abstract classes to become interfaces with default methods because the only reason they were abstract classes in the first place was to be able to have some default methods (for fluent chaining and stuff) || interesting feedback i still have mixed feeling about relaxing spy to allow an interfaceill sleep on it and think about it as your migration use case is legitimateand anyway this address only a part of the original issue || @bric3 can you explain which part isnt addressed in the original issue assuming we put aside the mock() vs spy() naming difference? || @fluentfuture i meant regarding configurability of stubbing default method for a mock not a spyyet the use cases discussed above are defintely additional scenario to account for when we will implement the stuff || @bric3 are you okay with allowing @spy on interfaces? if so ill send a pr || @fluentfuture yes i have worked on it in #906 but i wont have a computer near me for a week still || great discussion +1 to allow spying on interfaces-1 to adding new public api method like fake - it would make the api more complicated just for the sake of a single use case+ 05 to changing the default behavior of mockito 3 to spy interface defender methods by default this way it is the most intuitive behavior users expect see  || i attempted to update the ticket description to reflect the outcome of the discussion feel free to change if needed || if i were going to add another method i would call it `stub` based on [martin fowlers article describing the 3](  like `@incubating mockitospy( class<?> clazz )` more or less does what i expect ultimately finding that behavior though required quite a bit of researchwhether or not adding `mockitostub( class<?> clazz )` method would be worth it i cant say because i dont feel like im familiar enough with the underlying implementation/behavior to know how different `mock` and `spy` are if those are just configuration differences then its probably worth it if theres more to it maybe not if `stub` could `call_real_methods` but only work for `abstract` and `interface` and not be able to do `verify` that would make it different from a `spy` imoeither way more docs seem necessary i might try to put those together for #940  || i somehow missed this ticket mockito should imho follow the idea of defender methods and allow api-evolution without  breaking client code/test i other words if a class under test evolves and calls defender methods on a mocked interface the tests should not fail or should not be rewritten by replacing `@mock` with `@spy` or setting up special mocking settings like `withsettings()usedefaultmethods()`i think it is possibe to rewrite the `mock()` implementation to generate stubbed calls to default methods  without special mock settings  ```javapublic <t> t mock(class<t> type){    t mockmockito_coremock(type)    if (!typetomockisinterface())            return mock    for (method method : typetomockgetdeclaredmethods()) {        if (methodisdefault()) {            docallrealmethod()when(mock)            callwithanymatchers(mock method)        }    }    return mock}private static void callwithanymatchers(object mock method method) {    class<?> parametertypes  methodgetparametertypes()    list<object> defaultvalues  new arraylist<object>()    for (class<?> type : parametertypes) {            defaultvaluesadd(mockitoany(type))    }        try {        methodinvoke(mock defaultvaluestoarray())    } catch (exception e) {        throw new mockitoexception(egetmessage() e)    }}```this way clients can redefine the defender stubbings like overriding it in an implementation @bric3 @szczepiq @fluentfuture what do you think? || is it any different from api-evolution of abstract classes?in template-method pattern if the sut calls an abstract method and then later evolves to call a default method that indirectly calls the abstract method the exact same problem can happen no?this kind of evolution has always been possible and its not clear to me that the user always means to only stub/verify the abstract method sometimes the user may just want to stub/verify the method directly called abstract or notit seems to me not the mocking frameworks responsibility to guess the users intention instead if the user wants to stub/verify the direct method invocation use `@mock` while if the user wants to stub/verify abstract methods use `@spy` || > is it any different from api-evolution of abstract classes?>>in template-method pattern if the sut calls an abstract method and then later evolves to call a default method that indirectly calls the abstract method the exact same problem can happen no?i agree if you see it like that they are pretty equali want to avoid that `@spy` is misused to stub in the first place the word ""spying"" implies that there is something to spy on (the sut) but for interfaces the ""spying"" make no sense we would spy on a mocked interface >it seems to me not the mocking frameworks responsibility to guess the users intention i agree here too! what about a littel helper that create stubbings that call the real default method:  `mockitodelegatedefaultmethodstoreal(mockedinterface)` || i still suggest `stub` as the method name for that per previous reasons cited || did a bit of archeology #106 has a discussion both about the api and the namingin that thread i argued against `spy`: ""all the use cases i know of for partial mocking dont need spying"" at the time ""stub"" wasnt suggested but now i think about it it seems to make sensealthough changing it may mean to introduce a new `@stub` annotation and deprecate `@spy abstractclass` if we are willing to consider the ship not sailed yet || interesting discussion! thank you for all suggestions>the tests should not fail or should not be rewritten by replacing @mock with @spy or setting up special mocking settings like withsettings()usedefaultmethods()you are right ideally the tests only fail when a bug is introducedi have a feeling the discussion is getting broader and i am not sure if still discusses the issue reported :) my immediate reaction to new `@stub` interface and potential deprecation of `@spy` is -1 because i dont see clear value however please formulate a separate ticket with the use case code samples and the team will for sure review it!coming back to the original issue: relaxing spy annotation for interfaces is useful for spying on interfaces with default methods the use case is reasonable and team is +1 to the change do we have new data / use cases that indicate that this change inappropriate? || ";1;0;javadoc;
953;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix javadocs on mockitorule.java to correct an error on its usage.;fixing the javadoc to reflect the api for mockitojunitrule;;0;sorting map entries by value; ""how can i sort maps by value"" is a question that comes up on a depressingly regular basis on stackoverflow andwell let me be honest: many of them decide to write a comparator&ltkey> that secretly compares by the value and that just makes me cry  its unsafe itll behave unpredictably when you make queries on keys that arent in the map and if you do it wrong itll behave _really_ confusinglythe traditional ""correct"" way to solve this problem is to sort the map entries separately but ill be fair and admit this is a relatively awkward solution requiring a few distinct stepsim wondering if we can provide something better: either an option in the immutablemap builder to sort by values or a mapscopysortedbyvalues method of some kindor maybe if theres some more general solution"; i think we were already moderately convinced that this was worthwhile but in case it helps: i came across a dozen potential google users while researching a proposed iterable&ltentry>-to-map method i was looking only for that pattern so i surely missed other potential users || added a method to immutablemapbuilder to support this should be mirrored out soon || 6640609a10c02ad8708cff784417a47a9b4006a4 || ";;;;0;1;;
953;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix javadocs on mockitorule.java to correct an error on its usage.;fixing the javadoc to reflect the api for mockitojunitrule;;0;fix javadocs on mockitorulejava to correct an error on its usage;fixing the javadoc to reflect the api for mockitojunitrule;   no coverage uploaded for pull request base  ;;;;1;1;update mockitorulejavafixing the javadoc to reflect the api for mockitojunitrule;
953;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix javadocs on mockitorule.java to correct an error on its usage.;fixing the javadoc to reflect the api for mockitojunitrule;;0;cassandra plugin;this pull request contain an updated version of martin weindels cassandra plugin for presto  the changes include the following:updated the code to the presto coding style ( cassandraclient into separate services  this is how the other connectors are designed and hive is only this way for legacy reasonsremove the classloader wrappers because cassandra client does not seem to load class dynamically (like hive does)  we can add this back if we find out the client is loading classesadded some initial tests that start an embedded cassandra server  we need much more extensive tests but i think this is a good starting point;"on reviewing the changes to my original code i have found three minor issues:1 in `cassandraclientconfig` the default value for cassandranative-protocol-port is set to `9142` this should changed to `9042` as this is the correct default port used by cassandra there seems to be a red hat installation package which uses `9142` (see  but all installation packages from the apache cassandra project and also from datastax use `9042` as far as i know   if you take a look into the jdbc driver code it has also `9042` by default2 `cassandrarecordcursorgetlong(int)` now returns a value for the varint type this can lead to wrong results if the value is outside the 64bit integer range according to javadoc of bitinteger which backs the varint type: ""if this biginteger is too big to fit in a long only the low-order 64 bits are returned"" if we want to allow this conversion a range check should be performed before returning the value3 `rowutil` class in the package `comdatastaxdrivercore` we should not pollute the jdbc driver package it would be better to move this class to the package `comfacebookprestocassandrautil` for `testhost` this is not possible as the constructor of the super class is package privatethanks again for your cleanup work || thanks!1 ill change it to 90422 should i make it `double` for now or just remove the mapping?  if i remove it people wont be able to access varint data  in general i think we should hide any column with an unsupported type3  iirc i had to put `rowutil` in that package because the `row` constructor is package protected (which sucks)let me know what you think about 2  then ill make the changes and push this  id also appreciate it if you can look at adding tests for super columns and more types (with nulls) || my solution was to map `varint` to `string` then its up to the user to decide what to do with itand yes i will work on adding more tests after we have a common starting point || thanks for the great contribution! || ";;;;1;1;remove thread context classloader logic from cassandra plugin;
953;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix javadocs on mockitorule.java to correct an error on its usage.;fixing the javadoc to reflect the api for mockitojunitrule;;0;make observeontesttestnonblockingouterwhileblockingonnext deterministic;reported at https://twittercom/jaceklaskowski/status/443153927069249536;;;;;1;1;make operatorobserveontesttestnonblockingouterwhileblockingonnext deterministicreported at https://twittercom/jaceklaskowski/status/443153927069249536;
959;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix broken build;commit da4e42 introduced a static import from the non-existent;;0;"about the filter function of helper class ""list"""; hello buddies```    so appreciate for the guava lib its so useful  when i using the google-collections im puzzled about that why there is no filter function in the helper class ""lists"" but in ""collections2""there is filter method  if i want to filter some element in list i need get the result collection firstthen add the collection into list it makes the code ugly can i know why? any response is  appreciated```best regardsxianning liuemail:xianlinbox@gamilcom"; ;;;;0;1;;
959;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix broken build;commit da4e42 introduced a static import from the non-existent;;0;fix broken build;commit da4e42 introduced a static import from the non-existent`orgmockitointernalutilstringjoiner` (it exists only in the masterbranch not the release/2x branch)this patch fixes the build by correcting the import to reference`orgmockitointernalutilstringutil`;   no coverage uploaded for pull request base  ;;;;1;1;fix broken buildcommit da4e42 introduced a static import from the non-existentorgmockitointernalutilstringjoiner (it exists only in the masterbranch not the release/2x branch)this patch fixes the build by correcting the import to referenceorgmockitointernalutilstringutil;
959;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix broken build;commit da4e42 introduced a static import from the non-existent;;0;whether the presto has supported to sql querying on hbase currently?;hi presto team:i would like to use presto for sql querying on a table that has been exist in my hbaseso fari find presto that has supported to query data from datasources as hive/hdfs with sqlbut i am not sure whether it has supported to query data from a exist table of hbase as well as sql querying please give me some helpsthank you very muchi will wait your replies online;why nobody answers to me? my god || @phoenixhadoop have you tried to query on hive table which point to hbase ?but please keep in mind that pull request system is not an irc session :> || @damiencarol  i will try to query an external table of hive which points to hbase || @phoenixhadoop anyway its not an issueuse  to query help || i can not open the page  probably china firewall || we have an internal version of presto connector over hbase but open sourcing it needs some additional work we plan to open source it but not anytime soon (probably some time this half) || ok i konw  thank you  || @rishidwivedi did you happen to work on that and open sourced it? i am in need of presto-hbase connector any help would be great || any update on this please? ||;;;;0;1;;
959;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix broken build;commit da4e42 introduced a static import from the non-existent;;0;operationtofuture must throw cancellationexception on get() if cancelled;the jdk documentation for futureget() and its overload requires these methods to throw cancellationexception if the future was cancelled before the task completed the futures returned by operationtofuturetofuture() did not respect this contract now they do;#897 ;;;;1;1;operationtofuture must throw cancellationexception on get() if cancelledthe documentation for futureget() requires the method to throw cancellationexception if the future was cancelled before the task completed the futures returned by operationtofuturetofuture() did not respect this contract now they do;
972;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;verifies #688: acceptance test to prevent future regression;added an acceptance test to verify #688;;0;add orderingnoeffect(); it seems like there is a gap in the api of ordering a no-effect ordering is very useful for when you wish to preserve the ordering but you have to uphold a contract of supplying a comparator it can also be very useful for things like this:orderingnoeffect()onresultof(usersemailaccessorinstance)nullslast()if you wish to push all the users who have no email to the bottom of the list; ;;;;0;1;;
972;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;verifies #688: acceptance test to prevent future regression;added an acceptance test to verify #688;;0;enable checkstyle for tests;;;;;;1;1;enable checkstyle for tests;
972;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;verifies #688: acceptance test to prevent future regression;added an acceptance test to verify #688;;688.0;verifies #688: acceptance test to prevent future regression;added an acceptance test to verify #688;this is going to fail until mockito updates to the next version of byte buddy (that re-688) that contains the following commit:  || could you rebase on `release/2x`? this test should pass now    || @timvdlippe rebased on `release/2x` and tests are passing now ||   thank you guys! nice and clean change and makes mockito safer for our users!!! ||;enabled mocking interface clone method;mocking a `clone()` method on an interface appears to no longer be working with **mockito 210** the below code works fine with **mockito 11019** but throws an `illegalaccesserror` with **mockito 210**:```public interface cloneableinterface extends cloneable {   cloneableinterface clone()}public class cloneableinterfacetest {   @test   public void test() {            cloneableinterface i  mockitomock(cloneableinterfaceclass)      mockitowhen(iclone())thenreturn(i) // throws illegalaccesserror   }}```result of running above test:```javalangillegalaccesserror: cloneableinterface$mockitomock$833899610clone()lcloneableinterface```environment: **jdk 180_102 junit 411 mockito 210 gradle 30 windows 10**edit: link to [so post](http://stackoverflowcom/questions/39967723/mocking-interface-clone-method);i see what is happening here since `object::clone` is protected and since java favors subclass inheritance over interface inheritance the subclass overrides clone as a `protected` method rather than a `public` method of course mockito should render all mock methods public currently we are not doing this but this is trivial to fixthanks for reporting this || @raphw thanks for the quick response ah your root cause analysis makes sense i suppose this is a bit of a corner case and completely understand why it would have been overlooked looking forward to the fix as this is the final item blocking us from upgrading to 210 thanks for all the great work || @jpenglert it should be  in `mockito 221` thanks a lot for reporting! || unfortunately maven sync is disabled thanks to #683  || triggered central sync @bric3 i will enable sync now i wanted to manually verify few releases || thanks @szczepiq  || this bug appears to be back after i upgraded from mockito 221 -> 2713 the original test case i posted is failing in the same manner i ran the above test case with various versions and it appears the 2712 re-introduced this bug perhaps #963 is responsible?would it be possible to add my test case to the mockito test suite to ensure this regression doesnt happen in the future? || we should add it i originally added a modified version to byte buddy but it seems to have missed an aspect feel free to send a pr || i already located and fixed the error i forgot to adjust the visibility for bridge methods || ill make a pr for the acceptance test || i just release a new byte buddy version but i did not correctly apply the fix next version! ||;1;0;verifies #688: acceptance test to prevent future regression;
972;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;verifies #688: acceptance test to prevent future regression;added an acceptance test to verify #688;;971.0; deadlock in subjects + operatorcache;fix for issue #971- i had to rewrite operatorcache to allow testing for deadlocks in all subject types- the terminationlatch was unnecessarily waiting for existing subscribers to deliver their termination events which caused deadlock with repeat()- treating subjects as internal implementations was not necessary to fix the problem;#912  i dont understand these changes yet but on first review they are very awkward as the `subjectsubscriptionmanager` methods now both invoke a function and return a collection || true the rewritten subjects dont require an action1 they are fine with action0 the changes had to be made since the countdonwlatch logic acted as a synchronization block and emitting events while holding locks is prone to deadlocks as the associated issue demonstrates || ah holding the lock is the issue we should find a way of doing that without the latches at all as it is blocking  || the latch has its use because once the state has been swapped to terminal state we still need to perform some tasks on any related state within the particular subject before client notifications can resume: usually it is to set the last event which then will be available to newcomers || i havent merged this yet as i need to spend time better understanding this and the impact on design || since this has conflicts and i did some cleanup based on our discussion above ive opened  for merging this  ||;subjects are not recognized as internal observer implementations;"based on an [issue report]( the following program prints the sequence twice instead of continuously:``` javapublic class repeatcachetest {    public static void main(string args) throws exception {        observablefrom(1 2 3)                subscribeon(schedulersio())                flatmap(i -> observabletimer(i * 100                       timeunitmilliseconds)map(j -> i))                cache()                repeat()                zip(observabletimer(0 300                        timeunitmilliseconds schedulersnewthread())                        (a b) -> a)                subscribe(        systemout::println throwable::printstacktrace                 () -> systemoutprintln(""done""))        threadsleep(100000)    }}```the problem seems to be in `observableisinternalimplementation()` (l8661) not recognizing the replaysubject of the `cache()` operator wrapped by a anonymous subscriber under observable - a logic is required on l7002 to preserve the safeness of the wrapped observer somehow (private indicator interface?)- can we consider rxsubjects\* classes as safe?alternatively cache() could wrap the subject in a subscriber so it will count as internal implementation but this has to be repeated for multicast and other placesthoughts?edit:i did some experimenting and found out the above changes are half solving the problem the second issue is with the subjectsubscriptionmanager which deadlocks on the terminationlatchawait (l69) because after the second iteration the terminationlatchcountdown (l140) is never called the onterminate call triggers a new subscription through the repeat operator which reenters the call on l50 and deadlock";would this be simplified if we eliminate the `isinternalimplementation` check (that i dont like) and use `unsafesubscribe()` as discussed here:  ? || sureto be clear the real problem was something else i discovered soon after i posted this issue || closing as not relevant anymore ||;1;0; deadlock in subjects + operatorcache;
979;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored singlebibtexfield;based on the initial ideas in #978 the class singlebibtexfield is extracted and two enumsets are used for implementing the existing functionality.;;0;compoundorderingcompare() optimization; currently compoundorderingcompare() is implemented using the for-each construct which relies on creating an iterator every time  with compare() typically being a very hot method this creates lots of temporary objects and thus stress on the gc  ive seen escape analysis take care of the allocation of some iterators but apparently not this one  until escape analysis is capable of dealing with more (this) scenarios wanted to suggest optimizing this method to use an int-based (uglier looking) for-loop instead; ;;;;0;1;;
979;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored singlebibtexfield;based on the initial ideas in #978 the class singlebibtexfield is extracted and two enumsets are used for implementing the existing functionality.;;0;fix hive connector semaphore release bug;;;;;;1;1;fix hive connector semaphore release bug;
979;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored singlebibtexfield;based on the initial ideas in #978 the class singlebibtexfield is extracted and two enumsets are used for implementing the existing functionality.;;0;android: subscriber gets garbage collected prematurely;the code in `operatorweakbindingjava` creates a weak reference onto the subscriber in addition to a weak reference onto the android componentnot keeping a strong reference on the subscriber is wrong i have had a lot of non-delivered messages on cgeo because we use code like:``` java   androidobservablebindactivity(this someobservable)subscribe(new observer<…> {      // do something with the data such as display it in a view      …   })```the _only_ reference to the subscriber is in the subscription if it is transformed into a weak reference it will be garbage collected much too soon this is a major departure from the usual (non-android) rxjava subscription modeli think the subscriber should be kept as-is and not be kept as a weak reference onlyi understand that this has been done so that the activity life cycle is not extended due to the subscriber keeping a reference onto it i think this is the subscriber responsibility to keep only a weak reference to the activity (or fragment)maybe another mechanism to allow the subscriber to use a weak reference to the component should be found but in the meantime the current behaviour seems just wrong to me;"cc @mttkay || i see what you mean the rationale behind using a weak reference to the subscriber is that in most of the cases itll be an inner class of the activity (in your case too) if we would hold a strong reference to the observer we would hold a strong reference to the activity too so for the life time of the sequence your activity would immediately leak when attempting to destroy itthat said its not as simple as turning a weak reference into a strong reference but i totally see your point im open for suggestions here as ive tried many approaches to solve these issues and we keep finding (edge) cases where the solutions collapse || on the top of my head: couldnt we find a way to give the android component back to the subscriber?something like``` scala   def bindactivity[t <: activity u](activity: t sourceobservable: observable[u]): observable[(t u)]```this way the subscriber will get a reference to the activity with every item and doesnt need to keep strong references to itof course it means that the user needs to be cautious in not closing over the activity through other references but it can do so by declaring the subscriber in the companion object rather than in the activity itself if they are not sure to do it correctly || (forget my remark about the companion object i was thinking in scala term i meant ""as a static method"" in java :-) || @samueltardieu is this still an issue? i believe that as of #1021 that was merged this should no longer be happening || exactly closing it || ";;;;0;1;;
979;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored singlebibtexfield;based on the initial ideas in #978 the class singlebibtexfield is extracted and two enumsets are used for implementing the existing functionality.;;974.0;974: fix to get correct stubbing location with inline mocking;- fix stacktracefilter to support inline mocking- add one test to stacktracefiltertest- add stubbinglocationtest into inline subprojectthis pr 974; merging 979 ;mockitojunitrunnerstrictstubs does not detect unnecessary stubbing when inline mock maker is enabled;"- mockito-core 2713- openjdk 180_121- ubuntu 1610- enable `mock-maker-inline` (or use `mockito-inline` artifact)if running the following test unnecessary stubbing is not detected```java@runwith(mockitojunitrunnerstrictstubsclass)public class mockitotest {    @mock    arraylist<string> mock    @test    public void should_pass() {        when(mockget(0))thenreturn(""foo"")        assertequals(""foo"" mockget(0))    }    @test    public void should_detect_unnecessary_stubbing() {        when(mockget(1))thenreturn(""foo"")    }}```in the above code unnecessary stubbing is detected by changing arraylist to list```java    @mock//    arraylist<string> mock    list<string> mock```this problem does not occur with default mock maker";"this is working as intended you should not mock data classes such as `list` the new mock maker is stricter in this regard as we could not ship another breaking change for the original mock makerwe could add an explicit exception when we encounter these classes instead of silently continueing wdyt @raphw ? || i am sorry that my test case was badthe following test **passes** using inline mock makerthis test does not use data classes```java@runwith(mockitojunitrunnerstrictstubsclass)public class mockitotest {    @mock    c mock    @test    public void should_pass() {        when(mockdoit())thenreturn(""foo"")        assertequals(""foo"" mockdoit())    }    @test    public void should_detect_unnecessary_stubbing() {        when(mockdoit())thenreturn(""foo"")    }    public static class c {        public string doit() {            throw new unsupportedoperationexception()        }    }}```using default mock maker this test **fails**this is the result that i expect```orgmockitoexceptionsmisusingunnecessarystubbingexception: unnecessary stubbings detected in test class: mockitotestclean & maintainable test code requires zero unnecessary codefollowing stubbings are unnecessary (click to navigate to relevant line of code):  1 -> at comexamplemockitotestshould_detect_unnecessary_stubbing(mockitotestjava:25)please remove unnecessary stubbings or use silent option more info: javadoc for unnecessarystubbingexception class	at orgmockitointernalrunnersstrictrunnerrun(strictrunnerjava:49)	at orgmockitojunitmockitojunitrunnerrun(mockitojunitrunnerjava:161)	at orgjunitrunnerjunitcorerun(junitcorejava:137)	at comintellijjunit4junit4ideatestrunnerstartrunnerwithargs(junit4ideatestrunnerjava:117)	at comintellijjunit4junit4ideatestrunnerstartrunnerwithargs(junit4ideatestrunnerjava:42)	at comintellijrtexecutionjunitjunitstarterpreparestreamsandstart(junitstarterjava:262)	at comintellijrtexecutionjunitjunitstartermain(junitstarterjava:84)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at comintellijrtexecutionapplicationappmainmain(appmainjava:147)```does **new mock maker** mean **inline mock maker**?according to the results of this test inline mock maker seems to be less strict than default mock makersorry if i have misunderstood || ah that is a better testcase definitely a bug! || just tested this on master and the result is the same for both mock makers where neither test detects the unneccessary stubbung i do not know this part of mockito too well but i assume there is a bug in this component || i wrote a new test for this issue```javapublic class strictstubsrunnerbymockingabstractclasstest {    private final junitcore junitcore  new junitcore()    @test    public void test_for_abstract_method_should_detect_unnecessary_stubbings() {        runtest(forabstractmethodclass)    }    @test    public void test_for_concrete_method_should_detect_unnecessary_stubbings() {        runtest(forconcretemethodclass)    }    private void runtest(class<?> testclass) {        result result  junitcorerun(testclass)        list<failure> failures  resultgetfailures()        assertthat(failuressize() equalto(1))        failure failure  failuresget(0)        assertthat(failuregetexception() instanceof(unnecessarystubbingexceptionclass))    }    static abstract class testtarget {        abstract string abstractmethod()        string concretemethod() {            throw new unsupportedoperationexception()        }    }    @runwith(mockitojunitrunnerstrictstubsclass)    public static class forabstractmethod {        @mock        testtarget mock        @test        public void correct_stubbing() {            when(mockabstractmethod())thenreturn("""")            mockabstractmethod()        }        @test        public void unused_stubbing() {            when(mockabstractmethod())thenreturn("""")        }    }    @runwith(mockitojunitrunnerstrictstubsclass)    public static class forconcretemethod {        @mock        testtarget mock        @test        public void correct_stubbing() {            when(mockconcretemethod())thenreturn("""")            mockconcretemethod()        }        @test        public void unused_stubbing() {            when(mockconcretemethod())thenreturn("""")        }    }}```to test this test on the master i put this into the following directory1 src/test/java/org/mockitousage/junitrunner (using the default mock maker)1 inline/src/test/java/org/mockitoinline (using the inline mock maker)in the first case this test passed```$ /gradlew -dorggradleparallelfalse clean :test --tests ""orgmockitousagejunitrunnerstrictstubsrunnerbymockingabstractclasstest""version: 2714 android:clean up-to-date clean up-to-date clean clean up-to-date  some input files use or override a deprecated apinote: recompile with -xlint:deprecation for detailsnote: some input files use unchecked or unsafe operationsnote: recompile with -xlint:unchecked for details processresources up-to-date createtestresources  some input files use or override a deprecated apinote: recompile with -xlint:deprecation for detailsnote: some input files use unchecked or unsafe operationsnote: recompile with -xlint:unchecked for details processtestresources up-to-date testbuild successfultotal time: 5707 secs```however in the second case it failed```$ /gradlew -dorggradleparallelfalse clean  test --tests ""orgmockitoinlinestrictstubsrunnerbymockingabstractclasstest""version: 2714 android:clean up-to-date clean up-to-date clean clean up-to-date  some input files use or override a deprecated apinote: recompile with -xlint:deprecation for detailsnote: some input files use unchecked or unsafe operationsnote: recompile with -xlint:unchecked for details processresources up-to-date jar compilejava up-to-date processresources classes compiletestjava processtestresources up-to-date testclasses testorgmockitoinlinestrictstubsrunnerbymockingabstractclasstest > test_for_concrete_method_should_detect_unnecessary_stubbings failed    javalangassertionerror:     expected: <1>         but: was <0>        at orghamcrestmatcherassertassertthat(matcherassertjava:20)        at orgjunitassertassertthat(assertjava:956)        at orgjunitassertassertthat(assertjava:923)        at orgmockitoinlinestrictstubsrunnerbymockingabstractclasstestruntest(strictstubsrunnerbymockingabstractclasstestjava:36)        at orgmockitoinlinestrictstubsrunnerbymockingabstractclasstesttest_for_concrete_method_should_detect_unnecessary_stubbings(strictstubsrunnerbymockingabstractclasstestjava:30)2 tests completed 1 failed test failedfailure: build failed with an exception* what went wrong:execution failed for task  test> there were failing tests see the report at: file:///home/tmura/ideaprojects/mockito/subprojects/inline/build/reports/tests/indexhtml* try:run with --stacktrace option to get the stack trace run with --info or --debug option to get more log outputbuild failedtotal time: 3505 secs```for the abstract method unnecessary stubbing was detected correctly but it did not detected for the concrete method || i thnk i have found the cause of this problemwhen using the inline mock maker it seems that locationimpl cannot get the stubbed location of the concrete method correctly`unusedstubbingfinder` which detects unnecessary stubbing calls `locationimpl#tostring()` to get the stabbed locationthe code below is the implementation of `locationimpl#tostring()````javastacktraceelement filtered  stacktracefilterfilter(stacktraceholdergetstacktrace() false)if (filteredlength  0) {    return ""-> at <<unknown line>>""}return ""-> at "" + filtered[0]tostring()```this method filters the stack trace elements of `stacktraceholder` to get the location`stacktraceholder` is a throwable object that is created in the constructor of `locationimpl`the stack trace elements of this object are as follows:- stubbing the concrete method with the default mock maker```0  {stacktraceelement@1679} ""orgmockitointernaldebugginglocationimpl<init>(locationimpljava:23)""1  {stacktraceelement@1680} ""orgmockitointernaldebugginglocationimpl<init>(locationimpljava:18)""2  {stacktraceelement@1681} ""orgmockitointernalcreationbytebuddyinterceptedinvocation<init>(interceptedinvocationjava:52)""3  {stacktraceelement@1682} ""orgmockitointernalcreationbytebuddymockmethodinterceptordointercept(mockmethodinterceptorjava:41)""4  {stacktraceelement@1683} ""orgmockitointernalcreationbytebuddymockmethodinterceptor$dispatcherdefaultingtorealmethodinterceptsupercallable(mockmethodinterceptorjava:102)""5  {stacktraceelement@1684} ""comexamplemockitotest$c$mockitomock$648066763doit(unknown source)""6  {stacktraceelement@1685} ""comexamplemockitotestshould_detect_unnecessary_stubbing(mockitotestjava:25)"- stubbing the abstract method with the inline mock maker```0  {stacktraceelement@2201} ""orgmockitointernaldebugginglocationimpl<init>(locationimpljava:23)""1  {stacktraceelement@2202} ""orgmockitointernaldebugginglocationimpl<init>(locationimpljava:18)""2  {stacktraceelement@2203} ""orgmockitointernalcreationbytebuddyinterceptedinvocation<init>(interceptedinvocationjava:52)""3  {stacktraceelement@2204} ""orgmockitointernalcreationbytebuddymockmethodinterceptordointercept(mockmethodinterceptorjava:41)""4  {stacktraceelement@2205} ""orgmockitointernalcreationbytebuddymockmethodinterceptor$dispatcherdefaultingtorealmethodinterceptabstract(mockmethodinterceptorjava:120)""5  {stacktraceelement@2206} ""comexamplemockitotest$c$mockitomock$1683798279doit(unknown source)""6  {stacktraceelement@2207} ""comexamplemockitotestshould_detect_unnecessary_stubbing(mockitotestjava:25)""```- stubbing the concrete method with the inline mock maker```0  {stacktraceelement@1927} ""orgmockitointernaldebugginglocationimpl<init>(locationimpljava:23)""1  {stacktraceelement@1928} ""orgmockitointernaldebugginglocationimpl<init>(locationimpljava:18)""2  {stacktraceelement@1929} ""orgmockitointernalcreationbytebuddyinterceptedinvocation<init>(interceptedinvocationjava:52)""3  {stacktraceelement@1930} ""orgmockitointernalcreationbytebuddymockmethodinterceptordointercept(mockmethodinterceptorjava:41)""4  {stacktraceelement@1931} ""orgmockitointernalcreationbytebuddymockmethodadvicehandle(mockmethodadvicejava:76)""5  {stacktraceelement@1932} ""comexamplemockitotest$cdoit(mockitotestjava:30)""6  {stacktraceelement@1933} ""comexamplemockitotestshould_detect_unnecessary_stubbing(mockitotestjava:25)""```the resulting location should be `#6` but in the last case it is `#5`because `stacktracefilter` does not exclude `#5` || yes this is expected the inline mock maker inlines the code and does therefore not add a stack frame this is a bug in the `unusedstubbingfinder` which should not rely on the stack shape@timvdlippe do you have time to look at this? || thank you guys for really thorough debugging!>this is a bug in the unusedstubbingfinder which should not rely on the stack shapethere is a reason why the finder relies on the string representation of line where the unused stub is declared i documented it in the [javadoc]( hopefully it is more less clear :) im not saying we should keep the current implementation im ok changing it i just wanted to give more data pointsafter reading this thread my gut feel tells me that the stack trace filter (different component than unused stubbing detection) may not be coping well with inline mocking this could also have impact on stack trace filtering in general for inline mocking the quality of exception messages etc@tmurakami you made fantastic debugging effort to nail down the problem can you investigate if stack trace filter needs adapting for inline mocking and potentially submit a pr? || with the stack trace filter i actually did change the implementation to adjust this behavior such that it works i was not aware that the stubbing finder replicated something similar || @szczepiq @raphw i can submit the pr but this problem seems to have already been  by @raphwshould i submit the pr? || please submit i only fixed the issue partially || ";1;0;974: fix to get correct stubbing location with inline mocking;
980;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced bitset with enumset in ooutil;clearly enumset is superior.;;0;iterablesreverse (or collections2reverse); sometimes we have a collection which we know is in a defined order and would like to iterate it in reverse but we dont know if its a list or a navigablesetcurrently our workaround for this is as follows:```public static <t> collection<t> reverse(collection<t> collection) {    if (collection instanceof list) {        return listsreverse((list<t>) list)    } else if (collection instanceof navigableset) {        return ((navigableset<t>) collection)descendingset()    } else {        return listsreverse(new arraylist<>(collection)) // expensive copy as fallback    }}```after writing this i find it hard to find a reason why it shouldnt be expanded to support any iterable so iterables could be a better place i guess; whaaaat?  did i seriously just type ""barring something no one think of"" when i meant ""barring something new that none of us thought of""? || ";;;;0;1;;
980;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced bitset with enumset in ooutil;clearly enumset is superior.;;0;add 058 release notes;;;;;;1;1;add 058 release notes;
980;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced bitset with enumset in ooutil;clearly enumset is superior.;;0;rxjava: gradlew issue --> could not create task of type scaladoc;heyim seeing a rxjava build issue / error related to scala(hint: i downloaded the special eclipse for scala a long time ago for my coursera class  probably something left over)it similar to  mattmccline$ /gradlew builddownloading  /users/mattmccline/gradle/wrapper/dists/gradle-18-all/2kopnp0i5dq014k75fp36m3vd5/gradle-18-allzip to /users/mattmccline/gradle/wrapper/dists/gradle-18-all/2kopnp0i5dq014k75fp36m3vd5set executable permissions for: /users/mattmccline/gradle/wrapper/dists/gradle-18-all/2kopnp0i5dq014k75fp36m3vd5/gradle-18/bin/gradledownload                                           taskcontaineradd() method has been deprecated and is scheduled to be removed in gradle 20 please use the create() method insteaddownload                                           build failed with an exceptionwhere:build file /users/mattmccline/rxjava/language-adaptors/rxjava-scala/buildgradle line: 1what went wrong:a problem occurred evaluating project :language-adaptors:rxjava-scalacould not create task of type scaladoctry:run with --stacktrace option to get the stack trace run with --info or --debug option to get more log outputbuild failedtotal time: 5 mins 18692 secs;"could you add `--stacktrace` to get the stacktrace of the error? whats version of your jdk? if its 18 maybe its a same issue as here:  || hi (shixiong)thank you for looking into the problemyes the jdk is 18ill look at the link you have provided nextbelow is the build with the ‹stacktrace option:matts-macbook-pro:rxjava mattmccline$ /gradlew build --stacktracethe taskcontaineradd() method has been deprecated and is scheduled to beremoved in gradle 20 please use the create() method insteadfailure: build failed with an exception- where:  build file   /users/mattmccline/rxjava/language-adaptors/rxjava-scala/buildgradle  line: 1- what went wrong:  a problem occurred evaluating project :language-adaptors:rxjava-scala    > could not create task of type scaladoc- try:  run with --info or --debug option to get more log output- exception is:  orggradleapigradlescriptexception: a problem occurred evaluating project  :language-adaptors:rxjava-scala  at   orggradlegroovyscriptsinternaldefaultscriptrunnerfactory$scriptrunnerim  plrun(defaultscriptrunnerfactoryjava:54)  at   orggradleconfigurationdefaultscriptpluginfactory$scriptpluginimplapply(d  efaultscriptpluginfactoryjava:132)  at   orggradleconfigurationprojectbuildscriptprocessorexecute(buildscriptpro  cessorjava:38)  at   orggradleconfigurationprojectbuildscriptprocessorexecute(buildscriptpro  cessorjava:25)  at   orggradleconfigurationprojectconfigureactionsprojectevaluatorevaluate(c  onfigureactionsprojectevaluatorjava:34)  at   orggradleconfigurationprojectlifecycleprojectevaluatorevaluate(lifecycl  eprojectevaluatorjava:55)  at   orggradleapiinternalprojectabstractprojectevaluate(abstractprojectjav  a:468)  at   orggradleapiinternalprojectabstractprojectevaluate(abstractprojectjav  a:76)  at   orggradleconfigurationdefaultbuildconfigurerconfigure(defaultbuildconfig  urerjava:31)  at   orggradleinitializationdefaultgradlelauncherdobuildstages(defaultgradlel  auncherjava:142)  at   orggradleinitializationdefaultgradlelauncherdobuild(defaultgradlelaunche  rjava:113)  at   orggradleinitializationdefaultgradlelauncherrun(defaultgradlelauncherja  va:81)  at   orggradlelauncherexecinprocessbuildactionexecuter$defaultbuildcontroller  run(inprocessbuildactionexecuterjava:64)  at   orggradlelaunchercliexecutebuildactionrun(executebuildactionjava:33)  at   orggradlelaunchercliexecutebuildactionrun(executebuildactionjava:24)  at   orggradlelauncherexecinprocessbuildactionexecuterexecute(inprocessbuild  actionexecuterjava:35)  at   orggradlelauncherexecinprocessbuildactionexecuterexecute(inprocessbuild  actionexecuterjava:26)  at orggradlelauncherclirunbuildactionrun(runbuildactionjava:50)  at   orggradleapiinternalactions$runnableactionadapterexecute(actionsjava:1  71)  at   orggradlelauncherclicommandlineactionfactory$parseandbuildactionexecute  (commandlineactionfactoryjava:201)  at   orggradlelauncherclicommandlineactionfactory$parseandbuildactionexecute  (commandlineactionfactoryjava:174)  at   orggradlelauncherclicommandlineactionfactory$withloggingexecute(command  lineactionfactoryjava:170)  at   orggradlelauncherclicommandlineactionfactory$withloggingexecute(command  lineactionfactoryjava:139)  at   orggradlelaunchercliexceptionreportingactionexecute(exceptionreportinga  ctionjava:33)  at   orggradlelaunchercliexceptionreportingactionexecute(exceptionreportinga  ctionjava:22)  at orggradlelaunchermaindoaction(mainjava:46)  at orggradlelauncherbootstrapentrypointrun(entrypointjava:45)  at orggradlelaunchermainmain(mainjava:37)  at   orggradlelauncherbootstrapprocessbootstraprunnoexit(processbootstrapja  va:50)  at   orggradlelauncherbootstrapprocessbootstraprun(processbootstrapjava:32)  at orggradlelaunchergradlemainmain(gradlemainjava:23)  at   orggradlewrapperbootstrapmainstarterstart(bootstrapmainstarterjava:33)  at orggradlewrapperwrapperexecutorexecute(wrapperexecutorjava:130)  at orggradlewrappergradlewrappermainmain(gradlewrappermainjava:48)  caused by: orggradleapitaskstaskinstantiationexception: could not create  task of type scaladoc  at   orggradleapiinternalprojecttaskfactorytaskfactory$1call(taskfactoryj  ava:126)  at   orggradleapiinternalprojecttaskfactorytaskfactory$1call(taskfactoryj  ava:121)  at   orggradleapiinternalabstracttaskinjectintonewinstance(abstracttaskjava  :142)  at   orggradleapiinternalprojecttaskfactorytaskfactorycreatetaskobject(tas  kfactoryjava:121)  at   orggradleapiinternalprojecttaskfactorytaskfactorycreatetask(taskfacto  ryjava:81)  at   orggradleapiinternalprojecttaskfactoryannotationprocessingtaskfactory  createtask(annotationprocessingtaskfactoryjava:99)  at   orggradleapiinternalprojecttaskfactorydependencyautowiretaskfactorycr  eatetask(dependencyautowiretaskfactoryjava:39)  at   orggradleapiinternaltasksdefaulttaskcontainercreate(defaulttaskcontain  erjava:52)  at   orggradleapiinternaltasksdefaulttaskcontainercreate(defaulttaskcontain  erjava:85)  at orggradleapitaskstaskcontainer$create$0call(unknown source)  at   orggradleapipluginsscalascalapluginconfigurescaladoc(scalaplugingroov  y:40)  at   orggradleapipluginsscalascalapluginthis$2$configurescaladoc(scalaplugi  ngroovy)  at   orggradleapipluginsscalascalaplugin$this$2$configurescaladoccallcurren  t(unknown source)  at orggradleapipluginsscalascalapluginapply(scalaplugingroovy:32)  at orggradleapipluginsscalascalapluginapply(scalaplugingroovy)  at   orggradleapiinternalpluginsdefaultplugincontainerprovideplugin(default  plugincontainerjava:104)  at   orggradleapiinternalpluginsdefaultplugincontaineraddplugininternal(def  aultplugincontainerjava:68)  at   orggradleapiinternalpluginsdefaultplugincontainerapply(defaultpluginco  ntainerjava:34)  at   orggradleapiinternalpluginsdefaultobjectconfigurationactionapplyplugin  (defaultobjectconfigurationactionjava:101)  at   orggradleapiinternalpluginsdefaultobjectconfigurationactionaccess$200(  defaultobjectconfigurationactionjava:32)  at   orggradleapiinternalpluginsdefaultobjectconfigurationaction$3run(defau  ltobjectconfigurationactionjava:72)  at   orggradleapiinternalpluginsdefaultobjectconfigurationactionexecute(def  aultobjectconfigurationactionjava:114)  at   orggradleapiinternalprojectabstractpluginawareapply(abstractpluginawar  ejava:39)  at orggradleapiproject$applycall(unknown source)  at   orggradleapiinternalprojectprojectscriptapply(projectscriptgroovy:34)  at orggradleapiscript$applycallcurrent(unknown source)  at   build_6cbd2484ji1s8a6u66c7j8j32qrun(/users/mattmccline/rxjava/language-adap  tors/rxjava-scala/buildgradle:1)  at   orggradlegroovyscriptsinternaldefaultscriptrunnerfactory$scriptrunnerim  plrun(defaultscriptrunnerfactoryjava:52)   33 more  caused by: javalangnullpointerexception  at orggradleapidefaulttask<init>(defaulttaskjava:33)  at orggradleapiinternalconventiontask<init>(conventiontaskjava:28)  at orggradleapitaskssourcetask<init>(sourcetaskjava:36)  at orggradleapitasksscalascaladoc<init>(scaladocjava:28)  at orggradleapitasksscalascaladoc_decorated<init>(unknown source)  at   orggradleapiinternaldependencyinjectinginstantiatornewinstance(dependen  cyinjectinginstantiatorjava:62)  at   orggradleapiinternalclassgeneratorbackedinstantiatornewinstance(classge  neratorbackedinstantiatorjava:36)  at   orggradleapiinternalprojecttaskfactorytaskfactory$1call(taskfactoryj  ava:124)   60 morebuild failedtotal time: 9812 secsmatts-macbook-pro:rxjava mattmccline$from:  shixiong zhu notifications@githubcomreply-to:  netflix/rxjava<reply+i-29996454-30fc8acd6ab4f72ffc0c7714cd73276bf6e93b53-7002312@replygithubcom>date:  sunday march 23 2014 7:27 pmto:  netflix/rxjava rxjava@noreplygithubcomcc:  matt mccline matt_mccline@yahoocomsubject:  re: [rxjava] rxjava: gradlew issue --> could not create task oftype scaladoc (#980)could you add --stacktrace to get the stacktrace of the error? whatsversion of your jdk? if its 18 maybe its the same issue as here: to this email directly or view it on github  || > yes the jdk is 18i tested it on jdk 18 and got the same problem when i changed back to jdk 17 everything is fine so i think that jdk 18 is incompatible with gradle my gradle version is 111can you downgrade to jdk 17 and test again? || i had this a long ago the issue is with the scala compiler not recognizing java 8 and throwing error in the gradle task early on jdk 7 works fine || well i wanted to try out ben christensens ""example of rxjava being used with java 8 lambdas""   it work to install rxjava under jdk 17 then switch to 18 afterwards?thanks for looking into this> on mar 25 2014 at 12:29 am akarnokd notifications@githubcom wrote:> > i had this a long ago the issue is with the scala compiler not recognizing java 8 and throwing error in the gradle task early on jdk 7 works fine> > —> reply to this email directly or view it on github || causing me issues too  im going to comment out scaladoc until it works as this is a real nuisance i cant even import the project into an ide environment where java 8 is being used@mccline36 you can use rxjava binaries (built for java 6) from a java 8 project and it will work fine this issue is only if trying to build rxjava using java 8 (which is not necessary since it works with java 6 onwards) || here is the bug report:  even look like i can comment out this behavior grrrrr || to work around this for now i have to comment out the rxjava-scala module in settingsgradle:```//language-adaptors:rxjava-scala \```i also have to skip all javadoc tasks which break in java 8```/gradlew clean build -x javadoc``` || hi benthank you very much!!!  that did the trick  i have a successful buildmattfrom:  ben christensen notifications@githubcomreply-to:  netflix/rxjava<reply+i-29996454-30fc8acd6ab4f72ffc0c7714cd73276bf6e93b53-7002312@replygithubcom>date:  wednesday march 26 2014 9:40 pmto:  netflix/rxjava rxjava@noreplygithubcomcc:  matt mccline matt_mccline@yahoocomsubject:  re: [rxjava] rxjava: gradlew issue --> could not create task oftype scaladoc (#980)to work around this for now i have to comment out the rxjava-scala module insettingsgradle://language-adaptors:rxjava-scala \i also have to skip all javadoc tasks which break in java 8/gradlew clean build -x javadoc‹reply to this email directly or view it on github  || closing out  builds with java 6/7 work fine java 8 gradle and scala are a wreck right now || ";;;;0;1;;
980;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced bitset with enumset in ooutil;clearly enumset is superior.;;976.0;976: resolve ambiguous constructors;"with the current code (introduced in mockito 2714 by commit 6a82c03) calling `mocksettingsuseconstructor` with an argument list that would be applicable to more than one constructor would fail with an `orgmockitointernalcreationinstanceinstantiationexception`this behavior however is suboptimal as described in issue #976 as it makes `useconstructor` less robust than the java compiler which is able to resolve such ambiguitieswith this patch mockito will attempt to match the constructor with the most specific parameter types a constructor x is considered more specific than a constructor y if:1 they are both applicable to the given argument list2 constructor x has at least one parameter which is a further specialization of the corresponding parameter of constructor y (ie `paramxisassignablefrom(paramy)`)3 constructor y has no parameter which is a further specialization of the corresponding parameter of constructor x as defined aboveeg consider the following class:    public class someclass {        someclass(object o) {}        someclass(string s) {}    }without this patch calling    mock(someclassclass withsettings()useconstructor(""string!""))would fail with this patch such a call would invoke the `someclass(string)` constructoras noted above this pr fixes issue #976";" merging 980  ";make mocksettingsuseconstructor able to choose the right constructor;## use casewe recently added a very nice new feature #935 - ability to mock abstract classes / use real constructor for creating mocks currently we fail fast when multiple constructors are found matching provided arguments however mockito could potentially do a better job identifying which constructor to use example scenario:```javaclass a {}class b extends a {}class c extends b {}class foo {  foo(a a) {}  foo(b b) {}}//below fails with current implementation:mock(foo withsettings()useconstructor(new a()))mock(foo withsettings()useconstructor(new b()))//however we could make above work because the constructor argument are not really ambiguous//example use case of ambiguous constructor that we can remain failing onmock(foo withsettings()useconstructor(new c()))```## implementationto get started see creatingmockswithconstructortest class unless the code changes the interesting test method is [this one](https://githubcom/mockito/mockito/blob/release/2x/src/test/java/org/mockitousage/constructor/creatingmockswithconstructortestjava#l150);@mureinik do you want to take a stab at this one? :) || @szczepiq sure ill take a crack at it but lets first decide what exactly we want to do first a note - `mock(foo withsettings()useconstructor(new a()))` most definitely works with the current implementation contrary to the comment in the above snippeti propose the following definition which is pretty much what the compiler does when facing a call like `new foo(new b())`:- an argument will be called _better matching_ parameter x over parameter y if the argument can be applied to either parameter x or parameter y and x is a more specific type than y<br/>for completeness sake: an argument will be called _worse matching_ parameter x over parameter y if it is _better matching_ parameter y over x an argument will be called _equally matching_ parameter x over parameter y if it is neither _better matching_ or _worse matching_ parameter x over parameter y- an argument list will be called _better matching_ a constructors parameters list x over y if one or more of the arguments are _better matching_ their respective parameters and the rest are _equally matching_ their respective parameters<br/>note that if the argument list is larger than one argument this is not a total order if constructor x is _better matching_ an argument list than constructor z and constructor y is _better matching_ the same argument list than constructor z nothing can be said about the relationship between x and yusing these definitions we can implement the following behavior:- if no constructor matches the argument list an exception is thrown (as it is with the current implementation)- if a single constructor matches the argument list its used (as it is with the current implementation)- if multiple constructors match the argument list and one is _better matching_ than any other constructor it is used (new behavior)- if multiple constructors match the argument list and there isnt one that is _better matching_ than all the  the other constructors an exception is thrown (similar to the current implementation although the error message may be more precise - see below)ill attempt to clarify this with an exampleconsider the following:```javaclass a {}class b extends a {}class c extends b {}class foo {  foo(a x a y) {}  foo(a x b y) {}  foo(b x a y) {}}a a  new a()b b  new b()c c  new c()// works foo(a a) is called obviouslymock(fooclass withsettings()useconstructor(a a)) // works foo(a b) is called// since b is more specific than a foo(a b) is better matching than foor(a a)mock(fooclass withsettings()useconstructor(a b)) // works foo(b a) is called following the same logic as abovemock(fooclass withsettings()useconstructor(b a)) // works foo(b a) is called following the same logic as abovemock(fooclass withsettings()useconstructor(a c)) // does not work as we cant decide between foo(a b) and foo(b a)mock(fooclass withsettings()useconstructor(b b)) ```if this approach makes sense ill cook up a patch that implements it so we have something concrete to discuss || @szczepiq feel free to assign this issue to me i dont think i have the permissions to do so myself ||;1;0;"fix freudian slip in message regarding issue 685the text should read ""a better job"" not ""a better join""";
983;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;some random cleanups (and probably a bug-fix);- removed unused imports - some code style fixes - most likely fixed a potential npe in savedatabaseaction (chosenfile will never be null here  but f might be and is later dereferenced);;0;provide fluentiterable#nonematch(predicate); having a method ""nonematch"" in addition to the methods ""anymatch"" and ""allmatch"" would make some code nicerfor example i would have the codeif (from(my_set)nonematch(my_predicate) {  }instead of if (!from(my_set)anymatch(my_predicate) {  }or if (from(my_set)allmatch(not(my_predicate)) {  }while the difference in code is not big i think the first is by far the easiest to read and understand especially because only in this version the words form a proper english sentencewith the static methods in iterables one could simply provide their own version of such a method if one felt it was worth it with fluentiterable this is not as easy anymore if they get passed around or are provided by third-party methods so i think the additional method is worth to be included in fluentiterable itselfadding the method would not be a big disadvantage yes it does add another name to the namespace but the name is pretty clear and very unlikely to be misunderstood"; ;;;;0;1;;
983;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;some random cleanups (and probably a bug-fix);- removed unused imports - some code style fixes - most likely fixed a potential npe in savedatabaseaction (chosenfile will never be null here  but f might be and is later dereferenced);;0;add new s3 filesystem using aws sdk;this is a new proof-of-concept s3 filesystem implementation that uses the aws sdk it passes the basic unit tests but has not been tested otherwise;"hi davidthis is great for presto working on s3 relieved the packaging worki tried this on a 11 node cluster it is running ok just have a few questions:#1 still could not figure out a way to disable logging extensive logging made prestos performance on s3 not so good compared with reading from hdfs here is my etc/logproperties:comfacebookprestodebugorgapachehadoopwarnorgapache still i get tens of:2014-01-30t22 03945+0000     info   20140130_221259_00004_56i9816-0-81    stdout  22 03945 [20140130_221259_00004_56i9816-0-81] debug orgapache - << ""[0xbd][0x14]5[0xe2]b[0xe6][0xf3][0xc9][0x9]s[0xbc][0x9a][0xd9][0xb6][0xa4]y9[0xc9][0x7][0xdf][0xe9][0x13][0xc7][0xfd][0xa2][0x13][0x88][0xfe][0xfa][0xbf]z[0x9][0xea][0xcc][0x7][0xd3][0x96][0x11][0xd0][0xa6]a7[0x1d]q[0xac][0xb5]`[0x83][0x2][0x84])h[0xca]rq[0xde][0xa9]3[0xa0]yo[\n]""2014-01-30t22 03946+0000     info   20140130_221259_00004_56i9816-0-81    stdout  22 03946 [20140130_221259_00004_56i9816-0-81] debug orgapache - << ""[0xa4][0xda][0x18][0x95]gb[0xbd]2[0xc0][0xe4]t[0xc7][0xc8][0xc9][0x6]][0xc3][0x1c]1:[0x9b]:[0x9f]w`[0xaf]k[0x9d]cp[0x2][0xb4][\r][0x8c]?)[0xf5]<[0x1b][0xcb][0xa8]u[0x1a]+i[0xbb][0xf]:which not only made presto running slow but also consumed lots of disk space do you have any hints about how to disable the log(as how presto is running on hdfs)?#2 the  deadlock problem is still there i found a way to get it  will post my patch following this onethis is really great work to start trying presto on s3 i tried some experiments(not using this patch but using emrs hadoop jars) and it showed that presto on s3 could be as fast as presto on hdfs i think we should put all s3 related work in this packaging structure and make its performance as fast as using emrs hadoopthankszhenxiao || this seem like a reasonable start   updated to address review comments will push after release || ";;;;1;1;add new s3 filesystem using aws sdk;
983;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;some random cleanups (and probably a bug-fix);- removed unused imports - some code style fixes - most likely fixed a potential npe in savedatabaseaction (chosenfile will never be null here  but f might be and is later dereferenced);;0;add operationtooperator and unit tests and overload for lift method;i found myself using this method a lot to easily create an operator so that i can use the lift method for example:suppose i want to use lift to perform a concat on a sequence of observables followed by count:``` javaprivate static <t> func1<observable<observable<t>> observable<integer>> concatcount() {    return new func1<observable<observable<t>> observable<integer>>() {        @override        public observable<integer> call(observable<observable<t>> source) {            return observableconcat(source)count()        }    }}```i can then use the suggested lift overload with the function above:``` javasourcelift(myclass<integer> concatcount())```or i could have made an operator form of it (especially if its component operations dont have readily available operator forms to chain together):``` javaprivate static <t> operator<integer observable<t>> concatcountoperator() {    return operationtooperatortooperator(myclass<t> concatcount())}```;"#920  to summarize the intent of this pr it intends to add this signature:``` javapublic <r> observable<r> lift(func1<? super observable<t>? extends observable<r>> function)```and allows this type of usage:``` java//puts 0 before and 100 after an observablefunc1<observable<integer>observable<integer>> surround  (observable<integer> source) -> {     return observableconcat(observablejust(0) sourceobservablejust(100))}list<integer> list  observablerange(1 3)     // surround the source with 0 and 100     liftorchain(surround)     //get as a list     tolist()toblockingobservable()single()```this would emit `0123100`perhaps this is better called `chain` as opposed to `lift` since `lift` is lifting a function against `subscriber` into an `observable` and this is actually chaining `observable` processing together?``` javapublic <r> observable<r> chain(func1<? super observable<t>? extends observable<r>> function)```do we need a cover type on this as well to handle generics? right now the t and r are not marked `super` and i think they need to be@headinthebox what do you think about this? || ping @headinthebox on this one again || ive pondered this one a bit more and for my usage i could do without the lift overload (or chain) and would have more flexibility if a static method existed with this signature:``` javapublic static operator<rt>  tooperator(func1<observable<t>observable<r>> function)```what do you think @benjchristensen? || #1120 ill still need to remove the use of publishsubject in operationtooperator but is there a subject implementation that performs this simple pass through? || review of my attempt to avoid use of publishsubject would be welcome  #1121 looks good || this reminds me of the selector-based multicast iesourcemulticast(publishsubject::create o -> concat(1 o 100))tolist()although using a single-subscriber subject has less overhead || thanks for that i didnt know about the multicast methodon 18 may 2014 17:54 ""akarnokd"" notifications@githubcom wrote:> this reminds me of the selector-based multicast ie> > sourcemulticast(publishsubject::create o -> concat(1 o> 100))tolist()> > although using a single-subscriber subject has less overhead> > —> reply to this email directly or view it on github  || [rxjava-pull-requests #1123]( successthis pull request looks good || as pointed out by @akarnokd the function could include a subscribeon call that makes subscription asynchronous so i included a countdownlatch to wait for subscription to happen  || how is this operator different from `public final <r> observable<r> publish(func1<? super observable<t> ? extends observable<r>> selector)`? the signature is the same `observable<r> lift(func1<? super observable<t>? extends observable<r>> function)`i (very) often use `publish` in this form when you want to subscribe to a source multiple times || i agree @headinthebox i overlooked that method when proposing the `lift` overload would a non-multicasting alternative be useful as well via `lift(tooperator(function))`?   || closing this out as there is not enough agreement for merging (and it can no longer be merged)discussion can continue at  || ";;;;0;1;;
983;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;some random cleanups (and probably a bug-fix);- removed unused imports - some code style fixes - most likely fixed a potential npe in savedatabaseaction (chosenfile will never be null here  but f might be and is later dereferenced);;982.0;break cyclical compile time dependency on hiderecursivecall;982;   no coverage uploaded for pull request base (`release/2x@64a1180`) [click here to learn what that means]( ` ! thanks for your quick reviews @raphw ! ||;break cyclical compile time dependency on hiderecursivecall;i am working on upgrading the version of mockito in aosp to 2713 using byte buddy and byte buddy android rather than dexmakeras part of that i need to exclude a number of classes which will not compile on android because it does not support java agents/instrumentation the mockito code has always been very well organized and made that very simple to do but in the latest version i found a minor issuethe files i need to exclude are:- src/main/java/org/mockito/internal/creation/bytebuddy/inlinebytebuddymockmakerjava- src/main/java/org/mockito/internal/creation/bytebuddy/inlinebytecodegeneratorjava- src/main/java/org/mockito/internal/creation/bytebuddy/inlinebytebuddymockmakerjavaunfortunately when i do that i get a compile error because mockmethodadvice is trying to use hiderecursivecall from inlinebytebuddymockmaker i looked at the code and it seems as though inlinebytebuddymockmaker depends on inlinebytecodegenerator which depends on mockmethodadvice which depends on hiderecursivecall from inlinebytebuddymockmakerthe only places that actually use hiderecursivecall are mockmethodadvice and inlinebytebuddymockmakertest that depends on inlinebytebuddymockmaker which depends on inlinebytecodegenerator which depends on mockmethodadvice which depends on hiderecursivecall from inlinebytebuddymockmakerso moving hiderecursivecall from inlinebytebuddymockmaker to mockmethodadvice breaks a dependency cycle and allows the inlinebytebuddymockmakerjava file to be excluded without problem also mockmethodadvice seems to be a better place for itif you are happy with this proposal or can suggest a better place for hiderecursivecall then i am happy to submit a fix for this;that seems like a reasonable issue looking forward to your pull request @paulduffin ! || should i make the change in release/2x?on 8 march 2017 at 12:57 tim van der lippe <notifications@githubcom>wrote:> that seems like a reasonable issue looking forward to your pull request> @paulduffin < !>> —> you are receiving this because you were mentioned> reply to this email directly view it on github> < or mute the thread> < > || yes please :) || done ||;1;0;break cyclical compile time dependency on hiderecursivecall;
985;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;981: update javadoc about the  mockito-inline  artifact;this pr 981.;;0;a write-through converterconvertall(list); from javadoc for liststransform:""since functions are not reversible the transform is one-way and new items cannot be stored in the returned list the add addall and set methods are unsupported in the returned list""removal operations are still supportedi would very much like to have a seamless insertion functionality as well this could be easily implemented by adding an optional third argument to transform ""reversetransform""egpublic &ltab> list&ltb> liststransform(list&lta> function&ltab> forward function&ltba> reverse)where reverse is nullable and an overload exists for the original 2 parameter formof course all the insertions methods in the resultant collections would need to be overridden to perform the reverse transform as necessary"; first i dont think we should even consider this unless we introduce a more specific invertibleconverter type  a list to which ""add(e) contains(e)"" returns false is too damn weird a list for mebut second even then i continue to feel that this crosses a certain line so far our transforming views have just been views this takes it to a new level  for now im closing but feel free to add more justification--- ;;;;0;1;;
985;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;981: update javadoc about the  mockito-inline  artifact;this pr 981.;;0;fix hang in hive split source;correctly decrement the outstandingsplitcount in getnextbatch;looks good otherwise ||;;;;1;1;fix hang in hive split sourcecorrectly decrement the outstandingsplitcount in getnextbatch;
985;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;981: update javadoc about the  mockito-inline  artifact;this pr 981.;;0;non-deterministic synchronizedobserverrunconcurrencytest;seeing this fail intermittently:```javalangassertionerror: concurrency test failed: expected:<173500> but was:<151756>    at orgjunitassertfail(assertjava:93)    at rxobserverssynchronizedobservertestrunconcurrencytest(synchronizedobservertestjava:377)    at sunreflectnativemethodaccessorimplinvoke0(native method)    at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:39)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:25)    at javalangreflectmethodinvoke(methodjava:597)    at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:45)    at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:15)    at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:42)    at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:20)    at orgjunitinternalrunnersstatementsrunbeforesevaluate(runbeforesjava:28)    at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:263)    at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:68)    at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:47)    at orgjunitrunnersparentrunner$3run(parentrunnerjava:231)    at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:60)    at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:229)    at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:50)    at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:222)    at orgjunitrunnersparentrunnerrun(parentrunnerjava:300)    at orggradleapiinternaltaskstestingjunitjunittestclassexecuterruntestclass(junittestclassexecuterjava:80)    at orggradleapiinternaltaskstestingjunitjunittestclassexecuterexecute(junittestclassexecuterjava:47)    at orggradleapiinternaltaskstestingjunitjunittestclassprocessorprocesstestclass(junittestclassprocessorjava:69)    at orggradleapiinternaltaskstestingsuitetestclassprocessorprocesstestclass(suitetestclassprocessorjava:49)    at sunreflectgeneratedmethodaccessor7invoke(unknown source)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:25)    at javalangreflectmethodinvoke(methodjava:597)    at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:35)    at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:24)    at orggradlemessagingdispatchcontextclassloaderdispatchdispatch(contextclassloaderdispatchjava:32)    at orggradlemessagingdispatchproxydispatchadapter$dispatchinginvocationhandlerinvoke(proxydispatchadapterjava:93)    at $proxy2processtestclass(unknown source)    at orggradleapiinternaltaskstestingworkertestworkerprocesstestclass(testworkerjava:103)    at sunreflectgeneratedmethodaccessor6invoke(unknown source)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:25)    at javalangreflectmethodinvoke(methodjava:597)    at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:35)    at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:24)    at orggradlemessagingremoteinternalhubmessagehub$handlerrun(messagehubjava:355)    at orggradleinternalconcurrentdefaultexecutorfactory$stoppableexecutorimpl$1run(defaultexecutorfactoryjava:66)    at javautilconcurrentthreadpoolexecutor$workerruntask(threadpoolexecutorjava:886)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:908)    at javalangthreadrun(threadjava:662)```test:  https://githubcom/netflix/rxjava/blob/master/rxjava-core/src/main/java/rx/observers/synchronizedobserverjava; in  ||;;;;0;1;;
985;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;981: update javadoc about the  mockito-inline  artifact;this pr 981.;;929.0;981: update javadoc about the mockito-inline artifact;this pr 981in the javadoc i write that the first version of `mockito-inline` is `276`this artifact was actually offered in version `272` but `275` or earlier it did not work due to the issue #929 so i write like that; ;new mockito-inline artifact does not work;mockito-inline 272buildgradle:```groovyapply plugin: javasourcecompatibility  javaversionversion_1_8targetcompatibility  javaversionversion_1_8repositories {    jcenter()}dependencies {    testcompile junit 412    testcompile orgmockito:mockito-inline:272}```test target:```javafinal class foo {}```test for foo:```javapublic class footest {    @test    public void test() {        mockitomock(fooclass)    }}```test command:```$ /gradlew clean test compilejava:processresources up-to-date compiletestjava:processtestresources up-to-date testcomexamplefootest > test failed    orgmockitoexceptionsbasemockitoexception at footestjava:101 test completed 1 failed:test failedfailure: build failed with an exception```test report:```orgmockitoexceptionsbasemockitoexception: cannot mock/spy class comexamplefoomockito cannot mock/spy because : - final class	at comexamplefootesttest(footestjava:10)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)	at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orggradleapiinternaltaskstestingjunitjunittestclassexecuterruntestclass(junittestclassexecuterjava:114)	at orggradleapiinternaltaskstestingjunitjunittestclassexecuterexecute(junittestclassexecuterjava:57)	at orggradleapiinternaltaskstestingjunitjunittestclassprocessorprocesstestclass(junittestclassprocessorjava:66)	at orggradleapiinternaltaskstestingsuitetestclassprocessorprocesstestclass(suitetestclassprocessorjava:51)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)	at orggradleinternaldispatchcontextclassloaderdispatchdispatch(contextclassloaderdispatchjava:32)	at orggradleinternaldispatchproxydispatchadapter$dispatchinginvocationhandlerinvoke(proxydispatchadapterjava:93)	at comsunproxy$proxy2processtestclass(unknown source)	at orggradleapiinternaltaskstestingworkertestworkerprocesstestclass(testworkerjava:109)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)	at orggradleinternalremoteinternalhubmessagehub$handlerrun(messagehubjava:377)	at orggradleinternalconcurrentexecutorpolicy$catchandrecordfailuresonexecute(executorpolicyjava:54)	at orggradleinternalconcurrentstoppableexecutorimpl$1run(stoppableexecutorimpljava:40)	at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)	at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)	at javalangthreadrun(threadjava:745)```### reason`mockito-extensions/orgmockitopluginsmockmaker` is not included in the mockito-inlinejar```$ jar tvf mockito-inline-272jar      0 sat feb 04 12 54 jst 2017 meta-inf/    25 sat feb 04 12 54 jst 2017 meta-inf/manifestmf```in [the inline subproject]( orgmockitopluginsmockmaker is in `src/resources/mockito-extensions` directoryis this correct?in [the android subproject]( the file is in src/**main**/resources/mockito-extensions;reproducible project:[mockito_issue_929zip]( || seems like our gradle build is not set up to include this file on travis it does work on my local machine though strange things thanks for reporting! ||;1;0;981: update javadoc about the mockito-inline artifact;
985;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;981: update javadoc about the  mockito-inline  artifact;this pr 981.;;981.0;981: update javadoc about the mockito-inline artifact;this pr 981in the javadoc i write that the first version of `mockito-inline` is `276`this artifact was actually offered in version `272` but `275` or earlier it did not work due to the issue #929 so i write like that; ;update documentation about mockito-inline artifact;"mockito documentation currently does not explain ""mockito-inline"" artifact that is used for inline mocking (mocking finals) the main mockito class still contains information on how to configure the inline mocking using a classpath resource";;1;0;981: update javadoc about the mockito-inline artifact;
986;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replaced replaceall with replace;replace is faster  so if no regular expression is needed it is better to use that.  there are a few more places where it can be replaced  but i got confused when it came to escaping;;0;made caturingmatcher threadsafe;in my tests i faced two problems with current capturing matcher1 it exposes its internal store through `#getallvalues()`2 internal data store in capturingmatcher is not threadsafe exposing internal store when interraction with mocked object isnt finished may produce all kind of weird exceptions in tests;@timvdlippe sorry about that  tests all green now ||  merging 986  ||;;;;1;1;capturingmatchergetallvalues returning new arraylist;
986;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replaced replaceall with replace;replace is faster  so if no regular expression is needed it is better to use that.  there are a few more places where it can be replaced  but i got confused when it came to escaping;;0;drop table in hive is not reflecting in presto cli in real time;"hidrop table in hive is not refleting in presto cli when i create one table in hive it is reflected in presto cli within few sec but when i drop a table in hive it was not refleted in presto after several min then i ""quit"" from that instance and reconnect it then it is reflected there that the table is dropped in hive";presto caches metadata fetch from the hive metastore for 2 minutes by default  this is because the hive metastore is slow and unreliable  you can change this setting with the `hivemetastore-refresh-interval` property in you hive catalog properties file || thanks dain  ||;;;;0;1;;
986;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;replaced replaceall with replace;replace is faster  so if no regular expression is needed it is better to use that.  there are a few more places where it can be replaced  but i got confused when it came to escaping;;0;fix synchronizedobserverrunconcurrencytest;it wasnt waiting on all threads before emitting oncompleted;;;;;1;1;fix synchronizedobserverrunconcurrencytestit wasnt waiting on all threads before emitting oncompleted;
994;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix the broken link on 1357 line in mockito.java;the link  mockitojunitrunner.strictstubs  in the 40th section in javadoc [mockito]( interface is broken. i fixed it by changing;;0;provide `optionalpresentinstances` on `fluentiterable`;j@ while `fluentiterable`&nbspis great to use the ""flow"" breaks when i want to collect only present values from optionalsexample:&nbsp&nbspfunction&ltstring optional&ltinteger>> tryparseintfunction&nbsp&nbsp&nbsp&nbsp new function&ltstring optional&ltinteger>>() {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsppublic optional&ltinteger> apply(string s) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn optionalfromnullable(intstryparse(s))&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp}&nbsp&nbsp&nbsp&nbsp}&nbsp&nbspimmutableset&ltinteger> ids  immutablesetcopyof(&nbsp&nbsp&nbsp&nbspoptionalpresentinstances(&nbsp&nbsp&nbsp&nbsp&nbsp&nbspfluentiterable&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspfrom(idstrings)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsptransform(tryparseintfunction)&nbsp&nbsp&nbsp&nbsp)&nbsp&nbsp)this would be a lot easier to read and write:&nbsp&nbspimmutableset&ltinteger> ids  fluentiterable&nbsp&nbsp&nbsp&nbspfrom(idstrings)&nbsp&nbsp&nbsp&nbsptransformandkeeppresent(tryparseintfunction)&nbsp&nbsp&nbsp&nbsptoimmutableset()this would be the new method in `fluentiterable`:&nbsp&nbsppublic &ltt> fluentiterable&ltt> transformandkeeppresent(function<? super e t> function) {&nbsp&nbsp&nbsp&nbspreturn from(optionalpresentinstances(iterablestransform(iterable function)))&nbsp&nbsp}it would be ok to do the transform separately followed by a call to a `presentinstances`&nbspmethod on `fluentiterable` but that method makes only sense for wrapped iterables of type `optional<t>` not `<t>`&nbspin general as this cant be enforced without a separate subclass (""fluentoptionaliterable"") afaik i suggest to add the above method instead";j@ im fine with ""jdk 8 will kinda solve this"" :) || ";;;;0;1;;
994;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix the broken link on 1357 line in mockito.java;the link  mockitojunitrunner.strictstubs  in the 40th section in javadoc [mockito]( interface is broken. i fixed it by changing;;0;fix the broken link on 1357 line in mockitojava;the link mockitojunitrunnerstrictstubs in the 40th section in javadoc [mockito]( interface is broken i  it by changing `{@link mockitojunitrunnerstrictstubs} ` to  `{@link mockitojunitrunnerstrictstubsclass} `; merging 994 ;;;;1;1;fix the broken link in 1357 line in mockitojava;
994;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix the broken link on 1357 line in mockito.java;the link  mockitojunitrunner.strictstubs  in the 40th section in javadoc [mockito]( interface is broken. i fixed it by changing;;0;method argument values might be null thus causing a null pointer exception;;i believe the idea of having an `@nullable` annotation here is to indicate that the elements of the variable-arity argument can be null not that the argument itself can be null from the point of view of a variable-arity method the argument should never be null (it just doesnt make sense) but due to quirks in javas type system its technically possible for example:```createstringsblock((string) null)``````createstring(null)```the first call works around the type system the second call should intuitively result in a non-null argument with a single null element but it does not due to how the call is resolved in general its a good idea to avoid these types of calls to avoid confusion (intellij will even warn you) all this is to say that imo the correct behavior is to fail loudly (maybe with a better error message) when the formal argument to the method is null so at most we should add a `preconditionschecknotnull` call to validate this (cf `arraysaslist` guavas `listsnewarraylist` etc) || closing see  for a fix based on my comments above ||;;;;0;1;;
994;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix the broken link on 1357 line in mockito.java;the link  mockitojunitrunner.strictstubs  in the 40th section in javadoc [mockito]( interface is broken. i fixed it by changing;;0;use @safevarargs for from and merge;a proposed change if we can demonstrate it works with androidsee  for discussionintended to eliminate overloads as defined in https://githubcom/netflix/rxjava/issues/686;;;;;0;1;;
995;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;verifyzerointeractions guarantees zero interactions instead of just delegating to verifynomoreinteractions;989;;0;cachebuilder documentation error; i was looking over the documentation for cachebuilder and saw that maximumsize and maximumweight both state that they would throw an exception if maximum size as already been seti am curious to know if these two behaviours are mutually exclusive or not; this appears to be done already?--- ;;;;0;1;;
995;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;verifyzerointeractions guarantees zero interactions instead of just delegating to verifynomoreinteractions;989;;0;adding rest api documentation and overview content;heres a pull request for rest api doc and overview content;this looks like a good start but i think its too verbose overall could you rewrite it using fewer paragraphs and shorter sentences? ||;;;;0;1;;
995;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;verifyzerointeractions guarantees zero interactions instead of just delegating to verifynomoreinteractions;989;;0;support custom jmh args;support executions of benchmarks such as:```/gradlew benchmarks -pjmh-f 1 -tu ns -bm avgt -wi 5 -i 5 -r 1 *operatorserializeperf*```by default it will run all benchmarks if no args are passed;;;;;1;1;support custom jmh args;
995;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;verifyzerointeractions guarantees zero interactions instead of just delegating to verifynomoreinteractions;989;;989.0;verifyzerointeractions guarantees zero interactions instead of just delegating to verifynomoreinteractions;989`verifyzerointeractions` no longer delegates to `verifynomoreinteractions`instead it fetches the number of invocations made to the mock and checks ifthey are zero failing otherwiseim not sure if the style of my code complies with mockito: please let me know what to change and where to look to make it more mockitoish;"you can always check if you comply with the code by running `/gradlew build` that runs the test and checks the code style :) ||  merging 995  ";misleading behavior of mockitoverifyzerointeractions();"## problemmockitoverifyzerointeractions() actually does not do what it advertises the purpose of this ticket is to discuss whether to change the behavior of this method in mockito 3## detailsbased on user feedback at #977 from @ffissore ""verifyzerointeractions"" api can be misleading when you read that method in test code you expect zero interactions with specified mocks however ""verifyzerointeractions"" is only an alias to ""verifynomoreinteractions"" and in fact it **does not** guarantee that there were zero interactions lets use examples to illustrate the problem## feedback neededplease comment / vote / state your opinion about changing the behavior of ""verifyzerointeractions"" so that it actually ensures that there were **zero** interactions with the mock (regardless if previously verified or not)## examplesbelow examples illustrate current behavior of mockito 2x in case you are puzzled what this ticket is aboutexample 1 - verifynomoreinteractions```javamockfoo()verify(mock)foo()verifynomoreinteractions(mock) //pretty clear i think```example 2 - verifyzerointeractions```javamockfoo()verify(mock)foo()verifyzerointeractions(mock)//above passes because verifyzerointeractions  verifynomoreinteractions//and we already have verified the only method invoked on the mock```example 3 - verifyzerointeractions with regular stubbing```javagiven(mockfoo())willreturn(""x"")assertequals(""x"" mockfoo())verify(mock)foo()verifyzerointeractions(mock)//above passes because verifyzerointeractions  verifynomoreinteractions```example 4 - verifyzerointeractions with new strict stubbing```javagiven(mockfoo())willreturn(""x"")assertequals(""x"" mockfoo())verifyzerointeractions(mock)//above passes because with strict stubbing//stubbed method are implicitly verified when they are ""used""//this is one of key features of strict stubbing (dry dont repeat yourself)```";this was  in #989 ||;1;0;removed try catch block by using ismock;
1007;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed problem with whitespaces in file paths for tests;after i relocated my workspace  i notice some problems with white spaces in file paths. the whitespaces got encoded as %20 and failed on windows. problem was url.tofile()  paths.get(url.touri()).tofile()  is now the correct way to handle files from urls. see   -   -  ? -  ?;;0;should it be comgooglecommonreflectreflection or reflection_s_?; usually all utility classes are in plural form; alternately think of it this way: sets deals with sets futures deals with futuresbut reflection deals with reflection  you dont pluralize ""reflection"" there || ";;;;0;1;;
1007;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed problem with whitespaces in file paths for tests;after i relocated my workspace  i notice some problems with white spaces in file paths. the whitespaces got encoded as %20 and failed on windows. problem was url.tofile()  paths.get(url.touri()).tofile()  is now the correct way to handle files from urls. see   -   -  ? -  ?;;0;fix test failing with java 9-ea+146+;"stack trace in jdk part contains also module name:```javalangassertionerror: expecting: ""[mockitohint] 1 unused -> at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)""to match pattern: ""\[mockitohint\] 1\ unused \-\> at [\w\]+\reflect\nativemethodaccessorimpl\invoke0\(*native method\)"the new regexp handles both variants"; merging 1007 ;;;;1;1;fix test failing with java 9-ea+146+stack trace in jdk part contains also module name;
1007;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed problem with whitespaces in file paths for tests;after i relocated my workspace  i notice some problems with white spaces in file paths. the whitespaces got encoded as %20 and failed on windows. problem was url.tofile()  paths.get(url.touri()).tofile()  is now the correct way to handle files from urls. see   -   -  ? -  ?;;0;fix overflow bug in hashpagepartitionfunction;;;;;;1;1;fix overflow bug in hashpagepartitionfunction;
1007;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed problem with whitespaces in file paths for tests;after i relocated my workspace  i notice some problems with white spaces in file paths. the whitespaces got encoded as %20 and failed on windows. problem was url.tofile()  paths.get(url.touri()).tofile()  is now the correct way to handle files from urls. see   -   -  ? -  ?;;0;yet another unimplemented class in android < 23;from release 20140331```javalangnosuchmethoderror: javautildequeiterator   at rxoperatorsoperationtakelast$takelast$itemobserveroncompleted(operationtakelastjava:83)   at rxobservable$28oncompleted(observablejava:7007)   at rxobserverssafesubscriberoncompleted(safesubscriberjava:73)   at rxobservable$28oncompleted(observablejava:7007)   at rxobserverssafesubscriberoncompleted(safesubscriberjava:73)   at rxsubjectssubjectsubscriptionmanager$subjectobserveroncompleted(subjectsubscriptionmanagerjava:258)   at rxnotificationaccept(notificationjava:153)   at rxsubjectspublishsubject$2call(publishsubjectjava:80)   at rxsubjectspublishsubject$2call(publishsubjectjava:72)   at rxsubjectssubjectsubscriptionmanager$1call(subjectsubscriptionmanagerjava:114)   at rxsubjectssubjectsubscriptionmanager$1call(subjectsubscriptionmanagerjava:57)   at rxobservablesubscribe(observablejava:7076)   at rxoperatorsoperationmulticast$multicastconnectableobservable$1call(operationmulticastjava:48)   at rxoperatorsoperationmulticast$multicastconnectableobservable$1call(operationmulticastjava:45)   at rxobservablesubscribe(observablejava:7080)   at rxobservablesubscribe(observablejava:7003)   at rxoperatorsoperationrefcount$refcountonsubscribe(operationrefcountjava:46)   at rxobservable$1call(observablejava:235)   at rxobservable$1call(observablejava:231)   at rxobservablesubscribe(observablejava:7080)   at rxobservablesubscribe(observablejava:7003)   at rxoperatorsoperationtakelast$takelastonsubscribe(operationtakelastjava:64)   at rxoperatorsoperationtakelast$1onsubscribe(operationtakelastjava:43)   at rxobservable$1call(observablejava:235)   at rxobservable$1call(observablejava:231)   at rxobservablesubscribe(observablejava:7080)   at rxobservablesubscribe(observablejava:7003)   at rxoperatorsoperationmaterialize$materializeobservableonsubscribe(operationmaterializejava:57)   at rxobservable$1call(observablejava:235)   at rxobservable$1call(observablejava:231)   at rxobservablesubscribe(observablejava:7080)   at rxobservablesubscribe(observablejava:7003)   at rxoperatorsoperationtoiteratortoiterator(operationtoiteratorjava:48)   at rxobservablesblockingobservablegetiterator(blockingobservablejava:161)   at rxobservablesblockingobservable$2iterator(blockingobservablejava:459)   at rxobservablesblockingobservablesingleordefault(blockingobservablejava:398)   at rxobservablesblockingobservablelastordefault(blockingobservablejava:278)   at cgeogeocachingnetworkhtmlimagewaitforbackgroundloading(htmlimagejava:223)   at cgeogeocachinggeocachestorecache(geocachejava:1614)   at cgeogeocachinggeocacherefreshsynchronous(geocachejava:1531)   at cgeogeocachingcachelistactivity$loaddetailsthreadrefreshcache(cachelistactivityjava:1154)   at cgeogeocachingcachelistactivity$loaddetailsthreadrun(cachelistactivityjava:1132)````deque` is implemented only starting with api 9;sorry intended to submit this to c:geo closing please delete :) ||;;;;0;1;;
1008;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;used positionwindow for preambleeditor dialog size;now the preamble editor opens with the same size and position as last time. (plus that some unused preferences and guiglobals variables were removed.);;0;provide a comparator<range> that compares first by lower bound then by upper; why range does not implement comparable?i cant use range as key in treemap or treesetfor example:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsptreeset&ltrange&ltinteger>> set  new treeset&ltrange&ltinteger>>()&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspsetadd(range1)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspsetadd(range2)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspsetadd(range3)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspsetadd(range4)```    systemoutprintln(set)```i create rangecomparator (see in attach); minor comment on the sample rangecomparator attached to the ticket:  it does not account for the bound types (open vs closed)a possibility is to implement a comparator in terms of cuts similar approach to used in the internal range implementation but of course that needs access to the cut class which is not exposed || we have come to feel that any such comparator like this is problematic and we dont want to add it users can write their own || ";;;;0;1;;
1008;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;used positionwindow for preambleeditor dialog size;now the preamble editor opens with the same size and position as last time. (plus that some unused preferences and guiglobals variables were removed.);;0;sample usage of soft assertions;could be propagated by the way also in other similar places;" merging 1008  ";;;;1;1;sample usage of soft assertionscould be propagated by the way also in other places;
1008;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;used positionwindow for preambleeditor dialog size;now the preamble editor opens with the same size and position as last time. (plus that some unused preferences and guiglobals variables were removed.);;0;add experimental support for approximate queries;"note most of these are from my sample weight pr the one that needs review is ""experimental support for approximate queries""";;;;;1;1;experimental support for approximate queriescurrently only avg is supported the syntax is:select avg(a)from my_sampled_tableapproximate at 950 confidencethis is disabled by default but can be enabled with the config option analyzerapproximate-queries-enabledtrue;
1008;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;used positionwindow for preambleeditor dialog size;now the preamble editor opens with the same size and position as last time. (plus that some unused preferences and guiglobals variables were removed.);;0;fix premature garbage collection of subscriber;keeping a weak binding onto the subscriber makes it possible to prematurely get the subscriber garbage collected if there are no other references to ithere we chose to pass around the component to which the subscriber is tied in form of a pair (`boundpayload`) this allows the subscribers to get a reference on the (guaranteed non-collected) target without keeping it in the closurethis introduces an interface change but the current implementation is wrong and should never be used (see issues #979 and #1006)an example usage can be seen at  where `selectfrompocketqueries` references the target activity through `pocketqueryliststarget` in the subscribercc @mttkay;"i would like @mttkay to review this as im not very involved in the android side so am not the right person for this || #935 the failure from cloudbees is about  rxoperatorsoperatorpivottesttestconcurrencyandserialization which is untouched and doesnt used any modified code please ignore it || sorry for not responding too much going on right now i hope ill get toit before or by the weekend meanwhile you can try running all the androidsamples using this give it some stress rotations and such and see if yousee any unwanted behavior or memory leaks || the tests pass so the observable is correctly unsubscribed when it becomes invalid or unreferenced ive run a modified version of cgeo in the field using this patch and havent noticed any problem || so i finally had a chance to look into this i see your idea with this but this implementation does not work either (as in it regresses on what this operator sets out to fix: not leaking context) it leaks the activity in every rotation change and it leaks it too when backing out of the activity while the sequence is still in progressat a quick glance this is simply because of the fact that its keeping a strong reference to the subscriber and the subscriber is keeping a strong reference to the activity (since its an inner class) so the weak reference is never cleared in essence this operator now does nothing :-) you could as well have simply subscribed the activity to it without using it and would wind up in the same situationunfortunately its very difficult to unit test this but its very easy to verify in practice: create a sequence that outlives your activity use this operator turn strictmode on and send it through a few config changes even when hitting the back button the subscriber is not released and keeps a reference to the activity and keeps emitting notifications to it in fact ive created the android-samples module as a sandbox for such thingsfrankly at soundcloud weve stopped using any of these operators we simply unsubscribe manually at the appropriate time (again have a look at the samples module it contains examples using managed subscriptions that achieve the same goals) ive went back and forth with these implementations here and no one has found a solution that covers everyones needsthat said i think unless someone is confident to have found a solution that works for everyone my vote is to remove of all these operators from the core library and simply encourage people to manage their subscription references themselves (although i remember @benjchristensen saying that this too is discouraged outside an operator implementation) || for the record heres the code i used (thrown together quickly:)activity:```    @override    protected void oncreate(bundle savedinstancestate) {        superoncreate(savedinstancestate)        setcontentview(rlayoutobserver_activity)        source  (observable<string>) getlastnonconfigurationinstance()        if (source  null) {            source  sampleobservablesnumberstrings(1 200 100)cache()        }        androidobservablebindactivity(this source)                subscribe(new rxobserver<boundpayload<observeractivity string>>() {                    @override                    public void oncompleted() {                    }                    @override                    public void onerror(throwable throwable) {                    }                    @override                    public void onnext(boundpayload<observeractivity string> atboundpayload) {                        systemoutprintln(this)                        textview textview  (textview) findviewbyid(androidridtext1)                        textviewsettext(atboundpayloadpayload)                    }                })    }```output after 7 rotation changes:```d/surfaceflinger(  490): setorientation mfbdev0xb860f9d8 mfbdev->setorientation0xb671ecc0 orientation0i/gralloc_vbox86(  490): setorientation: orientation0i/activitymanager(  466): config changes1480 {10 ?mcc?mnc en_us ldltr sw384dp w384dp h567dp 320dpi nrml port finger qwerty/v/v dpad/v s15}d/dalvikvm( 1481): gc_explicit freed 169k 9% free 3871k/4224k paused 0ms+1ms total 4mse/strictmode( 1481): class comnetflixrxjavaandroidsamplesobserveractivity instances8 limit1e/strictmode( 1481): androidosstrictmode$instancecountviolation: class comnetflixrxjavaandroidsamplesobserveractivity instances8 limit1e/strictmode( 1481):    at androidosstrictmodesetclassinstancelimit(strictmodejava:1)``` || i just thought of another problem (dont we love solving problems!)binding a context reference to an rx notification (in this case through `boundpayload`) introduces a very subtle issue: since `handlerthreadscheduler` posts that data to the android message loop then even if we solve the above issue you create another (often significant) window of time in which you leak that reference since the message plus everything attached to it (the callable that will execute the notification in this case) will stick around until the message is actually processedthats a problem since android stops processing the message loop when going through a rotation change: it literally ignores your messages that queue up until after `onresume` is called on the next instance of the recreated activity so until then you indirectly hold a strong reference to the old activity until its new counterpart is fully constructed and ready to renderfor more information square has written an article about this a while ago: || i spent the afternoon investigating other approaches using `reference` (such as counting via reference queues) but i think it will never work that way we need an external signal whether an activity is still valid and should probably not rely on the garbage collector the obvious but insufficient signals are:1 `isfinishing`: only true if someone requested to destroy the activity but not eg true for a config change2 `isdestroyed`: reports true even before `superondestroy` is called -- great! but only available since api level 17 so practically useless for now (at soundcloud we still support api 9)3 `ischangingconfigurations`: true when going through a config change so would be a perfect complement to 1 but only available since api level 11 so only useful for modern android devicesone other possibility could be to leverage `fragmentmanager`: it has an `isdestroyed` method this would have the benefit of being available to older clients through the support-v4 package ill investigate further || i finally removed my calls to `bindactivity` and `bindfragment` since i manage the subscriptions explicitly i too prefer not to use those mechanisms after all if i have a leak well this is my fault and no different from any other leak :) || thanks @samueltardieu for your feedback would you agree to recommend reverting `bindactivity` and `bindfragment` (to not use weak references) for the 10 release of rxjava and instead focus on providing exhaustive sample code that demonstrates how to properly handle this via subscriptions?i just spent some more time inspecting in which order android processes these messages in different scenarios and found some interesting patterns (unfortunately all this is undocumented and i had to resort to experimentation/observation logging and reading source code)i found that the following seems to be true:**for activities:**- rotation changes: these are atomic wrt life cycle calls when unsubscribing in ondestroy no messages emitted through the main thread scheduler will arrive between onpause of the destroyed activity and onresume of the new activity instance since unsubscribing also releases the reference to the subscriber (and by extension the activity) were already safe and done- finishing via `finish` or back button: destruction in this case is _not_ atomic even unsubscribing in ondestroy will open a window for messages to arrive between onpause and ondestroy however this can be caught with a test for `isfinishing`**for fragments:**- rotation changes: similar rules apply since the fragment life-cycle is bound to the activity life-cycle rotation changes are atomic and no messages are processed between fragment#onpause and fragment#onresume (re)subscribing to an observable should therefore happen in either onresume or onviewcreated since both hooks are called atomically and both guarantee the activity will be attached and the view tree constructed unsubscribing should happen in ondestroyview or onpause respectively- activity finishing: again similarly theres a window of time where messages can arrive in a fragment observer when the attached activity is in the process of being finished which leads me to the conclusion that the fragment validator that was being used was also incompleteso my suggestion is:- discard the idea of automatically unsubscribing from a sequence for now- instead clearly document where a sequence needs to be unsubscribed from- rewrite bindactivity to merely test a bound activity for `isfinishing` and clear the reference in unsubscribe- rewrite bindfragment to also test for `getactivity()isfinishing()`the two helper methods still add value even if they force you to manage subscriptions since they stop messages from being forwarded in the above mentioned cases but it sort of brings us back to where we were a few weeks ago || sorry just to clarify: i meant to say we should keep the `bindfragment` and `bindactivity` helpers but i will rewrite the operator to not use weak references and make the necessary amendments to accommodate for the behavior mentioned abovei will also add samples and more documentation to clarify these shortcomings || please have a look at #1021 we can understand this as a middle ground between the deprecated `operatorobservefromandroidcomponent` and the last experiment using weak references in summary:- you will have to manage subscriptions the only case it auto-unsubscribes is if the activity reports that its scheduled to get finished- its still re-subscribable (a problem we had with the old operator) and i added a sample activity for that case- its still flexible wrt using custom predicates to close the sequence- it still schedules on the main ui threadi think this is far as we can get with this for now i personally dont think its a big deal to have manual subscription management i actually like that level of control you often need it anyway (sometimes you want to always stop listening when the component is paused but other times only when it gets destroyed) || i like your pr (i didnt try it i just read it) i agree that manual subscription is more appropriate i often have a ""resumesubscriptions"" in my components as well as a ""createsubscriptions"" and i add subscriptions there (respectively in `onresume()` and `oncreate()`) and automatically unsubscribe them in my `onpause()` and `ondestroy()` methods || ";;;;0;1;;
1009;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;added enums;used enums instead of explicit ints for the mode of basepanel  how to render cells in maintable  and mode and result for duplicateresolverdialog.;;0;clean up unused imports;during development work orphaned unused imports sometime get leftbehind in the code at best these imports are just redundant atworst they introduce false dependencies in places there arentsupposed to be any dependenciesthis patch removes all those unused imports and adds a checkstylemodule to verify no such redundant imports will be introduced in thefuture;  nice  really nice thank you!!! ||;;;;1;1;clean up unused importsduring development work orphaned unused imports sometime get leftbehind in the code at best these imports are just redundant atworst they introduce false dependencies in places there arentsupposed to be any dependenciesthis patch removes all those unused imports and adds a checkstylemodule to verify no such redundant imports will be introduced in thefuture;
1009;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;added enums;used enums instead of explicit ints for the mode of basepanel  how to render cells in maintable  and mode and result for duplicateresolverdialog.;;0;do not close output buffers on failure;;;;;;1;1;do not close output buffers on failure;
1009;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;added enums;used enums instead of explicit ints for the mode of basepanel  how to render cells in maintable  and mode and result for duplicateresolverdialog.;;0;android - adding a new retainedfragment example;i wanted to augment the current `retainedfragment` example class to address some scenarios i have run into using the patterns defined in the current example  i was hoping to get some feedback on a more complete scenario i have been working on which is the followingon a typical login screen when the user taps a button we want to fire off our network request in an observable we want to show a progress dialog and then show either success or an error dialog when it fails we want to gracefully handle rotation and app switching in case a user does something else after firing off the login call when the user returns we should be able to tell them there was an error or continue forward i tried to address this scenario above but specifically i wanted to try and complete the following- get all the benefits from the current example - ie rotation support- make sure the callbacks are not triggered while the app is not in focus- make the example be triggered by a user action - ie a user tapping a buttonhoping to get some feedback on the example and see if there are any issues with the sample implementation any issues you see here @mttkay or other android rx users?thanks;"this looks fine im just wondering if it really adds much value over the existing sample? its almost identical with the exception of moving subscription logic to `onresume/onpause` instead of `onviewcreated/ondestroyview` and firing the observable manually (via a button click)how about this: to make this sample more interesting over the existing one have the observable toggle the button state you could map a completed notification to a boolean which in turn is used to set the enabled state then at least theres a new dimension to this sample: binding observables to views not just screensalso lets give it a more meaningful name `retainedfragmentactivity2` doesnt convey much meaning to a reader or do you think it will get too verbose? || thanks @mttkay i will go ahead and update the pr with your suggestions this weeki will try and come up with a less verbose but understandable name for the class itself || my updated sample now uses the observable to make the data request and then maps that observable to a boolean value where a user can control the state of the uii also updated the class documentation to closer match the current sampleslet me know what you think || #947] i was wondering is there a reason the samples dont use the `androidobservable` class for binding? are these examples safe in terms of being garbage collected properly? i assume since we are unsubscribing in `onpause` we are fine but i just want to make sureive been following the `androidobservable` classes but havent seen the justification for using them if i am subscribing and unsubscribingany insight on this would be great is this ready for merging after the last commit? || we probably want to wait for @mttkay to sign off on the updated example not sure if he has been able to look at the latest update || upon further investigation this might actually get updated again based on the status of #1021   || i think its fine just land it i look at the samples module as an ever moving target anyway i see some things here that we should take as clues for providing proper operators to bind sequences to views where a notifications value is mapped to a view property i believe this is what the original reactive extensions (and ports like reactivecocoa) already provide but rxjava is lacking since rxjava is client-platform independent (unlike reactivecocoa which was build with the apple sdk in mind from the ground up)there have been a few attempts already at providing such view bindings for android (cf `viewobservable`) but its far from exhaustive hopefully the core elements for android (scheduling on the main looper attaching sequences to screens) have settled and are stable going forward so im open to explore new territory (i really wanted to nail the core use cases first before looking into the ""nice to haves"") || should this be merged? || merge it we can iterate on samples frequently its not that anythingrelies on themon apr 15 2014 11:58 pm ""ben christensen"" notifications@githubcomwrote:> should this be merged?> > —> reply to this email directly or view it on github  || ";;;;1;1;updating the new sample to demonstrate ui bindingthis commit binds the observable to a method where a user can update their ui accordingly;
1012;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;do not suppress instrumentation exceptions;rather propagate them to mock maker that attempts instrumentation. addresses #1005.;;0;setsfilter for navigableset mapsfilterxxx for navigablemap; please consider addingpublic static &lte> navigableset&lte> filter(navigableset&lte> unfiltered&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsppredicate<? super e> predicate)to comgooglecommoncollectsetsthank you!; ;;;;0;1;;
1012;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;do not suppress instrumentation exceptions;rather propagate them to mock maker that attempts instrumentation. addresses #1005.;;0;do not suppress instrumentation exceptions;rather propagate them to mock maker that attempts instrumentation addresses #1005; merging 1012 ;;;;1;1;do not suppress instrumentation exceptions but rather propagate them to mock maker that attempts instrumentation addresses #1005;
1012;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;do not suppress instrumentation exceptions;rather propagate them to mock maker that attempts instrumentation. addresses #1005.;;0;window function should be able to run on distributed nodes;window function can cause memory or cpu pressure if it is executed on a single nodewhen it runs on distributed nodes and has _partition by_ clause  function execution should be run on distributed nodes also;nice!rebased and pushed ;;;;0;1;;
1012;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;do not suppress instrumentation exceptions;rather propagate them to mock maker that attempts instrumentation. addresses #1005.;;0;removed window between the two synchronized blocks;in the original version there was a window between finding a null queue and setting emitting false due to being in different synchronized block if another thread came in this window it created a new queue with its event which was not emitted until another onxxx method was called causing unnecessary event delivery delaywhile running the tests the `serializedobservertesttestnotificationdelay` failed from time to time due to thread timing i havent  this test;#939] strange contrib-quasar tests pass in timely manner on my local machine || thanks for this  benchmarks suggest no meaningful change  which is good as this should have been a change for a case not covered in these tests```benchmark                                                  (size)   mode   samples         mean   mean error    unitsrooperatorserializeperfnoserializationsinglethreaded      1024   avgt         5       45329        1851    ns/oprooperatorserializeperfnoserializationsinglethreaded   1048576   avgt         5       57587        3061    ns/oprooperatorserializeperfserializedsinglestream             1024   avgt         5       67744        2928    ns/oprooperatorserializeperfserializedsinglestream          1048576   avgt         5       73889        2139    ns/oprooperatorserializeperfsynchronizedsinglestream           1024   avgt         5       72970        3083    ns/oprooperatorserializeperfsynchronizedsinglestream        1048576   avgt         5       76640        1677    ns/op```compared with 0173```benchmark                                                          (size)   mode   samples         mean   mean error    unitsroperatorsoperatorserializeperfnoserializationsinglethreaded      1024   avgt         5       45504        1710    ns/oproperatorsoperatorserializeperfnoserializationsinglethreaded   1048576   avgt         5       58600        5647    ns/oproperatorsoperatorserializeperfserializedsinglestream             1024   avgt         5       68610        4596    ns/oproperatorsoperatorserializeperfserializedsinglestream          1048576   avgt         5       71313        2318    ns/oproperatorsoperatorserializeperfsynchronizedsinglestream           1024   avgt         5       73322        3666    ns/oproperatorsoperatorserializeperfsynchronizedsinglestream        1048576   avgt         5       76518        1355    ns/op``` ||;;;;1;1;removed window between the two synchronized blocks;
1018;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;enabled continuous delivery via robust mockito-release-tools project;- continuous delivery pipeline 2.0 (#911) almost implemented!;;0;permit guava to be used with findbugs 200 by altering the jsr-305 dependency; as of 120 guava is still using findbugs 139 and specifically the jsr 305 annotations artifact findbugs 200 has been out for many months now and as their website says:""anyone currently using findbugs 139 should find findbugs 20 to largely be a drop-in replacement that offers better accuracy and performance""furthermore projects using findbugs 200 with guava 12 will run into warnings about duplicate class files when generating packages using maven this is because in findbugs 200 the jsr305 annotations are part of the core annotationsjar and a separate artifact is not required"; guavas use of jsr-305 is a bit of an edge-case in maven with respect to scoping and optionality of dependenciesoptional is intended to be used by code that may have several sets of bytecode needed to compile but only one of which might be used at run-time so optional lets you cut the transitivity off so that the down-stream projects can (and must) declare the one of their choosing)  key use-cases of this would include compiling a framework against several back-end database drivers but only needing whichever one is actually used at runtime or several caching backends etc provided is intended to be used by projects that need dependencies at compile-time but at run-time these will be provided by some other means most notably by the jdk or by a container etc  key use-cases of this would be javaxservlet etc in practice they both behave identically  guavas use is about halfway in between and is still different  we use findbugs to provide an annotation whose bytecode does not have to be present at runtime and if needed will be provided by some other means  but were not choosing from multiple options and were not necessarily running in the container  in our case either mechanism behaves in exactly the same way i chose ""provides"" scope because i knew precisely what behaviour would result (down-stream dependents would have to declare it if they need it) and it was sort of a 50/50 decision on which way to go  and in our case we dont even need any bytecode for @﻿nullable to exist at runtime because its an annotation  so meh?i dont see a problem in changing this to compile/optional but i also dont see a payoff  the dependency resolution mechanism will perform exactly the same way - itll be present at compile/test time and not present in the transitive closure of down-stream dependentsim closing this on the basis of inertia unless anyone cares enough to make an impassioned plea for optional that shows substantial superiority--- ;;;;0;1;;
1018;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;enabled continuous delivery via robust mockito-release-tools project;- continuous delivery pipeline 2.0 (#911) almost implemented!;;0;fix localexecutionplanner handling of null literal projections;disable compiler tests involving untyped nulls;;;;;1;1;fix localexecutionplanner handling of null literal projectionsdisable compiler tests involving untyped nulls and mixed numeric types;
1018;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;enabled continuous delivery via robust mockito-release-tools project;- continuous delivery pipeline 2.0 (#911) almost implemented!;;0;retry() never unsubscribes from source until operator completes;the retry operator re-subscribes to the source observable if a retry is attempted however it never unsubscribes from the source for the previous attempt relying instead on the compositesubscription to cleanup when the operator completes this could cause problems esp with infinite retry operatorsive created a test + possible fix to illustrate the problem but its perhaps not the cleanest fix solution only applies for async observables as with a sync observable  the error can occur before the subscription has been returned (so there is no obvious way to unsubscribe);thank you for submitting a unit test and fix i pulled in your code and modified it somewhat to use serialsubscription which is intended for this type of use case and merged:  || ah figured there had to be a nicer way ;;;;0;1;;
1018;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;enabled continuous delivery via robust mockito-release-tools project;- continuous delivery pipeline 2.0 (#911) almost implemented!;;911.0;enabled continuous delivery via robust mockito-release-tools project;- continuous delivery pipeline 20 (#911) almost implemented!- removed tons of release logic complexity now all that is a part of general purpose mockito release tools project- the new release automation should be much easier to test;  does this also implement the logic to only publish a release once every x weeks? || >does this also implement the logic to only publish a release once every x weeks?it will be simpler let me finish off the documentation so that everything is clear good question! || i will be merging soon readmemd contains information about the releases more documentation will be provided but it should not blocking this pr! || more documentation on [spanking new wiki page]( plan to merge today || really excited for this change thanks for the great work @szczepiq ! || just merged this puppy ill keep an eye on the release automation things might be bumpy for the next week or so until the dust after this change drops down and all fallout is cleaned up :)thank you guys for patience! more documentation and improvements i will duly provide in the meantime shoot feedback || @szczepiq does this also close #618? || >@szczepiq does this also close #618?i suggest we leave #618 open for now so that its a place for discussion || btw thank you for updating #618 thread with the status! ||;mockito continuous delivery pipeline 20;"proposed changes on easy-to-grasp diagrams are documented on [mockito blog article]( current release modelevery code change results in a new version in central repository (not snapshot a real version) more information on [continuous delivery in mockito]( high rate of new versions the community and current tooling is not comfortable in taking in new mockito versions at fast pace more feedback and the discussion in issue #618## proposed changesrelease every change but not all releases go to central push to standard repository (jcenter / maven central) only substantial releases push remaining versions to less prominent but still public space for early adoptersglossary: what are major minor patch versions? explanatory example: version 265 has major2 minor6 patch51 every merged pull request produces new version that lands in bintray ""mockito/maven"" repo2 some versions we produce are ""notable versions"" by default those are new major (300 400) and new minor versions (310 320) in contrast to regular new versions the notable versions are included in well-known central repositories: jcenter and maven centralfor more details see the wiki page paragraph on [continuous delivery]( action list-  - configure 2722 as last notable version because it was the last version published to central- release notes:  -  - detailed release notes link to notable release notes and vice versa  -  - release notes inform where the jars can be found (  -  - link to wiki documentation-  - publish next notable version-  - procedure of promoting to notable release is documented -   - the new release model is comprehensively documented -   - release notes have clean format (  - notable release (target repo) can be forced by commit message## implementation details-  https://githubcom/mockito/mockito/blob/release/2x/readmemd#how-to-release-new-version";"> every minor or major version change lands in bothi do agree for major but for minor i am not sure i think we should not immediately release a new minor version when 1 function was added most notably because we might want to add a range of functions in all separate prs (since they are separate logical units) therefore i would say to not do it automatically but presumably faster than with patch releases eg minor every week published patch every month> example: “community” repo has 281 282 283 at the end of the month 283 is promoted to productionthis means that 281 and 282 are never available on production? i do think we should push this for 1 consistency in release versions and 2 if someone finds an issue with a version in `production` he/she can bisect using the in-between patch releases to see which version contained the error> im not completely happy with repository naming ""community"" and ""production""maybe `trunk` and `production`?> new version is published under following conditionsi would like to add an override here for to be able to push a new version eg not pushing an existing version to production but publishing a new version without manually editing javadoc to artificially trigger the release mechanismoverall i agree with the proposal just some small comments glad that we are taking action in this direction  great feedback thank you!>i do agree for major but for minor i am not sure i think we should not immediately release a new minor version when 1 function was added most notably because we might want to add a range of functions in all separate prs (since they are separate logical units) ""minor"" version (eg middle number :) is not automatically bumped by the system its us (or the pr submitter) that makes a judgement call to explicitly bump minor version this decision is based on the gravity of the changes we dont bump minor version unless it has substantial changes if it does have substantial changes it probably should be released to mass audience at least this is my reasoning if we dont automatically publish minor versions we can end up with versioning scheme where ""community"" and ""prod"" repo have pretty much random versions if we publish minor versions automatically ""prod"" contains announcable significant versions that add substantial value eg 310 320 330 and occasional patch release like 331 ""community"" repo would have all changes 310 311 312 313 320 etc thoughts?>this means that 281 and 282 are never available on production? i do think we should push this for 1 consistency in release versions and 2 if someone finds an issue with a version in production he/she can bisect using the in-between patch releases to see which version contained the errorthe idea is to only include substantial versions in official repo if the user wants to bisect he needs configure ""community"" repo explicitly in pom / buildgradle in short the answer to your question is yes 281 and 282 will never be in ""production"" repo>maybe trunk and production?lets keep thinking some other ideas: all-versions/announcable-versions all-artifacts/significant-artifacts early-adopters/slow-adoptersgiven that ""minor"" version (eg middle one) is updated explicitly by the pr submitter he controls >i would like to add an override here for to be able to push a new version good idea i will add it to the designreally nice feedback thanks! we can tweak/iterate the process as we learn more too || > we dont bump minor version unless it has substantial changesmakes sense 👍 > in short the answer to your question is yes 281 and 282 will never be in ""production"" repoi think for claritys sake they should be pushed it would be weird to browse maven central and see missing versions lets see what the others think> lets keep thinkinglatest - stable? || > > in short the answer to your question is yes 281 and 282 will never be in ""production"" repo> i think for claritys sake they should be pushed it would be weird to browse maven central and see missing versions lets see what the others thinki can think of two popular projects which sometines skip versions:- [maven]( missing versions eg 332 334-338 (and upcoming 350 will skip 340)- [tomcat]( missing versions eg 8510 857 8040 || @arend-von-reinersdorff thank you for feedback and examples!@timvdlippe currently i most like following naming scheme for repositories: ""all-versions"" and ""notable-versions"" || this looks good! i agree with the model where minor versions are in release channel (notable-versions) and patch versions are in beta channel (all-versions) modulo hot fixes if patch versions are pushed to notable-versions _at the time they are released_ you defeat the purpose of the release channel your ""notable versions"" channel would churn multiple times daily againmaybe mockito can push all interleaved patch versions available only on the beta channel to the release channel when the release channel is updated? for example ```release channel – 230beta – 230 231 232```after:```release channel – 230 231 232 233 (hotfix)beta – 230 231 232 233```this may go against the principle of least surprise since someone browsing the version history of release channel will notice that suddenly not one but three new versions became visible this may be acceptable if bisecting and keeping full version history on the release channel are important for the project as i said before i dont have a strong preference for this model except to say that patch versions should not appear in the release channel _at the time of their release_ unless they are hot fixes || i have an alternative opinion from everything proposed so far i propose introducing the usage of the `classifier` attribute to differentiate between community and production releases with this proposal the current cd procedure would be left unchanged and consumers who want to subscribe to the latest releases can continue to do so with no changes for those consumers who want to limit the thrashing on taking updates they can do so by declaring a `weekly` classifier the only change to the current release process would to be to release the most recent tag with the additional classifier attached it could be weekly or monthly```xml<!-- current usage unchanged! --><dependency>    <groupid>orgmockito</groupid>    <artifactid>mockito-core</artifactid>    <version>275</version></dependency><!-- using the `weekly` classifier --><dependency>    <groupid>orgmockito</groupid>    <artifactid>mockito-core</artifactid>    <classifier>weekly</classifier>    <version>271</version></dependency>```this could also be inverted to restore the delayed release process to the majority of consumers and allow opting in to the daily/continuous releases```xml<dependency>    <groupid>orgmockito</groupid>    <artifactid>mockito-core</artifactid>    <classifier>daily</classifier>    <version>275</version></dependency><dependency>    <groupid>orgmockito</groupid>    <artifactid>mockito-core</artifactid>    <version>271</version></dependency>``` || @mattnelson that is an interesting concept i had not heard of! i am not sure though if it would be valid for our usecase but definitely worth investigating || @mattnelson interesting idea! at this point i want avoid using classifiers because they would complicate things if you get this working for some project or there is a reference project that uses this method we would like to know the experiences@tinkerware thanks for feedback! || @szczepiq i think we can close this issue as well and direct any further discussion to the shipkit repository? || closing this per rationale in #618 and our implementation available at  || ";1;0;merge branch release/2x into sf;
1022;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added highlighting of differences in merge entries dialogs and made s…;based on an issue i cannot find at the moment. - show all information in the merge entries fields - show the difference between fields  may not be the worlds most advanced formatting and diff algorithm but it works (it seems).  ![clipboard01]( -  ? -   -  ?;;0;immutablelist<e> enumuniverse(); in the jdk enumset and enummap use internal magic to get access to a shared array of the ""universe"" of constants for that enumid like to see something along the lines of&nbsp&nbspimmutablelist&lte> enumsenumconstants(class&lte> clazz)that provides safe preferably globally cached access to the enum constants for a class either by using reflection to cheat access to clazzgetenumconstantsshared() or by sunmiscsharedsecrets like enumset itself does or by doing its own caching somehow(i was attempting to write a discretedomain for enum types and copying the universe array grated slightly)"; bleah im really dumb--- ;;;;0;1;;
1022;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added highlighting of differences in merge entries dialogs and made s…;based on an issue i cannot find at the moment. - show all information in the merge entries fields - show the difference between fields  may not be the worlds most advanced formatting and diff algorithm but it works (it seems).  ![clipboard01]( -  ? -   -  ?;;0;matcherstest numeric literals;use numeric literals which are more elegant instead of casting int literals to other primitive types; merging 1022  < ;;;;1;1;matcherstest numeric literalsuse numeric literals which are more elegant instead of casting intliterals to other primitive types;
1022;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added highlighting of differences in merge entries dialogs and made s…;based on an issue i cannot find at the moment. - show all information in the merge entries fields - show the difference between fields  may not be the worlds most advanced formatting and diff algorithm but it works (it seems).  ![clipboard01]( -  ? -   -  ?;;0;initial pull request for spi documentation;heres an initial pull request for the spi documentationthe strategy here is to simply walk users through the example- connector (and eventually the cassandra connector)   the apirst is an attempt to create an overview of the interfacts and each example section is an attempt to comment on and annotate the more important sections of the spi;im in the middle of a refactoring of the spi to simplify the implementation of the connectorxxx interfaces ||  please remove the dependency list that should not be in the documentation ||;;;;0;1;;
1022;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added highlighting of differences in merge entries dialogs and made s…;based on an issue i cannot find at the moment. - show all information in the merge entries fields - show the difference between fields  may not be the worlds most advanced formatting and diff algorithm but it works (it seems).  ![clipboard01]( -  ? -   -  ?;;0;merging streams from future-based subscriptions fails for rxjava > 017;"hithe merge() operation fails for me starting from rxjava>017 i refactored to the new onsubscribe idiom as follows:```public class responseonsubscribe implements observableonsubscribe<response> {    @override    public void call(subscriber<? super response> subscriber) {        try {            future<response> f  builderexecute(newasynchandler(subscriber))            subscriberadd(subscriptionsfrom(f))        } catch (ioexception e) {            throw throwablespropagate(e)        }    }}``` you see i add create a subscription from a future and add it the the subscriberi also provide a convenience factory method to create an observable:```    public static observable<response> create(final async builder) {        return observablecreate(new responseonsubscribe(builder))    }```when i construct a merged observable like so:```    @test    public void testmerge() {        async client  new async        observable<response> obs1  ningobservable                create(clientprepareget(""        observable<response> obs2  ningobservable                create(clientprepareget(""        observable<string> bodies  observable                merge(obs1 obs2)                map(responsestostring)        bodiestoblockingobservable()foreach(actionssystemout)    }```i recognize the following behavior and exception:```javautilconcurrentcancellationexception    at comning    at rxsubscriptionssubscriptions$2unsubscribe(subscriptionsjava:76)    at rxsubscriptionscompositesubscriptionunsubscribefromall(compositesubscriptionjava:175)    at rxsubscriptionscompositesubscriptionunsubscribe(compositesubscriptionjava:168)    at rxsubscriberunsubscribe(subscriberjava:59)    at rxsubscriptionscompositesubscriptionremove(compositesubscriptionjava:138)    at rxoperatorsoperatormerge$1$innerobservercleanup(operatormergejava:103)    at rxoperatorsoperatormerge$1$innerobserveroncompleted(operatormergejava:85)    at orgurbaniakningchunkedonsubscribe$1oncompleted(chunkedonsubscribejava:47)    at orgurbaniakningchunkedonsubscribe$1oncompleted(chunkedonsubscribejava:38)```what happens (imho) is that compositesubscriptionjava:168 prematurely unsubsribes from any streams that are not completed yeti recognized this behavior in my code starting from  i missing something or is my assumption about the behavior of merge() fundamentally wrong or do i use the 017 facilities in a wrong way?a minimal failing implementation is available at  for 017x and a working version for 016x at  a mvn test will reveal the failing tests on the consolethanks for any pointers and thanks for this very great library!!!sergiusz";"it will call `unsubscribe` on each `observable` after it completes this is what `merge` is supposed to do but wasnt before 017 which is why youre just now seeing this in your codeyou can see the code here:  and the issue that resulted in this change at  this memory leaks can occur if you look at the code youll see that it only calls `unsubscribe` when `oncomplete` or `onerror` is received by calling `childsubscriptionsremove(this)` and unsubscribing only the currently terminated `observable` not all others i think the problem is that your code is emitting a `response` object that is tied to the `future` and that it fails even if cancelled ""after"" having received a successful response an `observable` can (and should) be unsubscribed as soon as it emits `onerror` or `oncompleted` see section 43 of rx design guidelines for more on this:```43 assume resources are cleaned up after an onerror or oncompletedmessageparagraph 41 states that no more messages should arrive after an onerror or oncompleted message this makes it possible to cleanup any resource used by the subscription the moment an onerror or oncompleted arrives cleaning up resources immediately will make sure that any side-effect occurs in a predictable fashion it also makes sure that the runtime can reclaim these resources```thus you should not emit anything to `onnext` that relies upon `unsubscribe` not having been called since you cant control the processing later in the sequence (it can be delayed buffered rescheduled etc) and should be pure data in this particular example just emit the value of the `response` rather than `response` itself and it should work || thanks a lot for your extensive answer and for taking your time! i refactored my code to emit a string instead of the original response object but observed still the very same behavior i was also aware of the rx design guidelines and the design principle not to emit values that rely on possibly cleaned resources (the future in this case) and did not see any references to the original future in the response objectbut you brought me on the right track by explaining the intended behavior of operatormerge and by looking at the stacktrace more carefully the cause of the problem is a side-effect which became visible after the #897 optimizations what happens is the following:assuming you have two streams 1 and 2 being merged together:1 stream 1 completes2 operatormerge unsubscribes from stream 1 as per #897 earlier than in previous implementations3 the unsubscription operation is delegated to calling cancel() on the future of stream 14 now (unfortunately) whenever you call cancel() on the request future the apache ning library calls asynchandler#onthrowable() with an instance of a juccancellationexception as per     the asynchandler#onthrowable() callback propagates the cancellationexception to stream 1s observer by calling obs#onerror(throwable)6 the underlying mergeoperator (correctly) propagates the thrown exception and also finishes stream 2 prematurely with an errormy workaround unfortunately is to ignore a concrete cancellationexception in the callback (and abusing exceptions for control flow :-( ):```@overridepublic void onthrowable(throwable t) {  if (!(t instanceof cancellationexception)) {    obsonerror(t)  }}``` || am i reading that correctly that the future always will emit an exception even if already successfully completed? || that is the behavior i am observing here is the set of string messages gathered by a concurrentlinkedqueue replaying the stream of merged events without the instanceof check and stream 1 ending before stream 2:```onnext stream 2onnext stream 1onnext stream 1onnext stream 2onnext stream 2onnext stream 1onnext stream 2onnext stream 1onnext stream 2onnext stream 1onnext stream 2oncompleted stream 1unsubscribe: stream 1 (thus calling futurecancel())onerror stream 1 (received javautilconcurrentcancellationexception because the future was cancel()ed and propagating to onerror)unsubscribe: stream 2 (unsubscribed due to error)``` || to be more precise: i observe this behavior if and only if one cancel()s (via unsubscribe()) a ning request future that is already completed (as is done in observable#merge())if one unsubscribes to a future that has not completed yet (ie by using observable#take()) the cancellationexception is not being emittedthis behavior really is dependent on the library you use (in my case ning) || id suggest this is a bug with the ning future since it shouldnt do anything if cancel() is called if it has already received a successful response || closing my issue as there is nothing to be done in rxjava || ";;;;0;1;;
1023;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix broken link in mockito javadoc;commit  6a82c030756a30932406d6b807e7ca34f20631e3 (included in mockito 2.7.14) changed;;0;linkedlistmultimap doesnt properly present types to gwt for serialization;r@ in one of my dtos i have:private linkedlistmultimap&ltattribute string> attributes  linkedlistmultimapcreate()attribute is a gwt enum:public enum attribute implements isserializable {```// a bunch of stuff includingcanpublishcanexport```}when i compile this with gwt i see linkedlistmultimap in the generated rpc file but not the attribute enum thus it is not included in the serialization whitelist and i get a stacktrace (from gwt) like:comfooattribute was not included in the set of types which can be serialized by this serializationpolicy or its class object could not be loaded for security purposes this type will not be serialized: instance  canexport[info]  at comgooglegwtuserserverrpcimplserverserializationstreamwriterserialize(serverserializationstreamwriterjava:619)[info]  at comgooglegwtuserclientrpcimplabstractserializationstreamwriterwriteobject(abstractserializationstreamwriterjava:126)[info]  at comgooglecommoncollectlinkedlistmultimap_customfieldserializerserialize(linkedlistmultimap_customfieldserializerjava:52)[info]   51 more[error] sun jun 03 16 56 edt 2012 applicationwhen i add a field to my dto as follows:private attribute cheatthe enum is picked up by the gwt compiler and everything works in a beautiful and harmonious way thus i believe that somehow linkedlistmultimap is hiding the types from gwt; no worries--- ;;;;0;1;;
1023;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix broken link in mockito javadoc;commit  6a82c030756a30932406d6b807e7ca34f20631e3 (included in mockito 2.7.14) changed;;0;fix broken link in mockito javadoc;commit  6a82c030756a30932406d6b807e7ca34f20631e3 (included in mockito 2714) changed`mocksetting#useconstructor`s signature to accept an `object` argument while this change is backwards compatible (as calls can continue passing an empty argument list) it broke the javadocreference to `useconstructor()` in mockitos javadoc;thanks @mureinik ||   merging in release mode as release after #1021 was skipped due to no change in artifacts ||;;;;1;1;fix broken link in mockito javadoccommit 6a82c0 (included in mockito 2714) changedmocksetting#useconstructors signature to accept an objectargument while this change is backwards compatible (as calls cancontinue passing an empty argument list) it broke the javadocreference to useconstructor() in mockitos javadocthis patch fixes that broken link;
1023;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix broken link in mockito javadoc;commit  6a82c030756a30932406d6b807e7ca34f20631e3 (included in mockito 2.7.14) changed;;0;initial pull request for sql documentation;adding documentation for select clauses types lexical structure;rebased and ;;;;0;1;;
1023;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix broken link in mockito javadoc;commit  6a82c030756a30932406d6b807e7ca34f20631e3 (included in mockito 2.7.14) changed;;0;retry with onerrorresumenext;"hi guysfound another bug that is critical from my point of view:when using both retry and onerrorresumenext combinators the ""original"" sequence is being consumed after errorexample:``` scalaval brokenstream  observableinterval(500 millis)map(randombreak(_))brokenstream    retry(retrycount  3)    onerrorresumenext(observableempty)    subscribe(println(_))```in this example after 3 errors the subscriber switches to the alternative (empty) sequence correctly but the original `brokenstream` sequence is continued being consumed non stop it can easily be seen by writing a log inside the `randombreak` functionthis bug is not reproducible when only `retry` or only `onerrorresumenext` combinators are used using both causes the problem";"i believe this is solved as of 0183 when the operators were migrated to use `lift` i tried confirming with this code:``` javaimport rxobservableimport rxsubscriberimport rxschedulersschedulerspublic class testretryonerrorresumenext {    public static void main(string args) {        observable<long> o  observablecreate((subscriber<? super long> s) -> {            long l  0            while (!sisunsubscribed()) {                systemoutprintln(""emitting l: "" + l)                sonnext(l++)                if (l > 10) {                    sonerror(new runtimeexception(""forced failure""))                    break                }            }        })subscribeon(schedulerscomputation())        oretry(3)onerrorresumenext(observableempty())subscribe(systemout::println)        try {            threadsleep(1000)        } catch (interruptedexception e) {            eprintstacktrace()        }    }}```if the issue still exists in 0183+ please re-open this with a unit test || ah fix was in  || ";;;;0;1;;
1025;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;added ieee pdf fetcher;pdfs can now be automatically downloaded from ieee xplore  given that you have ip-based access (if not  nothing should happen). -  ? -   -  ? -  ?;;0;genericsignatureformaterror while using typesetrawtypes(); typetokenof(klass)gettypes()rawtypes() with klass  class comgooglecommoncollectabstractmultimap$wrappedlist$wrappedlistiterator is throwing javalangreflectgenericsignatureformaterrorim using guava 120i think that exception should be catched at comgooglecommonreflecttypetokengetgenericinterfaces(typetokenjava:330) and a simple getrawtype()getinterfaces() used in that case no ?here is the stack trace :caused by: javalangreflectgenericsignatureformaterror&nbsp&nbsp&nbsp&nbspat sunreflectgenericsparsersignatureparsererror(signatureparserjava:103)&nbsp&nbsp&nbsp&nbspat sunreflectgenericsparsersignatureparserparsesimpleclasstypesignature(signatureparserjava:262)&nbsp&nbsp&nbsp&nbspat sunreflectgenericsparsersignatureparserparseclasstypesignaturesuffix(signatureparserjava:270)&nbsp&nbsp&nbsp&nbspat sunreflectgenericsparsersignatureparserparseclasstypesignature(signatureparserjava:244)&nbsp&nbsp&nbsp&nbspat sunreflectgenericsparsersignatureparserparseclasssignature(signatureparserjava:171)&nbsp&nbsp&nbsp&nbspat sunreflectgenericsparsersignatureparserparseclasssig(signatureparserjava:126)&nbsp&nbsp&nbsp&nbspat sunreflectgenericsrepositoryclassrepositoryparse(classrepositoryjava:34)&nbsp&nbsp&nbsp&nbspat sunreflectgenericsrepositoryclassrepositoryparse(classrepositoryjava:23)&nbsp&nbsp&nbsp&nbspat sunreflectgenericsrepositoryabstractrepository&ltinit>(abstractrepositoryjava:56)&nbsp&nbsp&nbsp&nbspat sunreflectgenericsrepositorygenericdeclrepository&ltinit>(genericdeclrepositoryjava:30)&nbsp&nbsp&nbsp&nbspat sunreflectgenericsrepositoryclassrepository&ltinit>(classrepositoryjava:30)&nbsp&nbsp&nbsp&nbspat sunreflectgenericsrepositoryclassrepositorymake(classrepositoryjava:47)&nbsp&nbsp&nbsp&nbspat javalangclassgetgenericinfo(classjava:2254)&nbsp&nbsp&nbsp&nbspat javalangclassgetgenericinterfaces(classjava:794)&nbsp&nbsp&nbsp&nbspat comgooglecommonreflecttypetokengetgenericinterfaces(typetokenjava:330)&nbsp&nbsp&nbsp&nbspat comgooglecommonreflecttypetokencollecttypes(typetokenjava:557)&nbsp&nbsp&nbsp&nbspat comgooglecommonreflecttypetokenfindalltypes(typetokenjava:543)&nbsp&nbsp&nbsp&nbspat comgooglecommonreflecttypetokenaccess$100(typetokenjava:101)&nbsp&nbsp&nbsp&nbspat comgooglecommonreflecttypetoken$typesetdelegate(typetokenjava:465)&nbsp&nbsp&nbsp&nbspat comgooglecommonreflecttypetoken$typesetdelegate(typetokenjava:446)&nbsp&nbsp&nbsp&nbspat comgooglecommoncollectforwardingcollectioniterator(forwardingcollectionjava:60)&nbsp&nbsp&nbsp&nbspat comgooglecommonreflecttypetoken$typesetrawtypes(typetokenjava:475); ;;;;0;1;;
1025;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;added ieee pdf fetcher;pdfs can now be automatically downloaded from ieee xplore  given that you have ip-based access (if not  nothing should happen). -  ? -   -  ? -  ?;;0;smartprintertest tostring() calls;calling `tostring()` on a string object just returns the same object making such calls useless in most casesthis patch removes such calls from `smartprintertest` making the code a cleaner and easier to read; ;;;;1;1;smartprintertest tostring() callscalling tostring() on a string object just returns the same objectmaking such calls useless in most casesthis patch removes such calls from smartprintertest making the codea cleaner and easier to read;
1025;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;added ieee pdf fetcher;pdfs can now be automatically downloaded from ieee xplore  given that you have ip-based access (if not  nothing should happen). -  ? -   -  ? -  ?;;0;move input from client to presto-main;its not needed by the client (yet) we may move it back later if we decide to exposethis info to clients in a structural way; ;;;;0;1;;
1025;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;added ieee pdf fetcher;pdfs can now be automatically downloaded from ieee xplore  given that you have ip-based access (if not  nothing should happen). -  ? -   -  ? -  ?;;0;concurrency issue in replaysubject;in our testing weve seen a few arrayindexoutofboundsexceptions in the replay subject ```observable onerrorjavalangindexoutofboundsexception: index: 272 size: 272    at javautilarraylistrangecheck(arraylistjava:635)    at javautilarraylistget(arraylistjava:411)    at rxsubjectsreplaysubjectreplayobserverfromindex(replaysubjectjava:198)    at rxsubjectsreplaysubjectaccess$000(replaysubjectjava:52)    at rxsubjectsreplaysubject$1call(replaysubjectjava:74)    at rxsubjectsreplaysubject$1call(replaysubjectjava:69)    at rxsubjectssubjectsubscriptionmanager$1call(subjectsubscriptionmanagerjava:54)    at rxsubjectssubjectsubscriptionmanager$1call(subjectsubscriptionmanagerjava:48)```;since arraylists internal array and size fields are not volatile they may get out of sync for other threads synchronizing over the history prevents concurrent reads so either we should use readerwriterlock or have a serializedobserverfastlist variant with volatile marked fields || found the issue we had overlapping onnext calls going to the replay subject  wrapping the observable side of the subject with serialized observer resolved the issue || if you got here looking for an answer read more in this issue:  ||;;;;0;1;;
1027;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanups;fixed a number of issues pointed out in eclipse  codacy  and coverity. -   -  ?;;0;sliding window function; interest was expressed in  for a ""sliding window"" function for example taking the list [1 2 3 4] and an argument 2 and returning [[1 2] [2 3] [3 4]]sample use cases cited include moving averages bioinformatics (dealing with rolling windows of a dna sequence) and a few other examplesthe most obvious api seems to be a list&ltlist&lte>> slidingwindow(list&lte> int) returning a viewi guess my biggest concern with this design is that it doesnt seem to match the use cases?  these use cases feel like theyd be better served by maintaining their own deque for the sliding window which seems more appropriate for operations that need to focus on the front and back of the window rather than the window as a whole"; for that application it sounds like using a deque is really what you need to do and i dont think theres much we could do to make that use case easier || we have evictingqueue now making this even easier  || ";;;;0;1;;
1027;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanups;fixed a number of issues pointed out in eclipse  codacy  and coverity. -   -  ?;;0;fix some issues reported by sonarqube;colleague students ran sonarqube on mockito these were some easy fixes i was able to do no extreme value i will open an issue regarding a different and potentially more serious issue; merging 1027  thanks for the input @christianschwarz and @szczepiq ! ||;;;;1;1;fix some issues reported by sonarqube;
1027;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanups;fixed a number of issues pointed out in eclipse  codacy  and coverity. -   -  ?;;0;add presto support for index joins;this is still in development and there are no tests yet those will come at a later time but this is just to get some stuff checked in first;;;;;0;1;;
1027;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanups;fixed a number of issues pointed out in eclipse  codacy  and coverity. -   -  ?;;1024.0;isolate subscriber used for retries cleanup tests;potential fix for #1024there is an outstanding question (see commit comments) about whether its appropriate for the operator to use `unsafesubscribe` given that it does not completely isolate the `subscriber` from a badly behaved `observable`;#946 @benjchristensen can you clarify the usage of `unsafesubscribe`? im also confused now thank you || it wouldnt have been getting `safesubscriber` before `unsafesubscribe` anyways because this operator lives inside `rxoperator` so the wrapping would have been skipped it would have had some extra try/catch error handling in synchronous execution prior to the `unsafesubscribe` change but that should be itthe use of `unsafesubscribe` leaves operators to ensure contracts are kept the `safesubscriber` should really only be used to wrap the user-provided `subscriber` or `observer` at the very end because it has uber-error-handling calls execution hooks etc some operators will definitely need to do special things like unsubscribing such as `merge` and `retry` – but those would not have ever been happening since `isinternalimplementation` checks in `observable` would have prevented these from being wrapped  safesubscriber` before so any bugs found about this should have already existedoperators should just propagate errors or let them throw since the final `safesubscriber` or `lift` will handle them which is why `unsafesubscribe` is as lightweight as it is ill review this code and merge or modify if needed || the fix is good thank you @petermd  ||;possible problem with operatorretry and nested subscription;as reported on the [group]( there is a problem with `operatorretry` in combination with other operatorsi _think_ the issue might be because `operatorretry` re-uses the child subscriber inner compositesubscription causing it to be inadvertently completed (so re-subscribe fails)  added a test and the suggested fix (just use a new subscriber) which does address the problem might also be related #1023;thank you i think you are right i added some comment on your commit could you send a rp? ||  in  thanks @petermd  ||;1;0;isolate subscriber used for retries cleanup tests;
1035;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix nullpointerexception in junit test runner when test fails early in initialization;on case of   mockitoannotations.initmocks(target)   throw any exception  this.target  still null.;;0;add cachegetweight(); we are using a cache with a maximumweight  we expose the cache stats through jmx but we cant report the weight of all items in the cache  it would be nice if cache had a getweight() method; please reopen if a stronger reason comes up--- ;;;;0;1;;
1035;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix nullpointerexception in junit test runner when test fails early in initialization;on case of   mockitoannotations.initmocks(target)   throw any exception  this.target  still null.;;0;fix nullpointerexception in junit test runner when test fails early in initialization;on case of  `mockitoannotationsinitmocks(target)`  throw any exception `thistarget` still nullas impact to throw a **nullpointerexception on all next tests** on the method `defaultinternalrunnertestfinished`what append the method testfinished is never call on case of any error on the initialization phase as impact that the listener is not cleanupon next tests the method testfinished will notify the previous listener that have not been unregisteredto avoid this issue the mockitolistener must be remove if test fail and never started> javalangnullpointerexception at orgmockitointernaljunitutiltestnamegettestname(testnamejava:15)	at orgmockitointernaljunitmismatchreportingtestlistenertestfinished(mismatchreportingtestlistenerjava:33)	at orgmockitointernalrunnersdefaultinternalrunner$1$1testfinished(defaultinternalrunnerjava:60)	at orgjunitrunnernotificationsynchronizedrunlistenertestfinished(synchronizedrunlistenerjava:56)`; merging 1035 || for the storry this issue have been detected during a migration from mockito 1x / powermock to mockito 2x after  small compilation issues most of tests will failedlittle bit desperate at first time in reallity most of failures has related to this issue and only few tests requierd a fix to finalize the migrationthanks for your api ||;;;;1;1;mockitotestlistener must be remove on case test fail on the initialization;
1035;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix nullpointerexception in junit test runner when test fails early in initialization;on case of   mockitoannotations.initmocks(target)   throw any exception  this.target  still null.;;0;add missing dependency;;;;;;1;1;add missing dependency;
1035;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix nullpointerexception in junit test runner when test fails early in initialization;on case of   mockitoannotations.initmocks(target)   throw any exception  this.target  still null.;;0;scala cleanup;review by @headinthebox and @samuelgruetter;"#953  does this code still work with older scala versions where [si-7818]( is not yet ? || this change is local to rxjava-scala and doesnt affect clients as long aswe dont support cross-building with the older scala versions we are okon 14 apr 2014 14:40 ""samuelgruetter"" notifications@githubcom wrote:> does this code still work with older scala versions where si-7818 not yet fixed?> > —> reply to this email directly or view it on github  || true ""as long as"" -)but what if someone wants to build it with scala 2102? id find it safer to keep these ascriptions for some time || im fine with that can we formalize what level of backwards source compatibility we guarantee? || #955 also scaladoc mentions [[rxlangscalautilclosing]] that i cant find is scaladoc obsolete? || yes thats obsolete fixes are welcome -) the whole rxlangscalautil package was removed because it contained only timestamped (which was replaced by tuple2) and opening and closing (which were replaced by type parameters or any) || should this be merged? is it a breaking change? || formally that is a breaking change however i dont expect many users to specify closing type parameter explicitly otherwise source compatibility is preserved || #958 looks good || looks good to me should have been done together with `window`  || ";;;;1;1;update doc comments;
1040;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanups;fixed a number of issues  including: - removed unused imports - moved a class - provided get-methods for some fields in jabrefframe;;0;fix javadoc issues;this pr fixes several javadoc issues reported by intellij idea two types of errors are not handled in this pr:- references which gradle is unable to resolve - these references seem to be valid javadoc links so theres either an issue with gradle itself of with the configuration this project is using and needs a deeper look- javadoc tags missing descriptions which require a deeper understanding of the methods in question in order to resolve;we have some other javadoc warnings too might want to take a stab at these too? :) ||   @timvdlippe i was trying to keep the pr minimal but sure ill give it a go and add it to the pr ||;;;;1;1;varargstest#shouldcapturevarargsasarray @throws tagremove a @throws tag for the checked exception that isnt thrown bythis method;
1040;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanups;fixed a number of issues  including: - removed unused imports - moved a class - provided get-methods for some fields in jabrefframe;;0;check for no tpch nodes when generating splits;;;;;;1;1;check for no tpch nodes when generating splits;
1040;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleanups;fixed a number of issues  including: - removed unused imports - moved a class - provided get-methods for some fields in jabrefframe;;0;merge and cleanup of #972;@akarnokd i have manually merged your changes ( and migrated from `action1` to `action0` as we discussed can you review what i did on top of your changes to make sure its correct it seems correct to me but there is some nuanced concurrency here (obviously hence your fixes) and i would appreciate your validation;#956  the changes look fine || great thanks for the review going to merge and releasei really appreciate your involvement on this one thank you ||;;;;1;1;remove redundant action1 observer collection argumentsince the collection is being returned we dont want to also inject it as an argument so i migrated to action0 from action1 as per discussion at https://githubcom/netflix/rxjava/pull/972#issuecomment-38189145;
1041;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;write database type in lower case into the bib file;this finally 963. a quick fix has been introduced in 661eea007e555  but that does not cover the lower case writing of the type.      @comment{jabref-meta: database_type:bibtex }      finally gets      @comment{jabref-meta: databasetype:bibtex }     -   -> this has been introduced in the development versions after the last release  thus no entry required -   -> tests have been adapted to match this new implementation;;0;mapmaker documetation inconsistencies; comgooglecommoncollectmapmaker class api documentation doesnt explicitly state that its caching functionality has been moved to cachebuilder instead there are few methods commented and marked with @﻿deprecated (expiration makecomputingmap) but mapmakers description seems to be outdated and suggests something else:""a builder of concurrentmap instances having any combination of the following features:()- least-recently-used eviction when a maximum size is exceeded- time-based expiration of entries measured since last access or last write- notification of evicted (or otherwise removed) entries- on-demand computation of values for keys not already present""moreover the example doesnt even compile as it uses pre-v10 apii think this should be cleaned-up mapmakermigration wiki page ( gives importatnt information some of which should be included in mapmakers javadoc to avoid confision with cache-related stuff in comgooglecommoncache also what is mapmaker purpose now? soft/weak keys/values concurrentmap implementation only?btw: is mapmaker#expiration going to be removed in v130?"; ;;;;0;1;;
1041;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;write database type in lower case into the bib file;this finally 963. a quick fix has been introduced in 661eea007e555  but that does not cover the lower case writing of the type.      @comment{jabref-meta: database_type:bibtex }      finally gets      @comment{jabref-meta: databasetype:bibtex }     -   -> this has been introduced in the development versions after the last release  thus no entry required -   -> tests have been adapted to match this new implementation;;0;backport fixes of release/2x to master;yeah we did this quite some time ago and this merge was hell i hope i did not screw anything up there are still 7 test failures but i have to get dinner now please review this pr very carefully to make sure i did not introduce regressions into master  ;@timvdlippe why there is just one commit in this pr? it makes harder to determine later on what changes/commits were already  i did it in the same manner as you did in #861 || thank you guys for working on backporting! || okay looking at the travis logs:- we need to remove animalsniffer on `master` ( there are some regressions regarding varargs matching maybe related to matching in java 8 ( possibly an issue with bytebuddy on java 9? 😓 ( cc @raphw - need to not hardcode jdk version since java 9 uses a different format ( error i do not know what is causing it ( maybe a flaky test dont see it in a different build ( || ill take another stab at this soon the longer we wait the worse the merge gets || all right the log has gotten pretty nasty even though i just did `git merge` locally   but most of the updates have been  the only test that now fails is```orgmockitointernalstubbinganswersthrowsexceptiontest > should_throw_mock_exception_without_stacktrace failed    orgjunitcomparisonfailure: [no stack trace its mock] expected:<null> but was:<>        at sunreflectnativeconstructoraccessorimplnewinstance0(native method)        at sunreflectnativeconstructoraccessorimplnewinstance(nativeconstructoraccessorimpljava:62)        at sunreflectdelegatingconstructoraccessorimplnewinstance(delegatingconstructoraccessorimpljava:45)        at orgmockitointernalstubbinganswersthrowsexceptiontestshould_throw_mock_exception_without_stacktrace(throwsexceptiontestjava:35)```this might be a jdk issue but i have no clue why it is suddenly failing ||  merging 1041 ;;;;1;1;merge branch release/2x into backport-fixesalso bump build scan version for gradle 4 compatibility;
1041;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;write database type in lower case into the bib file;this finally 963. a quick fix has been introduced in 661eea007e555  but that does not cover the lower case writing of the type.      @comment{jabref-meta: database_type:bibtex }      finally gets      @comment{jabref-meta: databasetype:bibtex }     -   -> this has been introduced in the development versions after the last release  thus no entry required -   -> tests have been adapted to match this new implementation;;0;add jdbc feature databasemetadatagetcolumns;implement method getcolumns in databasemetadatawith few unit teststhis feature is needed for pentaho/mondrian bi tool compatibility;must redo some things (like rebase) sorry for the disturbance ||;;;;0;1;;
1041;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;write database type in lower case into the bib file;this finally 963. a quick fix has been introduced in 661eea007e555  but that does not cover the lower case writing of the type.      @comment{jabref-meta: database_type:bibtex }      finally gets      @comment{jabref-meta: databasetype:bibtex }     -   -> this has been introduced in the development versions after the last release  thus no entry required -   -> tests have been adapted to match this new implementation;;0;allow global strategy for dealing with onerrornotimplementedexception;it would be very useful to be able to provide a strategy to deal with this via the plugin mechanism in my case id want to wrap the cause of this exception in another exception and rethrow i can imagine the following cases:1 log the exception and rethrow (ie i _only_ want to log unhandled exceptions)2 action the exception and dont rethrow3 translate the exception to something elseid be happy to take a shot at adding this;sounds reasonable perhaps the `rxjavaerrorhandler` can be changed to meet these needs as id rather not have 2 different plugins for handling errors we can incorporate it into 018 or 019 right now we have `public void handleerror(throwable e)` but perhaps that just needs to return `throwable` to allow decorating?heres another plugin for error handling that has worked well:  more powerful plugin though is `rxjavaobservableexecutionhook` between `oncreate` and `onlift` you can decorate every step of an `observable` sequence and intercept all `onerror` invocations this may be another area for you to look at that doesnt need api changes to rxjava just an implementation from your end (we use the `oncreate` one for some fairly creative things in our production environment) || if something is added it should be to rxjavaerrorhandler yes`handleerror` doesnt quite work because it doesnt differentiate between “normal” errors and onerrornotimplemented will look into rxjavaobservableexecutionhook and report back  || i think i worked it out:  seems to work for my simple tests but im not rxjava guru enough to know when this isnt going to be enoughi think this ticket can be closed ||;;;;0;1;;
1058;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;test code refactoring - updated assertj test dependency from 1.x to 2.6.0;make use of assertj 2.6.0 since java 7 is used now for building mockito and assertj 1.x is no longer under development.;;0;add an unmodifiable bloomfilter wrapper; this would be similar in spirit to collectionsunmodifiablemap; kurt aspredicate would make this association obvious and i look forward to this addition  for now i implemented a predicate anonymous inner class   ";;;;0;1;;
1058;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;test code refactoring - updated assertj test dependency from 1.x to 2.6.0;make use of assertj 2.6.0 since java 7 is used now for building mockito and assertj 1.x is no longer under development.;;0;test code refactoring - updated assertj test dependency from 1x to 260;make use of assertj 260 since java 7 is used now for building mockito and assertj 1x is no longer under development;  thank you for updating the version! its nice that you can help us keeping good hygiene of versions - something easy to forget during day-to-day execution of the project :) || youre welcome! ||;;;;1;1;make use of assertj 260;
1058;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;test code refactoring - updated assertj test dependency from 1.x to 2.6.0;make use of assertj 2.6.0 since java 7 is used now for building mockito and assertj 1.x is no longer under development.;;0;memory exhaustion when creating tables;`inmemoryexchange` accepts pages forever until the jvm runs out of memory the sink needs to push back when the queue reaches a certain size; ||;;;;0;1;;
1058;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;test code refactoring - updated assertj test dependency from 1.x to 2.6.0;make use of assertj 2.6.0 since java 7 is used now for building mockito and assertj 1.x is no longer under development.;;0;typo in javadoc;;#976 ;;;;1;1;typo;
1060;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed  typos across the codebase;;;0;cachebuilderspec tests arent actually testing behavior; the ""assertcachebuilderequivalence"" method in cachebuilderspectest admits in the comments that its a hack but at the moment it doesnt do what its meant tospecifically it iterates over cachebuilderclassgetfields() but i suspect its meant to iterate over cachebuilderclassgetdeclaredfields() since cachebuilder _has_ no public fields and getfields() only returns public fields  in short this method is a no-op at the moment(just making the switch directly breaks some of the tests but i havent had time yet to dig through these and determine if they represent actual bugs)"; submitting internally right nowthanks louis :-)--- ;;;;0;1;;
1060;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed  typos across the codebase;;;0;  typos across the codebase;; merging 1060 `  thank you! ||;;;;1;1;fix some typos;
1060;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed  typos across the codebase;;;0;kerberos authentication;i updated the patch and used a concurrenthashmap to hold on to the ugi object im sorry for the code style and is there any guid to make it right?;sorry dont know how to update the original pull request #969 and i created this one || two questions:1) we have a hive connector property `hiveconfigresources` that specifies a list of hadoop configuration files to use have you tried using that to set the appropriate security properties?2) how do we setup an integration environment to test this? for example what do we need to add to a basic cdh4 installation? || im going to close this for now since we dont know how to setup an integration environment to test this if someone can provide those instructions wed be happy to revisit this ||;;;;0;1;;
1060;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed  typos across the codebase;;;0;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;"im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > —> reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple ""absolute"" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  ";;;;0;1;;
1075;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed a few more things + more strings;fewer strings to translate. more swedish strings translated.;;0;streamline assertj and junit4 usage in gradle files and update assertj (v270);it looks like i missed some occurrences of assertj-core 171 in #1058therefore i thought it might be a good idea to add a `dependenciesgradle` file which defines certain dependencies (for now assertj and junit4);  i like this idea! @epeee do you want to take a stab and configure other dependencies like that? it makes the code neatly readable and enforces consistent versioning nice!fyi: the version of dependenciesmockito-release-tools lives in gradleproperties file it probably cannot be placed in dependenciesgradle because that dependency is used in buildscript section this means it is needed when the *gradle file is compiled before any other plugin or apply from is evaluated i mentioning it in case you want to do some experiments in putting versions in gradleproperties file :)changes that help us maintain the project (consistent versions) and make the build logic easier to read are always welcome thank you! || @szczepiq thx for your feedback yes i will do so (configure other dependencies like that) ||;;;;1;1;update assertj (v270);
1075;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed a few more things + more strings;fewer strings to translate. more swedish strings translated.;;0;make unit tests faster;;;;;;1;1;make testsampledrightouterjoin() more obviously correctfix typo in expected query for testsampledrightouterjoin() to use aright join instead of a left join;
1075;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed a few more things + more strings;fewer strings to translate. more swedish strings translated.;;0;operatordebounce;operator debounceissue #1060two notes:- the behavior of the timed debounce has changed in the original if an oncompleted event arrived after an onnext event that last value was lost this new version emits the last value if it can then completes this is consistent with the selector-based debounce operator from before and now- in both overloads when the emission is run in parallel with the oncompleted of the main the last event might or might not reach the client subscriber: one of the threads will grab the last value but the call to the clientoncompleted might prevent the value delivery in the emission thread this couldnt happen in the original as the event emissions where performed under the lock as well we need to decide if we want to handle this corner case;#989  > when the emission is run in parallel with the oncompleted of the mainit seems to me we should ensure delivery and thus let the `onnext` emit `oncompleted` after its done if theres a race || okay ill add the necessary queue-drain logic tomorrow to fix that case || closing due to merge conflicts will post a new pr ||;;;;0;1;;
1076;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixed validation in returnargumentat(int) in case of type erasure on the parameter;1071;;0;"drop the ""immutable"" from the ""toimmutable[set etc]"" methods on fluentiterable?"; im personally in favor of this change it may have a somewhat high cost for users given that theres probably been a fair amount of adoption of fluentiterable already but it _is_ an @﻿beta api and we can deprecate the existing names for one release as usual to give users a chance to switch to the new namesthe other issue is that it may confuse users who dont expect the result to be immutable without the ""immutable"" in the name but the return types and javadoc should make that pretty clear not to mention that theyll get a runtime error as soon as they try to mutate it"; methods with the new names have been added the old names are deprecated until guava 150 at which point theyll be removed--- ;;;;0;1;;
1076;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixed validation in returnargumentat(int) in case of type erasure on the parameter;1071;;0;fix bugs of upper case cassandra schema table column names;;rebased and pushed  i change the commit a bit to hide the api change and added tests to verify the upper case names work as expected  i believe there is a similar problem for upper case column names ||;;;;0;1;;
1076;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixed validation in returnargumentat(int) in case of type erasure on the parameter;1071;;0;it is impossible to provide unsubscribe action;"observablecreate is deprecated and instead comment advises to use observableapply: problem is there is no way to supply unsubscribe action via ""apply"" function for example: ``` scalaval sub  observableapply[int](observer > {      println(""created"")      subscription({println(""unsubscribed"")})    })subscribe(println(_) e > println(""error"") () > println(""complete1""))    readline()    subunsubscribe()    println(""complete"")    readline()```will never produce ""unsubscribed"" string to make it worse replacing ""create"" with ""apply"" will compile and initialize subscription properly it is only unsubscribe will stop work if i have some resource created when subscribing (thread or socket) id like to be able to shutdown it i do not see how it can be done if ""create"" is deprecatedalso i could not find any unit test which would cover this use case subscription ""unsubscribe actions are tested without integration with observable so possible error when ""unsubscribe"" is not called is missing";"in the new api you need to use `subscriberadd` to add a`subscription` eg``` scala  val sub  observableapply[int](subscriber > {    println(""created"")    subscriberadd(subscription({println(""unsubscribed"")}))  })subscribe(println(_) e > println(""error"") () > println(""complete1""))``` || thanks @zsxwing this works well but i still think the comment in obsolete attribute should be corrected because i could not locate any hint how to use new api anywhere || @zsxwing is there a comment somewhere for us to remove? || i will add an example for the subscriber api and update the comment || thanks let me know when we can close this || i thought we agreed to keep create with the old signature || > i thought we agreed to keep create with the old signatureyes i meant updating docs and more examples please help review #1239  docs and example added so closing || ";;;;0;1;;
1076;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixed validation in returnargumentat(int) in case of type erasure on the parameter;1071;;1071.0; validation in returnargumentat(int) in case of type erasure on the parameter;1071 the parameter type inference takes now the type of the actual instanceinto account to avoid type erasure issues in case the parameter isgenericsee also: https://githubcom/mockito/mockito/issues/1071#issuecomment-300091021; merging 1076 ;mockito additionalanswersreturnsfirstarg() doesnt work with generic first arg;_issue concerning [this stackoverflow question]( checked its not working both mockito 1x and 2x_-------------------im trying to mock the typed method `getnameelement` of interface `roomgeneralservice` to return the first arg using mockito `additionalanswersreturnsfirstarg` functionality:**interface to mock**:    interface primarykeyelement<t> {       public string getnameelement(t primarykey)    }    interface roomgeneralservice extends primarykeyelement<string> {       //     }**my test** (note the imports)    import static orgmockitoadditionalanswersreturnsfirstarg    import static orgmockitomatchersany    import static orgmockitomatchersanystring    import static orgmockitomockitowhen    import orgmockitorunnersmockitojunitrunner        @runwith(mockitojunitrunnerclass)    public class sampletest {           @mock       roomgeneralservice roomgeneralservice           @test       public void testfoo() throws exception {          when(roomgeneralservicegetnameelement(anystring()))thenanswer(returnsfirstarg())          //       }    }also ive tried with other combinations but without success so far:    when(roomgeneralservicegetnameelement(matchers<string>any()))thenanswer(returnsfirstarg())    doanswer(returnsfirstarg())when(roomgeneralservicegetnameelement(anystring()))    doreturn(returnsfirstarg())when(roomgeneralservicegetnameelement(anystring()))**error received**:> the reason for this error can be :> 1 the wanted argument position is incorrect> 2 the answer is used on the wrong interaction> > position of the wanted argument is 0 and the possible argument indexes> for this method are :>     [0] object**workaround**:i know i can create my own answer and in fact its working fine if instead of use `returnfirstarg()` i do something like this:    when(roomgeneralservicegetnameelement(anystring()))thenanswer(new answer<string>() {       @override       public string answer(invocationonmock invocation) throws throwable {          return (string) invocationgetarguments()[0]       }    })but i would use `returnfirstarg()` as in the rest of my tests (tests look cleaner) as well as mocking is working fine if the method `getnameelement` would receive an `string` instead a `t` argthanks for the help;@troig mockito checks if the argument type is compatible with the return type to make a misuse ot the api as soon as posible visible  in this case the argument-type object is inferred from the generic type t due to type erasure since object is not a subtype of string mockito throws the exception you seesolution: the issue can by  by inferring the argument-type of the actual argument-instance in case the argument-type is a primitive or the arg is null mockito must fallback and use the type provided by method signature i have a solution ~~that currently doesnt work due to regressions introduced with #1032 (vararg-expansion is broken)~~ || thanks @christianschwarz for you quick answer! ||;1;0; intendation and import issues;
1079;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improded readability of some bibtex test strings;fixed encoding problem in test when running gradle check follow up from #1014   @tobiasdiez;;0;suggestion : setspartition; a method that would partition a set&ltt> with an equivalence&ltt> would be useful; this seems to have transitioned to being about graphs--- ;;;;0;1;;
1079;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improded readability of some bibtex test strings;fixed encoding problem in test when running gradle check follow up from #1014   @tobiasdiez;;0;add documentation for migrating from hive;;;;;;1;1;add documentation for migrating from hive;
1079;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improded readability of some bibtex test strings;fixed encoding problem in test when running gradle check follow up from #1014   @tobiasdiez;;1060.0;operatorcombinelatest;"operator combinelatestissue #1060remarks:- added an overload to observable which accepts any number of sources not sure why it wasnt exposed before? perhaps removed?- relying on just the sos onnext is not enough as leaving the synchronized block allows reordering of onnext calls therefore the combinator uses the trick from serializedobserver to make sure the combination order is consistent with whe winning of the synchronization ""race"" ";#990 ;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;"im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > —> reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple ""absolute"" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  ";1;0;operatorcombinelatest;
1079;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;improded readability of some bibtex test strings;fixed encoding problem in test when running gradle check follow up from #1014   @tobiasdiez;;1065.0; #1065 add information about donothing() method to cannotstubvo…;; ;complement error message;exception from [cannotstubvoidmethodwithareturnvalue]( does not inform about `donothing()` method but i think in many cases it is what user want to do;feel free to open a pr to fix this issue   thanks for the report ||;1;0;changed message according to pr review;
1090;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;1083: interfaces only declare tostring implicitly and should t…;…herefore override it explicitly from the inline mock maker.;;0;non-blocking concurrentbloomfilter?; is it possible to create a concurrent version of bloomfilter?semantics i am looking for:1 ability for multiple threads to call put() simultaneously without blocking2 a put(x) will ensure that all mightcontain(x) calls that occur _after_ it will return true; issue #﻿1134 tracks merging bloom filters of the same size: || my use-case would also benefit from thread safety on bloom filters im rate limiting connections and the underlying framework (netty) is multithreaded merging filters doesnt help in this case because the threads need to see the same data having stale data violates the ""no false negatives"" aspect of bloom filters and makes guavas bloom unsuitable for my applicationi could use synchronization but having profiled bloom it is apparent that most of the processing on my system is generating the hash the way bloom works now- hashing is done on a single core i find this silly since the guavas hash functions are specifically designed to be stateless and thread-safe since ~90% of cpu time is tied up in hash calculation bloom should scale nicely using striped locks im fairly familiar with the bloom code and can submit a patch for thread safety if desired || dupe of #2761 that weve now done || ";;;;0;1;;
1090;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;1083: interfaces only declare tostring implicitly and should t…;…herefore override it explicitly from the inline mock maker.;;0;add backpressure to inmemoryexchange;;;;;;1;1;add backpressure to inmemoryexchange;
1090;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;1083: interfaces only declare tostring implicitly and should t…;…herefore override it explicitly from the inline mock maker.;;0;hangs from unhandled errors when scheduling;"i found a use case where the `unsafesubscribe` combined with `scheduler` since 0175 can cause a hang in certain cases because a terminal event (`onerror` in this case) never gets emittedhere is an example:``` java                innerschedule(new action0() {                    @override                    public void call() {                        ounsafesubscribe(subscriber)                    }                })```in this case if the `observable` being subscribed to throws an exception (breaks the contract) instead of using `onerror` the exception is completely swallowed because its inside a `scheduler` on another threadheres a unit test demonstrating it:``` java    @test    public void testthrownerrorhandling() {        testsubscriber<string> ts  new testsubscriber<string>()        observablecreate(new onsubscribe<string>() {            @override            public void call(subscriber<? super string> s) {                throw new runtimeexception(""fail"")            }        })subscribeon(schedulerscomputation())subscribe(ts)        tsawaitterminalevent(1000 timeunitmilliseconds)        tsassertterminalevent()    }```because its inside a `scheduler` the catch-all inside `lift` does not help this casethere are two options as i see it:1) make every use of `unsafesubscribe` inside a `scheduler` try/catch/onerror2) make `unsafesubscribe` just a tad safer for the broken contract caseoption 1 is not great as all it takes is one mistaken place and we end up with code that hangs without any clue as to whyoption 2 is simple no cost and solves it everywhere it does not defeat the reason for `unsafesubscribe` as this will not involve `safesubscriber` plugin invocation or anything else that should only happen with `subscribe`the code will change from:``` java    public final subscription unsafesubscribe(subscriber<? super t> subscriber) {        onsubscribecall(subscriber)        return subscriber    }```to``` java    public final subscription unsafesubscribe(subscriber<? super t> subscriber) {        try {            onsubscribecall(subscriber)        } catch (throwable e) {            // handle broken contracts            subscriberonerror(e)        }        return subscriber    }```";;;;;0;1;;
1090;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;1083: interfaces only declare tostring implicitly and should t…;…herefore override it explicitly from the inline mock maker.;;1083.0;1083: interfaces only declare tostring implicitly and should t…;…herefore override it explicitly from the inline mock maker;;mockito 2 mock-maker-inline not able to mock object methods on an interface;"hi therei recently upgraded from mockito `195` to `2722` (mockito-inline) and some tests started failed as mockito is unable to mock `objecttostring()` method on an interfaceit appears to be that the inline mock maker cannot mock object methods on an interface using a class (hashset for the below example) or mockito-core instead of mockito-inline makes it work***system:***```os:       windows 10 (version 1703)java:     jdk 18u131mockito:  orgmockito:mockito-inline:2722 //orgmockito:mockito-core:2722 works fine!junit:    junit 412```***sample example that fails:***```javaimport orgjunitassertimport orgjunittestimport orgmockitomockitoimport javautilsetpublic class testinterfacetostring {    @test    public void testinterfacetostring() {        set set  mockitomock(setclass) // change setclass to hashsetclass makes it work        mockitowhen(settostring())thenreturn(""bla"")        assertassertequals(""bla"" settostring())    }}```***output:***```bash""c:\program files\java\jdk180_131\bin\java"" -dideatestcyclicbuffersize1048576 ""-javaagent \program files\jetbrains\intellij idea 201712\lib\idea_rtjar58071 \program files\jetbrains\intellij idea 201712\bin"" -dfileencodingutf-8 -classpath ""c:\program files\jetbrains\intellij idea 201712\lib\idea_rtjarc:\program files\jetbrains\intellij idea 201712\plugins\junit\lib\junit-rtjarc:\program files\java\jdk180_131\jre\lib\charsetsjarc:\program files\java\jdk180_131\jre\lib\deployjarc:\program files\java\jdk180_131\jre\lib\javawsjarc:\program files\java\jdk180_131\jre\lib\jcejarc:\program files\java\jdk180_131\jre\lib\jfrjarc:\program files\java\jdk180_131\jre\lib\jfxswtjarc:\program files\java\jdk180_131\jre\lib\jssejarc:\program files\java\jdk180_131\jre\lib\management-agentjarc:\program files\java\jdk180_131\jre\lib\pluginjarc:\program files\java\jdk180_131\jre\lib\resourcesjarc:\program files\java\jdk180_131\jre\lib\rtjarc:\program files\java\jdk180_131\jre\lib\ext\access-bridge-64jarc:\program files\java\jdk180_131\jre\lib\ext\cldrdatajarc:\program files\java\jdk180_131\jre\lib\ext\dnsnsjarc:\program files\java\jdk180_131\jre\lib\ext\jaccessjarc:\program files\java\jdk180_131\jre\lib\ext\jfxrtjarc:\program files\java\jdk180_131\jre\lib\ext\localedatajarc:\program files\java\jdk180_131\jre\lib\ext\nashornjarc:\program files\java\jdk180_131\jre\lib\ext\sunecjarc:\program files\java\jdk180_131\jre\lib\ext\sunjce_providerjarc:\program files\java\jdk180_131\jre\lib\ext\sunmscapijarc:\program files\java\jdk180_131\jre\lib\ext\sunpkcs11jarc:\program files\java\jdk180_131\jre\lib\ext\zipfsjarc:\users\mina\documents\ideaprojects\testingmockito2\out\production\testingmockito2c:\users\mina\m2\repository\org\mockito\mockito-inline\2722\mockito-inline-2722jarc:\users\mina\m2\repository\org\mockito\mockito-core\2722\mockito-core-2722jarc:\users\mina\m2\repository\net\bytebuddy\byte-buddy\1611\byte-buddy-1611jarc:\users\mina\m2\repository\net\bytebuddy\byte-buddy-agent\1611\byte-buddy-agent-1611jarc:\users\mina\m2\repository\org\objenesis\objenesis\25\objenesis-25jarc:\users\mina\m2\repository\junit\junit\412\junit-412jarc:\users\mina\m2\repository\org\hamcrest\hamcrest-core\13\hamcrest-core-13jar"" comintellijrtexecutionjunitjunitstarter -ideversion5 testinterfacetostringorgmockitoexceptionsmisusingmissingmethodinvocationexception: when() requires an argument which has to be a method call on a mockfor example:    when(mockgetarticles())thenreturn(articles)also this error might show up because:1 you stub either of: final/private/equals()/hashcode() methods   those methods *cannot* be stubbed/verified   mocking methods declared on non-public parent classes is not supported2 inside when() you dont call method on mock but on some other object	at testinterfacetostringsetup(testinterfacetostringjava:20)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:497)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)	at orgjunitinternalrunnersstatementsrunbeforesevaluate(runbeforesjava:24)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orgjunitrunnerjunitcorerun(junitcorejava:137)	at comintellijjunit4junit4ideatestrunnerstartrunnerwithargs(junit4ideatestrunnerjava:68)	at comintellijrtexecutionjunitideatestrunner$repeaterstartrunnerwithargs(ideatestrunnerjava:51)	at comintellijrtexecutionjunitjunitstarterpreparestreamsandstart(junitstarterjava:242)	at comintellijrtexecutionjunitjunitstartermain(junitstarterjava:70)process finished with exit code -1```cheersmina";"your jdk seems fairly outofdate could you update to a more recent version?that should probably fix the issueon mon 15 may 2017 02:56 mina asham <notifications@githubcom> wrote:> hi there>> i recently upgraded from mockito 195 to 2722 and some tests started> failed as mockito is unable to mock objecttostring() method on an> interface>> sample example that fails:>> import orgjunitbeforeimport orgjunittestimport orgmockitomockimport orgmockitomockitoannotations> import javautilset> import static orgjunitassertassertequalsimport static orgmockitomockitowhen> public class testinterfacetostring {>>     @mock>     private set set>>     @before>     public void setup() {>         mockitoannotationsinitmocks(this)>>         when(settostring())thenreturn(""bla"")>     }>>     @test>     public void testinterfacetostring() {>         assertequals(""bla"" settostring())>     }> }>> output:>> ""c:\program files\java\jdk180_45\bin\java"" -dideatestcyclicbuffersize1048576 ""-javaagent \program files\jetbrains\intellij idea 201712\lib\idea_rtjar58071 \program files\jetbrains\intellij idea 201712\bin"" -dfileencodingutf-8 -classpath ""c:\program files\jetbrains\intellij idea 201712\lib\idea_rtjarc:\program files\jetbrains\intellij idea 201712\plugins\junit\lib\junit-rtjarc:\program files\java\jdk180_45\jre\lib\charsetsjarc:\program files\java\jdk180_45\jre\lib\deployjarc:\program files\java\jdk180_45\jre\lib\javawsjarc:\program files\java\jdk180_45\jre\lib\jcejarc:\program files\java\jdk180_45\jre\lib\jfrjarc:\program files\java\jdk180_45\jre\lib\jfxswtjarc:\program files\java\jdk180_45\jre\lib\jssejarc:\program files\java\jdk180_45\jre\lib\management-agentjarc:\program files\java\jdk180_45\jre\lib\pluginjarc:\program files\java\jdk180_45\jre\lib\resourcesjarc:\program files\java\jdk180_45\jre\lib\rtjarc:\program files\java\jdk180_45\jre\lib\ext\access-bridge-64jarc:\program files\java\jdk180_45\jre\lib\ext\cldrdatajarc:\program files\java\jdk180_45\jre\lib\ext\dnsnsjarc:\program files\java\jdk180_45\jre\lib\ext\jaccessjarc:\program files\java\jdk180_45\jre\lib\ext\jfxrtjarc:\program files\java\jdk180_45\jre\lib\ext\localedatajarc:\program files\java\jdk180_45\jre\lib\ext\nashornjarc:\program files\java\jdk180_45\jre\lib\ext\sunecjarc:\program files\java\jdk180_45\jre\lib\ext\sunjce_providerjarc:\program files\java\jdk180_45\jre\lib\ext\sunmscapijarc:\program files\java\jdk180_45\jre\lib\ext\sunpkcs11jarc:\program files\java\jdk180_45\jre\lib\ext\zipfsjarc:\users\mina\documents\ideaprojects\testingmockito2\out\production\testingmockito2c:\users\mina\m2\repository\org\mockito\mockito-inline\2722\mockito-inline-2722jarc:\users\mina\m2\repository\org\mockito\mockito-core\2722\mockito-core-2722jarc:\users\mina\m2\repository\net\bytebuddy\byte-buddy\1611\byte-buddy-1611jarc:\users\mina\m2\repository\net\bytebuddy\byte-buddy-agent\1611\byte-buddy-agent-1611jarc:\users\mina\m2\repository\org\objenesis\objenesis\25\objenesis-25jarc:\users\mina\m2\repository\junit\junit\412\junit-412jarc:\users\mina\m2\repository\org\hamcrest\hamcrest-core\13\hamcrest-core-13jar"" comintellijrtexecutionjunitjunitstarter -ideversion5 testinterfacetostring>> orgmockitoexceptionsmisusingmissingmethodinvocationexception: when() requires an argument which has to be a method call on a mock> for example:>     when(mockgetarticles())thenreturn(articles)>> also this error might show up because:> 1 you stub either of: final/private/equals()/hashcode() methods>    those methods *cannot* be stubbed/verified>    mocking methods declared on non-public parent classes is not supported> 2 inside when() you dont call method on mock but on some other object	at testinterfacetostringsetup(testinterfacetostringjava:20)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:497)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)	at orgjunitinternalrunnersstatementsrunbeforesevaluate(runbeforesjava:24)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orgjunitrunnerjunitcorerun(junitcorejava:137)	at comintellijjunit4junit4ideatestrunnerstartrunnerwithargs(junit4ideatestrunnerjava:68)	at comintellijrtexecutionjunitideatestrunner$repeaterstartrunnerwithargs(ideatestrunnerjava:51)	at comintellijrtexecutionjunitjunitstarterpreparestreamsandstart(junitstarterjava:242)	at comintellijrtexecutionjunitjunitstartermain(junitstarterjava:70)process finished with exit code -1>> using the class hashset instead of the interface set would make the class> work but this feels like a bug to me i havent seen anything in the> release notes about it am i missing something or is this a new bug?>> cheers> mina>> —> you are receiving this because you are subscribed to this thread> reply to this email directly view it on github> < or mute the thread> < > || update above for clarity also added some system specs and minified the example a bit || @timvdlippe is running a recent jdk version a hard requirement for mocking `final` classes/methods via `orgmockito:mockito-inline`? if so please state the minium version needed || @johnjohndoe there is not a minium jdk version for mockito but there are a small subset of errors that are jdk related and  in more recent versions i think all versions > 1845 are good enough for this subset || this is failing on 18131 anyways so i dont think it a jdk issuethis only fails with `orgmocker:mockito-inline` but works fine on `orgmockito:mockito-core` i suspect the inline mocker is not able to extend interfaces properly? || if it is also failing with the latest jdk it probably is an issue with bytebuddy-android cc @raphw  || yes its a bug in the inline mock maker fixed in attached pr || ";1;0;1083: interfaces only declare tostring implicitly and should therefore override it explicitly from the inline mock maker;
1091;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1088 : updating documentation of verify feature to correct a s…;updating documentation of verify feature to correct a supposed typo that results in confusing behaviour when cut  pasted  and run verbatim.;;0;change retention policy of @gwtcompatible to runtime; i have this ant typedef that builds fileset of class files based on annotations present to check if a class is annotated with ""gwtcompatible"" i use classisannotationpresent(gwtcompatibleclass) that didnt work (because gwtcompatible has class retention policy) to work around i now use my own variant of @﻿gwtcompatible that has retentionpolicy of runtime as an enhancement can retentionpolicy of @﻿gwtcompatible be changed to runtime ?"; i have a module that contains both gwt safe and non gwt safe classes  i need to create a jar file that contains only the gwt safe java files from the module to be provided to the eventual ui module that owns the full gwt compile process  that is the requirement im trying to satisfyin order to do this it seemed like a good idea to annotate the classes with @﻿gwtcompatible  then the question became how during our ant build process could we recognize which classes were gwtcompatible in order to build this jar file  we found the grokbase article that defined exactly a manner to do what we wanted that it select java files that contain classes with a specific annotation  the problem is that implementation presumes an annotation that has retentiontype of runtimefrom the ant build file perspective this is a very clear and readable approach that we would like to have and from the annotationselector implementation it is a vary simple implementation given this runtime availabilityis there a particular concern with the runtime availability in general  while class retention states that the annotation is recorded in the class file i dont know of a mechanism to obtain that without trying to actually interpret the byte code itself  how could i implement annotationselector in a simple manner with that constraint?  im not sure i understand the jvm level value provided by the class retention type what does use case does that really provide that source or runtime do not? ||;;;;0;1;;
1091;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1088 : updating documentation of verify feature to correct a s…;updating documentation of verify feature to correct a supposed typo that results in confusing behaviour when cut  pasted  and run verbatim.;;0;rest api documentation;closed the previous pull request  this one addresses several of the issues that @cberner found in the last one  bring on the feedback;;;;;0;1;;
1091;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1088 : updating documentation of verify feature to correct a s…;updating documentation of verify feature to correct a supposed typo that results in confusing behaviour when cut  pasted  and run verbatim.;;0;handle thrown errors with unsafesubscribe;oxymoronic commit here  adding some safety to unsafesubscribe fixes https://githubcom/netflix/rxjava/issues/1090;;;;;1;1;handle thrown errors with unsafesubscribe oxymoronic commit here  adding some safety to unsafesubscribe fixes https://githubcom/netflix/rxjava/issues/1090;
1091;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1088 : updating documentation of verify feature to correct a s…;updating documentation of verify feature to correct a supposed typo that results in confusing behaviour when cut  pasted  and run verbatim.;;1088.0;1088 : updating documentation of verify feature to correct a s…;"updating documentation of verify feature to correct a supposed typo that results in confusing behaviour when cut pasted and run verbatimthe documentation presents the following example of the verify exact number of invocations feature:    //using mock    mockedlistadd(""once"")        mockedlistadd(""twice"")    mockedlistadd(""twice"")        mockedlistadd(""three times"")    mockedlistadd(""three times"")    mockedlistadd(""three times"")        //following two verifications work exactly the same - times(1) is used by default    verify(mockedlist)add(""once"")    verify(mockedlist times(1))add(""once"")        //exact number of invocations verification    verify(mockedlist times(2))add(""twice"")    verify(mockedlist times(3))add(""three times"")        //verification using never() never() is an alias to times(0)    verify(mockedlist never())add(""never happened"")        //verification using atleast()/atmost()    verify(mockedlist atleastonce())add(""three times"")    verify(mockedlist atleast(2))add(""five times"")    verify(mockedlist atmost(5))add(""three times"")the last but one line says:    verify(mockedlist atleast(2))add(""five times"")this could be confusing to someone using these examples as it would result in a toolittleactualinvocations failure being reported by mockito this is because in the example the `add()` method is never called with the string `five times` in order to have this example make sense in the way i think it should ive replaced the string `five times` with `three times` as suggested by @szczepiq cheerstim cooke"; merging 1091 ;javadoc example throws unexpected exception;" verify(mockedlist atleast(2))add(""five times"") - would throworgmockitoexceptionsverificationtoolittleactualinvocationscorrecting this would help to make sure new devs are not confused by the verify use case there<img width""678"" alt""screen shot 2017-05-17 at 8 40 03 pm"" src""https://cloudentcom/assets/10499046/26181818/2241904c-3b41-11e7-8f71-6974d46d5579png"">";"what would you consider to be the correct behaviour here? at a push i might propose a slight change in naming to ""toofewactualinvocations"" but the core behaviour is the sameyour example is confusing because your ""atleast(2)"" verification is on add(""five times"") which suggests five invocations of add() with that string but there are no invocations with that stringwhat do you expect to see here? || i think the expectation is that the code works when it is copy pasted to ide and executed why dont we fix it by changing ""five times"" to ""three times""? do you want to contribute? please do! :) || oh wait i see now its a problem with [the documentation]( sure thing i can update that no problem || thanks folks  || ";1;0;1088 : updating documentation of verify feature to correct a supposed typo that results in confusing behaviour when cut pasted and run verbatim;
1092;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix link to mockito junit rule heading;;;0;fix link to mockito junit rule heading;; merging 1092 ;;;;1;1;fix link to mockito junit rule heading;
1092;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix link to mockito junit rule heading;;;0;merge multiple partitions into a single split by using in clause if the;partitions have same host list;superseded by #1342  ||;;;;0;1;;
1092;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix link to mockito junit rule heading;;;0;restore observableexecutionhookoncreate;;#1002;;;;1;1;reconnecting observableexecutionhookoncreatesomehow this got lost in the refactorings over the past few weeks;
1096;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;inorderimpl constructor signature;replace  list<? extends object>  in the constructor s argument list with a simpler  list<?> .;;0;release 130 breaks builds that dont provide googles findbugs/jsr-305 jar themselves;j@ from release 120 to 130 the scope of the dependency on `comgooglecodefindbugs`/`jsr305`/`139`&nbsphas been changed from default (""compiled"") to ""provided""i havent found this change in the source `pomxml`&nbspfiles yet but the `guava-{12 13}0pom`&nbspdiffers in this regardas a result code that depends on that artifact because it eg uses `javaxannotationnullable`&nbspbreakswas this (afaik undocumented) change intentional?"; what about the fact that jsr 305 is dead in the water? now that eclipse 38/42 supports null analysis annotations i would love to start using them as well and i would love to use the same ones as guava for obvious reasons (the eclipse compiler would handle guavas code as if it was my own telling me which parameters can be null and which nonnull) unfortunately because jsr 305 is not going anywhere i will never be able to convince the powers that be at my company to allow usage of those annotations (these guys are very obsessed about not using any ""beta"" or ""alpha"" software) also one of the annotations (parametersnonnullbydefault) is a bit of a misnomer since it covers return values as well does anybody at google know what the status of this jsr really is? || ";;;;0;1;;
1096;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;inorderimpl constructor signature;replace  list<? extends object>  in the constructor s argument list with a simpler  list<?> .;;0;inorderimpl constructor signature;replace `list<? extends object>` in the constructors argument list with a simpler `list<?>`the `extends object` adds nothing and just serves to confuse the reader; merging 1096 ` ;;;;1;1;"inorderimpl constructor signaturereplace list<? extends object> in the constructors argument listwith a simpler list<?>the ""extends object"" adds nothing and just serves to confuse thereader";
1096;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;inorderimpl constructor signature;replace  list<? extends object>  in the constructor s argument list with a simpler  list<?> .;;0;update overview page;the overview page on the website is out of date (doesnt mention apache 2x) and should be restructured now that we have multiple connectors it would also be nice to have a general list of features on that page (or possibly on another prominent page);;;;;0;1;;
1096;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;inorderimpl constructor signature;replace  list<? extends object>  in the constructor s argument list with a simpler  list<?> .;;1060.0;operatorgroupjoin;operator groupjoinfor issue #1060maybe this could be moved to the new joins;#1006 is this better associated with rxjava-joins? ||;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;"im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > —> reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple ""absolute"" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  ";1;0;operatorgroupjoin;
1118;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;some performance improvements;motivated by the nice blog post from @mlep  i tried to further improve the performance.  starting point  benchmark                         score      error  units benchmarks.parse                 30        ± 2.7  ops/s benchmarks.search                230.359 ±   27.399  ops/s benchmarks.write                 53.323 ±    5.528  ops/s  now with this pr benchmark                         score     error  units benchmarks.parse                 46.965 ±   0.608  ops/s benchmarks.search                304.795 ±   5.905  ops/s benchmarks.write                 85.171 ±   1.301  ops/s  for further improvements on should have a closer look at the formatter: - removelatexcommands for search (70% of time is spent there) - fieldcontentparser and latexfieldformatter for write (also >50%)  (also fixed a bug in the parse benchmarkthis is why the numbers are so different than in my previous post) ##  -   -   -   ();;0;closablesclosequietly should be deprecated or at least needs lots of warnings in documentation; about 95% of all the usage of closequietly i see is broken closequietlys primary purpose right now appears to entice people to write buggy programs thats not a good thingsome explanation is probably warranted the vast majority of closables fall into two categories:a) a readable inputstream or reader the vast majority of implementations of any such streams never actually throw ioexception so the close(readable true) method does nothing of any use whatsoever closequietly lets you dodge the need to formally handle the wont-actually-ever-happen ioexception but this is rarely needed as the close method is usually near the read methods which can and do throw ioexception just pop the close() call into the try block and voilab) a writable outputstream or writer swallowing ioexceptions on close is very very very very bad and something that the mere existence of closequietly is strongly enforcing many implementations use buffers and if not the implementation itself upstream systems might be buffering no byte or character that was supplied to a write method even if that call to write did not cause an exception is guaranteed to have gone anywhere until you flush the stream which close implicitly does therefore any exception that falls out of a close() method should be treated as if any number of previous write calls would have failed with that exception if only there were less buffers in between in other words there is no practical difference between write() throwing an exception and close() throwing an exception for writables closequietly() is an outright bug if used in this way as it leads to programs silently ignoring a disk failure or network failure event there is zero difference between silently ignoring ioexceptions thrown by your write() methods and silently ignoring ioexceptions thrown by closing that stream or writerin conclusion closablesclosequietly has vanishingly small true use cases but in practice it is abused therefore it should probably be removed (well @﻿deprecated) or at least a lot of scary warnings need to be added to the javadoc to explain what it is for (to dodge the need to formally handle ioexceptions for readables only - it is inappropriate for anything else)closablesclose does have a realistic use case (to facilitate the throwing of the first exception and not the followup usually less useful exception thrown by the close method once a write/read has already failed); fyi i just noticed there seems to be closequietly methods in guava 17 which talk specifically about being useful when closing readers/inputstreams: || ";;;;0;1;;
1118;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;some performance improvements;motivated by the nice blog post from @mlep  i tried to further improve the performance.  starting point  benchmark                         score      error  units benchmarks.parse                 30        ± 2.7  ops/s benchmarks.search                230.359 ±   27.399  ops/s benchmarks.write                 53.323 ±    5.528  ops/s  now with this pr benchmark                         score     error  units benchmarks.parse                 46.965 ±   0.608  ops/s benchmarks.search                304.795 ±   5.905  ops/s benchmarks.write                 85.171 ±   1.301  ops/s  for further improvements on should have a closer look at the formatter: - removelatexcommands for search (70% of time is spent there) - fieldcontentparser and latexfieldformatter for write (also >50%)  (also fixed a bug in the parse benchmarkthis is why the numbers are so different than in my previous post) ##  -   -   -   ();;0;argsmismatchfinder#getstubbingargmismatches generics;this patch allows calling `getstubbingargmismatches` with any `iterable` not just an `iterable<object>` in order to make it more convenient to useas seen in `argmismatchfindertest` this saves having to cast potential arguments to raw types; merging 1118 ;;;;1;1;argsmismatchfinder#getstubbingargmismatches genericsthis patch allows calling getstubbingargmismatches with any iterablenot just an iterable<object> in order to make it more convenient touseas seen in argmismatchfindertest this saves having to cast potentialarguments to raw types;
1118;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;some performance improvements;motivated by the nice blog post from @mlep  i tried to further improve the performance.  starting point  benchmark                         score      error  units benchmarks.parse                 30        ± 2.7  ops/s benchmarks.search                230.359 ±   27.399  ops/s benchmarks.write                 53.323 ±    5.528  ops/s  now with this pr benchmark                         score     error  units benchmarks.parse                 46.965 ±   0.608  ops/s benchmarks.search                304.795 ±   5.905  ops/s benchmarks.write                 85.171 ±   1.301  ops/s  for further improvements on should have a closer look at the formatter: - removelatexcommands for search (70% of time is spent there) - fieldcontentparser and latexfieldformatter for write (also >50%)  (also fixed a bug in the parse benchmarkthis is why the numbers are so different than in my previous post) ##  -   -   -   ();;0;add release notes for 061;; applied comments and ;;;;0;1;;
1118;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;some performance improvements;motivated by the nice blog post from @mlep  i tried to further improve the performance.  starting point  benchmark                         score      error  units benchmarks.parse                 30        ± 2.7  ops/s benchmarks.search                230.359 ±   27.399  ops/s benchmarks.write                 53.323 ±    5.528  ops/s  now with this pr benchmark                         score     error  units benchmarks.parse                 46.965 ±   0.608  ops/s benchmarks.search                304.795 ±   5.905  ops/s benchmarks.write                 85.171 ±   1.301  ops/s  for further improvements on should have a closer look at the formatter: - removelatexcommands for search (70% of time is spent there) - fieldcontentparser and latexfieldformatter for write (also >50%)  (also fixed a bug in the parse benchmarkthis is why the numbers are so different than in my previous post) ##  -   -   -   ();;0;operator parallelmerge;operator parallelmerge just renamedissue #1060;#1030 ;;;;1;1;operator parallelmerge;
1119;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;made it possible to delay the return of a mock or spy.  (#1117);this is a useful aid in debugging race conditions and other synchronicity problems.;;0;bloomfilter broken when really big; **bug 1:when the number of bits in a bloomfilter gets high its fpp is much worse than expected the culprit is the modular arithmetic in bloomfilterstrategiesmurmur128_mitz_32you compute `x%n`&nbspwhere `nbitssize()`&nbspand `x`&nbspis uniformly distributed in range `0integermax_value` for big `n` `x%n`&nbspis far from uniform in range `0n-1` for example with `n3<<29` values below `1<<29`&nbspare twice as probable as the othersthis non-uniformity leads to results like this:desiredfpp   0000001000000expectedfpp  0000000610089realfpp      0000003000000here `desiredfpp`&nbspis the value used in `bloomfiltercreate` `expectedfpp`&nbspwas reported after exactly `expectedinsertions`&nbspwere done obviously much fewer bits than expected were set if this happened once it might be a good luck but here its a sign of this bug as the `realfpp`&nbspshowsthis problem is well reproducible its no glitch caused by bad luck with selected values afaik it concerns all versions since the switch from powers of two**bug 2:with ""31149b4 the number of bits can reach integermax_value now rather than integermax_value/64"" another bug was introduced the commit message is obviously wrong as there can be allocated up to `integermax_value`&nbsplongs allowing nearly `2**37`&nbspbits however the arithmetic is still int-based and allows to address only`2**31`&nbspbits so most of the allocated memory get wastedeven worse `bitssize()`&nbspmay overflow leading to all kinds of disaster like ""/ by zero"" (eg for expectedinsertions244412641 and desiredfpp1e-11) or using only 64 bits**inefficiency:in `murmur128_mitz_32`&nbspthere are one modulus operation and one unpredictable branch per hash function this is quite wasteful as its enough to compute modulus for the basic two hashes and than use conditional subtraction**enhancement 1:as the filter may take up to 16 gb there should be a method to find out the memory consumption**enhancement 2:possibly there could be a strategy using a power of two table which may be faster in case the speed up is non-negligible such a strategy makes a lot of sense as the additional memory (assuming rounding up) is not wasted at all -- you get better fppquestion:i see no reason for limiting `numhashfunctions`&nbspto 255 in the `serialform` theres an `int` so why?**proposed solution:because of serialized form compatibility id suggest to leave murmur128_mitz_32 alone and create murmur128_mitz_64 which- extracts two longs instead of two ints from the hashcode- uses long arithmetic for everythingthe `bitarray`&nbspmust use long indexes long `bitcount()`&nbspand `size()` too this works with both strategies and the `serialform`&nbspneeds no changefor small filters (up to few millions bits before the non-uniformity starts to make problems) its fine to use the old strategyfor larger the new one must get used id suggest to use the new one for all new filtersin order to get maximum speed the following comes in mind:- create package-private `hashcodeassecondlong()`- compute hash2 only if `numhashfunctions>1`the attached patch solves it all"; ugh not sure how i missed thatmade the appropriate change and re-ran the guavabloomtest  results:desired false positive rate: 10e-10inserting 0% 8% 15% 23% 31% 38% 46% 53% 61% 69% 76% 84% 92% 99% doneexpected false positive rate: 9998725915640892e-11testing 0% 8% 15% 23% 31% 38% 46% 53% 61% 69% 76% 84% 92% 99% doneobserved false positive rate: 00factor: 000--- ;;;;0;1;;
1119;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;made it possible to delay the return of a mock or spy.  (#1117);this is a useful aid in debugging race conditions and other synchronicity problems.;;0;enable experimental features in dev config;; ;;;;0;1;;
1119;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;made it possible to delay the return of a mock or spy.  (#1117);this is a useful aid in debugging race conditions and other synchronicity problems.;;0;operatorrefcount;operator refcount#1060;#1031;;;;1;1;operatorrefcount;
1119;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;made it possible to delay the return of a mock or spy.  (#1117);this is a useful aid in debugging race conditions and other synchronicity problems.;;1117.0;made it possible to delay the return of a mock or spy  (#1117);this is a useful aid in debugging race conditions and other synchronicity problems;" merging 1119  ";answer with delay in mock or spy to improve testing of asynchronous code;"im currently using mockito for component testing of microservices  all code should be run up to the boundary at which another microservice is called  in the component test the mocks return very quickly but obviously in integration testing the real calls return much more slowly  some threading problems are revealed by the slow returns that would have been revealed in the component test if the returns could be forced to come back more slowly  since integration tests are *painfully* slow to start this would save me the developer considerable time in debugging this kind of issue once i discover it in the integration testsbecause its so easy to write ive already solved it with a class called answerwithdelay  it takes another answer as a parameter and inserts a little sleep before it returnsif desired i can turn this little helper into a pr for mockito or perhaps theres already something there that does this that ive overlookedbest regardsmyrle```@runwith(springrunnerclass)@springboottest(webenvironment  springboottestwebenvironmentdefined_port        classes  {abstractrhythmtesttestconfigurationclass}        properties  {""rhythmuserhomer"" ""rhythmbeatcheckrate500""})public class abstractrhythmtest {  //  static class answerwithdelay<t> implements answer<t> {    private final int sleepytime    private final answer<t> answer    answerwithdelay(final int sleepytime final answer<t> answer) {      thissleepytime  sleepytime      thisanswer  answer    }    @override    public t answer(final invocationonmock invocation) throws throwable {      timeunitmillisecondssleep(sleepytime)      return answeranswer(invocation)    }  }  beat createbeat(          final string applicationidentifier          final string beatidentifier          final int alignmenthour          final localdatetime expectedbeattimestamp) throws interruptedexception {    final string tenantidentifier  tenantdatastorecontextgettenantname()    final beat beat  new beat()    beatsetidentifier(beatidentifier)    beatsetalignmenthour(alignmenthour)    mockitodoanswer(new answerwithdelay<>(2_000 new returns(optionalof(permittablegroupidsforapplication(applicationidentifier)))))when(beatpublisherservicespy)requestpermissionforbeats(matcherseq(tenantidentifier) matcherseq(applicationidentifier))    mockitodoanswer(new answerwithdelay<>(2_000 new returns(true)))when(beatpublisherservicespy)publishbeat(matcherseq(beatidentifier) matcherseq(tenantidentifier) matcherseq(applicationidentifier)            additionalmatchersor(matcherseq(expectedbeattimestamp) matcherseq(getnexttimestamp(expectedbeattimestamp))))    thistestsubjectcreatebeat(applicationidentifier beat)    assertasserttrue(thiseventrecorderwait(eventconstantspost_beat new beatevent(applicationidentifier beatgetidentifier())))    mockitoverify(beatpublisherservicespy mockitotimeout(2_500)times(1))requestpermissionforbeats(tenantidentifier applicationidentifier)    return beat  }  //}```";if the implementation is clean and generic i would be in favor of it || @szpak for what version is that feature planned (or has it been already released)? ||;1;0;made it possible to delay the return of a mock or spy  (1117);
1121;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;improve and develop apis required for framework integrators;### problem;;0;optionalorthrow(throwable t); optional could be extended by the operation ""orthrow(throwable t)"" which would be thrown if the value is absent"; someone proposed adding this method internallyheres the discussion from api reviewpros:allows you to throw app-specific exceptions without rethrowing an ise or checking ispresent separatelyif we add enumsget() that returns an optional lots of people catch/rethrow checked exceptions and unchecked exceptionsthat could become sexier with:suit suit  enumsget(suitclass usersuit)orthrow(new suitnotfoundexception())fits well into a fluent api:value value  fluentiterablefrom()tryfirstmatching()orthrow()cons:very similar to what get() already does - unchecked exception for freebut if your only goal is to throw a bare get() call that doesn’t save the result may look too hacky for someeasy to make a helper method that does this by checking ispresent()“construct an exception pass it in to maybe get thrown or not” is not even remotely a common patternhow often do you really want to throw a checked exception (or care that much which unchecked exception) when the value isn’t present?new throwable has to fill in the stack trace - useless expense(from the throwable() javadocs: “the {@﻿link #fillinstacktrace()} method is called to initialize the stack trace data in the newly created throwable“)optional’s javadoc lists 14 methods  optional feels like it should be way smaller and simpler than that (we felt those methods were justified but it should raise the cost for each additional suggested one)if we discount static methods and object overrides and collapse overloads it’s really only 5 methods with orthrow making 6encourages other types of exceptionsdecision: no - too expensive not a common pattern can just use !ispresent() throw--- ;;;;0;1;;
1121;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;improve and develop apis required for framework integrators;### problem;;0;revert scheduler changes;the scheduler changes can result in smaller queries being starvedby bigger queries due to the introduction of global per-node queuesreverting for now so we can release well revisit later;looks good  ||;;;;1;1;remove reference to scheduler improvements from release notes;
1121;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;improve and develop apis required for framework integrators;### problem;;1060.0;operatorskiptimed;operator skiptimed#1060there was an unexpected dependency in `operationtaketimedtest` and is surely to cause conflict when `taketimed` is rewritten once all operators have been merged i suggest we create a primary `testexception` and rewrite tests to use it instead of all those custom exception classes everywhere;#1033;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;"im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > —> reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple ""absolute"" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  ";1;0;operatorskiptimed;
1121;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;improve and develop apis required for framework integrators;### problem;;1110.0;improve and develop apis required for framework integrators;mockito does not do static mocking at the moment powermockito does powermockito uses a lot of internal mockito apis exposing the community to issues and wasted productivity on version upgrades we want mockito apis to be easily extensible by framework integrators such us powermockito without compromising api simplicity and consistencyall proposed changes are backwards compatible in accordance to mockitos compatibility contract (in short: limited changes to orgmockito* types freedom to change orgmockitointernal*)### public api changesthe full discussion on the use cases implementation options and decisions is in #1110 ticket1 new public method for creating mock creation settings object:```javamockitowithsettings()name(“my mock”)build(fooclass)```2 framework integrators can now provide custom mockhandler via ```mockmaker#getmockhandler()``` previously it we didn’t offer this capability because we didn’t have convincing use cases that it was needed### public api considerations1 framework integrators may **not** provide custom implementation of ```invocationcontainer``` at this stage this part of api is accessible via public ```mockmaker#getmockhandler()getinvocationcontainer()``` method there are no convincing use cases that exposing this new public api is needed;" merging 1121  ";powermock and mockmaker: api change request;hi guysive taken a time for reviewing powermock code to find place where it use internal mockito api id like to discuss what could be done to avoid first think that id like to talk about its mockmaker powermock uses it custom mockmaker which it past was used only for two things: - cache a class create by cglib- return fake `internalmockhandler` for static mocks the first case is no more actual because bytebuddy uses current context classloader so `mockclassloader` is used but the second case still actual but investigation shows that returning fake `internalmockhandler` is required only for one case right now method `orgmockitointernalexceptionsreporternomoreinteractionswanted(invocation undesired list<verificationawareinvocation> invocations)` tries to `safelygetmockname(undesiredgetmock())` finally call comes to `orgmockitointernalutilmockutilismock(object mock)` it tries to get `mockhandler` for mock but it mock is static and its not a powermockmaker then `null` is returned i was surprised that having `powermockmaker` is required  only for such thing if speak honestly i dont have any idea how it can be  on mockito site maybe you have any thoughts? the second point its a way how mockito loads plugins  we had some discussion within #1006 main point provided @podarsmarty (as for me main) that if there are two files `orgmockitopluginsmockmaker`  in class path then order of loading plugins are unpredictable such undetermined behaviour could introduce some fluky bugs when for example one plugin specified in project and other in  dependency jar and for example it works but later author of dependency jar make refactoring and change package or something like this as result other plugin is loaded by mockito  and tests start failed  for powermock it is issue because is has own `mockmaker` which is required only if test runs with powermock but unfortunately if powermock in class path it will be used always  if a developer wants to use `mock-maker-inline` to be able to mock final without powermock then it was impossible until powermock 170 where i added ability to specify  `mockmaker` to which `powermockmaker` delegates calls as for me it will be good to have ability to separate custom `mockmaker` and mockito build-in `mockmaker` so custom `mockmaker` could know which build-in `mockmaker` should be used to delegate call if its required;"@thekingnothing do you live in krakow? i spent most of my adult life in krakow )thank you for reaching out to us so that we can work together thats how this should be done - we design the apis between open source components so that our users get higher quality products (eg products that dont break on version upgrade :)im also surprised that those are the only issues with using mockitos private api something tells me there is more lets keep working on this an expose all integration points>method orgmockitointernalexceptionsreporternomoreinteractionswanted(invocation undesired list<verificationawareinvocation> invocations) tries to safelygetmockname(undesiredgetmock()) finally call comes to orgmockitointernalutilmockutilismock(object mock) it tries to get mockhandler for mock but it mock is static and its not a powermockmaker then null is returnedi was surprised that having powermockmaker is required only for such thing if speak honestly i dont have any idea how it can be  on mockito site maybe you have any thoughts?multiple methods from reporter class attempt to use safelygetmockname i assume you use nomoreinteractionswanted as an example getting mock name is only used to make verification errors cleaner its not a critical feature without it the errors are still decentto get started i suggest to hack mockito code and return empty string if getting mock name throws an exception this way you can push forward and identify other contention points once we get full picture we can design public api that will solve all use cases cases for integration with powermock>the second point its a way how mockito loads plugins we had some discussion within #1006 main point provided @podarsmarty (as for me main) that if there are two files orgmockitopluginsmockmaker in class path then order of loading plugins are unpredictable such undetermined behaviour could introduce some fluky bugs when for example one plugin specified in project and other in dependency jar and for example it works but later author of dependency jar make refactoring and change package or something like this as result other plugin is loaded by mockito and tests start failedi totally agree that random order of loading plugins is undesired we dont have a clean way of solving this problem at the moment it needs more brainstorming ideas are welcome :)>for powermock it is issue because is has own mockmaker which is required only if test runs with powermock but unfortunately if powermock in class path it will be used always if a developer wants to use mock-maker-inline to be able to mock final without powermock then it was impossible until powermock 170 where i added ability to specify mockmaker to which powermockmaker delegates calls as for me it will be good to have ability to separate custom mockmaker and mockito build-in mockmaker so custom mockmaker could know which build-in mockmaker should be used to delegate call if its requiredthis is an interesting use case let me understand it: an author of custom mockmaker would like to have access to default mockito mockmaker so that she can delegate some invocations to it? in mockito we can introduce public api to expose the default mock maker (or means to obtain the default mock maker) || > @thekingnothing do you live in krakow? i spent most of my adult life in krakow )yeah im living in krakow for one year nice city except winter time i mean issue with air in winter :) > im also surprised that those are the only issues with using mockitos private api something tells me there is moreits just begin i only started (demon laughing) there a lot of issue and thing todo powermock has been being developed for 9 years in isolation and there are a lot of hacks (sometimes really dirty)  i started with easiest issue all other could take more time to explain and fix: directly creating mocks registration invocation control creating mock handler verify static and so on > multiple methods from reporter class attempt to use safelygetmockname i assume you use nomoreinteractionswanted as an example no `nomoreinteractionswanted` and `nomoreinteractionswantedinorder`  its only one case right now all other methods which use `safelygetmockname` is not called in context of static mocking powermock handle all these cases by itself as result mockito `mockmaker` always can returns handler and mock name could be obtained> i totally agree that random order of loading plugins is undesired we dont have a clean way of solving this problem at the moment it needs more brainstorming ideas are welcome :)first of all it will be nice to show warning like jvm shows on mac ) a developer will be aware about issue i clear understand that most of developers are ignoring such messages but at least some of them will know that they test are unstable > objc[48004]: class javalaunchhelper is implemented in both /library/java/javavirtualmachines/jdk180_111jdk/contents/home/bin/java (0x103ae94c0) and /library/java/javavirtualmachines/jdk180_111jdk/contents/home/jre/lib/libinstrumentdylib (0x104b544e0) one of the two will be used which one is undefined> in mockito we can introduce public api to expose the default mock maker (or means to obtain the default mock maker)yeah it will be create to have ability to obtain default mock maker (or other plugin) instead writing something like `private final mockmaker cglibmockmaker  new cglibmockmaker()`   || >no nomoreinteractionswanted and nomoreinteractionswantedinorder its only one case right now all other methods which use safelygetmockname is not called in context of static mocking ok thanks! hack mockito codebase and keep pushing forward safely getting mock name is a simple issue to fix so lets move on and identify hard problems :)>first of all it will be nice to show warning like jvm shows on mac )we can show a warning id like us to brainstorm and understand what options we have here to fix this caveat this problem should be fairly common when plugin system is based of metadata declared in the classpath>yeah it will be create to have ability to obtain default mock maker (or other plugin) instead writing something like private final mockmaker cglibmockmaker  new cglibmockmaker()does powermock still use cglibmockmaker? this class no longer exists in mockito 2x codebase || > hack mockito codebase and keep pushing forward just to make sure that were on the same page does you mean to raise a pull request with the change on reporter?  || > does powermock still use cglibmockmaker? this class no longer exists in mockito 2x codebasepowermock have used  repackaged `cglibmockmaker` until version 170 ive dropped all repackaged cglib code a few hours ago i was going to release powermock 170 on next week but i think ill postpone it until issue with `saflygetmockname` will be fixed and released it will give me ability to delete powermockmaker and make code simple  || answers to your questions below :) thank you for pushing this forward!>just to make sure that were on the same page does you mean to raise a pull request with the change on reporter?i was hoping you can hack the code test locally if things work and expose harder problems i need to think a little bit about whats the best way to solve the reporterare you sure that there are no other ```import ""orgmockitointernal" in powermock codebase?>powermock have used repackaged cglibmockmaker until version 170 ive dropped all repackaged cglib code a few hours agogot it thank you! || i have investigated powermockito codebase and found out that the problem is that mockhandler api in mockito is not quite finished therefore powermockito had to create custom implementation of mockhandler despite our javadoc saying:> this api is work in progress do not provide your own implementations(im not complaining i very much sympathize many times i needed to resort to using internal api because i had no choice thanks again for engaging with us on cleaning the apis between both libraries!)@thekingnothing if we make the mockhandler api public will this work for you? ive initiated the efforts here:  my initial thought is that after #1121 is applied we can just move the internalmockhandler methods onto mockhandler and delete internalmockhandler in powermockito you can then create implementation of mockhandler that works with static mocking how does it sound? || im sorry i didnt have a time to answer earlier i was driving a car to prague and back im still limited in access and writing from mobile phone sorry for some inaccuracies> are you sure that there are no other import ""orgmockitointernal"" in powermock codebase?im sure that there are a lot of such places in codebase because powermock has package `orgpowermockapimockitointernal` where locate classes which either extends mockito internal api or provides hacks for it> @thekingnothing if we make the mockhandler api public will this work for you?as we discuss earlier if you resolve an issue with `saflygetmockname` then there will be no reason to implement `mockmaker` and `mockhandler` by powermock ill remove `powermockmaker` as result `powermockinternalmockhandler` will be removedlets move to another issue:-  to create a mock powermock uses mockmaker but to get an instance of mockmaker i have to call `pluginsgetmockmaker()` - internal api call- then to create a mock i have to pass a `mockhandler` to `createmock` i found only one way to do it use `mockhandlerfactory` - one more internal use- to create `mockhandler` the settings is required everything is pretty good with `mockitowithsettings` except that i need to set mock type- the instance of `mockhandler` is used to create `mockitomethodinvocationcontrol` this class is full of internal calls and dirty hacksbtw one of hack in `mockitomethodinvocationcontrol`  as i remember that it replaces a field in `mockhandler` by own copy-past implementation only for one purpose: fix and issue with getting mock name in `tostring()` so `saflygetmockname` not only place with such issue but i think i have to revisit this part of code and double check it if getting mock name works for nomoreinteractionswanted` it should work for `tostring` hmm maybe it will be better to keep powermockmackerbest regradsarthur zagretdinovon 12 jun 2017 at 06:57 szczepan faber <notifications@githubcom<mailto:notifications@githubcom>> wrote:i have investigated powermockito codebase and found out that the problem is that mockhandler api in mockito is not quite finished therefore powermockito had to create custom implementation of mockhandler despite our javadoc saying:this api is work in progress do not provide your own implementations(im not complaining i very much sympathize many times i needed to resort to using internal api because i had no choice thanks again for engaging with us on cleaning the apis between both libraries!)@thekingnothing< if we make the mockhandler api public will this work for you? ive initiated the efforts here: #1121< my initial thought is that after #1121< is applied we can just move the internalmockhandler methods onto mockhandler and delete internalmockhandler in powermockito you can then create implementation of mockhandler that works with static mocking how does it sound?—you are receiving this because you were mentionedreply to this email directly view it on github< or mute the thread< || @thekingnothing just a question to understand the ""saflygetmockname"" problem: what is missing here on the mockito side or what is not working as you expect? do you get null as mock name?@szczepiq  as far as i can see internalmockhandler needs to be part of the public api since `mockutilgetmockhandler(t mock)` returns this type an other option would be to move itss methods to the super class || >@szczepiq as far as i can see internalmockhandler needs to be part of the public api since mockutilgetmockhandler(t mock) returns this type an other option would be to move itss methods to the super classyup thats the plan :) i was thinking of just moving those methods onto mockhandler and killing internalmockhandler thanks for joining the discussion! || >im sorry i didnt have a time to answer earlier i was driving a car to prague and back im still limited in access and writing from mobile phone sorry for some inaccuraciesno worries hopefully you had good time in prague!>as we discuss earlier if you resolve an issue with `saflygetmockname` then there will be no reason to implement `mockmaker` and `mockhandler` by powermock ill remove `powermockmaker` as result `powermockinternalmockhandler` will be removedmaking ""saflygetmockname"" lenient is only good for short term experimentation in the future other features of mockito will be accessing mockhandler in powermockito static scenarios and it can cause failures lets come up with a proper solution :) plus if we make mockhandler public powermockito use will be better: we will actually print decent static mock name in verification errorsplease give public mockhandler a second thought and get back to us with any feedback you would be able to keep powermockinternalmockhandler just make it extend public type mockhandler || > what is missing here on the mockito side or what is not working as you expect? do you get null as mock name?it throws `notamockexception` for case of static mocking the `saflygetmockname` tries to get mockhandler from mockmaker if powermock doesnt provide custom implementation  of `mockmaker` then mock handler is null and exception is thrownif `powermockmaker` is used then it leads to issues with `mock-maker-inline` for non-powermock testsas for me  consequences of  `powermockmaker` worse than empty empty string as mock namebest regradsarthur zagretdinovon 13 jun 2017 at 16:03 christian schwarz <notifications@githubcom<mailto:notifications@githubcom>> wrote:@thekingnothing< just a question to understand the ""saflygetmockname"" problem: what is missing here on the mockito side or what is not working as you expect? do you get null as mock name?@szczepiq< as far as i can see internalmockhandler needs to be part of the public api since mockutilgetmockhandler(t mock) returns this type an other option would be to move itss methods to the super class—you are receiving this because you were mentionedreply to this email directly view it on github< or mute the thread< || >-  to create a mock powermock uses mockmaker but to get an instance of mockmaker i have to call `pluginsgetmockmaker()` - internal api callwe should be able to address this by adding public api for default mockmaker instance easy to address i havent put enough thought to it but it seems easy so lets move on to next problem> - then to create a mock i have to pass a `mockhandler` to `createmock` i found only one way to do it use `mockhandlerfactory` - one more internal usewhy do you need to create instances of mockhandlers? can you point some code? keep in mind that we are making mockhandler public so you should be able to provide your own implementation if needed> - to create `mockhandler` the settings is required everything is pretty good with `mockitowithsettings` except that i need to set mock typewhy setting mock type is problematic? is it for static mocking scenario? can you point some code?> - the instance of `mockhandler` is used to create `mockitomethodinvocationcontrol` this class is full of internal calls and dirty hacks:) we will resolve them all :)nice progress!i suggest we do this: i will push to my branch mockito with cleaned up mockhandler api you can build mockito jar from source from that branch and see how it fits powermockito use case lets see how much internal api we can resolve by cleaning up mockhandler api i will make changes on ""sf"" branch by the end of todaythanks again for working on this! || i have two concerns regarding keeping `powermockinternalmockhandler`1   it requires implementing `powermock` and leads to issue with `mock-maker-inline` 1   powermock never use `powermockinternalmockhandler`  by itself only for handling case ""static mock name`im entering on thin ice if i choice to keep `powermockinternalmockhandler` and have more logic in it  i have to keep in mind that powermock works with easymock as i see i have two options: have better integration with mockito but duplicate logic for easymock and mockito or implement some general things same for easymock and mockito but not use full power integration with mockito > why do you need to create instances of mockhandlers? can you point some code? keep in mind that we are making mockhandler public so you should be able to provide your own implementation if neededthe instance is used later to handle static/non-public method call  mockitomethodinvocationcontrol`  mockitomethodinvocationcontrol implements methodinvocationcontrol `methodinvocationcontrol` is a proxy for mockito and easymock api when method is called powermock looks for `methodinvocationcontrol` for the methods signature and delegates handling call to `methodinvocationcontrol` in mockito case `mockitomethodinvocationcontrol` uses  `mockhandler`  to handle method invocation ```invocation invocation  new invocationimpl(            interceptionobject            new delegatingmethod(method)            arguments            sequencenumbernext()            cleantracerealmethod            new locationimpl()        )                try {            return mockhandlerhandle(invocation)        } catch (notamockexception e) {            if (invocationgetmock()                          getclass()                          getname()                          startswith(""java"") && mockrepositorygetinstancemethodinvocationcontrol(invocationgetmock()) ! null) {                return invocationcallrealmethod()            } else {                throw e            }        } catch (mockitoassertionerror e) {            invocationcontrolassertionerrorupdateerrormessageformethodinvocation(e)            throw e        }``` [source]( why setting mock type is problematic? `mocksettings` does not have public method to set type > is it for static mocking scenario? can you point some code?i have to check when it is required  ```        final mocksettingsimpl<t> settings        final mockmaker mockmaker  getmockmaker()                if (mocksettings  null) {            settings  (mocksettingsimpl) mockitowithsettings()        } else {            settings  (mocksettingsimpl) mocksettings        }                if (isspy) {            settingsdefaultanswer(mockitocalls_real_methods)        }                settingssetmockname(new mocknameimpl(mockname))        //settingssettypetomock(type)                internalmockhandler mockhandler  mockhandlerfactorycreatemockhandler(settings)                t mock  mockmakercreatemock(settings mockhandler)```[source](  please give public mockhandler a second thought and get back to us with any feedback you would be able to keep powermockinternalmockhandler just make it extend public type mockhandler> i suggest we do this: i will push to my branch mockito with cleaned up mockhandler api you can build mockito jar from source from that branch and see how it fits powermockito use case lets see how much internal api we can resolve by cleaning up mockhandler api i will make changes on ""sf"" branch by the end of todayanyway im going to focus on release in near few days i have to clear documentation for the release after release ill build powermock with your change and check thank you for providing me help with it! :)  || thank you for all the information - it is super useful! i will work on the mockhandler api (this needs to be sorted out anyway) later i will reply with more details to your last comment || im making progress on exposing mockhandler api but it is taking more time than i have anticipated hah i love engineering :d !!!>im entering on thin ice if i choice to keep powermockinternalmockhandler and have more logic in it i have to keep in mind that powermock works with easymock as i see i have two options: have better integration with mockito but duplicate logic for easymock and mockito or implement some general things same for easymock and mockito but not use full power integration with mockitoi suspect that own implementation of mockhandler unavoidable mockutilgetmockhandler() is used in bunch of other places and fixing the reporter case with mock name will be a very short term solutionlets push forward with making mockhandler public i suspect that once this api is neatly public you should be able to implement powermockmaker that supports static mocking scenarios ill keep you posted on the progress! || @thekingnothing how can i try out powermockito? when i clone the repo and import it to idea tests dont work in idea this makes it hard to debug i love debugging to learn how stuff works can you tell me how do i import powermockito code to idea so that i can run some static mocking testing with powermockito? thanks in advance :) || > i suspect that own implementation of mockhandler unavoidable mockutilgetmockhandler() is used in bunch of other places and fixing the reporter case with mock name will be a very short term solutionokay im throwing in the towel :) ill keep own implementation of mockhandler in this case its hight important have ability use `pluginloader` to prevent issues like  @thekingnothing how can i try out powermockito? when i clone the repo and import it to idea tests dont work in idea this makes it hard to debug i love debugging to learn how stuff works can you tell me how do i import powermockito code to idea so that i can run some static mocking testing with powermockito?what issue did you have? have you tried to build it with gradle?  ive just cloned repository from master and imported to intellij idea as gradle project and was able to run static tests  anyway it was a tricky moment that modules depended on mockito had two test/source sets that pointed to same java source path it was done to be able to test same code against mockito 1x and mockito 2x ive created a new branch `mockito2` where i dropped supporting mockito 1x and removed all complicated logic from gradle could you try with the branch?  || > ive created a new branch mockito2 where i dropped supporting mockito 1x and removed all complicated logic from gradle could you try with the branch?i will try it thank you!>okay im throwing in the towel :) ill keep own implementation of mockhandler in this case its hight important have ability use pluginloader to prevent issues like powermock/powermock#811ok :) btw i made progress in my branch but its late and will check in the morning whats the status i think i managed to expose the api so that powermockito can stop depending on the internal api wrt to the mockhandler || @thekingnothing can you try out building mockito from ""sf"" branch? ""/gradlew build"" produces binaries ""/gradlew publishtomavenlocal"" builds and installs binaries to local maven repo things i changed: - mockhandler api is public and you can provide your own implementation :) just dont provide your own implementation of mockhandlergetinvocationcontainer() - you can create an instance of mockcreationsettings using a new public api: ""mockitowithsettings()name(""foo"")build()""let us know how it goes! || @szczepiq thank you! i built mockito from branch and tried to run(after all compile issues were resolved) and one major issue appeared `powermockitostubberimpl` has the method `addanswersforstubbing` which use deleted `mockhandlersetanswersforstubbing````    @suppresswarnings(""unchecked"")    private void addanswersforstubbing(mockitomethodinvocationcontrol invocationcontrol) {        final mockhandler mockhandler  invocationcontrolgetmockhandler()        final list list  whiteboxgetinternalstate(this listclass)        try {            whiteboxinvokemethod(mockhandler ""setanswersforstubbing"" list)        } catch (exception e) {            throw new runtimeexception(e)        }    }```what do you think better to do in this case?  || > you can create an instance of mockcreationsettings using a new public api: ""mockitowithsettings()name(""foo"")build()""great! now `powermockmaker` has been cleared from internal imports ```import orgmockitomockitoimport orgmockitoinvocationinvocationimport orgmockitoinvocationinvocationcontainerimport orgmockitoinvocationmockhandlerimport orgmockitomockmockcreationsettingsimport orgmockitopluginsmockmakerimport orgpowermockconfigurationglobalconfiguration```but i have to cast to `mocksettingsimpl` still in `defaultmockcreator` because if a `mocksettings` is specified i have two options: - implement logic of cloning `mocksettings` but it also requires using internal mockitos classes  - set name and type to existing `mocksettings`is it possible to add method to builder creating mocksetting from existing settings? || >but i have to cast to mocksettingsimpl still in defaultmockcreator because if a mocksettings is specified i have two options:i need to understand the use case more can you point out to the code?>set name and type to existing mocksettingsthis seems like a reasonable option would this work for you?happy we are making progress! || > i need to understand the use case more can you point out to the code?example from the `defaultmockcreator` i didnt commit code after refactoring  but its very close to old code```    private static <t> mocksettingsimpl<t> getmocksettings(final string mockname final class<t> type final boolean isspy final mocksettings mocksettings) {        final mocksettingsimpl<t> settings        if (mocksettings  null) {            settings  (mocksettingsimpl) mockitowithsettings()        } else {            settings  (mocksettingsimpl) mocksettings        }                if (isspy) {            settingsdefaultanswer(mockitocalls_real_methods)        }                settingssetmockname(new mocknameimpl(mockname))        settingssettypetomock(type)        return settings    }``` || >is it possible to add method to builder creating mocksetting from existing settings?there are 2 separate asks here:1 create settings object conveniently with the type2 creating settings object from other settings object (eg copy)i fully understand the use case behind 1) - in static mocking scenario you need custom mock handler with custom mock name i dont understand why we need 2) and the code sample does not explain why i hope you dont really need 2) given 1) is implemented )for 1) you can already do it with the code that i pushed to the branch new ""build"" public method: ```withsettings()build(fooclass)```let us know how things are and what your progress is! || > for 1) you can already do it with the code that i pushed to the branch new ""build"" public method: withsettings()build(fooclass)i change code in branch and use a new api it helps clear `powermockmaker` from internals calls where are a least two reason why the 2) is asked: 1 set default answer if `powermockitospy(class<t> type)` or `powermockitospy(t object)` (this part can be refactored if take into account that public api does not provide ability to create spy with settings)1 npe exception in `subclassbytebuddymockmaker` and `inlinebytebuddymockmaker` if mock type is not set but a user provides custom settings via ` mockstatic(class<?> classtomock mocksettings mocksettings)` for example ```javalangnullpointerexception	at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakerprettifyfailure(subclassbytebuddymockmakerjava:90)	at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemocktype(subclassbytebuddymockmakerjava:77)	at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemock(subclassbytebuddymockmakerjava:42)	at orgpowermockapimockitomockmakerpowermockmakercreatemock(powermockmakerjava:50)	at orgpowermockapimockitointernalmockcreationdefaultmockcreatorcreatemethodinvocationcontrol(defaultmockcreatorjava:116)``````90:     if (mockfeaturesgettypetomock()isarray()) {            throw new mockitoexception(join(                    ""mockito cannot mock arrays: "" + mockfeaturesgettypetomock() + """"                    """"                    ) generationfailed)        }``` || thank you for working on this! i would love to see us getting to the conclusion - nice demonstration of 2 library owners working together to develop clean & flexible api :)>if take into account that public api does not provide ability to create spy with settingsheres how you can create spy with settings:```java        return mock(classtospy withsettings()                useconstructor()                defaultanswer(calls_real_methods))```>npe exception in subclassbytebuddymockmaker and inlinebytebuddymockmaker if mock type is not setcan you address this issue by making sure powermockito mocks have the mock type?where are we at this point? what are the remaining gaps? || > thank you for working on this! i would love to see us getting to the conclusion - nice demonstration of 2 library owners working together to develop clean & flexible api :)thank you for assisting me im also really happy to see how we move its a big win for community!  > can you address this issue by making sure powermockito mocks have the mock type? here we come to main reason why i asked ""creating settings object from other settings object (eg copy)"" i need ability to set mock type and mock name to already defined mock settings    || >here we come to main reason why i asked ""creating settings object from other settings object (eg copy)"" i need ability to set mock type and mock name to already defined mock settingsok :) can you point me to the code where it is needed? id like to fully understand the use case the previous code you showed did not validate this need or perhaps you you can walk me through the workflow that explains the need for copying settings object? ideally id like to grow public api in smallest possible steps to keep it cleanthank you for patience! || accidentaly closed :) || okay lets go through the flow the `powermockito` has methods:```    public static synchronized void mockstatic(class<?> type class<?> types) {        threadsafemockingprogressmockingprogress()reset()        defaultmockcreatormock(type true false null null (method) null)        if (types ! null && typeslength > 0) {            for (class<?> aclass : types) {                defaultmockcreatormock(aclass true false null null (method) null)     }   }   }``````    public static void mockstatic(class<?> classtomock mocksettings mocksettings) {        threadsafemockingprogressmockingprogress()reset()        defaultmockcreatormock(classtomock true false null mocksettings (method) null)  }  } }```both methods call `public <t> t createmock(class<t> type boolean isstatic boolean isspy object delegator                            mocksettings mocksettings method methods)`from `defaultmockgreator`but one method passes `mocksettings` provided by user the second passes `null` as result i have to check it later in `private static <t> mockdata<t> createmethodinvocationcontrol(final string mockname class<t> type                                                                 method methods boolean isspy object delegator                                                                 mocksettings mocksettings)````                if (mocksettings  null) {            settings  (mocksettingsimpl) mockitowithsettings()        } else {            settings  (mocksettingsimpl) mocksettings        }                if (isspy) {            settingsdefaultanswer(mockitocalls_real_methods)        }                settingssetmockname(new mocknameimpl(mockname))        settingssettypetomock(type)```if for the first case when `settings` is null i can use a new api and create a new settings with type but for the second case its impossible without using internal api  || thank you very much for very comprehensive description! with the new public api you can replace:```javasettingssettypetomock(type)```with:```settingsbuild(type) //this actually returns new object that you can use to create mocks```can you try it out and let me know if it works? || thank you! its my fall i was thinking that you added a method to an other class im sorry for misunderstanding now im getting stuck with setting name the following method is used to calculate mock name ```        private string toinstancename(class<?> clazz final mocksettings mocksettings) {        // if the settings define a mock name use it        if (mocksettings instanceof mocksettingsimpl<?>) {            string settingname  ((mocksettingsimpl<?>) mocksettings)getname()            if (settingname ! null) {                return settingname            }        }                // else use the class name as mock name        string classname  clazzgetsimplename()        if (classnamelength()  0) {            return clazzgetname()        }        // lower case first letter        return classnamesubstring(0 1)tolowercase() + classnamesubstring(1)    }```what could happen if powermock does not set a mock name? will be name set by default by mockito?  || >now im getting stuck with setting namein what way you are stuck?>what could happen if powermock does not set a mock name?try it out ) from looking at powermockito code i think you should be able to get it working: - i think that ""toinstancename"" method can be removed - in ""createmethodinvocationcontrol"" method when ""mocksettings"" is null just create new settings object and pass the desired mocked type to new ""build()"" method i have added to the public api (you need to use mockito branch i have created for you)hope that helps! || @thekingnothing friendly ping :) || thank you for reminding :) i have a personal issue so i dont have enough time right now but i hope ill find a few minutes to check it on next weekend || sounds good i [wrote an article]( what we are doing your name is there we need to finish it off :) || i still havent had time to check settings but i recall another issue after you moved the `setanswersforstubbing` from `mockhandler`could you check the [powermockitostubberimpl]( class? it has method that call `setanswersforstubbing` via reflection  what you can suggest to do in this case? ```    @suppresswarnings(""unchecked"")    private void addanswersforstubbing(mockitomethodinvocationcontrol invocationcontrol) {        final mockhandler mockhandler  invocationcontrolgetmockhandler()        final list list  whiteboxgetinternalstate(this listclass)        try {            whiteboxinvokemethod(mockhandler ""setanswersforstubbing"" list)        } catch (exception e) {            throw new runtimeexception(e)        }    }``` || ive finally got the time to look at and  after changing settings api  everything looks good now: test are green hence we can move to a next issue there are three mockitos internal imports are left in `defaultmockcreator`: * orgmockitointernalconfigurationpluginsplugins — is used to get `mockmaker` * orgmockitointernalhandlermockhandlerfactory — is used to get an instance of a `mockhandler` ill replace it by powermock implementation but this implementation will also use  internal classes like `mockhandlerimpl` and `nullresultguardian`* orgmockitointernalutilreflectionlenientcopytool — is used to copy values in case of spy  || fantastic! thank you!can you check in your changes to the branch so that i can poke around the new implementation? i should be able to get answers / suggestions on the way forward soon || ive already pushed my changes to mockito2 branch today in the morning || >ive already pushed my changes to mockito2 branch today in the morninggreat! i will pull the changes and look into the code sometime today || i looked at the state of things and more work is needed can you help me understand why powermock needs to explicitly create mockmaker instance to create mocks? submitted pr with the idea here:  || we probably need to get on a video call to close down this project faster :) || > we probably need to get on a video call to close down this project faster :)i think that it is a great idea im still limited in time but i hope it will be possible to schedule such call  || > can you help me understand why powermock needs to explicitly create mockmaker instance to create mocks? powermock uses  `mockitomethodinvocationcontrol` to handle static or non-public method invocation  new instance call and calls to system classes there are two implementations of the `methodinvocationcontrol`: `mockitomethodinvocationcontrol` and `easymockmethodinvocationcontrol` mockito implementation is heavy rely on `mockhanlder` powermock has to have access to mocks mockhandler one of the way that is used now its to create a instance of `mockhanlder` the create a mock with using the created mockhanlder and then pass the same instance to `mockitomethodinvocationcontrol` the second way create mock with settings by using public api then if possible cast mock to `mockaccess` and get mockhanlder both approaches use internal mockito api hmm ive just realized that there is one more way to achieve the same goal create mock with using public api and then get mockhandler from `mockutil` maybe its possible anyway powermock needs a public api to create a mock with settings and then get mockhandler for the mock  || >hmm ive just realized that there is one more way to achieve the same goal create mock with using public api and then get mockhandler from mockutil maybe its possibleyup thats exactly what im suggesting! can you try to go on that path? in the meantime ill figure out a way to offer public api to call ""handle"" method on the mockhandler || okay ill move forward with `mockutil` only one concern `mockutil` is internal class is it possible to provide public api to get `mockhandler` for mock?  || i am working on adding that public api please continue with assumptionthat this will be ready soon! )on sat jul 15 2017 at 10:05 arthur zagretdinov <notifications@githubcom>wrote:> okay ill move forward with mockutil only one concern mockutil is> internal class is it possible to provide public api to get mockhandler> for mock?>> —> you are receiving this because you modified the open/close state>>> reply to this email directly view it on github> < or mute the thread> < >-- szczepan faberfounder @  | twitter  @  || i  already did it and pushed change to mockito2 branch ive isolated most of dependency on mockito internals in two classes [mockhandleradaptor]( and [mockitomethodinvocationcontrol]( mockito api will be ready you have a way to tested it by replacing code in these two classes   || can you check out mockito sf branch? - see ```staticmockingexperimenttest``` that attempts to simulate static mocking with the current state of mockito api (i know it is crude but rome wasnt built in a day :) - getting mock handler: ```mockitomockingdetails(mock)getmockhandler()``` - creating invocation instances: ```mockitoframework()createinvocation()```i suspect that with that api you should be able to remove the internal api use completely please give it a shot :) || ill move powermock to a new api and come back with feedback asap  || fantastic thank you! || friendly ping :) || thank you for pingi looked at new api and your example i partially applied them but ive got stuck with replacing realmethod with callable i have to refactor powermock code to be able to pass target to mockitomethodinvocationcontroli hope ill have a time to finish with it on the weekend || sounds good let me know if you need anything from me || i closed the issue accidentally unfortunately i didnt have enough time to resolve all issues im continue working on it but i have a question about stubbing  how do you see the flow with using this api for stubbing in case of static/private methods ```  //register stubbed return value        doreturn(""hey"")when(mock)`````` || ok thank you for update! in sf branch of mockito project you canfind ""staticmockingexperimenttest"" in this test i simulated verificationand stubbing for static methods long term we can improve the api howeverfor now i hope its enough for you to experiment and get it working :) || @szczepiq thank you for your talk in krakow :) i was really glad to meet with you ive moved significantly since monday i about to manage all issue that was raised one think left to do - implementing verifyzeroiteration/verifynomoreiteration and here i have two issues: 1 verify in case of constructor call 1 verify static and current powermock api according to current powermock api verify static starts like replayall in easymock without pointing exactly a mock ```verifystatic()classwithstaticcallstatic()verifystatic()secondclasswithstaticcallstatic()```this issue im going to fix by making current api as deprecated in powermock 1x and replace  ``verifystatic(classwithstaticclass)classwithstaticcallstatic()```to fix first we need to thing about possibility to create an invocation for constructor  || youre welcome! i am very happy you are making progress!!!>this issue im going to fix by making current api as deprecated in powermock 1x and replace bythe suggested api looks good from the standpoint of consistency / familiarity with existing powermock api>to fix first we need to thing about possibility to create an invocation for constructorthis is really hard i was thinking about it recently and havent come up with anything useful yet will keep pondering about it || i think i found a way to deal with mocking new! how about we adapt constructor for method:```javainterface constructormethodadapter {  object construct(constructor constructor object  args)}```i simulated this idea in this new test please take a look at it ) test is already pushed to the sf branch || hey @thekingnothing with the ""constructormethodadapter"" trick you should be able to mock new is there any other gap we need to close down to clean up the interface? || i havent tried your approach yeti focused on deprecating `verifystatic` releasing the powermock 171 to let community know about incompatible changes  in powermock 20im finishing with removing `verifystatic` and i hope ill have a time to try your approach with `constructormethodadapter`best regradsarthur zagretdinovon 13 aug 2017 at 16:21 szczepan faber <notifications@githubcom<mailto:notifications@githubcom>> wrote:hey @thekingnothing< with the ""constructormethodadapter"" trick you should be able to mock new is there any other gap we need to close down to clean up the interface?—you are receiving this because you were mentionedreply to this email directly view it on github< or mute the thread< || hi @szczepiq  how are you? :) i have a good news we about to finish there are two places are left in powermock where mockitos internal packages age importfirst place it is the annotation engine: powermock extends mockitos `spyannotationengine` and `injectingannotationengine` classes and use `powermockito` for cases when mockito cannot create a mock im going to rewrite this part and unify with easymock implementation with general logic like 1 call mocking framework engine with public api like `mockitoannotationinit()` in mockito case 1 catch exception and re-throw exception with modified message with suggestion to use powermock annotation on fields that cannot be mocked by mockito1 call powermock annotation inject engine the second place is more interesting powermock has to detect if invocation is already caught by mockito and mockito tries to invoke real method ```/*           * if we come here and it means that the class has been modified by           * powermock if this handler has a delegator (ie is in spy mode in           * the current implementation) and it has been caught by the mockito           * proxy before our mockgateway we need to know if the method is private           * or not because if the previously described preconditions are met and           * the method is not private it means that mockito has already processed           * the method invocation and we should not delegate the call to mockito           * again (thus we return proceed) if we would do that mockito will           * receive multiple method invocations to proxy for each method           * invocation for privately spied methods mockito havent received the           * invocation and thus we should delegate the call to the mockito proxy           */        final object returnvalue        if (iscanbehandledbymockito(method) && hasbeencaughtbymockitoproxy()) {            returnvalue  mockgatewayproceed        }```it has very ugly implementation right now ```    private boolean hasbeencaughtbymockitoproxy() {        stacktraceelement stacktrace  threadcurrentthread()getstacktrace()        stacktracefilter filter  new stacktracefilter()        /*        * we filter the stack-trace to check if ""mockito"" exists as a stack trace element (the filter method        * remove all mockito stack trace elements) if the filtered stack trace length is not equal to the original stack trace length        * this means that the call has been caught by mockito        */        final stacktraceelement filteredstacktrace  filterfilter(stacktrace true)        return filteredstacktracelength ! stacktracelength    }```   do you have idea how to avoid such dirty code?  || >hi @szczepiq  how are you? :) i have a good news we about to finishgreat! when we are ready i will need to spend some time to polish mockito changes and poll the community for feedback it probably will take me a week>first place it is the annotation engine: powermock extends mockitos spyannotationengine and injectingannotationengine classes and use powermockito for cases when mockito cannot create a mockyour idea with wrapping mockitos exceptions seems like a reasonable plan at the time being its not a clean solution but it feels that we should focus on the core use cases and eliminate the internal api use then we can make the solution perfecti am wondering how this powermockito api will blend with mockitos junit rule / mockito junit runner / mockitosession when we finish id like to help reviewing powermockito test coverage and possibly suggest few additions :)>the second place is more interesting powermock has to detect if invocation is already caught by mockito and mockito tries to invoke real methodvery interesting let me think about this use case can you point me to the code in powermockito codebase and what branch i can find your changes? || > very interesting let me think about this use case can you point me to the code in powermockito codebase and what branch i can find your changes?branch: 2x/mockito2 class `mockitomethodinvocationcontrol` > i am wondering how this powermockito api will blend with mockitos junit rule / mockito junit runner / mockitosession i think the same way as it work right now if a developer use powermockrunner then all fields annotated with  `@mock`  are created and injected into `@injectmocks` so there is no reason to use  mockitos junit rule / mockito junit runner  || thank you! i loaded powermockito to the idea and most tests worked :)i have some ideas how to approach the problem with mockitomethodinvocationcontrol im using ""samplespowermockitojunit4annotationbasedspyannotationtest#spyingonprivatemethodsworkswithspyannotation"" for debugging this use case ill let you know by the end of today whats up || i have been debugging the issue and submitted a pull request to powermock with an idea to tackle the private spy use case:  let me know if you can leverage this idea to move forward!thank you for working on this! || i have checked the pull request i think i have got your idea but it will work only in case if a mock is created with using `powermockito` but if a mock is created with using `mockito` and added to `@preparefortest` then it will be loop with stack overflow || > but if a mock is created with using `mockito` and added to `@preparefortest` then it will be loop with stack overflowthank you for review! can you point me to the unit test that demonstrates this use case? powermock documentation indicates that we need to use both `@preparefortest` and `powermockrunner` alltogether i have tried below but it does not seem to reproduce the scenario (test is based on existing ""spyannotationtest"" test class in the powermock codebase):```java@runwith(powermockrunnerclass)@preparefortest(privatepartialmockingexampleclass)public class spyannotation2test {	@test	public void spyingonprivatemethodsworkswithspyannotation() throws exception {		privatepartialmockingexample undertest  mockitospy(new privatepartialmockingexample())		final string expected  ""test value""		final string nameofmethodtomock  ""methodtomock""		final string input  ""input""		when(undertest nameofmethodtomock input)thenreturn(expected)		assertequals(expected undertestmethodtotest())		verifyprivate(undertest)invoke(nameofmethodtomock input)	}}``` || i have double checked the case that i meant its not an issue any more i think that  it was the issue with cglib approach because fix for the issue also included changes in cglib handlers and determining is class a proxyfor case that you debugged - your will work regarding what api is usedif powermock is used then marker will show that a method is already handledif mockito - then mockitoinvocationcontrol will not be createdone case better to check: verifying public methods for mocks created with powermock and  inline mock makeras i remember inline mock maker uses current thread context class loader to redefine class in case of powermock class loader powermock code will be injected at the beginning of redefined class as result powermock code could be called first || in what way powermock supports mockito’s plugins such as mockmaker? in what way the inline mockmaker is supported?in my ‘sf’ branch in mockito i added a new experimental public api so that you can get hold of default mockito plugins:```javamockitoframework()getmockitoplugins()getdefaultplugin(mockmakerclass)```however i am not sure how this api is useful because i see that powermock has some complexity around inline mock maker || > in what way powermock supports mockito’s plugins such as mockmaker? in what way the inline mockmaker is supported?powermock requires that there is no `orgmockitopluginsmockmaker` in classpath except one that locates in `powermock-api-mockitojar` in case if powermock is used and locates in classpath its needed to avoid possible issues when another mockmaker will be loaded instead `powermockmaker`but powermock provides ability to configure to which mockmaker the `powermockmaker` has to delegate calls > however i am not sure how this api is useful because i see that powermock has some complexity around inline mock makeryes ive already implemented another approach so it will not help me  || ive checked behaviour with inline-mock-maker and tests are passed i think you may start finalising public api and cleaning code ill do required changes on powermock side and then also clean and a bit refactor code   || >ive checked behaviour with inline-mock-maker and tests are passedgreat!>i think you may start finalising public api and cleaning code will do!>ill do required changes on powermock side and then also clean and a bit refactor codecan you make sure that none of the powermock code imports ""orgmockitointernal*"" packages? internal classes eg classes that reside underneath ""orgmockitointernal*"" can change without notice with any version of mockito those classes are not considered public api in current ""mockito2"" branch in powermock i still references to internal mockito classesdo i need to provide you public api to get hold of the default implementation of mockmaker (inline or not)? || > can you make sure that none of the powermock code imports ""orgmockitointernal"" packages? internal classes eg classes that reside underneath ""orgmockitointernal"" can change without notice with any version of mockito those classes are not considered public api in current ""mockito2"" branch in powermock i still references to internal mockito classesi can find several places where `orgmockitointernal` is mentioned in code:1 annotation processing - will be rewritten not an issue 1 checking if method was called - as ill change it as we discuss 1 several test - some of them will be refactored for some of them its not a big deal because string `orgmockitointernal` is used just as test data1 configuration - using `mock-maker-inline` as alias `orgmockitointernalcreationbytebuddyinlinebytebuddymockmaker` - it has to be changed maybe > do i need to provide you public api to get hold of the default implementation of mockmaker (inline or not)?no i dont need a public api for getting an instance of `mockmaker` but it will be useful to get class of default mockmaker or class base on alias   || thank you for reviewing the code!>no i dont need a public api for getting an instance of mockmaker but it will be useful to get class of default mockmaker or class base on aliasi see let me know if you need the instance exposing implementation class name is something i would like to avoid because the implementation class is internal and we want the flexibility of replacing it if needed i can provide you the instance but if you dont need the instance id rather implement as little new public api as possiblethat said i do believe that you need public api from mockito to give you the instance of default mockmaker :) please confirm || that i really need chain of response for mockmaker with ability setting order/priorities in this case i will put powermockmaker first in the chain handle call only for mock created with powermockito and continue chain otherwisesecond option- its get an insane of `mockmaker` base on class name or allies  because powermock provides the same flexibility as mockito a developer may specify a class or allies in configuration || from our conversation and my understanding how powermock works it looks like you need access to default mockmakers ) ill provide api for that i think it is a reasonable addition to mockito public api || access to instance of default mockmaker will not help me because ill still create an instance of inlinemockmaker which locates in internal packagesupporting of inline maker is one of higher demanded featurebest regradsarthur zagretdinovon 18 aug 2017 at 19:07 szczepan faber <notifications@githubcom<mailto:notifications@githubcom>> wrote:from our conversation and my understanding how powermock works it looks like you need access to default mockmakers ) ill provide api for that i think it is a reasonable addition to mockito public api—you are receiving this because you were mentionedreply to this email directly view it on github< or mute the thread< || main idea is that android developers especially kotlin developers want to use powermock for mocking static methods and mockito for any other purpose like mocking final classes but mockito allows to declare only one mockmaker in class path so if powermock put the file for in jar as it is done now then a developer cannot declare and use inline mockmaker  || for what it is worth i opened a ticket for both mockito and powermock toaddress this but it was closed saying it will be addressed in mockito 3 ihave old branches that allow a user to switch manually || there is no reason to provide ability for manual switching it will face the same issue - using mockito and powermock internal packages || ive added new public api and changed existing api in my experimental branch sf please try it out before i start polishing the code further herere the changes i made:```java//for mockmakers:mockitoframework()getplugins()getdefaultplugin(mockmakerclass)mockitoframework()getplugins()getinlinemockmaker()//changed a little bit how invocations are created:mockitoframework()getinvocationfactory()createinvocation()```please confirm that this is all we need to get rid of all ""orgmockitoninternal"" from powermock codebase || exciting :) were almost done! || once this process is completed we should publish a new version to mavencentral and announce on like twitter i have been following this thread fora while now this is great work! || thank you! i agree completely i am also looking forward to the happy ending :) || > please confirm that this is all we need to get rid of all ""orgmockitoninternal"" from powermock codebasei confirm ive just push changes where ""orgmockitoninternal"" is used only in one place it is annotation processing as i mentioned earlier im going create a additional task for it and completely rewrite this part because easymock version also have such problem im going to create a one annotation engine for mockito and easymock  || ive started code clean up and one interesting idea came to my mind if im able to create a custom implementation of `mockitosettings` then ill implement all mock creating logic in `powermockcreator` instead using custom class that uses `mockitomock` in this case `powermockito` could delegate all calls to `mockito` with custom `mockitosettings` what do you think?  || > i confirm ive just push changes where ""orgmockitoninternal"" is used only in one placefantastic!!!>ive started code clean up and one interesting idea came to my mind if im able to create a custom implementation of mockitosettings then ill implement all mock creating logic in powermockcreator instead using custom class that uses mockitomockdo you mean something like that:```java//instead:powermockitomockstatic(myclassclass mockitowithsettings()name(""foo""))//you would do:mockitomock(myclassclass powermockitowithsettings()staticmock()name(""foo""))```very interesting! can you scope this and list down the pros & cons of both approaches?cons: - mockito teams considers adding new methods to mocksettings as compatible changes because we dont recommend mocksettings to be subclassed we need that ability otherwise we would have to ship a major version of mockito every time we add a new method to ""mockito"" or ""mocksettings"" classes if you provide custom interface that extends mocksettings you might be exposed to incompatible changes with minor versions of mockito we could potentially discuss this point and figure out a solution that would work for powermockito - new api would be different from what your users are accustomed to and might be more problematic to roll out discourage from upgrading users still have to know about powermockito static method entry point regardless if it is powermockitomock or powermockitowithsettingsprons (im not sure you can help out with this): - are you looking to remove powermockito class and have less code to maintain? is it the goal that sparked this idea? - it would be cool to unify the api so that to use powermockito the one uses normal mockito api and drops some annotation to the class or method to signify to use powermockito behind the hood it does seem like a lot of work thoughhope that helps! || > are you looking to remove powermockito class and have less code to maintain? is it the goal that sparked this idea?no im not going to drop `powermockito` because is has api for new and private code mocking i thinking about putting code that create mock in one place right now the creating mock logic is spread between at least two classes: `powermockmaker` and `defaultmockcreator` first implements mockitos interface and has logic with handler and so on the second is use to create mock by powermock and validate mock (duplicates `typemockability`)>  do you mean something like that:> //instead:> powermockitomockstatic(myclassclass mockitowithsettings()name(""foo""))> //you would do:> mockitomock(myclassclass powermockitowithsettings()staticmock()name(""foo""))its one of the option `powermockito` will still have `mockstatic` as shortcut for `powermockitowithsettings()staticmock()` > it would be cool to unify the api so that to use powermockito the one uses normal mockito api and drops some annotation to the class or method to signify to use powermockito behind the hood it does seem like a lot of work thoughi agree that it will be nice to have powermock as plugin to mockito for mocking cases such as mock static system and new all these 3 cases could be covered by using java agent and class redefining with using bytebuddy and without using custom class loader  || i think that we can stop for now make mockito release with new api first beta powermock 20 and continue discuss feature change we have achieved our goal - removing using mockito private api  || i have raised a pull request  to merge all change and prepare for release im waiting only while mockito code will be cleaned and released  || sounds good were on it! || i made first pass on the changes and the public api looks good we are not far from being ready to merge!### new public apiorgmockitomocksettings#buildorgmockitomockingdetails#getmockhandlerorgmockitomockitoframework#getpluginsorgmockitomockitoframework#getinvocationfactorydeprecated orgmockitointernalinternalmockhandlerorgmockitoinvocationinvocationcontainerorgmockitoinvocationinvocationfactoryorgmockitoinvocationmockhandler#getmocksettingsorgmockitoinvocationmockhandler#getinvocationcontainerorgmockitonotextensible### todo @szczepiq1 verify powermock needs it2 add missing documentation / tests3 add (@)since tag || mockito 2100 has been published!!! wooot!nice work everybody it tooks us 3 months but we made it :) @thekingnothing let us know if you need something! || yeah! it was a great job @szczepiq thank you a lot for help! im preparing a first beta release with using mockito public api  || @thekingnothing how are things? were you able to push a stable release of powermock with new version of mockito? do you need help? is there a ticket in powermock that we can track?cheers! || @szczepiq im continue working on powermock 200 release but its too early to talk about a stable release i focused on jdk 90 support in past two weeks which was required for kafka and maven surefire ( i also dropped the first public beta with supporting new mockito api and im collecting first issues like  yes there is a ticket where all issues to fix/implement are listed  || ";1;0;merge branch release/2x into sf;
1122;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;made it possible to delay the return of a mock or spy (#1117);a cherry-picked version of #1119 for the 2.x branch.;;0;indivisible;;looks good but wait until i cut release 061 before pushing ||;;;;1;1;add missing @override annotations;
1122;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;made it possible to delay the return of a mock or spy (#1117);a cherry-picked version of #1119 for the 2.x branch.;;0;operatorskipuntil;operator skipuntil#1060;#1034 ;;;;1;1;operatorskipuntil;
1122;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;made it possible to delay the return of a mock or spy (#1117);a cherry-picked version of #1119 for the 2.x branch.;;1117.0;made it possible to delay the return of a mock or spy (#1117);a cherry-picked version of #1119 for the 2x branch;yup in master there are not checkstyle verification || thats because the backport wasnt finished yet :( havent had time to dive into the failing tests there ||  merging 1122  the change to 2x! ||;answer with delay in mock or spy to improve testing of asynchronous code;"im currently using mockito for component testing of microservices  all code should be run up to the boundary at which another microservice is called  in the component test the mocks return very quickly but obviously in integration testing the real calls return much more slowly  some threading problems are revealed by the slow returns that would have been revealed in the component test if the returns could be forced to come back more slowly  since integration tests are *painfully* slow to start this would save me the developer considerable time in debugging this kind of issue once i discover it in the integration testsbecause its so easy to write ive already solved it with a class called answerwithdelay  it takes another answer as a parameter and inserts a little sleep before it returnsif desired i can turn this little helper into a pr for mockito or perhaps theres already something there that does this that ive overlookedbest regardsmyrle```@runwith(springrunnerclass)@springboottest(webenvironment  springboottestwebenvironmentdefined_port        classes  {abstractrhythmtesttestconfigurationclass}        properties  {""rhythmuserhomer"" ""rhythmbeatcheckrate500""})public class abstractrhythmtest {  //  static class answerwithdelay<t> implements answer<t> {    private final int sleepytime    private final answer<t> answer    answerwithdelay(final int sleepytime final answer<t> answer) {      thissleepytime  sleepytime      thisanswer  answer    }    @override    public t answer(final invocationonmock invocation) throws throwable {      timeunitmillisecondssleep(sleepytime)      return answeranswer(invocation)    }  }  beat createbeat(          final string applicationidentifier          final string beatidentifier          final int alignmenthour          final localdatetime expectedbeattimestamp) throws interruptedexception {    final string tenantidentifier  tenantdatastorecontextgettenantname()    final beat beat  new beat()    beatsetidentifier(beatidentifier)    beatsetalignmenthour(alignmenthour)    mockitodoanswer(new answerwithdelay<>(2_000 new returns(optionalof(permittablegroupidsforapplication(applicationidentifier)))))when(beatpublisherservicespy)requestpermissionforbeats(matcherseq(tenantidentifier) matcherseq(applicationidentifier))    mockitodoanswer(new answerwithdelay<>(2_000 new returns(true)))when(beatpublisherservicespy)publishbeat(matcherseq(beatidentifier) matcherseq(tenantidentifier) matcherseq(applicationidentifier)            additionalmatchersor(matcherseq(expectedbeattimestamp) matcherseq(getnexttimestamp(expectedbeattimestamp))))    thistestsubjectcreatebeat(applicationidentifier beat)    assertasserttrue(thiseventrecorderwait(eventconstantspost_beat new beatevent(applicationidentifier beatgetidentifier())))    mockitoverify(beatpublisherservicespy mockitotimeout(2_500)times(1))requestpermissionforbeats(tenantidentifier applicationidentifier)    return beat  }  //}```";if the implementation is clean and generic i would be in favor of it || @szpak for what version is that feature planned (or has it been already released)? ||;1;0;fix checkstyle violation + add @since tags;
1125;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo: remove repeated  a;;;0;array handling in objects#tostringhelper; currently there is no handling for arrays in helpers in objects eg tostringhelper and objectequalthat means i cannot doobjectstostringhelper(getclass())&nbsp&nbsp&nbsp&nbspadd(""foo"" thisfoo)&nbsp&nbsp&nbsp&nbspadd(""anarray"" thisanarray)&nbsp&nbsp&nbsp&nbsptostring()(i know i can change it to add(""anarray"" arraystostring(thisanarray)) but it looks bad)same for objectsequal when i am overriding equals() i cannot do:return objectsequal(""foo"" otherfoo) &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&& objectsequals(""anarray"" otheranarray)i believe adding corresponding overloads should not be difficult and it makes the api much easier to use"; as kurt says this is mostly just a matter of changing objectstostringbuilder to append ""arraysdeeptostring(value)"" instead of just ""value"" then you can add some tests for the new behavior it should make a decent introductory real cl scottjohnson@googlecom || this should be mirrored out shortly || ";;;;0;1;;
1125;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo: remove repeated  a;;;0;"fix typo: remove repeated ""a""";; merging 1125 ;;;;1;1;"fix typo: remove repeated ""a""";
1125;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo: remove repeated  a;;;0;read timing;;;;;;1;1;add support for tracking connector read time;
1125;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo: remove repeated  a;;;1060.0;operator contrib math;operators of contrib-mathissue #1060i only changed the average code to operators left the sum and min/max as they were renamed files to operator;#1039;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;"im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > —> reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple ""absolute"" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  ";1;0;corrected lf;
1128;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;improve detection on non-mockable types - byte buddy 1.6.14->1.7.0;stronger assertions on class loader origin when choosing what methods are mockable.;;0;cacherefresh(k key callable<v> newvalueloader); i could use cache (not loading cache) with support for refreshing values ""manually"" iecacherefresh(k key callable&ltv> loaderfornewvalue)would you please consider adding this feature? thanks"; ;;;;0;1;;
1128;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;improve detection on non-mockable types - byte buddy 1.6.14->1.7.0;stronger assertions on class loader origin when choosing what methods are mockable.;;0;improve detection on non-mockable types - byte buddy 1614->170;stronger assertions on class loader origin when choosing what methods are mockable; merging 1128 ;;;;1;1;addresses #1064: stronger assertions on class loader origin when choosing what methods are mockable;
1128;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;improve detection on non-mockable types - byte buddy 1.6.14->1.7.0;stronger assertions on class loader origin when choosing what methods are mockable.;;0;add directorylister interface;use dependency injection instead of a static method call;;;;;1;1;add directorylister interface;
1128;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;improve detection on non-mockable types - byte buddy 1.6.14->1.7.0;stronger assertions on class loader origin when choosing what methods are mockable.;;0;fix for serializedobservertest; the serializedobservertests problematic assertions:- `testmultithreadedwithnpeinmiddle` might schedule all non-null values before the exception might reach the serialized observer in addition waiting after the serialization doesnt help because the cheap value emissions get queued up before that again possibly before the exception the new code adds some delays to the non-null elements allowing the exception to get into the queue ive looped it 10000 times without failure but there is still a non-zero chance the `new nullpointerexception()` thread is significantly delayed and ends up as the last event- `testnotificationdelay` might fail due to thread scheduling of the two `onnextthread` delayed too much in respect to each other before the main thread allows the pass-through the fix is to let bot instances thread reach the run method and then let the main thread pass through them again a loop of 10000 succeeded locally- both tests are run 10 times to be more sure;#1041 ;;;;1;1;fix for serializedobservertest;
1136;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1135: properly resolve visibility bridges.;resolve the method hierarchy by byte buddy s method graph compiler to properly handle bridge methods which require a full method hierarchy analysis to detect.;;0;make eventhandler a public class; eventbus cannot be extended (protected void dispatch()) because eventhandler is package-privateworkaround: create the eventbus subclass in the comgooglecommoneventbus package suboptimal; the dispatch method and other methods that took eventhandler parameters have been made package-private themselves as of 130 they werent intended to be exposed in the first place--- ;;;;0;1;;
1136;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1135: properly resolve visibility bridges.;resolve the method hierarchy by byte buddy s method graph compiler to properly handle bridge methods which require a full method hierarchy analysis to detect.;;0;include metastore host name in exception message;;;;;;1;1;include metastore host name in exception message;
1136;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1135: properly resolve visibility bridges.;resolve the method hierarchy by byte buddy s method graph compiler to properly handle bridge methods which require a full method hierarchy analysis to detect.;;0;issues to be  with the latest operators;while merging the new operators from issue #1060 some open questions remained this issue tracks the fixes for those-  `operatormulticast` to not subscribe/unsubscribe while holding the lock-  `operatorrefcount` to not connect/disconnect while holding the lock -  `operatorsamplewithtime` to unsubscribe when oncomplete is called so the periodic schedule can be stopped;;;;;0;1;;
1136;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1135: properly resolve visibility bridges.;resolve the method hierarchy by byte buddy s method graph compiler to properly handle bridge methods which require a full method hierarchy analysis to detect.;;1135.0;1135: properly resolve visibility bridges;resolve the method hierarchy by byte buddys method graph compiler to properly handle bridge methods which require a full method hierarchy analysis to detect; merging 1136 ;[mock-maker-inline] method calls on mock forwarded to real instance;"with mock-maker-inline enabled given package-private abstract class superclass and a public subclass subclass a mocked instance of subclass sometimes incorrectly calls into real methods on the super class heres a super simple example where im able to reproduce this:```/*pkg private*/ abstract class superclass {    public abstract string getstring()    public void getstringlength() {        getstring()length()    }}public class subclass extends superclass {    @override    public string getstring() {        return ""foo""    }}```and then in a test:```public class mytest {    @rule public final mockitorule mmockitorule  mockitojunitrule()    @mock private subclass mmocksubclass    @test    public void dotest() {        mmocksubclassgetstringlength()    }}```this would fail with the following exception because the real getstringlength() method on superclass is being called:```javalangnullpointerexception	at comexamplesuperclassgetstringlength(superclassjava:7)	at comexamplesubclassgetstringlength(subclassjava:3)	at comexamplemytestdotest(mytestjava:15)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)	at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)	at orgmockitointernaljunitjunitrule$1evaluatesafely(junitrulejava:63)	at orgmockitointernaljunitjunitrule$1evaluate(junitrulejava:43)```interestingly enough if superclass visibility is changed from package private to public then things work just fine this is a pretty critical problem for us since we are trying to mock some library classes that we dont control and this is the class hierarchy the library has";;1;0;1135: properly resolve visibility bridges;
1137;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;don t use raw rypes in unusedstubbingstest;use generic specification instead of casting to the raw list type in order to make it a bit stricter.;;0;"is joineron("""") readable enough?"; some users are saying they find joineron("""") to be a less than ideal way to join strings with no separator  theyd like an alternate static factory like joinerwithnoseparator() (name unknown really)im open to arguments for and against this  my personal feeling is that nothing we do can be as obvious in its meaning as joineron("""") -- whatever method we come up with users will have to go read it and understand it as some _new_ concept i dont see a lot of value in that but again im listening"; thanks everyone after weighing all the feedback im ready to conclude ""if it aint broke dont fix it""  joineron("""") already works and its behavior is very clear--- ;;;;0;1;;
1137;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;don t use raw rypes in unusedstubbingstest;use generic specification instead of casting to the raw list type in order to make it a bit stricter.;;0;dont use raw rypes in unusedstubbingstest;use generic specification instead of casting to the raw list type in order to make it a bit stricternote that when we move to java 8 language level these workarounds could be completely removed as the built in type inference should handle it; ;;;;1;1;dont use raw rypes in unusedstubbingstestuse generic specification instead of casting to the raw list type inorder to make it a bit stricternote that when we move to java 8 language level these workaroundscould be completely removed as the built in type inference shouldhandle it;
1137;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;don t use raw rypes in unusedstubbingstest;use generic specification instead of casting to the raw list type in order to make it a bit stricter.;;0;truncate sql query text in index page;large queries make the table hard to navigate; ;;;;0;1;;
1137;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;don t use raw rypes in unusedstubbingstest;use generic specification instead of casting to the raw list type in order to make it a bit stricter.;;1136.0;fixes to the operators;fixes for issue #1136- `operatormulticast` is straightforward from concurrency perspective the only consideration is that if the current subscription gets unsubscribed before the `connect` reaches the `unsafesubscribe` it really depends on the source what it will do with an unsubscribed client it is possible to put extra effort to make sure a newly established connection wont get unsubscribed before it is actually connected or if it gets unsubscribed immediately no subscription is attempted at all- `operatorsamplewithtime`: didnt want to push too many prs so i just included it here there was a missing unsubscribe in the `oncompleted()` that makes sure the worker is stopped- `subscribersempty()` was implemented by returning the same subscriber to everyone which subscriber is stateful so if someone unsubscribes it it will appear everywhere as unsubscribed and can have unwanted effects there is no such problem with `observersempty()` as it is stateless the change just uses `subscribersfrom()` to wrap `observersempty()` and every caller gets its own independent instance- `operatorrefcount` was a bit more tricky since it has a connection counter one has to serialize subscriptions with unsubscriptions however it is possible a subscription gets unsubscribed before code reaches the connect check which may disrupt the connection counter the solution is to keep track of the unsubscriptions that happen before the connection attempts and not change the counter in case of out-of-order behavior the final aim was to avoid leaking the connection statuses if the `unsafesubscribe` throws concurrently with a client unsubscribing by using weak tokens (integers wouldnt have worked as the first 0-127 are cached in the jvm and would never gc);#1050  thanks for tackling these complicated issues ||;issues to be  with the latest operators;while merging the new operators from issue #1060 some open questions remained this issue tracks the fixes for those-  `operatormulticast` to not subscribe/unsubscribe while holding the lock-  `operatorrefcount` to not connect/disconnect while holding the lock -  `operatorsamplewithtime` to unsubscribe when oncomplete is called so the periodic schedule can be stopped;;1;0;fixes to the operators;
1146;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced map.get()  with containskey() where appropriate;based on a disussion in #1142  pointed out by @siedlerchr   checking if a  map  containts a key is better done using  map.containskey()  than checking if  map.get()  returns null. (i have checked that null is not stored in the  map  as well.);;0;addcallback to future with timeout;n@  was looking for a solution to solve an issue where i want to put a callback on a future but also want to impose a timeout on the future the optimal solution would be to have the timeoutexception fire through the onfailure callbackthe so question has a lot more context and a great answer from chris povirk i think itd be pretty useful; +1 for this feature any update on when this will be available? || +1 we are waiting on an external  service and need to control how long we wait before giving up || another +1 here we run a bunch of tasks with deadlines and this would make managing the deadlines a lot easier || ";;;;0;1;;
1146;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced map.get()  with containskey() where appropriate;based on a disussion in #1142  pointed out by @siedlerchr   checking if a  map  containts a key is better done using  map.containskey()  than checking if  map.get()  returns null. (i have checked that null is not stored in the  map  as well.);;0;intermittent classnotfoundexception;i see this failure now and then but am never able to reproduce it by running the same query a second time```javalangruntimeexception: javasqlsqlexception: query failed (#20140320_120253_02730_8tb9n): unable to create input format orgapachehadoophiveqliorcfileinputformatat comfacebookprestojdbcinternalguavabasethrowablespropagate(throwablesjava:160)at comfacebookprestojdbcprestoresultset$resultspageiteratorcomputenext(prestoresultsetjava:1555)at comfacebookprestojdbcprestoresultset$resultspageiteratorcomputenext(prestoresultsetjava:1533)at comfacebookprestojdbcinternalguavacollectabstractiteratortrytocomputenext(abstractiteratorjava:143)at comfacebookprestojdbcinternalguavacollectabstractiteratorhasnext(abstractiteratorjava:138)at comfacebookprestojdbcinternalguavacollecttransformediteratorhasnext(transformediteratorjava:43)at comfacebookprestojdbcinternalguavacollectiterators$5hasnext(iteratorsjava:542)at comfacebookprestojdbcprestoresultsetnext(prestoresultsetjava:90)at comfacebookprestoverifiervalidatorconvertjdbcresultset(validatorjava:221)at comfacebookprestoverifiervalidatorexecutequery(validatorjava:174)at comfacebookprestoverifiervalidatorvalidate(validatorjava:97)at comfacebookprestoverifiervalidatorvalid(validatorjava:67)at comfacebookprestoverifierverifier$1run(verifierjava:193)at javautilconcurrentexecutors$runnableadaptercall(executorsjava:471)at javautilconcurrentfuturetask$syncinnerrun(futuretaskjava:334)at javautilconcurrentfuturetaskrun(futuretaskjava:166)at javautilconcurrentexecutors$runnableadaptercall(executorsjava:471)at javautilconcurrentfuturetask$syncinnerrun(futuretaskjava:334)at javautilconcurrentfuturetaskrun(futuretaskjava:166)at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1110)at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:603)at javalangthreadrun(threadjava:722)caused by: javasqlsqlexception: query failed (#20140320_120253_02730_8tb9n): unable to create input format orgapachehadoophiveqliorcfileinputformatat comfacebookprestojdbcprestoresultsetresultsexception(prestoresultsetjava:1567)at comfacebookprestojdbcprestoresultsetaccess$100(prestoresultsetjava:60) 21 morecaused by: javalangruntimeexception: unable to create input format orgapachehadoophiveqliorcfileinputformatat comfacebookprestohivehiveutilgetinputformat(hiveutiljava:78)at comfacebookprestohivehivesplitsourceproviderloadpartitionsplits(hivesplitsourceproviderjava:179)at comfacebookprestohivehivesplitsourceprovideraccess$000(hivesplitsourceproviderjava:74)at comfacebookprestohivehivesplitsourceprovider$2run(hivesplitsourceproviderjava:153)at comfacebookprestohiveutilboundedexecutorexecuteormerge(boundedexecutorjava:82)at comfacebookprestohiveutilboundedexecutoraccess$000(boundedexecutorjava:41)at comfacebookprestohiveutilboundedexecutor$1run(boundedexecutorjava:53) 3 moresuppressed: javalangruntimeexception: unable to create input format orgapachehadoophiveqliorcfileinputformat 10 morecaused by: javalangclassnotfoundexception: orgapachehadoophiveqliorcfileinputformatat javaneturlclassloader$1run(urlclassloaderjava:366)at javaneturlclassloader$1run(urlclassloaderjava:355)at javasecurityaccesscontrollerdoprivileged(native method)at javaneturlclassloaderfindclass(urlclassloaderjava:354)at javalangclassloaderloadclass(classloaderjava:423)at sunmisclauncher$appclassloaderloadclass(launcherjava:308)at javalangclassloaderloadclass(classloaderjava:356)at javalangclassforname0(native method)at javalangclassforname(classjava:264)at orgapachehadoopconfconfigurationgetclassbyname(configurationjava:848)at comfacebookprestohivehiveutilgetinputformatclass(hiveutiljava:86)at comfacebookprestohivehiveutilgetinputformat(hiveutiljava:69) 9 morecaused by: javalangclassnotfoundexception: orgapachehadoophiveqliorcfileinputformatat javaneturlclassloader$1run(urlclassloaderjava:366)at javaneturlclassloader$1run(urlclassloaderjava:355)at javasecurityaccesscontrollerdoprivileged(native method)at javaneturlclassloaderfindclass(urlclassloaderjava:354)at javalangclassloaderloadclass(classloaderjava:423)at sunmisclauncher$appclassloaderloadclass(launcherjava:308)at javalangclassloaderloadclass(classloaderjava:356)at javalangclassforname0(native method)at javalangclassforname(classjava:264)at orgapachehadoopconfconfigurationgetclassbyname(configurationjava:848)at comfacebookprestohivehiveutilgetinputformatclass(hiveutiljava:86)at comfacebookprestohivehiveutilgetinputformat(hiveutiljava:69) 9 more```;fwiw weve also seen this error intermittently at airbnb but have been similarly unable to reliably reproduce it || havent seen this in a long time please reopen if youre still seeing it ||;;;;0;1;;
1146;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced map.get()  with containskey() where appropriate;based on a disussion in #1142  pointed out by @siedlerchr   checking if a  map  containts a key is better done using  map.containskey()  than checking if  map.get()  returns null. (i have checked that null is not stored in the  map  as well.);;0;scheduler fixes505;this pr contains some changes to the newthreadscheduler and eventloopscheduler which makes them work more correctly and gives some flexibility to themnote that this conflicts with pr #1143notable changes:- changed `newthreadscheduler` to use a `scheduledexecutorservice` as i dont see any particular reason why not- added proper logic for tracking and unsubscribing scheduled actions- renamed inner classes to better express their purpose (got lost in all of those inner eventloopscheduler workers)- added the ability to specify the number of cores and the worker selection policy to `eventloopscheduler` two policies are available: round robin and least-recent (default) a new `schedulers()` method is added which lets the caller specify the pool size since the eventloopscheduler is package private i wasnt sure how to expose the worker selection policy in addition eventloopscheduler implements subscription so the scheduler returned  fixed()` can be terminated i made sure the `computation()` scheduler cant be terminated this way- fixed `eventloopscheduler` to track the submitted actions properly- note that the potential subscription leak due to `innersubscriptionremove()` happening before `innersubscriptionadd()` in `eventloopworker` is not handled it cant happen with `newthreadscheduler` though although it would benefit from a `compositesubscriptiondelete()` method which doesnt unsubscribe the removed item and thus not interrupting the executor unnecessarily;"#1067 pivot fails again but locally everything works i wonder why sometimes that particular pivot test wont get enough concurrency? || ill wait for this to get merged to master and then ill rebase my pr branch for #1143 to include these changes || > pivot fails again but locally everything works i wonder why sometimes that particular pivot test wont get enough concurrency?``` java        if (runtimegetruntime()availableprocessors() > 4) {            systemoutprintln(""max outer concurrency: "" + maxouterconcurrencyget())            asserttrue(maxouterconcurrencyget() > 1) // should be 4 since we have 4 threads and cores running but setting at just > 1 as this is non-deterministic        }```i have no idea why the build system would allow only 1 thread when there are 4 cores it suggests though that this unit test is not trustworthy enough to leave as it yet this is supposed to assert we actually achieve concurrency and arent single-threaded what do you suggest doing with this test? || i plan to examine the pivot tomorrow and perhaps force a thread switch somehow || this change negatively affects performance`schedulerperformancetests` > `sptsingleresponse(schedulerscomputation())`##### before```run: 11 - 11977855 ops/sec run: 12 - 12026921 ops/sec run: 13 - 12101234 ops/sec run: 14 - 12055745 ops/sec ```##### after```run: 11 - 4616532 ops/sec run: 12 - 4525013 ops/sec run: 13 - 4605726 ops/sec run: 14 - 4622058 ops/sec ``` || the lru policy is the source of most of the performance problemswhy should we support multiple strategies? also @spodila is working on a new algorithm to replace round-robin and taking into account things such as rebalancing the event loops when long running workers get out of balance over time thus anything being done to improve these algorithms should be coordinated ive created an issue to track this:  || yes the lrus overhead is high compared to the simple subscriber activity i cant think of any trivial way to make it faster but i guess any bookkeping would increase the overhead i can switch back to the original simple round robin to see how the correctness changes affect the performance || thanks that makes sense as part of #1149 i want to mature the performance testing of this stuff using jmh so we let data drive future enhancements of these classes || ill close this and post a new pr without the  part || ";;;;0;1;;
1146;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced map.get()  with containskey() where appropriate;based on a disussion in #1142  pointed out by @siedlerchr   checking if a  map  containts a key is better done using  map.containskey()  than checking if  map.get()  returns null. (i have checked that null is not stored in the  map  as well.);;86.0;enable stubonly() on @mock annotation;since issue #86  withsettings() has a api stubonly() which speed up mocked stub a lotsin my case stubonly() huge amount of test overhead stacktrace and avoid invocation footprint list grow too large and cause oomhowever  the api is not available with `@mock` annotationi had to move tens of mock annotation from `@mock foo foo` into `mockitomock(fooclass withsetting()stubonly())````@mock(stubonlytrue)public foo lightweight```suggest adding the above api for convenience check list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_; merging 1146  < ;new lightweight stub-only mocks for scenarios where high performance is needed;"it is possible to create ""stub-only"" mocks that dont track invocations and hence might be useful for scenarios where low memory footprint / high speed is desired``` javafoo lightweight  mock(fooclass withsettings()stubonly())```for more information please see: https://codegooglecom/p/mockito/issues/detail?id84";;1;0;add test on mockannotationprocessor for @mock(stubonly  true);
1157;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add tests to verify and show that @spy can be used to allow stubbing/verification of list parameters using varargs.;hi  i thought about sending an email first but then figured that i d probably put in the test code as the example anyway  which is what this pr is all about.;;0;suggestion to support arbitrary chaining with subclasses of fluentiterable; this is a suggestion for the fluentiterable class - which is clearly intended to be extended - and also a general solution for chainability of extensible fluent interfaces  the problem is that the chainable methods on fluentiterable&ltt> return a fluentiterable&ltt> and so any chainable methods defined on the subclass cant be called after that  this problem forces chained calls to appear in a specific sequence subclass methods first  (perhaps this is not such a terrible problem but with ide auto-complete its very easy to run into)ive solved this in my own code with a certain ugly approach to template declarations - but the ugliness is restricted to the extends clause of subclass declarations  if the base class is used directly as fluentiterable likely is then the ugliness may leak out though it can easily be elided from the returns from static methods such as fluentiterablefrom()the solution is to introduce an additional template argument like so:public abstract class fluentiterable&lte t extends fluentiterable&ltet>>implements iterable&lte>chainable methods should return t  a protected method can be defined to aid this class and all subclasses in providing the correct return (because ""return this"" wont work):```@suppresswarnings(""unchecked"")protected final t me() {    return (t) this}```chainable methods can then ""return me()""each subclass merely needs to include itself as the 2nd template argument  if the subclass is also intended for extension then it can use the same template signature eg public abstract class myfluentiterable&lte t extends myfluentiterable&ltet>> extends fluentiterable&ltet>ive used this and it definitely lets you chain methods arbitrarily  the only drawback i can see is potential confusion from the wonky template signature  (i suspect anyone smart enough to want to use fluentiterable in the first place could understand it)a possible solution for segregating the confusion - and also supporting the continued use of the fluentiterable interface as it exists now - is to introduce a new base class for fluentiterable&lte> using this template signature mechanism and move all of the non-static methods to the base class  fluentiterable would retain the same effective class signature and anyone who wanted to gain the benefit of arbitrary chaining could switch to extending that base class directly"; unchecked ! unsafe in all cases especially when the design contract is to instantiate with a factory (provided by the same code unit doing the cast) but i think this is tangential  regardless of whiether the cast is checked a factory method would let subclasses override chainable methods without needing to put yet another wrapper around the superclass method return though i suppose it is a very lightweight wrapper as fluentiterable isthe real question here is whether this class is designed for extension  if it is - and if and when you implement something like a fluentset extending fluentiterable - i suspect youll want to address this somehowa key point about the extensibility of a class like fluentiterable is that the purpose of fluent interfaces is to improve the readability (and writability) of the code that _uses_ the fluent interface  making it easy and pleasant to extend seems less important  making extension possible at all is useful though || ";;;;0;1;;
1157;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add tests to verify and show that @spy can be used to allow stubbing/verification of list parameters using varargs.;hi  i thought about sending an email first but then figured that i d probably put in the test code as the example anyway  which is what this pr is all about.;;0;add tests to verify and show that @spy can be used to allow stubbing/verification of list parameters using varargs;hi i thought about sending an email first but then figured that id probably put in the test code as the example anyway which is what this pr is all aboutim not completely sure that there isnt already a better way to go about stubbing list params if there are im happy to learn! :);while the test code should be self explanatory heres a more sales-friendly exampleassuming the test wants to stub the following interface:```javainterface batchsender {  result send(list<unitofwork> batch)}```and if `unitofwork` has a lot of uninteresting data that the test doesnt care about its typical that one wants to use matchers for stubbingbut matchers dont work for list elements by default one might craft some kind of `doanswer()` statement to do this but it will be verbose and not static type safe`@spy` provides an alternative all one needs is to create a simple delegating abstract class:```javaclass footest {  @spy private mockbatchsender batchsender  @test public void testbatch() {    when(batchsendersend(same(work1) eq(work2) isnotnull())        thenreturn(ok)    // now invoke sut that calls batchsender  }  abstract static class mockbatchsender {    @override public final result send(list<unitofwork> batch) {       return send(batchtoarray(new unitofwork[0]))    }    // tests can stub/verify using this varargs friendly method    abstract result send(unitofwork batch)  }}``` ||   i am all for increasing our test coverage but i am not sure what this test tries to achieve is there an existing bug that is uncovered by this test? (even though the build and thus the test is passing) are you missing something in our documentation and should we thus add it there as an example? || this test code serves as proof that the usage pattern documented in thiswiki< advertised and as a guard against regressionon wed oct 4 2017 at 4:46 am tim van der lippe <notifications@githubcom>wrote:> i am all for increasing our test coverage but i am not sure what this> test tries to achieve is there an existing bug that is uncovered by this> test? (even though the build and thus the test is passing) are you missing> something in our documentation and should we thus add it there as an> example?>> —> you are receiving this because you modified the open/close state> reply to this email directly view it on github> < or mute> the thread> < > ||;;;;1;1;test that list of matchers (which is the main point of using @spy) works;
1157;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add tests to verify and show that @spy can be used to allow stubbing/verification of list parameters using varargs.;hi  i thought about sending an email first but then figured that i d probably put in the test code as the example anyway  which is what this pr is all about.;;0;approx_percentile fails if given a long for p;select approx_percentile(x 50) should fail with an error that p must be < 1 but instead fails with this stacktracejavalangunsupportedoperationexception    at comfacebookprestoblockuncompresseduncompressedlongblockcursorgetdouble(uncompressedlongblockcursorjava:162)    at comfacebookprestooperatoraggregationapproximatepercentileaggregation$approximatepercentilegroupedaccumulatoraddinput(approximatepercentileaggregationjava:171);duplicate of  ||;;;;0;1;;
1157;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add tests to verify and show that @spy can be used to allow stubbing/verification of list parameters using varargs.;hi  i thought about sending an email first but then figured that i d probably put in the test code as the example anyway  which is what this pr is all about.;;0;observabledefer and java 8 type-inference;"im having issues with `observabledefer` and java 8 and am not sure if theres anything we can do about it``` javapackage ioreactivexlabedgeimport rxobservablepublic class testdefer {    public static void main(string args) {        observabledefer(() -> {           return observablefrom(1)         })toblockingobservable()single()    }}```when trying to run this from eclipse i get this:```exception in thread ""main"" javalangbootstrapmethoderror: call site initialization exception    at javalanginvokecallsitemakesite(callsitejava:328)    at javalanginvokemethodhandlenativeslinkcallsite(methodhandlenativesjava:296)    at ioreactivexlabedgetestdefermain(testdeferjava:8)caused by: javalangclassformaterror: duplicate method name&signature in class file io/reactivex/lab/edge/testdefer$$lambda$1    at sunmiscunsafedefineanonymousclass(native method)    at javalanginvokeinnerclasslambdametafactoryspininnerclass(innerclasslambdametafactoryjava:324)    at javalanginvokeinnerclasslambdametafactorybuildcallsite(innerclasslambdametafactoryjava:194)    at javalanginvokelambdametafactoryaltmetafactory(lambdametafactoryjava:473)    at javalanginvokecallsitemakesite(callsitejava:301)     2 more```and trying to compile with jdk i get:```testdeferjava  error: method defer in class observable<t#2> cannot be applied to given types        observabledefer(() -> {                  ^  required: func0<? extends observable<? extends t#1>>  found: ()->{ retu1) }  reason: no instance(s) of type variable(s) t#3 exist so that observable<t#3> conforms to ? extends observable<? extends t#1>  where t#1t#2t#3 are type-variables:    t#1 extends object declared in method <t#1>defer(func0<? extends observable<? extends t#1>>)    t#2 extends object declared in class observable    t#3 extends object declared in method <t#3>from(t#3)1 error```java version:```java version ""180_05""java(tm) se runtime environment (build 180_05-b13)java hotspot(tm) 64-bit server vm (build 255-b02 mixed mode)```";"it looks like changing the generics can get it to compilethis compiles:``` java    public static void main(string args) {        deferb(() -> {           return observablefrom(1)         })toblockingobservable()single()    }    public final static <t> observable<t> deferb(func0<observable<t>> observablefactory) {        return observablecreate(new operatordefer<t>(observablefactory))    }```but this does not:``` java    public static void main(string args) {        defera(() -> {           return observablefrom(1)         })toblockingobservable()single()    }    public final static <t> observable<t> defera(func0<? extends observable<? extends t>> observablefactory) {        return observablecreate(new operatordefer<t>(observablefactory))    }``` || this compiles but isnt as slick as a one-liner``` javafunc0<observable<integer>> f  () -> observablefrom(1)observabledefer(f)```i cant remember if a similar question was asked on lambda-dev so you could ask about this issue there based on similar questions there i guess this is one of the many limitation of the new type inference algorithm: it cant propagate types anywhere around lambdas || yeah thats not okay :-)i dont understand the co/contra-variance on the current `defer` implementation especially since it doesnt seem to workthis doesnt compile (inside covariancetestjava):``` java    @test    public void testdefercovariance() {        observabledefer(new func0<observable<movie>>() {            @override            public observable<movie> call() {                if(true) {                    return observablefrom(new horrormovie())                }else {                    return observablefrom(new actionmovie())                }            }        })    }```right now the signature is this:``` javapublic final static <t> observable<t> defer(func0<? extends observable<t>> observablefactory)```it seems to work with lambdas when changed to this:``` javapublic final static <t> observable<t> defer(func0<observable<? extends t>> observablefactory)```and definitely works with this:``` javapublic final static <t> observable<t> defer(func0<observable<t>> observablefactory)```since type t is just passing through i dont understand what the `? extends` is getting for us especially since the `movie` example doesnt workcan you help me understand why co/contra-covariance is buying us on this method? if it is not giving us anything then lets remove it so it works with lambdas if it actually does serve some value then lets create a new method (no idea what to call it) without co/contra-variance that works with lambdas for the far more common case || i cant explain this but googling around indicates this to be a javac and jls problem we can remove the `? extends` after the `func0<` we have this pattern on several operators so might worth checking them as well || thanks for the feedback im going to change it to:``` javapublic final static <t> observable<t> defer(func0<observable<? extends t>> observablefactory)``` || i also confirmed this code works as of eclipse luna 44m7 it does not work in the kepler version where it compiles but never actually invokes the observable inside `defer` || apparently thats not happy everywhere i need to change it to this:``` javaobservable<t> defer(func0<observable<t>> observablefactory)```or leave it like this:``` javaobservable<t> defer(func0<? extends observable<? extends t>> observablefactory)```in order for this code to compile:``` java        observable<string> deferred  observabledefer(new func0<observable<string>>() {            @override            public observable<string> call() {                return null            }        })```have i mentioned before that i dont like dealing with `? extends`/`? super` generics?!i want to make it like this:``` javaobservable<t> defer(func0<observable<t>> observablefactory)``` || i really dislike generics the only way to keep these 3 compiling is to leave the code as is:``` java        observable<movie> d  observabledefer(new func0<observable<? extends movie>>() {            @override            public observable<? extends movie> call() {                if (true) {                    return observablefrom(new actionmovie())                } else {                    return observablefrom(new horrormovie())                }            }        })        observable<string> deferred  observabledefer(new func0<observable<? extends string>>() {            @override            public observable<? extends string> call() {                return null            }        })        observable<string> deferred2  observabledefer(new func0<observable<string>>() {            @override            public observable<string> call() {                return null            }        })```but this doesnt work with java 8 lambdasthe only thing i can think of doing is having a different operator without `? extends` for the simple cases and supported by lambdas  and leaving `defer` for the complicated ones using anonymous inner classes``` javadefer(func0<? extends observable<? extends t>> observablefactory)`````` javasomeothername(func0<observable<t>> observablefactory)```then comes the naming challenge - there is no other overload of `from` that takes a `func` so we could use that``` javafrom(func0<observable<t>> observablefactory)```- or it could be a `factory`:``` javafactory(func0<observable<t>> observablefactory) or fromfactory(func0<observable<t>> observablefactory)```the type of code this is trying to cater to is like this:  what do you think the right solution is for this? || the issue might be with the java 8 compiler there are some changes coming up in 8u20 which might affect this for the better also it might be worth posting a question on lambda-dev || this works in eclipse 44m7 for me with rxjava 0183:``` javapublic class test1 {    public static void main(string args) {        systemoutprintln(defer(() -> (() -> 1))get())        observabledefer(() -> observablefrom(1))subscribe(systemout::println)    }    @suppresswarnings(""unchecked"")    public static <t> supplier<t> defer(supplier<? extends supplier<? extends t>> func) {        return (supplier<t>)funcget()    }}``` || try compiling that code from java 8:```lgml-bechristensen:tmp benjchristensen$ /library/java/javavirtualmachines/jdk180/contents/home/bin/javac -cp rxjava-core-0183jar testdeferjava testdeferjava  error: method defer in class observable<t#2> cannot be applied to given types        observabledefer(() -> observablefrom(1))subscribe(systemout::println)                  ^  required: func0<? extends observable<? extends t#1>>  found: ()->observom(1)  reason: no instance(s) of type variable(s) t#3 exist so that observable<t#3> conforms to ? extends observable<? extends t#1>  where t#1t#2t#3 are type-variables:    t#1 extends object declared in method <t#1>defer(func0<? extends observable<? extends t#1>>)    t#2 extends object declared in class observable    t#3 extends object declared in method <t#3>from(t#3)1 error```this is with javac 180_05 || whether variance is nested the compiler falls over  :-( || @akarnokd since you are following the jdk 8_u20 stuff closer than us are these problems going to be solved or do we need to consider reducing support for co/contra-variance so that the normal use cases can work? || i can only be sure once 8u20 is released i take the upcoming eclipses compiler which doesnt have this problem is the indicator that the issue should be solved by the next release of javac however [this]( preview builds change notes doesnt seem to mention the issue at hand id say lets keep the current variance set and if the u20 release doesnt come before last week of june lets change the signatures || sounds good with variance you always loose :-( || eclipse luna (44) release works as expected i cant find any eta on 8u20 but i guess they will release it right after we changed our signature || looks like august is when it is scheduled for ga release:  || as of java version ""180_11"lgml-bechristensen:tmp benjchristensen$ /library/java/javavirtualmachines/jdk180_11jdk/contents/home/bin/javac -cp ~/development/github/rxjavafork/rxjava-core/build/libs/rxjava-core-0200-rc5-snapshotjar testdeferjava testdeferjava  error: method defer in class observable<t#2> cannot be applied to given types        observabledefer(() -> observablefrom(1))subscribe(systemout::println)                  ^  required: func0<? extends observable<? extends t#1>>  found: ()->observom(1)  reason: no instance(s) of type variable(s) t#3 exist so that observable<t#3> conforms to ? extends observable<? extends t#1>  where t#1t#2t#3 are type-variables:    t#1 extends object declared in method <t#1>defer(func0<? extends observable<? extends t#1>>)    t#2 extends object declared in class observable    t#3 extends object declared in method <t#3>from(t#3)testdeferjava  error: method defer in class observable<t#2> cannot be applied to given types        systemoutprintln(observabledefer(() -> {                                     ^  required: func0<? extends observable<? extends t#1>>  found: ()->{ retu2) }  reason: no instance(s) of type variable(s) t#3 exist so that observable<t#3> conforms to ? extends observable<? extends t#1>  where t#1t#2t#3 are type-variables:    t#1 extends object declared in method <t#1>defer(func0<? extends observable<? extends t#1>>)    t#2 extends object declared in class observable    t#3 extends object declared in method <t#3>from(t#3)2 errors`````` javaimport javautilfunctionsupplierimport rxobservablepublic class testdefer {    public static void main(string args) {        rxdefer()        javadefer()    }    public static void javadefer() {        systemoutprintln(defer(() -> (() -> 1))get())        observabledefer(() -> observablefrom(1))subscribe(systemout::println)    }    @suppresswarnings(""unchecked"")    public static <t> supplier<t> defer(supplier<? extends supplier<? extends t>> func) {        return (supplier<t>) funcget()    }    public static void rxdefer() {        systemoutprintln(observabledefer(() -> {            return observablefrom(2)        })toblocking()single())    }}``` || still a problem in java version ""180_20-ea""  so were going to remove the variance on `defer` || ";;;;0;1;;
1162;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix for #1155 thenthrow(class);fix for #1155;;0;detect non-distinct hash codes in equalstester; just saw your google+ post on equalstester nice utility class for unit tests currently the tester does not raise alarm if each tested object returns the exact same hash code this is not strictly necessary but obviously recommended for better performance i was wondering if it would be possible to add such an option to equalstester e gnew equalstester()&nbsp&nbsp&nbspdistincthashcode()&nbsp&nbsp&nbspaddequalitygroup()or via a constuctor parameter?; id say that using plain xor in hash is an error most of the time or at least causes problems later see eg caused by the dumb specification of mapentry (using addition would be much better)most of the cases you mentioned are hash collisions caused by a hash collision of a single field this can be solved by providing two non-colliding instances for the field (failing to do so could be an error maybe)xcreate(a b1 c)hashcode() ! xcreate(a b2 c)hashcode()whenever b1hashcode() ! b2hashcode() while theres no guarantee (there are even good functions sometimes failing the test eg md5put(a)put(b)put(c)hashcode()asint()) the most probable cause is having forgotten the field agreed that error-prone could do it better || ";;;;0;1;;
1162;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix for #1155 thenthrow(class);fix for #1155;;0;rewrite identical projection expressions in terms of the same symbol;this is an existing gap in our optimizer whereby a projection may have the same deterministic expression being generated for multiple output symbols this results in the expression being computed and stored multiple times unnecessarilyfor example consider this query: our plan would look like this: the fix it looks like this //gistgithubcom/erichwang/e08606ae5fe17dc52a6c;thats odd that used to work before there wasnt any explicit optimization step but it was a side-effect of how the planner worksanyway  actually this is a slightly different case than what you are thinking of so the planner does take care of this if you explicitly call out a the expressions in a projection: like select a+1 a+1 from a and it happens in the initial planning phase the problem here is that the duplicate projections expressions are implicitly generated when we coalesce multiple consecutive projections together from under a join for example consider this:select \* from (select dummy || x as dummy from dual) a join dual b on adummy  bdummythe join planner will add a projection to generate a new adummy for the equijoin even though an existing one was already used to produce the query output ||;;;;1;1;rewrite identical projection expressions in terms of the same symbol;
1162;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix for #1155 thenthrow(class);fix for #1155;;0;fix to remove drift from scheduleperiodic;"when implementing the worker scheduler pattern in rxcpp i implemented scheduleperiodic differently because i predicted that the rxjava version would drift once the changes were working i verified my prediction in rxcpp i decided to test the same in rxjava and contribute my approachthis was my test:``` javaimport javautilconcurrenttimeunitimport rxschedulerimport rxschedulersschedulersimport rxfunctionsaction0public class periodic {    public static void main(string args) {        final scheduler scheduler  schedulersimmediate()        final schedulerworker w  schedulercreateworker()        final long initial  timeunitsecondstomillis(2)        final long period  timeunitsecondstomillis(1)        final long start  schedulernow() + initial        wscheduleperiodically(new action0() {            long count  0            @override            public void call() {                long tick  schedulernow()                systemoutprintln(stringformat(""expected -> %dms actual -> %dms drift -> %dms"" count*period tick - start tick - (start + (count*period))))                ++count            }        } initial period timeunitmilliseconds)    }}```the existing impl causes this output:```$ java -cp rxjava-core/build/libs/rxjava-core-0183-snapshotjar:/ periodicexpected -> 0ms actual -> 1ms drift -> 1msexpected -> 1000ms actual -> 1002ms drift -> 2msexpected -> 2000ms actual -> 2003ms drift -> 3msexpected -> 3000ms actual -> 3004ms drift -> 4msexpected -> 4000ms actual -> 4005ms drift -> 5msexpected -> 5000ms actual -> 5006ms drift -> 6msexpected -> 6000ms actual -> 6007ms drift -> 7msexpected -> 7000ms actual -> 7008ms drift -> 8msexpected -> 8000ms actual -> 8009ms drift -> 9msexpected -> 9000ms actual -> 9010ms drift -> 10msexpected -> 10000ms actual -> 10011ms drift -> 11msexpected -> 11000ms actual -> 11012ms drift -> 12msexpected -> 12000ms actual -> 12013ms drift -> 13msexpected -> 13000ms actual -> 13014ms drift -> 14msexpected -> 14000ms actual -> 14016ms drift -> 16msexpected -> 15000ms actual -> 15017ms drift -> 17msexpected -> 16000ms actual -> 16018ms drift -> 18msexpected -> 17000ms actual -> 17019ms drift -> 19msexpected -> 18000ms actual -> 18020ms drift -> 20msexpected -> 19000ms actual -> 19021ms drift -> 21msexpected -> 20000ms actual -> 20022ms drift -> 22msexpected -> 21000ms actual -> 21023ms drift -> 23msexpected -> 22000ms actual -> 22023ms drift -> 23msexpected -> 23000ms actual -> 23024ms drift -> 24ms```with this commit the test outputs:```$ java -cp /:/rxjava-core/build/libs/rxjava-core-0183-snapshotjar periodicexpected -> 0ms actual -> 3ms drift -> 3msexpected -> 1000ms actual -> 1001ms drift -> 1msexpected -> 2000ms actual -> 2001ms drift -> 1msexpected -> 3000ms actual -> 3000ms drift -> 0msexpected -> 4000ms actual -> 4001ms drift -> 1msexpected -> 5000ms actual -> 5000ms drift -> 0msexpected -> 6000ms actual -> 6000ms drift -> 0msexpected -> 7000ms actual -> 7000ms drift -> 0msexpected -> 8000ms actual -> 8001ms drift -> 1msexpected -> 9000ms actual -> 9001ms drift -> 1msexpected -> 10000ms actual -> 10001ms drift -> 1msexpected -> 11000ms actual -> 11001ms drift -> 1msexpected -> 12000ms actual -> 12001ms drift -> 1msexpected -> 13000ms actual -> 13001ms drift -> 1msexpected -> 14000ms actual -> 14001ms drift -> 1msexpected -> 15000ms actual -> 15001ms drift -> 1msexpected -> 16000ms actual -> 16001ms drift -> 1msexpected -> 17000ms actual -> 17000ms drift -> 0msexpected -> 18000ms actual -> 18000ms drift -> 0msexpected -> 19000ms actual -> 19000ms drift -> 0msexpected -> 20000ms actual -> 20000ms drift -> 0msexpected -> 21000ms actual -> 21002ms drift -> 2msexpected -> 22000ms actual -> 22000ms drift -> 0msexpected -> 23000ms actual -> 23001ms drift -> 1msexpected -> 24000ms actual -> 24001ms drift -> 1ms```";"#1077 very nice thanks @kirkshoopwhile considering this i though of something but i havent played with this enough to know exactly how it will behave but if someone chooses an interval of 1ms and the work being done each time takes longer than 1ms what is the expected behavior? we should never have concurrent execution if i understand correctly it will result in a negative delay and result in scheduling it immediately but obviously have drift  || from what i can tell it does the right thing and just delays rather than allow concurrent execution``` javapublic class periodic {    public static void main(string args) {        final scheduler scheduler  schedulersimmediate()        final schedulerworker w  schedulercreateworker()        final long initial  100        final long period  100        final long start  schedulernow() + initial        wscheduleperiodically(new action0() {            long count  0            @override            public void call() {                try {                    threadsleep(1500)                } catch (interruptedexception e) {                }                long tick  schedulernow()                systemoutprintln(stringformat(""expected -> %dms actual -> %dms drift -> %dms"" count*period tick - start tick - (start + (count*period))))                ++count            }        } initial period timeunitmilliseconds)    }}``````expected -> 0ms actual -> 1503ms drift -> 1503msexpected -> 100ms actual -> 3009ms drift -> 2909msexpected -> 200ms actual -> 4511ms drift -> 4311msexpected -> 300ms actual -> 6012ms drift -> 5712msexpected -> 400ms actual -> 7513ms drift -> 7113msexpected -> 500ms actual -> 9015ms drift -> 8515ms```based on this im merging this as it is safe in the degraded case while being better in the normal case (work being less time than the interval) || yes that was the behavior before and i kept it there were only two options and skipping a period seemed like the wrong policy to me the user supplies both the function and the period and so they own the behavior (they can return immediately to skip and get back on track or just ensure that the period was sufficient to begin withon may 6 2014 at 9:11 am ""ben christensen"" <notifications@githubcom<mailto:notifications@githubcom>> wrote:very nice thanks @kirkshoop considering this i though of something but i havent played with this enough to know exactly how it will behave but if someone chooses an interval of 1ms and the work being done each time takes longer than 1ms what is the expected behavior?we should never have concurrent execution if i understand correctly it will result in a negative delay and result in scheduling it immediately but obviously have drift## reply to this email directly or view it on github || this is an excellent improvement im working on something that does microsecond level scheduling and this change makes it work very accurately:```########################################################################################step: 10  interval: 111micros  rate: 9000/s########################################################################################total > success: 315237 error: 0   last 10s > success: 9001/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0total > success: 360280 error: 0   last 10s > success: 9000/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0total > success: 405334 error: 0   last 10s > success: 9001/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0total > success: 450373 error: 0   last 10s > success: 9001/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0```without this change it isnt even close:```########################################################################################step: 10  interval: 111micros  rate: 9000/s########################################################################################total > success: 239363 error: 0   last 10s > success: 6835/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0total > success: 273742 error: 0   last 10s > success: 6869/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0total > success: 308053 error: 0   last 10s > success: 6863/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0total > success: 342820 error: 0   last 10s > success: 6901/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0``` || ";;;;1;1;fix to remove drift from scheduleperiodic;
1162;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix for #1155 thenthrow(class);fix for #1155;;1155.0;fix for #1155 thenthrow(class);fix for #1155 mockitothenthrow(class) now fails when the given throwable type is not declared on the stubbed method;"the build fails for jdk7 seem like an ci problem: execution failed for task :fetchallcontributors || >the build fails for jdk7 seem like an ci problem: execution failed for task :fetchallcontributorsi will look into that thank you ||  merging 1162  ";thenthrow(class) should only throw checked exceptions that match the signature of the stubbed method;hi- mockito-core 2847```javapublic class footest {    @test(expected  mockitoexceptionclass)    public void using_thenthrow_throwable() {        c mock  mock(cclass)        // set a checked exception that does not matche the method signature        when(mockdoit())thenthrow(new exception())    }    @test(expected  mockitoexceptionclass)    public void using_thenthrow_class() {        c mock  mock(cclass)        // set a checked exception that does not matche the method signature        when(mockdoit())thenthrow(exceptionclass)    }    static class c {        string doit() {            return null        }    }}````using_thenthrow_throwable()` passes but `using_thenthrow_class()` fails```javalangassertionerror: expected exception: orgmockitoexceptionsbasemockitoexception```the javadoc of `ongoingstubbing#thenthrow(class)` says *if the throwable class is a checked exception then it has to match one of the checked exceptions of the stubbed method signature*however the result of `using_thenthrow_class()` shows that it is not so;i am going to fix this throwsexceptionclass must simply implement validableanswer || thank you for reporting indeed it is a bug ||;1;0;added more tests;
1181;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;#1179: fix performance regression caused by use of method graph compiler.;in order to properly discover visibility bridges  we have to run a full analysis of the method graph. the compilation of this method graph is rather expensive and we require to cache a computed graph. the caching is however non-trivial as it references classes which might be unloaded. in order to avoid a leak  we cache classes using non-strong references.;;0;built javadoc looks terribly incomplete because nothing is being inherited from jdk sources as expected; our built javadoc is really sad right now as everything that should be inherited out of jdk sources is just missingdoes anyone know how to fix the maven configuration to do the right thing here?  if the best we can do is ""optimistically hope to find srczip inside whatever jdk directory were using"" that may be good enough i wouldnt be surprised if there were no better way";  `` ;;;;0;1;;
1181;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;#1179: fix performance regression caused by use of method graph compiler.;in order to properly discover visibility bridges  we have to run a full analysis of the method graph. the compilation of this method graph is rather expensive and we require to cache a computed graph. the caching is however non-trivial as it references classes which might be unloaded. in order to avoid a leak  we cache classes using non-strong references.;;0;fix thread ui and add release notes;;;;;;1;1;remove documentation footer;
1181;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;#1179: fix performance regression caused by use of method graph compiler.;in order to properly discover visibility bridges  we have to run a full analysis of the method graph. the compilation of this method graph is rather expensive and we require to cache a computed graph. the caching is however non-trivial as it references classes which might be unloaded. in order to avoid a leak  we cache classes using non-strong references.;;0;behavior subject time gap fix;this fix should make sure subscribing between two event emissions wont create a gap in the received events i had to implement my own subscription management to ensure the required coordination behavior performance comparison for simple pass-through behavior:publishsubject (master) ~86 mops/sbehaviorsubject (master) ~47 mops/sbehaviorsubject (this) ~46 mops/sthe relative slowness compared to ps is due the volatile write on each element and the additional ~1mops/s is due to the subscription coordination;#1092  > i had to implement my own subscription management to ensure the required coordination behaviorcan this really not be done with `subjectsubscriptionmanager`? having it be different makes an already complicated set of logic now be implemented in two different wayswhy would the others not benefit from the same improvements? || its more like an augmentation than an improvement over the existing subject subscription management at first glance id need to add 1-2 callback points to an already complicated ssm i cant say for sure until i try to reimplement the other subjects and see what are the common points || id rather not proceed with this change until we know the implications across all of them its hard enough working with subjects without 2 slightly different implementations of the same thing || closing this as outdated see #1185 for the new proposal ||;;;;0;1;;
1181;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;#1179: fix performance regression caused by use of method graph compiler.;in order to properly discover visibility bridges  we have to run a full analysis of the method graph. the compilation of this method graph is rather expensive and we require to cache a computed graph. the caching is however non-trivial as it references classes which might be unloaded. in order to avoid a leak  we cache classes using non-strong references.;;1179.0;#1179: fix performance regression caused by use of method graph compiler;in order to properly discover visibility bridges we have to run a full analysis of the method graph the compilation of this method graph is rather expensive and we require to cache a computed graph the caching is however non-trivial as it references classes which might be unloaded in order to avoid a leak we cache classes using non-strong referencesthis requires some real-world experience to discover if this caching mechanism suffices; merging 1181  < ;mockito 290 is significantly slower;we just tried to upgrade to mockito 290 (from 2847) and found that our individual tests went from about 1 second to run per test to about 24 seconds to run per testwe tried to find which release version causes the tests to run slow and found that version 2850 is the first version that causes the slowdown (versions 2848 and 2849 run fine)our environment:- java 180_144- android gradle project (using gradle 41 and android studio 30 beta3)- kotlin 114-2- junit 412other test dependencies- dagger 211- threetenbp:136- orgxerial:sqlite-jdbc:3200;"@raphw seems to be #1136 is the culprit any insight or immediate thoughts about it? || @jeffdcamp thanks for the description are you using the android mock maker or the final mock maker? could you attach a profiler when running the tests to see what takes so much time?just to be sure: you verified that 2850 causes the same performance problems? || if you are using the final mock maker i see how the resolution could be problematic using the method graph compiler this is quite expensive and i did not think much about it when implementing the correct solution we should definetly cache the result || @jeffdcamp could you build mockito from the branch `performance-fix` and try it out? i wonder if that fixes the regression  @raphw  we are not using ""android mock maker or the final mock maker""   yes 2850 is the version that causes the slowdowns (we tried both  2848 and 2849 and those 2 versions work fine)ill try to perform a build of mockito ""performance-fix"" branch || @raphw i just built the ""performance-fix"" branch and changed the dependency on our project to ""291"" and that did not fix the slow downthe following is using version 291 (note the long run times):( following is using version 2847:![image]( || and you really get the same behavior in 2850? this seems unlikely if you are not using the inline mock maker (are you sure you have no mock maker configured?) the only change from 2849 to 2850 is in the class `mockmethodadvice` which should not even get loaded unless you are using the mock maker in which case the versions should be identicalmaybe the performance regression happens with 2849 too? this would make more sense as it includes a major version update of byte buddycould you run the tests while profiling with something like jprofiler (there is a free trial) to see where the tests spend their time compared to before the update? || @raphw i just went to the git log and checked-out and built revision "" flaky bintray badge szczepan faber* 6/22/17 4:16 pm (1a60a8496d4b704cac115608ca67840c7d8a6865)"" and tests runs fast i then checked-out revision and built revision ""1135: properly resolve visibility bridges (#1136) rafael winterhalter* 6/24/17 2:29 am (fa66960eeb74473822fe9081246f360964da6023)"" and the tests run slowill see what i can do to profile || thanks for investigating! this is just super strange i have no idea how this could affect the subclass mock makerwhen profiling with jprofiler run a cpu sample for the `orgmockito` and `netbytebuddy` namespaces || @raphw is it possible that when tests are run/executed in android studio / intellij it might cause mock maker fire off? (sorry i dont know much about ""mock maker"") || that should not happen for kotlin it might however make sense as most types are final by defaultyou can set a break point in the `mockutil::createmock` method and see what instance of `mockmaker` you have (inline or subclass) to see what plugin is loaded || it appears to be ""inlinebytebuddymockmaker"" || in this case you are using the inline mock maker to support mocking of final types i am afraid that the lookup of visibility bridges still takes too long i will try to further improve the runtime || awesome!  let me know if there is anything else you would like me to test/try/identify || i tried caching the entire graph could you try the performance-fix branch once more? || its fixed!the latest code on the ""performance-fix"" branch is back to expected speeds!  good work! || its still preliminary as it leaks memory unfortunately i have to work a bit more with it before merginggood to know that the approach is right though! thanks for checking || let me know if you would like me to rerun my tests with updated code || thanks @jeffdcamp for the report and awesome @raphw to find the fix so quickly    || does the inline work for you in 290? several tests here fail when mocking kotlin classes but work in 2847 || @paulwoitaschek take a look at the #1183 || ";1;0;#1179: fix performance regression caused by use of method graph compiler;
1186;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;compare method of graph to defined form of method.;1180: compare against non-generic method when deciding if a method should be stubbed.;;0;localloadingcacheget(k supplier) wastes an instance on every call even if the key is present; my particular use case is:i have single shared service instance with loadingcache accessible from multiple threads service itself does not have access to datasource so i cannot create cacheloader in service and provide it to loadingcache - instead iam using overloaded ""get"" method of cache: v get(k key callable<? extends v> valueloader)my concern is: every time i call the method with callable - localcache implementation creates new cacheloader (wrapper object for that callable) even if cache already has value for that key it is not very garbage collector friendlylocalcache has a solution for that already - method that accepts cacheloader as second argument unfortunately it is package private and cannot be accessed from outsideit would be beneficial to expose this method via loadingcache interface"; kevin and i talked about it and it looks like this is more duplication than were willing to accept--- ;;;;0;1;;
1186;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;compare method of graph to defined form of method.;1180: compare against non-generic method when deciding if a method should be stubbed.;;0;full type support;;ok i think im done going through this stuff ) || ;;;;0;1;;
1186;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;compare method of graph to defined form of method.;1180: compare against non-generic method when deciding if a method should be stubbed.;;0;co/contra-variance madness;try to use the overload of mergemap with 3 function with lambdas and you get the most beautiful error message ever (in reality times 3):```error:(32 24) java: no suitable method found for mergemap(<anonymous rxfunctionsfunc1<javalangstringrxobservable<? extends javalangvoid>>><anonymous rxfunctionsfunc1<javalangthrowablerxobservable<? extends javalangvoid>>>()->responose())    method rxobservable<r>mergemap(rxfunctionsfunc1<? super javalangstring? extends rxobservable<? extends r>>) is not applicable      (cannot infer type-variable(s) r        (actual and formal argument lists differ in length))    method rxobservable<r>mergemap(rxfunctionsfunc1<? super javalangstring? extends rxobservable<? extends r>>rxfunctionsfunc1<? super javalangthrowable? extends rxobservable<? extends r>>rxfunctionsfunc0<? extends rxobservable<? extends r>>) is not applicable      (cannot infer type-variable(s) r        (argument mismatch bad return type in lambda expression          rxobservable<javalangvoid> cannot be converted to ? extends rxobservable<? extends r>))    method rxobservable<ur>mergemap(rxfunctionsfunc1<? super javalangstring? extends rxobservable<? extends u>>rxfunctionsfunc2<? super javalangstring? super u? extends r>) is not applicable      (cannot infer type-variable(s) ur        (actual and formal argument lists differ in length))```maybe (i have not tried) we can tone done on the `? extends` and `? super` in the signature a bit to avoid nesting generic types which seems to confuse the java compiler;related:  || @headinthebox  have you figured out anything you want to do here? || ill have another look maybe now that java is real the typechecker has improved ||  in  ||;;;;0;1;;
1186;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;compare method of graph to defined form of method.;1180: compare against non-generic method when deciding if a method should be stubbed.;;1180.0;compare method of graph to defined form of method;1180: compare against non-generic method when deciding if a method should be stubbed; merging 1186 ` ;stubbing superclass method using mockito inline propagate to the real method call;"hi my java env is ```java version ""180_74""java(tm) se runtime environment (build 180_74-b02)java hotspot(tm) 64-bit server vm (build 2574-b02 mixed mode)```os version`macos sierra 10126`mockito version: `mockito-inline:290`for this simple snippet:```    public class stringlist extends arraylist<string>{    }```then stubbing the size() method```stringlist stringlist  mock(stringlistclass)doreturn(10)when(stringlist)size()```stringlistsize() will always return 0 and size() is acually called in arraylist instread of the stubthe above code works perfectly with mockito-core for a workaround stringlist can be written in ```    public class stringlist extends arraylist<string>{        @override        public int size(){            return 0        }    }```then size() can be stubbedi only need mockito inline to mock a single final class in one test case but mockito-inline took over my entire modules unit tesst im wondering if theres a way to choose mockito-core or inline for each test?and im not sure if this is related if stub in this way` when(stringlistsize())thenreturn(11)`mockito reports> orgmockitoexceptionsmisusingmissingmethodinvocationexception: > when() requires an argument which has to be a method call on a mock> for example:>     when(mockgetarticles())thenreturn(articles)> > also this error might show up because:> 1 you stub either of: final/private/equals()/hashcode() methods>    those methods *cannot* be stubbed/verified>    mocking methods declared on non-public parent classes is not supported> 2 inside when() you dont call method on mock but on some other object";"if i am not mistaken we explicitly disallow mocking of such data classesif you need to stub a list then just create a list with the value youexpect for more information see wed 30 aug 2017 07:49 hu yao <notifications@githubcom> wrote:> hi my java env is>> java version ""180_74""> java(tm) se runtime environment (build 180_74-b02)> java hotspot(tm) 64-bit server vm (build 2574-b02 mixed mode)>> os version> macos sierra 10126>> mockito version:> mockito-inline:290>> for this simple snippet:>>     public class stringlist extends arraylist<string>{>>     }>> then stubbing the size() method>> stringlist stringlist  mock(stringlistclass)> doreturn(10)when(stringlist)size()>>> stringlistsize() will always return 0 and size() is acually called in> arraylist instread of the stub> the above code works perfectly with mockito-core for a workaround> stringlist can be written in>>     public class stringlist extends arraylist<string>{>         @override>         public int size(){>             return 0>         }>     }>> then size() can be stubbed> i only need mockito inline to mock a single final class in one test case> but mockito-inline took over my entire modules unit tesst im wondering> if theres a way to choose mockito-core or inline for each test?>> and im not sure if this is related if stub in this way> when(stringlistsize())thenreturn(11)> mockito reports>> orgmockitoexceptionsmisusingmissingmethodinvocationexception:> when() requires an argument which has to be a method call on a mock> for example:> when(mockgetarticles())thenreturn(articles)>> also this error might show up because:>>    1 you stub either of: final/private/equals()/hashcode() methods>    those methods *cannot* be stubbed/verified>    mocking methods declared on non-public parent classes is not supported>    2 inside when() you dont call method on mock but on some other>    object>> —> you are receiving this because you are subscribed to this thread> reply to this email directly view it on github> < or mute the thread> < > || @timvdlippe sorry i didnt intend to mock list i happened to use the list as a simple example this case happens when mocking superclass method which is not overridden in child class || this seems to be a regression in version 290 with `mock-maker-inline` in our code base we hit the issue with some code that mocks elasticsearch 235s [`deleterequestbuilder`]( simplified example:```javadeleterequestbuilder b  mock(deleterequestbuilderclass)assertnull(bget())```this passes with mockito 2847 but causes an npe with mockito 290 because the ""real"" method is invoked:```javalangnullpointerexception	at orgelasticsearchactionactionrequestbuilderexecute(actionrequestbuilderjava:86)	at orgelasticsearchactionactionrequestbuilderexecute(actionrequestbuilderjava:56)	at orgelasticsearchactionactionrequestbuilderget(actionrequestbuilderjava:64)```cc @raphw since the issue only happens when `mock-maker-inline` is enabled  || i found the error which lies in the new bridge method sensitive override detection mechanism i added a test case and hope everything works again in the new version || i  this in #1179 please reopen the issue if it is not resolved || hi @raphw i just built and installed 1c61f1a91a7d5d8367b3dbddb6270afdd96c8f6a using `/gradlew publishtomavenlocal` the above issue still reproduces unfortunately || darn i reproduced the issue as a test case but i assume it was insufficient to capture the full problemthanks for double-checking i will hav another lookps: you did build the release 2x branch? alternatively the build should be released by now || ah i just double-checked and it seems like the actual fix got lost in git rebase i will fix this tonight! || new try! || thanks! just built `v292` locally and i can confirm the issue is fixed   dare i ask: since this release resolves a regression do you plan to publish it on maven central? || should be published automatically @szczepiq? || nah by default they only go to bintray (i can configure our nexus to proxy to bintray but i prefer to keep the number of non-maven central hosted dependencies as small as possible also by publishing on maven central a larger audience will find the fix using the `versions-maven-plugin`) || >should be published automatically @szczepiq?we currently dont publish automatically to maven central based on the feedback from community that there are too many versions of mockito around :) we might get back to publishing every version as we did beforei plan to ship 210 soon for  so it will land in maven central! || ";1;0;compare method of graph to defined form of method;
1192;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;added new public api for spring-boot use case;not intended for merging yet  submitted for visibility.;;0;charmatcher static init is long; charmatcher does a lot of work in static init including creating a 65k element (where elements are ""bits"") and calling charmatchermatch() for every codepoint on a complex matcherthe worst offender is:public static final charmatcher invisible  &nbspprecomputed()which does the aforementioned work  this takes maybe 50ms in the best base but can take > 10 seconds in pathological cases as described here: who never use the static members of charmatcher or even who never use charmatcher at all (but it gets indirectly referred to by other guava code) pay this pricein addition to speeding up the underlying table creation (perhaps with an optimized non-fluent version of the matchers for things like invisible) it would be great if these singletons were created lazily so you dont pay the cost until they are used - very useful for things like invisible which are probably rarely used this could be accomplished by having a char matcher which internally delegates to some underlying matcher but constructs the underlying lazily"; we might want to explain what we   is all precomputing() lazy now? ||;;;;0;1;;
1192;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;added new public api for spring-boot use case;not intended for merging yet  submitted for visibility.;;0;system connector predicate pushdown bug fix;domains with single value were getting ignored by system connector;this looks good but @erichwang should take a look || yep other than that one comment looks good to me too ||;;;;0;1;;
1192;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;added new public api for spring-boot use case;not intended for merging yet  submitted for visibility.;;0;replaysubject with time and size bounds;ive implemented the bounded `replaysubject` variants and removed the old `operatorreplaycustomreplaysubject` so the various `observablereplay()` now use this versionnote that this is based on the current `subjectsubscriptionmanager` and not my manager from pr #1185 ive copied the `replaysubjectconcurrencytest` to check the concurrency propertiesthe bounded buffering is implemented via a doubly-linked list where the back reference is a weak reference this allows keeping a reference to the latest `node` for each replaystate and once a node is no longer indexed it will be removed by gc a concurrency review would be much appreciated;#1104 #1105 nice people will be happy to have all the functionality on `replaysubject`should we wait until after  to rebase and merge this?i have not yet reviewed this || id review and merge this first and go back to #1185 as it surely needs some rebase anyway || closing this as the master merge got messed up || #1126;;;;0;1;;
1192;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;added new public api for spring-boot use case;not intended for merging yet  submitted for visibility.;;1191.0;added new public api for spring-boot use case;"not intended for merging yet submitted for visibility- for design and rationale see #1191- for usage see ""verificationstartedlistenertest"" classthis is still experimental so refactorings error handling javadoc is missing";" merging 1192  ";ensure spring-boot can use mockito public api;"mockito framework integrators need robust public apis from us this way they ship great mockito integrations to their customers we want to avoid the situation where framework integrators have to use mockito internal apis this leads to overhead relying on stale versions of mockito class conflicts in runtimespring-boot currently uses some internal api from mockito see  for the problem statement solution options and chosen design ### solutionas discussed in spring-boot ticket heres the api we would like to prototype:- new ""verificationstartedlistener""- the instance of listener can be passed on mock creation- listener is notified when mockitoverify is invoked but before the verification is triggered- it is possible to replace the mock object that is being verified (key feature needed by spring-boot)### example usage```javamock(fooclass withsettings()verificationstartedlisteners(new verificationstartedlistener() {  public void onverifystarted(verificationstartedevent event) {    eventgetmock()    eventsetmock(arbitrayobject)  }}```";"i put together a prototype in ""mockito-spring-boot"" branch opened pr #1192 for visibility how to use it?- clone mockito and check out ""mockito-spring-boot"" branch- /gradlew publishtomavenlocal- grab newly published version of mockito from maven local and try it out!- i dont have javadocs yet this test class documents the new api (hopefully :) ->  next steps:- @wilkinsona let me know if this is enough for you to try it out!- we can use the pr that i have opened for review comments regarding the api || @szczepiq this looks great ive built the `mockito-spring-boot` branch and prototyped the updates required for spring boot to use it:  all our tests pass and as you can hopefully see boots code is now significantly simpler thanks very much || fantastic! i will polish the code / documentation and get the release out soon thank you for testing this out and suppling sample project! || @wilkinsona can you try out one more time for us please?ive cleaned up the implementation and the pr in mockito is ready to go i want to make sure that we ship code that works for spring boot i have added some extra validation for setmock() method other than that i think that the api has not changed since i provided the experimental the code is in the same branchthank you in advance! :) || @szczepiq thanks for the opportunity to double-check things ive built the current head of the `mockito-spring-boot` branch and updated [my prototype]( to use the resulting 2110 binaries the only change that was necessary was to update the version number so things look good from my perspective || we released new version today: 2110 it includes the new api that spring boot can use || @wilkinsona - thank you for help and nice collaboration! || closing per     || ";1;0;merge branch release/2x into mockito-spring-boot;
1199;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixes 977: javadoc on verifyzerointeractions;make the javadoc of  mockito#verifyzerointeractions  to make it more;;0;fixes 977: javadoc on verifyzerointeractions;make the javadoc of `mockito#verifyzerointeractions` to make it moreobvious that it does the same thing as `mockito#verifynomoreinteractions`977;  nice change makes the documentation more accurate and simpler thank you! ||;;;;1;1;fixes 977: javadoc on verifyzerointeractionsmake the javadoc of mockito#verifyzerointeractions to make it moreobvious that it does the same thing asmockito#verifynomoreinteractions;
1199;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixes 977: javadoc on verifyzerointeractions;make the javadoc of  mockito#verifyzerointeractions  to make it more;;0;installation documentation -- delete section 12 discovery service;summarythe existing documentation for 12 discovery service is not needed: configuration shown in 11 deploying presto already has the embedded discovery server enabled looks to me like section 12 can simply be removed/deleted thereby simplifying installation procedures even more detail david phillips wrote:> at facebook we recently switched to using the embedded discovery server> and have not seen any issues with it i have also removed the separate discovery service from my installation and have not experienced any issues while i have done some testing i assume that this is insignificant to usage with the embedded discovery server at facebook > i think we can further simplify the> installation and documentation by making this default and removing> the discovery service section > > set discovery-serverenabledtrue in the config properties for the coordinator> the update discoveryuri on all presto nodes to point to the coordinatorin fact the configproperties examples show for the coordinator and the workers at has the embedded discovery server enabled i believe that section 12 can simply be deleted from the installation documentation with no other changes the end;;;;;0;1;;
1199;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixes 977: javadoc on verifyzerointeractions;make the javadoc of  mockito#verifyzerointeractions  to make it more;;0;rxjava-string: stringobservablefrom(inputstream) does not close inputstream;would be nice if `stringobservablefrom(inputstreamsize)` closed the `inputstream` once finished with it are there any obstacles to this being incorporated?the same again for the `stringobservablefrom(reader size)`line 62 //githubcom/netflix/rxjava/blob/master/rxjava-contrib/rxjava-string/src/main/java/rx/observables/stringobservablejava;"i think its better that leaving the user to close it sometimes the user may need to reuse the stream and if the user wants to close it once the observable finishes he can use `using` operator eg``` java    public void foo(final inputstream i) {        observableusing(new func0<subscription>() {                             @override                             public subscription call() {                                 return subscriptionscreate(new action0() {                                     @override                                     public void call() {                                         try {                                             iclose()                                         } catch (ioexception e) {                                             throw new runtimeexception(e)                                         }                                     }                                 })                             }                         } new func1<subscription observable<byte>>() {                             @override                             public observable<byte> call(subscription subscription) {                                 return stringobservablefrom(i)                             }                         }        )    }``` || i think this is best served by the practice of ""whoever opened it should close it""the `from(inputstream)` approach means the `observable` didnt open it and therefore shouldnt close itif it was `from(file)` then it is the `observable` who opens it and should close it || thanks @zsxwing  for the explicit example thats very helpful i expect that the use case where the user wants it closed will be common so for the convenience of the user i might make a pull request with additional methods like `fromandclose(inputstream)` so that users dont need to implement all that using code || >  i might make a pull request with additional methods like fromandclose(inputstream) so that users dont need to implement all that using codei suppose we also miss some document about `stringobservablefrom(inputstreamsize)` or `stringobservablefrom(reader size)` observables returned by them can only be subscribed once they can not be used directly with `repeat` `retry` || thanks for the answers looks fine to close || ";;;;0;1;;
1201;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added method to generate string with n spaces or n characters;used in a number of places so makes sense to have a method.;;0;cachegetall fails to trigger refresh; after determining which keys we already have in the cache we could check which of those are already stale and include those in the set we query  if any of those dont happen to come back perhaps we still use the stale values; ;;;;0;1;;
1201;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added method to generate string with n spaces or n characters;used in a number of places so makes sense to have a method.;;0;fix javadoc in pluginloader#withalias javadoc;fix the misuse of `@deprecated` in `pluginloader#withalias` - `@deprecated` is an annotation while the correct javadoc tag is `@deprecated`; ;;;;1;1;fix javadoc in pluginloader#withalias javadocfix the misuse of @deprecated in pluginloader#withalias - @deprecatedis an annotation while the correct javadoc tag is @deprecated;
1201;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added method to generate string with n spaces or n characters;used in a number of places so makes sense to have a method.;;0;full type support updated with feedback;this included all code from udt and  full-type-support and has been updated based on feedback from the reviews;;;;;1;1;fix timestamp type in hive connector;
1201;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added method to generate string with n spaces or n characters;used in a number of places so makes sense to have a method.;;0;takeuntil behavior when other observable terminates;say i have two observables <b>source</b> & <b>other</b> if i do a <b>sourcetakeuntil(other)</b> should the source observable complete when <b>other</b> completes? this appears to be the current behavior (assuming that im looking at it right) the test-cases also indicate that its intentional but the docs & msdn spec seem vague;"yes source will be unsubscribed as soon as other emits anything (oncomplete onerror or onnext)  || ah i see i didnt realize that oncomplete and onerror counted as ""emitting an item""  ";;;;0;1;;
1202;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced some guava usage with standard java.*;while looking for the use of guava i found these calls which can be replaced with standard java-classes.  regarding the original quest: - most uses are for checking null or empty strings or similarly return an empty string if the input string is null  it may not be worth importing the library just for these two and better to create these two trivial methods in stringutil (and use them to a larger extent) - there is also  charmatcher.whitespace  which may be slightly less trivial to replace;;0;index joins;updated for new type system;im done but @martint should review the planner stuff || ;;;;1;1;add unit tests for index joins;
1202;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced some guava usage with standard java.*;while looking for the use of guava i found these calls which can be replaced with standard java-classes.  regarding the original quest: - most uses are for checking null or empty strings or similarly return an empty string if the input string is null  it may not be worth importing the library just for these two and better to create these two trivial methods in stringutil (and use them to a larger extent) - there is also  charmatcher.whitespace  which may be slightly less trivial to replace;;0;need help with replaysubject having weird interaction with custom operators;"helloim writing some code that involves some of my custom operators that i have made  unfortunately im getting into a situation where oncomplete is never called for one of my observables and im having trouble figuring out why this is happening  i believe this is a result of my operators not behaving well with the replay subject though its hard for me to debug what is happeningive created a contrived example of what i am doing below along with descriptions and code of my custom operators``` java @test    public void testreplay() {        listeningexecutorservice pool  moreexecutorslisteningdecorator(new threadpoolexecutor(10 10 60l timeunitseconds new synchronousqueue<runnable>()))        // creates an observable that emits integers via a pool calling a function        final observable<integer> waitobs  observablejust(""foo"")                                                      lift(new operatorflatmapinpool<integer string>(  // ** custom operator                                                              new func1<string observable<integer>>() {                                                                  @override                                                                  public observable<integer> call(string s) {                                                                      try {                                                                          threadsleep(1000)                                                                      } catch (interruptedexception e) {                                                                          eprintstacktrace()                                                                      }                                                                      return observablejust(1)                                                                  }                                                              }                                                              pool                                                      ))        // replayable obseravble that emits ints from wait obs        connectableobservable<integer> intobs1  waitobsreplay()        intobs1connect()        // replayable obseravble that emits ints from wait obs after being zipped with an observable that emits true        observable<integer> intobs2  observablexflatzipwithfirstvalue( // ** custom operator                intobs1                observablejust(true)                new func2<integer boolean observable<integer>>() {                    @override                    public observable<integer> call(integer integer boolean aboolean) {                        return observablejust(integer)                    }                })        list<integer> list  observableconcat( // concat maps of yid/guid ->phones                intobs1                intobs2)                                       tolist()                                       toblockingobservable()                                       first()        assertequals(2 listsize()        )    }```custom operator:  operatorflatmapinpoolthis will run the provided function for each incoming item on a thread in the provided pool (we created this as a workaround for onsubscribe/onobserve not working for some reason via this issue  )code:``` javapublic class operatorflatmapinpool<r t1> implements observableoperator<r t1> {    final listeningexecutorservice pool    final func1<t1 observable<r>> func    public operatorflatmapinpool(func1<t1 observable<r>> pfunc listeningexecutorservice ppool) {        thispool  ppool        thisfunc  pfunc    }    @override    public subscriber<? super t1> call(final subscriber<? super r> subscriber) {        return new subscriber<t1>(subscriber) {            atomicinteger itemsemitted  new atomicinteger(0)            atomicboolean completed  new atomicboolean(false)            atomicboolean errored  new atomicboolean(false)            @override            public void oncompleted() {                completedset(true)                // if no mor items are being emitted and we arent working on any items currently                // then we                 if(itemsemittedget() 0){                    subscriberoncompleted()                }            }            @override            public void onerror(throwable e) {                if (!erroredgetandset(true)) {                    subscriberonerror(e)                }            }            @override            public void onnext(final t1 t1) {                itemsemittedaddandget(1)                // do function on another thread                listenablefuture<observable<r>> result  poolsubmit(new callable<observable<r>>() {                    @override                    public observable<r> call() throws exception {                        return funccall(t1)                    }                })                // all done on same thread dont need atomic values                futuresaddcallback(result new futurecallback<observable<r>>() {                    @override                    public void onsuccess(observable<r> result) {                        // threaded process finised subscribe to the result                        resultsubscribe(new subscriber<r>() {                            @override                            public void oncompleted() {                                // if no mor items are being emitted and we arent working on any items currently                                // then we are done                                if (itemsemittedaddandget(-1) 0 && completedget()) {                                    subscriberoncompleted()                                }                            }                            @override                            public void onerror(throwable e) {                                if (!erroredgetandset(true)) {                                    subscriberonerror(e)                                }                            }                            @override                            public void onnext(r r) {                                subscriberonnext(r)                            }                        })                    }                    @override                    public void onfailure(throwable t) {                        if (!erroredgetandset(true)) {                            subscriberonerror(t)                        }                    }                })            }        }    }}```custom operator:  flatzipwithfirstvalueflat map zips each item emitted from the main observable with the first value emitted from the second observable via the provided function``` java  public static <t1 t2 r> observable<r> flatzipwithfirstvalue(final observable<t1> main final observable<t2> valueobs final func2<t1 t2 observable<r>> func) {        return valueobsfirst()flatmap(new func1<t2 observable<r>>() {            @override            public observable<r> call(final t2 t2) {                return mainflatmap(new func1<t1 observable<? extends r>>() {                    @override                    public observable<? extends r> call(t1 t1) {                        return funccall(t1 t2)                    }                })            }        })    }```";hi this test passes for me with 0183 and guava 170 || thanks for validating this @akarnokd closing due to inactivity please reopen if bug still exists as of version 020 ||;;;;0;1;;
1202;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replaced some guava usage with standard java.*;while looking for the use of guava i found these calls which can be replaced with standard java-classes.  regarding the original quest: - most uses are for checking null or empty strings or similarly return an empty string if the input string is null  it may not be worth importing the library just for these two and better to create these two trivial methods in stringutil (and use them to a larger extent) - there is also  charmatcher.whitespace  which may be slightly less trivial to replace;;1198.0;1202] java 9 ci build for mockito 2x;## summaryprovide java 9 travis build to ensure java 9 compatibility in at least tested use casessupport for java 9 was improved in gradle 4x and that version is being used due to some issues with newer gradle versions (#1198) some other configuration changes were required as well as jacoco version has been bump ( #1198## check list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_;" merging 1202  ";"""could not initialize inline byte buddy mock maker"" with gradle 4x";"i tried to add java 9 build for the mockito 2x branch which in turn requires gradle upgrade to 4x unfortunately with gradle 4x (tested with 401 and 421) 38 inline mock maker related tests are broken (without `mock_maker` env variable defined)for example:```orgmockitointernalcreationbytebuddyinlinebytebuddymockmakertest > should_create_mock_from_interface failed    orgmockitoexceptionsbasemockitoinitializationexception:     could not initialize inline byte buddy mock maker (this mock maker is not supported on android)    java               : 18    jvm vendor name    : oracle corporation    jvm vendor version : 25144-b01    jvm name           : openjdk 64-bit server vm    jvm version        : 180_144-b01    jvm info           : mixed mode    os name            : linux    os version         : xxx        at orgmockitointernalcreationbytebuddyinlinebytebuddymockmaker<init>(inlinebytebuddymockmakerjava:171)        at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakertest<init>(inlinebytebuddymockmakertestjava:35)        caused by:        javalangillegalstateexception:         the mockmethoddispatcher class file is not locatable: org/mockito/internal/creation/bytebuddy/mockmethoddispatcherraw        the class loader responsible for looking up the resource: sunmisclauncher$appclassloader@73d16e93```travis build reproducing that issue with oracle jdk (just gradle upgrade in the `brokenwithgradle4` branch): dont know why the gradle upgrade can result in that behavior especially that ""the mockmethoddispatcher class file is not locatable: org/mockito/internal/creation/bytebuddy/mockmethoddispatcherraw"" sounds strange@raphw under what circumstances that bb error can occur (even abstracting it from gradle)?";gradle is supposed to rename the `org/mockito/internal/creation/bytebuddy/mockmethoddispatcherclass` file to `org/mockito/internal/creation/bytebuddy/mockmethoddispatcherraw` during its build this is necessary to prohibit the class from being loaded by any class loader as we explicily inject it into the bootstrap class loader using the instrumentation api it seems like this does no longer work as the runtime cannot locate this name i guess it was not renamed and is still available under `class` || it looks like this one is failing due to this ( change in gradle 40 and the fact that `inline-mockgradle` is using the old hardcoded path || yup that was a problem @raphw thanks @epeee for an implementation hint || @szpak  @epeee  @raphw : can you please help me understand what i should do to make it work in my android project? it has mockito-core and mockito-android v 2210 and also powermockito2 api and the project has both java and kotlin classes i would like to test the kotlin classes  || @hearbeathorror this issue has been closed almost a year ago and it is rather loosely related to your problem i propose you to ask a question using [stack overflow]( or the [mailing list]( however you mix many various elements which can cause some issues ||;1;0;fix another test failing with java 9;
1203;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed documentation issue  added unit tests;- while working on new verification started listeners (#1191) i found an instance of incorrect documentation. i added unit tests and simplified the documentation.;;0;allow customized expiry time for cache entry; allow per entry expiry time for caches built with expireafterwrite / expireafteraccess (something like put(k key v value long timeout); ;;;;0;1;;
1203;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed documentation issue  added unit tests;- while working on new verification started listeners (#1191) i found an instance of incorrect documentation. i added unit tests and simplified the documentation.;;0;update to hive 012;;" :+1:  im very grateful for this pr working with our custom ""hive 012 patch"" everyday was painful || ";;;;1;1;update to hive 012;
1203;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed documentation issue  added unit tests;- while working on new verification started listeners (#1191) i found an instance of incorrect documentation. i added unit tests and simplified the documentation.;;0;androidobservable to hold weak reference to activity or fragment;bindactivity() and bindfragment() hold strong references to theactivity or fragment thus requiring explicit unsubscription to avoidleaks this commit weakens that referencethe observable chain should never be the owner of an activity orfragment so weakening the reference here should be safe  an earlierversion of bindactivity() used weak references for both the activityand the source observable weakening the reference to the observable maybe unsafe as the observable chain might be the owner of an anonymoussource observablethis commit removes the need to explicitly unsubscribe as long as thefinal subscriber holds only a weak reference to the context (ieview activity or fragment)for example consider a class:```  public class clickableproperty extends subscriber<boolean> {    private final weakreference<view> mviewref    public clickableproperty(view view) {      mviewref  new weakreference<view>(view)    }    @override    public void onnext(boolean clickable) {      view view  mviewrefget()      if (view ! null) {        viewsetclickable(clickable)      } else {        unsubscribe()      }    }    @override    public void oncompleted() {      // ignore    }    @override    public void onerror(throwable e) {      // ignore    }  }```the clickable property of a view can be safely bound to a booleanobservable as follows without needing to explicitly unsubscribe in theactivitys ondestroy()```  public class mainactivity extends activity {    button mbutton    protected void oncreate(bundle savedinstancestate) {      setcontextview(ridactivity_main)      mbutton  findviewbyid(ridbutton)      observable<boolean> allowclicks  globalstaticobservablesallowclicks()      clickableproperty clickableproperty  new clickableproperty(mbutton)      bindactivity(this allowclicks)subscribe(clickableproperty)    }    protected void ondestroy() {      // nothing to do here    }  }```without weakening the activity reference in bindactivity() explicitunsubscription would still be needed to prevent context leaks;"pinging @mttkay (since i dont know if github does that automatically here) || #1115 we used to do it this way and it inherently collides with the way rx works: by providing anonymous functions as closures if we were to hold a weak reference to such a function often being an inner class of an activity or view (and thus holding a strong reference to a `context`) it would immediately become eligible for garbage collectionsince we cannot determine whether the subscriber is an activity/view or not (since they will end up being wrapped in `safesubscriber`) we cannot make this decision from within the operatorhave a look at the discussion behind the development of `operatorconditionalbinding` as well as it contains more information around this (it used to be called `operatorweakbinding` because it did actually use weak references until we realized its not gonna work) || in general i should add that after having worked with rxjava on android for close to a year now i found myself ending up with a lot of compromises on my hands the nature of android ui objects is bound to the strict and complex life-cycle android imposes on them and it doesnt fit well with the way rx(java) worksi found that the library adds the most value on those layers that are below the ui but as soon as you enter ui and activity territory youll have to deal with rotation changes juggling subscriptions replaying view state etc youre swapping one area of complexity for another || this commit is different  `operatorweakbinding` held a weak reference to _both_ the `activity` (or `fragment`) and the source `observable`  of course a weak reference to the latter is unsafe for the reasons you mentionthis commit uses a weak reference _only_ for the `activity` or `fragment`  this is safe because the framework owns those objects and holds strong references to them while alive  the `observable` reference is still strong for the reasons you mentionthe original commit message explains this in more detail with an example use case essentially though this doesnt by itself save the `unsubscribe` calls if the `observable` or its closure holds a strong reference to the `activity` (or `fragment` or `view`)  however it allows for  judicious use of `weakreference`s  in the `observers` to eliminate the need entirely  notice that in both the diff and the example code weak references are used only for classes explicitly owned by the framework ie `activity` `fragment` and `view` || if i read the code correctly it only works in those cases where thesubscriber holds no references to the fragment or activity whatsoever inany other case youre either explicitly or implicitly holding a strongreference to the activity/fragment through the subscriber (either becausethe activity/fragment is the subscriber itself or more likely because itsan inner class) so you gain nothing and you still have to unsubscribe toprevent a memory leakthat said im not sure i understand the use case here: if you have asubscriber that does not reference the activity or fragment why use thisoperator to begin with? its meant to be used to bind sequences to screenobjects or maybe im misunderstanding? can you post an example of howyoure using it? || i think the point is you can make the subscriber have a weak reference tothe activity/fragment by making it (say) a static inner class with aweakreference member (see the original post for an example)perhaps making a generic ""weakobserver"" abstract class that wraps a givenactivity/fragment in a weakreference would be good this could then besubclassed using static inner classessomething like: (on my phone so sorry for the formatting/capitals/errors)abstract class weakobserver<t r> implements observer<r> {```weakreference<t> thingrefpublic weakobserver(t thing) {     //put it in thingref}final public void onnext( r next) {     if (thingrefget() ! null) {           donext(thingrefget() next)     }} pubic abstract void donext(t thing r next)//same for complete and error```}this would make using these changes slightly less annoyingthat said my existing code just has an activity and fragment base classthat has an add/remove subscription method and unsubscribes at theappropriate times i find this works well but it does require care toalways add subscriptions to it || in other words youre managing a reference to the activity :-) how is thatmore convenient than calling unsubscribe() in ondestroy?in general i would find it confusing from an api perspective if there weresome cases (exceptional cases in fact) where you dont have tounsubscribe an api should communicate a clear contract and in face of theabove mentioned problems pretty much everyone (see previous issues) votedfor simply letting the caller decide when its time to release thesereferencesdont get me wrong id love to have this more automated i just think thatthis solution only shoots for the 10% of the cases it adds complexity tothe implementation and needs to be documented as well im just notconvinced its worth itcurious what others think? @samueltardieu  @tehmou  @zsxwing   fri may 16 2014 at 11:05 am dylan sale notifications@githubcomwrote:> i think the point is you can make the subscriber have a weak reference to> the activity/fragment by making it (say) a static inner class with a> weakreference member (see the original post for an example)> > perhaps making a generic ""weakobserver"" abstract class that wraps a given> activity/fragment in a weakreference would be good this could then be> subclassed using static inner classes> > something like: (on my phone so sorry for the formatting/capitals/errors)> > abstract class weakobserver<t r> implements observer<r> {> > weakreference<t> thingref> > public weakobserver(t thing) {> //put it in thingref> }> > final public void onnext( r next) {> if (thingrefget() ! null) {> donext(thingrefget() next)> }> }> > pubic abstract void donext(t thing r next)> > //same for complete and error> }> > this would make using these changes slightly less annoying> > that said my existing code just has an activity and fragment base class> that has an add/remove subscription method and unsubscribes at the> appropriate times i find this works well but it does require care to> always add subscriptions to it> > —> reply to this email directly or view it on github  || i used to think like @dylansale however since you _have_ to manage your ui components lifecycles anyway unsubscribing at the right place (`onpause` `onstop` or `ondestroy`) is easy to do and it removes the ""magic"" of sometimes unsubscribing when by change the garbage collector kicks in and there are no circular references || @mttkay i dont like the idea of weak binding at all and i always manage all my subscriptions explicitly as @samueltardieu said its not a big deal || @dylansale has it  managing a few subscriptions isnt a big deal but im using rx for all the view properties and manual management is a huge amount of boilerplate  each subscription requires three lines (a member declaration the subscription and an unsubscribe) instead of just a single linei was using a home-rolled subscription manager to reduce this boilerplate:```   private subcriptionmanager msubs   protected void oncreate(bundle bundle) {       msubs  new subscriptionmanager()       msubsmanage(           bindactivity(this o1)subscribe(s1)           bindactivity(this o2)subscribe(s2)           bindactivity(this o3)subscribe(s3)       )   }   protected void ondestroy() {       msubsunsubscribeall()   }```but this is still extra boilerplatefurther  im using an mvc (or mvvm or mvp pick your overloaded acronym) with a single `activity` and custom `view`s and viewmodels for most of my ""screens"" (similar to squares mortar/flow effort in some ways)   the models are retained across configuration changes and rebound to the new view instance  i use rx for this data-binding  android doesnt propagate lifecycle information to the `view`s so this has to be done manually for them to unsubscribe themselves---yet more boilerplate and an extra view hierarchy traversal during a screen rotationmy approach may not be the best way in the long run but `rxjava-android` will be _much_ more useful for ui binding (a la reactiveui) if we can work towards automated unbinding rather than just accepting the current statethis commit lets users of `rxjava-android` experiment with various methods of automated unbinding in their own apps _without_ breaking or changing any existing functionality || id like to reiterate my last point from my previous commentthis commit lets advanced users of `rxjava-android` experiment with various approaches for automated unbinding in their own apps _without_ breaking or changing any existing functionality the documentation can stay the same (""users must call unsubscribe"") or can be made more precise (""users should call unsubscribe"") either way the salient point to new users is that subscriptions need to be managed   advanced users can experiment with gc-based unsubscription but the docs dont need to mention this || let me also describe my other utility features that make gc-based unsubscription feasible  - a library to expose all android `view`  setters as (weakly-bound) `observer`s    specifically `rxfrom(view)` functions return `rxview` objects that expose the view properties as `observer`s  eg `rxview(view)` returns an `rxview` with methods like `rxviewvisibility()` (returns `observer<integer>`) and `rxviewclickable()` (returns `observer<boolean>`)  `rxview(textview)` returns an `rxtextview extends rxview` with additional methods like `rxviewtext()` (returns `observer<? extends charsequence>`)    these `observer`s hold only a `weakreference` to the `view` allowing gc-based unsubscription (see the original commit message or @dylansales example)- a utility function to partially apply a `function` (or `action`) with weak-binding of the first argument    sometimes you need to reference the `view` or `activity` in the closure provided to an `observable` combinator (eg `map` or `combinelatest`)  this would create a strong reference to the `context`  the `weakpartial()` methods solve this instead of calling for example `observablemap((e) -> myviewtranslate(e))subscribe(s)` call `observablemap(weakpartial((v e) -> vtranslate(e) myview)subscribe(s)`     the function (or action) returned  weakpartial()` only holds a weak reference to the applied argument when called the actions do nothing once the reference has been gced the functions return a default value (if provided) or null (if not provided) once the reference has been gcedas an example:``` javapublic class myloginview extends linearlayout {    @injectview(ridusername) textview musername    @injectview(ridlogin) button mlogin    private boolean shouldcapitalize // assume set via xml attribute in constructor    @override    public void onfinishinflate() {        butterknifeinject(this)    }     // called by activity when the view hierarchy is inflated    public void bind(activity activity myloginviewmodel model) {       // show normalized username in textview        bindactivity(activity modelusername())                map(weakpartial(myloginview::normalize this))                subscribe(rxfrom(musername)text())        // enable clicking of login button if username is not null or empty        bindactivity(activity modelusername())                map((n) -> n ! null && !nequals(""""))                subscribe(rxfrom(mlogin)clickable())    }    charsequence normalize(charsequence name) {         return shouldcapitalize ? stringscapitalize(name) : name    }}```judicious application of these two library features (`view` properties exposed via weak observers and `context`-holding objects only referenced in combinator closures via `weakpartial`) allows safe rx binding to the android view hierarchy without explicit subscription management || @mttkay what are your thoughts on `bindactivity` registering an `applicationactivitylifecyclecallbacks` that completes any bound `observables` when the activity is destroyed  (for api >14)  maybe this has been discussed before`androidobservables` could register for lifecycle callbacks keep a static mapping from each `activity` to its bound `observable` wrappers call `oncomplete()` for each such `observable` when the activity is destroyed  assuming `safesubscribers` completing should propagate an unsubscribe back up the observable chain || i find those use cases very compelling does this rxview wrapper exist already? || @dylansale ive got an internal version that im using right now but its not ready for prime time  it needs to be filled out (its missing views and properties that i dont use) probably by writing a script to generate it from the android api and it needs to be documented  im not sure when ill first be able to make time to work on that but would like to sometime in the next month or so if someone else doesnt do it first || @drbild it looks to me as if your subscriptionmanager can be replaced by a simple `compositesubscription`? thats what we use whenever we have more than one subscriber and we want to unsubscribe them all at onceas for the code sample: youre using lambda expressions to map your observables these translate to anonymous inner classes that will hold a strong reference to the outer class (the layout in your case) and by extension a strong reference to the activity (every view in android strongly references the host activity) even if you used weakreferences to bind the view and to bind your subscriber the observable will keep a strong reference to your mapping function and again would not allow that context reference to be cleared unless you unsubscribe that said i still dont see how the use of weakreferences helps to prevent a memory leak here without additional instrumentation from the outsideone thing that i pursued in the past but didnt succeed with is some form of reference counting using referencequeue if we found a way to automatically unsubscribe whenever the gc decides that the context has become eligible for gc then we might solve the problem that way perhaps?with regards to `activitylifecyclecallbacks`: in the case of activities this would indeed help for api level 14 or above however in modern android apps the role of activities is typically reduced to being a mere screen container to hold fragments so whenever an app uses fragments youre stuck again since we would need an event whenever `fragmentondestroyview` is called i dont think that event exists outside the fragment itself unfortunatelyagain dont read me wrong in theory im all with you here i would love to have a reliable solution to this unless im missing something i just dont see how the changes proposed so far actually fix the problemone more thing to keep in mind: whatever check we perform to test whether a context has gone dead it cannot be performed in an rx notification (onnext oncompleted etc) since those notifications might arrive with a significant delay theres only 2 ways to actually address the issue: receive an event from the framework outside the rx call chain that we can listen for and unsubscribe from the sequence or do so from within the context that subscribed itself since we havent been successful so far to do 1) we settled on doing 2) || @mttkay with regards to the your concern about the lambdas holding a strong reference this is not the casethese lambdas do not capture any state from the enclosing class (by using the `weakpartial` function) and thus are translated into static instance methods (or static inner classes)  see  can confirm that my approach works fine with retrolambda targeting language level 17 for android as well my `activity`s are gced just fine  (im still a little amazed the javac-18 -> retrolambda -> dex process works) || too bad android doesnt have `fragmentlifecyclecallbacks` as well  regardless of my opinions about them (as opposed to custom views and view models with custom backstack management) they are part of android that is here to stay || thats interesting thanks for sharing i was assuming youre using java 6 and you just used short hand notation for readabilityi havent used retrolambda or even java 8 on android it says in the article that java 8 lambdas are translated using invokedynamic i believe retrolambda translates to java 7 byte code? considering that dalvik isnt java 7 compliant before kitkat how would that work on older devices? it sounds like highly experimental territory but if you say youve tested this and it did in fact work using that configuration thats very interesting as said above i was going into this discussion assuming java 6 everywhereperhaps we should extend the scope of this to include the other missing pieces like `weakpartial` so that all rxjava-android users can benefit from this change || i think retrolambda can backport to 15 and 16 even by replacing invokedynamici havent done extensive tests with older android devices but it works fine on several jellybean devices || im fine with extending the scope  we can shelve the pull request until one with all three pieces (view properties weakpartial and weak bindactivity) is ready  there will likely need to be quite a bit of discussion around the appropriate apis for the first piece || sounds good! thanks for looking into this || @mttkay should these changes be merged? || no not yet i think the outcome of the discussion is that we want propersupport for users of java 8 plus retrolambda but to enable this goesbeyond this pr as it needs a more holistic discussion around apisim all for pursuing this idea though david as a next step maybe wecould set up a working sample project that uses some of the additionalhelpers you created? this could be a good starting point to extract codeinto the library let me know if i can help in any waylets maybe keep this pr open until weve nailed the next steps then gofrom there?on may 20 2014 6:29 am ""ben christensen"" notifications@githubcom wrote:> @mttkay  should these changes be merged?> > —> reply to this email directly or view it on github  || matthias sounds good  itll be a few weeks---im overloaded for the rest of this month and will be on vacation for the first week of june || thats fine no worries || closing this out due to inactivity  when something is finalized please re-submit || @drbild now that rxandroid has been split out from rxjava core how about picking this up again?we could start by simply creating an issue and drafting somethingone thing id like to investigate further however is this:> these lambdas do not capture any state from the enclosing class (by using the weakpartial function) and thus are translated into static instance methods (or static inner classes) see  just had a guest speaker from typesafe speaking about jvm level macros and lambda expansion this was about java 8 and lambdametafactory but retrolambda does the exact same thing just at compile time not at runtime via invokedynamicif i understood him correctly the way lambdas are generated is _always_ via an anonymous inner class or in other words the byte code you end up with to represent is always an anonymous class this particular section you pointed out refers to the body of the lambda which might be completely captured with a static method if there is no access to the outer scope but that doesnt mean a lambda such as an argument to `map` is invoked as a static method it will invoke an anonymous class (having references to the outer class like any class) which in turn invokes the static methodplease let me know if im misinterpreting anything this was all rather new to mevideo:   || i think the interesting bit is on slide 19 the code the lambda factory generates and that ends up being invoked is an _instance_ of a lambda class (here `lambda$$0`) that implements the functional interface (eg `func1`) it then in return invokes the lambda body in form of a static methodi guess the pivotal question here is whether `lambda$$0` is an inner class of the caller or not if not then theres no problem if it is then even pure functions will leak their owner until the time someone unsubscribes from the sequencemight have to brush up my byte code skills to really understand what happens in practice || @mttkay it is an inner class but (if no enclosing state is captured) it is a _static_ inner class  so theres no owning instance of the outer class and nothing is leakedi dont know how much of this behavior is codified but given that current implementations are sane itd be rather silly for future versions of the compiler/retrolambda to start needlessly holding references to non-captured containing instances || im happy to revisit this  i havent followed the recent rxjava changes (eg new package name and repo re-organization)  could you open a skeleton issue in the correct place and then ill add some more details in an initial proposal for comments hopefully sometime this week/weekend? || > it is an inner class but (if no enclosing state is captured) it is a static inner class so theres no owning instance of the outer class and nothing is leakedah good point i guess that only makes senseas for the issue ive created a proposal here:  || ";;;;0;1;;
1203;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed documentation issue  added unit tests;- while working on new verification started listeners (#1191) i found an instance of incorrect documentation. i added unit tests and simplified the documentation.;;1191.0; documentation issue added unit tests;- while working on new verification started listeners (#1191) i found an instance of incorrect documentation i added unit tests and simplified the documentation- currently contrary to what the javadoc said we do guarantee the order in which invocation listeners get notified some of our users might have started to depend on this behavior i added unit tests and  the javadoc in general it is seems useful to guarantee the order this way the api is more predictable easier to use;  thank you for review! ||;ensure spring-boot can use mockito public api;"mockito framework integrators need robust public apis from us this way they ship great mockito integrations to their customers we want to avoid the situation where framework integrators have to use mockito internal apis this leads to overhead relying on stale versions of mockito class conflicts in runtimespring-boot currently uses some internal api from mockito see  for the problem statement solution options and chosen design ### solutionas discussed in spring-boot ticket heres the api we would like to prototype:- new ""verificationstartedlistener""- the instance of listener can be passed on mock creation- listener is notified when mockitoverify is invoked but before the verification is triggered- it is possible to replace the mock object that is being verified (key feature needed by spring-boot)### example usage```javamock(fooclass withsettings()verificationstartedlisteners(new verificationstartedlistener() {  public void onverifystarted(verificationstartedevent event) {    eventgetmock()    eventsetmock(arbitrayobject)  }}```";"i put together a prototype in ""mockito-spring-boot"" branch opened pr #1192 for visibility how to use it?- clone mockito and check out ""mockito-spring-boot"" branch- /gradlew publishtomavenlocal- grab newly published version of mockito from maven local and try it out!- i dont have javadocs yet this test class documents the new api (hopefully :) ->  next steps:- @wilkinsona let me know if this is enough for you to try it out!- we can use the pr that i have opened for review comments regarding the api || @szczepiq this looks great ive built the `mockito-spring-boot` branch and prototyped the updates required for spring boot to use it:  all our tests pass and as you can hopefully see boots code is now significantly simpler thanks very much || fantastic! i will polish the code / documentation and get the release out soon thank you for testing this out and suppling sample project! || @wilkinsona can you try out one more time for us please?ive cleaned up the implementation and the pr in mockito is ready to go i want to make sure that we ship code that works for spring boot i have added some extra validation for setmock() method other than that i think that the api has not changed since i provided the experimental the code is in the same branchthank you in advance! :) || @szczepiq thanks for the opportunity to double-check things ive built the current head of the `mockito-spring-boot` branch and updated [my prototype]( to use the resulting 2110 binaries the only change that was necessary was to update the version number so things look good from my perspective || we released new version today: 2110 it includes the new api that spring boot can use || @wilkinsona - thank you for help and nice collaboration! || closing per     || ";1;0;updated testpreserved current behavior based on code review feedback thanks!;
1209;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;clean up junit imports;fix junit imports throughout the project to use the standard  org.junit.assert  assertions instead of the obsolete  junit.framework.testcase  assertions which just delegate to  assert  s methods.;;0;clean up junit imports;fix junit imports throughout the project to use the standard `orgjunitassert` assertions instead of the obsolete `junitframeworktestcase` assertions which just delegate to `assert`s methods; ;;;;1;1;clean up junit importsfix junit imports throughout the project to use the standardorgjunitassert assertions instead of the obsoletejunitframeworktestcase assertions which just delegate to assertsmethods;
1209;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;clean up junit imports;fix junit imports throughout the project to use the standard  org.junit.assert  assertions instead of the obsolete  junit.framework.testcase  assertions which just delegate to  assert  s methods.;;0;json_extract and json_extract_scalar return null on non-null key-value;"when running this query ```select    datafrom uievents where    json_extract(data $error) is null```on the following data (ive only included 2 lines to illustrate the problem)| id | data || --- | --- || 0 | {""success"":false""error"":{""uiaction"":""displayederror""""displayedmessage"":""unable to connect to blah please try again""""deeperror"":[{""debug"":{""message"":""blahblah: error""}}{""debug"":{""message"":""""}}]}} || 1 | {""success"":false""error"":{""uiaction"":""displayederror""""displayedmessage"":""sorry blah hasnt come to this part of the world yet""""deeperror"":[{""debug"":{""message"":""geolocation policy reject: ae""}}]}} |only the the row with `id  1` is returned if i run `json_extract` or `json_extract_scalar` on `$error` row 0 returns `null` while row 1 returns the proper value- is this a bug?- is there a better way to test whether a key exists in a `json` object?";nevermind i finally was able to find the issue in the data ;;;;0;1;;
1209;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;clean up junit imports;fix junit imports throughout the project to use the standard  org.junit.assert  assertions instead of the obsolete  junit.framework.testcase  assertions which just delegate to  assert  s methods.;;0;any reason funcn is not parametrized on the input type ?;current funcn definition is only parametrized on the result type loosing type information regarding the input of the call method:```public interface funcn<r> extends function {    public r call(object args)}```an implementer will most often cast the parameter in order to process it adequately which can be tricky (and ugly) for arrays for example when using the varadic overload of combinelatest a `sequence :: list<observable<boolean>> -> observable<list<boolean>>` looks like this:```observable<list<boolean>> sequence (list<observable<boolean>> listofobservablebools) {return observablecombinelatest(listofobservablebools new funcn<list<boolean>> {   public list<boolean> call(object args) {     boolean  arrayscopyof(args argslength booleanclass) // ewww      return arraysaslist(booleans)  }})}```it also prevents abstracting over the content type (here boolean) as erasure disallows something like tclass it is thus impossible to implement a generic version of this operator `list<observable<t>> -> observable<list<t>>`the solution imho is to add a type parameter to funcn representing the type of the input parameter:```public interface funcn<t r> extends function {    public r call(t args)}```combinelatest would go from```public static final <t r> observable<r> combinelatest(list<? extends observable<? extends t>> sources funcn<? extends r> combinefunction)```to```public static final <t r> observable<r> combinelatest(list<? extends observable<? extends t>> sources funcn<? extends t ? extends r> combinefunction)```making this (and others usages) possible:```observable<list<t>> sequence (list<observable<t>> listofobservablets) {return observablecombinelatest(listofobservablets new funcn<t list<t>> {   public list<t> call(t args) {      return arraysaslist(args)  }})}```is there a technical reason for the current state of affair ?thanks for your hard work and time !;"> is there a technical reason for the current state of affair ?answering my own question:as far as i can see having funcn non-parametrized on the input type was made to permits using `combinelatest(list funcn)` in the implementations  of the multiple parameter versions (`combinelatest(observable<t1> observable<t2> func2<t1 t2 r>)` `combinelatest(observable<t1> observable<t2> observable<t3> func3<t1 t2 t3 r>)` )through a transformation from `func<2|3|4| r> to funcn<r>` looking like this:```    public static <t0 t1 t2 t3 r> funcn<r> fromfunc(final func4<? super t0 ? super t1 ? super t2 ? super t3 ? extends r> f) {        return new funcn<r>() {            public r call(object args) {                if (argslength ! 4) {                    throw new runtimeexception(""func4 expecting 4 arguments"")                }                return fcall((t0) args[0] (t1) args[1] (t2) args[2] (t3) args[3])            }        }    }```indeed in that case the parameters types might be heterogeneous and fallback to the lower denominator type object before being cast back to their original type || the `funcn` type is used in places (3 that im aware of) where heterogeneous types are supported and there are more than 9 types (supported  func1` through `func9`) these are `combinelatest` and `zip` both of which have strongly typed signatures up to 9 types  || which is a simpler than messing with tuples if you need a function with more than 8 arguments you may want to apply for a job at ms office ( -) || @headinthebox :)not such a bad match after all a spreadsheet is nothing but a glorified ui for observable streams frp-style!still even in a inadequate language like java (compared to haskell or any lang with proper support and un/currying) id favor tuples to `list<object>` anyday || > id favor tuples to list<object> anydaylets agree to disagree on this you are trading a lot of complexity for what some type safety? in this case that is not worth the trouble static types are nice when they work but they are just a means to an end not a goal you chase at any cost like spice & food  || ";;;;0;1;;
1213;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;standardize junit imports;this pr standardizes importing assertion methods  making the code base cleaner and easier to maintian.;;0;some tests of our testers (in guava-testlib) fail on some jdks;cgruber@ one example:  sun jdk 16 on what i must presume is a linux machine (cloudbees) under jenkinsfailedcomgooglecommoncollecttestingtestersmapputtestertestput_nullkeysupportednotpresent[safetreemap with null-friendly comparator [collection size: zero] submap no_bound-exclusive [collection size: zero] descending [collection size: zero]](from comgooglecommoncollecttestingsafetreemaptest)failing for the past 20 builds (since #﻿4 )took 5 msadd descriptionerror messagedid not contain expected element nullapril expected  [nullapril] actual  stacktracejunitframeworkassertionfailederror: did not contain expected element nullapril expected  [nullapril] actual  &nbsp&nbsp&nbsp&nbspat junitframeworkassertfail(assertjava:47)&nbsp&nbsp&nbsp&nbspat comgooglecommoncollecttestinghelpersassertequalignoringorder(helpersjava:91)&nbsp&nbsp&nbsp&nbspat comgooglecommoncollecttestingabstractcontainertesterexpectcontents(abstractcontainertesterjava:112)&nbsp&nbsp&nbsp&nbspat comgooglecommoncollecttestingabstractmaptesterexpectcontents(abstractmaptesterjava:195)&nbsp&nbsp&nbsp&nbspat comgooglecommoncollecttestingabstractcontainertesterexpectadded(abstractcontainertesterjava:144)&nbsp&nbsp&nbsp&nbspat comgooglecommoncollecttestingtestersmapputtestertestput_nullkeysupportednotpresent(mapputtesterjava:145)&nbsp&nbsp&nbsp&nbspat sunreflectnativemethodaccessorimplinvoke0(native method)&nbsp&nbsp&nbsp&nbspat sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:39)&nbsp&nbsp&nbsp&nbspat sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:25)&nbsp&nbsp&nbsp&nbspat javalangreflectmethodinvoke(methodjava:597)&nbsp&nbsp&nbsp&nbspat junitframeworktestcaseruntest(testcasejava:168)&nbsp&nbsp&nbsp&nbspat junitframeworktestcaserunbare(testcasejava:134)&nbsp&nbsp&nbsp&nbspat junitframeworktestresult$1protect(testresultjava:110)&nbsp&nbsp&nbsp&nbspat junitframeworktestresultrunprotected(testresultjava:128)&nbsp&nbsp&nbsp&nbspat junitframeworktestresultrun(testresultjava:113)&nbsp&nbsp&nbsp&nbspat junitframeworktestcaserun(testcasejava:124)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiteruntest(testsuitejava:243)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiterun(testsuitejava:238)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiteruntest(testsuitejava:243)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiterun(testsuitejava:238)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiteruntest(testsuitejava:243)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiterun(testsuitejava:238)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiteruntest(testsuitejava:243)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiterun(testsuitejava:238)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiteruntest(testsuitejava:243)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiterun(testsuitejava:238)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiteruntest(testsuitejava:243)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiterun(testsuitejava:238)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiteruntest(testsuitejava:243)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiterun(testsuitejava:238)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiteruntest(testsuitejava:243)&nbsp&nbsp&nbsp&nbspat junitframeworktestsuiterun(testsuitejava:238)&nbsp&nbsp&nbsp&nbspat orgjunitinternalrunnersjunit38classrunnerrun(junit38classrunnerjava:83)&nbsp&nbsp&nbsp&nbspat orgapachemavensurefirejunit4junit4testsetexecute(junit4testsetjava:53)&nbsp&nbsp&nbsp&nbspat orgapachemavensurefirejunit4junit4providerexecutetestset(junit4providerjava:123)&nbsp&nbsp&nbsp&nbspat orgapachemavensurefirejunit4junit4providerinvoke(junit4providerjava:104)&nbsp&nbsp&nbsp&nbspat sunreflectnativemethodaccessorimplinvoke0(native method)&nbsp&nbsp&nbsp&nbspat sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:39)&nbsp&nbsp&nbsp&nbspat sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:25)&nbsp&nbsp&nbsp&nbspat javalangreflectmethodinvoke(methodjava:597)&nbsp&nbsp&nbsp&nbspat orgapachemavensurefireutilreflectionutilsinvokemethodwitharray(reflectionutilsjava:164)&nbsp&nbsp&nbsp&nbspat orgapachemavensurefirebooterproviderfactory$providerproxyinvoke(providerfactoryjava:110)&nbsp&nbsp&nbsp&nbspat orgapachemavensurefirebootersurefirestarterinvokeprovider(surefirestarterjava:175)&nbsp&nbsp&nbsp&nbspat orgapachemavensurefirebootersurefirestarterrunsuitesinprocesswhenforked(surefirestarterjava:107)&nbsp&nbsp&nbsp&nbspat orgapachemavensurefirebooterforkedbootermain(forkedbooterjava:68);given how old this issue is and that the example is about jdk 6 im going to close it we can investigate such issues if/when we get more current reports about specific jdks ||;;;;0;1;;
1213;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;standardize junit imports;this pr standardizes importing assertion methods  making the code base cleaner and easier to maintian.;;0;standardize junit imports;this pr standardizes importing assertion methods making the code base cleaner and easier to maintian;  @christianschwarz as seen in the updated patch the string in `fail` isnt the actual message in the thrown exception but using the `expectedexception` definitely makes the test more robust (and imho easier to maintain) thanks for the review! ||;;;;1;1;import static methods from orgjunitassertthe de-facto standard of mockitos test is to use statically importedmethods from the orgjunitassert classthis patch changes the few places that import assert and use itsmethods to statically import them in order to standardize thecodebase and make it easier to maintain;
1213;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;standardize junit imports;this pr standardizes importing assertion methods  making the code base cleaner and easier to maintian.;;0;minor fixes;;;;;;1;1;add check for unsupported hive partition type;
1213;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;standardize junit imports;this pr standardizes importing assertion methods  making the code base cleaner and easier to maintian.;;0;"""another strategy was already registered"" even when using default";"ive been experimenting with rxjava-debug one problem ive run into is that i _must_ set the observable execution hook before _anything_ else or else i get ""another strategy was already registered"" exceptionthe exception seems off when rxjavaobservableexecutionhook is the hook being used in that case it feels like you should still be able to register a new hook if the default is just being used to cover";"this was done to reduce the overhead as much as possible when hooks where not in use at all  ive toyed with the idea of submitting a pr for `composablerxjavaobservableexecutionhook` to allow late registration of as many hooks as you need || @abersnaze if you do it should be a separate module and not part of core@dlew this is done for determinism a single plugin is registered during the entire lifecycle of an application this rule applies to all plugin types otherwise caching thread-safety and non-deterministic behavior all become issues || alright that makes sense  @dlew on my android app im trying to use this code``` javarxjavapluginsgetinstance()registerobservableexecutionhook(new debughook(new debugnotificationlistener() {    public object onnext(debugnotification n) {        logv(tag""onnext on ""+n)        return superonnext(n)    }    public object start(debugnotification n) {        logv(tag""start on ""+n)        return superstart(n)    }    public void complete(object context) {        supercomplete(context)        logv(tag""onnext on ""+context)    }    public void error(object context throwable e) {        supererror(context e)        loge(tag""error on ""+context)    }}))```and im getting the ""another strategy was already registered"" error you said i should put it before anything else where is that? i tried putting it in my activitys constructor but still got the error message || that means its still being registered sometime before your activitys constructor try putting it into  `applicationoncreate()` that will run before anything else on android (except for any `static` initialization blocks) || thanks   it worked || ";;;;0;1;;
1214;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1211: improve @deprecated javadoc;this pull request 1211 by improving the  @deprecated  javadoc of  mockito.debug()    mockitodebugger  and  mockitodebugger.printinvocations(object  mocks)  by adding the additional information on how to retrieve an actual instance of the  mockitodebugger  interface.;;0;reflectclasspath should provide resourceinfo in addition to classinfo; the classpath class being added to 140 should provide methods for access not only to classes but also general resources on the classpath;benyu@ manually running jar cvf proves not adding the directory resources along with the class files so this approach isnt always reliable--- ;;;;0;1;;
1214;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1211: improve @deprecated javadoc;this pull request 1211 by improving the  @deprecated  javadoc of  mockito.debug()    mockitodebugger  and  mockitodebugger.printinvocations(object  mocks)  by adding the additional information on how to retrieve an actual instance of the  mockitodebugger  interface.;;0;add comment field in describe table;;@electrum : i have updated the pull request || add a comment to `hiveclientgetcolumnmetadata()` that the method does not return the column comment || any word on whether or not this is going to be merged in @dain or @electrum  || @electrum : do you have any additional comment? if not i can merge it || i have addressed review comments lmk if its ok to merge will squash commits before merging  || thank you for signing our contributor license agreement we can now accept your code for this (and any) facebook open source project  hey @rishidwivedi it looks like there are tests failing any word on when they failures will be resolved? || ;;;;0;1;;
1214;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1211: improve @deprecated javadoc;this pull request 1211 by improving the  @deprecated  javadoc of  mockito.debug()    mockitodebugger  and  mockitodebugger.printinvocations(object  mocks)  by adding the additional information on how to retrieve an actual instance of the  mockitodebugger  interface.;;0;retry with predicate;several people have expressed need for conditional retry behavior i suggest a new `retry` overload that simply takes a predicate that receives the `throwable```` javapublic final observable<t> retry(func1<throwable boolean> predicate)```this would allow deciding whether to retry based on the `throwable` and/or count which can be maintained by the `func1`or we could use a `func2` and pass in the count:``` javapublic final observable<t> retry(func2<integer throwable boolean> predicate)```;"here is the type of thing that has to be done for conditional retries without this overload:``` javaimport javautilconcurrentatomicatomicintegerimport rxobservableimport rxsubscriberpublic class conditionalretry {    public static void main(string args) {        final atomicinteger c  new atomicinteger()        observable<string> owithruntimeexception  observablecreate((subscriber<? super string> s) -> {            systemoutprintln(""execution: "" + cget())            if (cincrementandget() < 3) {                sonerror(new runtimeexception(""retryable""))            } else {                sonnext(""hello"")                soncompleted()            }        })        final atomicinteger c2  new atomicinteger()        observable<string> owithillegalstateexception  observablecreate((subscriber<? super string> s) -> {            systemoutprintln(""execution: "" + c2get())            if (c2incrementandget() < 3) {                sonerror(new runtimeexception(""retryable""))            } else {                sonerror(new illegalstateexception())            }        })        subscribe(owithruntimeexception)        subscribe(owithillegalstateexception)    }    public static void subscribe(observable<string> o) {        o  omaterialize()flatmap(n -> {            if (nisonerror()) {                if (ngetthrowable() instanceof illegalstateexception) {                    return observablejust(n)                } else {                    return observableerror(ngetthrowable())                }            } else {                return observablejust(n)            }        })retry()dematerialize()        osubscribe(systemout::println t -> tprintstacktrace())    }}``` || completed || ";;;;0;1;;
1214;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1211: improve @deprecated javadoc;this pull request 1211 by improving the  @deprecated  javadoc of  mockito.debug()    mockitodebugger  and  mockitodebugger.printinvocations(object  mocks)  by adding the additional information on how to retrieve an actual instance of the  mockitodebugger  interface.;;1211.0;1211: improve @deprecated javadoc;this pull request 1211 by improving the `@deprecated` javadoc of `mockitodebug()` `mockitodebugger` and `mockitodebuggerprintinvocations(object  mocks)` by adding the additional information on how to retrieve an actual instance of the `mockitodebugger` interface; ;improve @deprecated javadoc of mockitodebugger;the `@deprecated` javadoc of : * method: `mockitodebug()`  * class: `mockitodebugger`  * method `mockitodebuggerprintinvocations()` should point to `mockitomockingdetails()printinvocations()` currently its too hard to find the rigth entry point for the replacement;;1;0;1211: improve @deprecated javadoc;
1216;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored cli code;moved code related to the cli to the cli package  including half of jabref.java.;;0;improve javadoc for threadfactorybuilder#setnameformat(string); the current javadoc for paramter nameformat goes:&nbsp""a stringformat(string object)-compatible format string to which a unique integer (0 1 etc) will be supplied as the single parameter""this is correct but one have to spend time in checking the stringformat() javadoc to recognize that the answer is hidden in the formatter javadoc to get the placeholder %d for int-parameter this is very the consuming if one is not familar with formatter arguments it would be nice to provide a sample or something else that avoids looking deep into the javadocseg: ""a string containing %d as parameter for a unique integer""";graft@ ;;;;0;1;;
1216;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored cli code;moved code related to the cli to the cli package  including half of jabref.java.;;0;spi cleanup;remove unnecessary methodsuse consistent namingadd javadocs to interfaceschange recordcursor getstring to getslice returning a sliceallow plugins to register new types and blockencodingfactories;;;;;1;1;cleanup parsing of the time zonesadd test for time zone key parsingmake timezonekey case insensitivefix handling of utc equivalent time zonesremove gmt0 from zone file since it is utc equivalent and the zone file has not been published yet;
1216;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored cli code;moved code related to the cli to the cli package  including half of jabref.java.;;0;exposing publishsubject;all other subjects (async behavior replay) have non-private companion objects;#1128 ;;;;1;1;exposing publishsubjectall other subjects (async behavior replay) have non-private companion objects;
1216;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;refactored cli code;moved code related to the cli to the cli package  including half of jabref.java.;;1206.0;adresses #1206: allow opting out from annotation copying within mocks;the `mocksettings` now include an option to disable copying of annotations to mock classes; merging 1216  < ;mockito should not copy annotations in all cases;"when mocking an interface mockito 2100 copies the annotations on the interface to the generated classi believe mockito  2100  should just implement the class as if the one would do new interface(){}in fact migrating to mockito 210 broke the tests of my working production codehowever when mocking a class the current behavior could be the expected behaviori have provided a very simple test case here:  the test-case ""interfacemock()"" fails at least it should be optional (via mocksettings?) to control this behavior";"> i believe mockito 2100 should just implement the class as if the one would do new interface(){}i agree java does it that way when an interface is implemented by a class the annotations are not present no matter if the annotation is marked with `@inherit` or not>however when mocking a class the current behavior could be the expected behaviorthe class object of a mocked class should look close as possible as one of the mocked type therefore i would assume that annotations are copied currently mocktio uses as default the `subclassbytebuddymockmaker` which well subclasses the type to mock you can try to use the inline-mock-maker (by adding the dependency `orgmockito:mockito-inline:2100` ) i dont know how it acually works but it may behave differently since it dont subclass the type to mock as far as i know || adding `orgmockito:mockito-inline:2100` to my project did not change any test results || okay thanks for checking it out possibly @raphw has a good explanation for the current behaviour || we introduced this as a feature since the mock class should be a representation of the mocked type many times this is rather an advantage than a disadvantage you are however right that it should be something that can be controlled in the mock options we will look into italready today you can trick mockito into not copying the annotations by creating a mock of type object and adding the interface as ""additional interface"" || @raphw - great trick i think this will work in my environment for the moment || @raphw > we introduced this as a feature since the mock class should be a representation of the mocked type out of interest: shouldnt annotations never by copied from interfaces? i mean if an interface is implemented the compiler dont copy any annotation to the class so it is a bit surprising that mockito does it  i would expect this only for mocked classes  > already today you can trick mockito into not copying the annotations by creating a mock of type object and adding the interface as ""additional interface""this should imho the default behaviour when an interface is mocked maybe mockito should take this into account actually i dont see a case where this would be an disadvantage || @christianschwarz i would completely agree :) || this has been addressed in #1216 || ";1;0;adresses #1206: allow opting out from annotation copying within mocks;
1217;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;added integrity checker for odd number of #;will sometimes help for #1212 and #1188;;0; length format-using splitter; i am having a flat filei am using guava splitter to split the linesi need to store a  length file(of length 650) into one array and other so on while reading flat filethe real issue is line should be read including whitespacesany solutions?the snippet is given below:iterable&ltstring> splitstrings  splitterfixedlength(640)split(line); @﻿op if you have a look at spring batch its flatfileitemreader could be what you need:  ||;;;;0;1;;
1217;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;added integrity checker for odd number of #;will sometimes help for #1212 and #1188;;0;adding documentation for having and group by clauses;; why does this have backslashes? ||;;;;0;1;;
1217;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;added integrity checker for odd number of #;will sometimes help for #1212 and #1188;;0;behaviorsubjectcreate();add `behaviorsubjectcreate()` without need for defaultsee  for a discussion on this;available in #1185 but it surely needs rebasing and syncing with the bounded replaysubject || merged and available:  ||;;;;0;1;;
1217;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;added integrity checker for odd number of #;will sometimes help for #1212 and #1188;;1183.0;1183: make override check more forgiving to accomondate kotlin compile patterns;the override check implies java compile patterns such that kotlin method resolutions could fail for void return types which do not fit into javas reference-type only generic hierarchies this pr eases this restriction to fix this resolution for kotlini added the test case of the reported issue as a reference; merging 1217 ;unfinishedverificationexception with kotlin after updating to 290;mockito update 2847 → 290 brought us the exception when running the following test```kotlinpackage redactedpackagenameimport orgjunittestimport orgmockitomockitospyimport orgmockitomockitoverifyclass mockitotest {    @test fun test() {        val value  spy({})        valueinvoke()        verify(value)invoke()    }    @test fun testagain() {        val value  spy({})        valueinvoke()        verify(value)invoke()    }}``````orgmockitoexceptionsmisusingunfinishedverificationexception: missing method call for verify(mock) here:-> at redactedpackagenamemockitotesttestagain(mockitotestkt:20)example of correct verification:    verify(mock)dosomething()also this error might show up because you verify either of: final/private/equals()/hashcode() methodsthose methods *cannot* be stubbed/verifiedmocking methods declared on non-public parent classes is not supported	at redactedpackagenamemockitotesttest(mockitotestkt:10)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)	at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orggradleapiinternaltaskstestingjunitjunittestclassexecuterruntestclass(junittestclassexecuterjava:114)	at orggradleapiinternaltaskstestingjunitjunittestclassexecuterexecute(junittestclassexecuterjava:57)	at orggradleapiinternaltaskstestingjunitjunittestclassprocessorprocesstestclass(junittestclassprocessorjava:66)	at orggradleapiinternaltaskstestingsuitetestclassprocessorprocesstestclass(suitetestclassprocessorjava:51)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)	at orggradleinternaldispatchcontextclassloaderdispatchdispatch(contextclassloaderdispatchjava:32)	at orggradleinternaldispatchproxydispatchadapter$dispatchinginvocationhandlerinvoke(proxydispatchadapterjava:93)	at comsunproxy$proxy1processtestclass(unknown source)	at orggradleapiinternaltaskstestingworkertestworkerprocesstestclass(testworkerjava:109)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)	at orggradleinternalremoteinternalhubmessagehubbackedobjectconnection$dispatchwrapperdispatch(messagehubbackedobjectconnectionjava:146)	at orggradleinternalremoteinternalhubmessagehubbackedobjectconnection$dispatchwrapperdispatch(messagehubbackedobjectconnectionjava:128)	at orggradleinternalremoteinternalhubmessagehub$handlerrun(messagehubjava:404)	at orggradleinternalconcurrentexecutorpolicy$catchandrecordfailuresonexecute(executorpolicyjava:63)	at orggradleinternalconcurrentmanagedexecutorimpl$1run(managedexecutorimpljava:46)	at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)	at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)	at orggradleinternalconcurrentthreadfactoryimpl$managedthreadrunnablerun(threadfactoryimpljava:55)	at javalangthreadrun(threadjava:748)``` please notice that the following test will produce no errors```kotlinpackage redactedpackagenameimport orgjunittestimport orgmockitomockitospyimport orgmockitomockitoverifyclass mockitotest {    @test fun test() {        val value  spy({})        valueinvoke()        verify(value)invoke()    }}```this works as well so i assume it can be kotlin-lamda-related```kotlinpackage redactedpackagenameimport ioreactivexfunctionsactionimport orgjunittestimport orgmockitomockitospyimport orgmockitomockitoverifyclass mockitotest {    class actionimpl : action {        override fun run()  unit    }    @test fun test() {        val value  spy(actionimpl())        valuerun()        verify(value)run()    }    @test fun testagain() {        val value  spy(actionimpl())        valuerun()        verify(value)run()    }}```also important detail running from ide works fine only gradle runner is affected```/gradlew  testdebugunittest```;fyi the same thing happens with mockito 2100 || should be  on master already || @raphw can you please point me at the commit? ||  || @raphw just double-checked 2100 and the issue is still the same 😞  || ah too bad i will have a look it surely is related to our performance optimizations of detecting overridden calls to avoid repeated mocking down the hierarchy || the issue remains when using 2110 as well || i have added a test case on a branch now and started investigating seems like there is some issue with the sefl-invocation check such that the apply call is not recognized as a mock invocation || it seems like this is an issue within bridge method resolution kotlin creates several methods with equal java signature given test test class:```javaclass examplefunctiontest$testagain$value$1```the kotlin compiler implements two methods:```javajavalangobject examplefunctiontest$testagain$value$1invoke()void examplefunctiontest$testagain$value$1invoke()```from the view of the java language these two methods have an identical invocation signature and byte buddy attempts to resolve one method as a bridge method of the other one what is not correct for the kotlin languagei am currently trying to figure out why kotlin is doing that this would also break interoperability from java unfortunately this is not an easy mistake to work around either as we need to resolve bridge methods in order to handle java classes correctly and even with kotlin java classes will always be involved via the core class library such that one cannot simply offer a language switchthe fact that this broke recently is a result of fixing this resolution for java which was necessary due to a bug in this mechanism || just checked the 2120 and the issue seems to be fixed indeed ;1;0;1183: make override check more forgiving to accomondate kotlin compile patterns;
1219;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored some dialogs;extracted some code to methods.;;0;threadschecknotinterrupted() throws interruptedexception or similar; suppose im implementing a cpu-expensive background operation and i need to cancel it fast if the thread running it gets interruptedi would repeatedly write:if(threadinterrupted())&nbsp&nbsp&nbsp&nbspthrow new interruptedexception()it would be nice to have that as a library method such as:threadschecknotinterrupted()that would just implement the same behavior of interruptible system calls so i think it may deserve getting into guava; yeah a reasonable request but its a small enough snippet of code that id prefer to avoid introducing a new class--- ;;;;0;1;;
1219;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored some dialogs;extracted some code to methods.;;0;update to airbase 19;this updates jetty to 914 which we hope will fix https://githubcom/facebook/presto/issues/1138;;;;;1;1;update to airbase 19this updates jetty to 914 which we hope will fix https://githubcom/facebook/presto/issues/1138;
1219;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored some dialogs;extracted some code to methods.;;0;new executorscheduler implementation;it turns out a lot of people used `executorscheduler` despite its problems (#711 & #713) we need to bring it back but in a way that is compliant with the contractthis will mean that each `worker` from the `executorscheduler` will need to maintain its own queue outside of the `executor` (similar to `observeon`) and then recurse on the `executor` only a single task per `worker` can be scheduled/enqueued on an `executor` and when it completes then it should recurse pulling items from the `worker` queue when the queue is empty it can stop processing when a new task is enqueued on the `worker` then it can schedule against for execution on the `executor`we will be working against the default behavior of the `executor` but need to do that to maintain the single-threaded contract of a `schedulerworker`;"@benjchristensen youve probably already investigated but does any of the quasar work help or the backported `forkjoin` for jre6? || my understanding of `forkjoin` is that it would still have the same need for us to manage a queue externally otherwise it will process the items on multiple threads concurrently if we put them into the `forkjoin` queue || @benjchristensen your rightso idea i have at present is you spawn a new `serialexecutor` for each worker - pass in a executor into the scheduler- create `worker()` this creates a `serialexecutor` that _sits on_ a thread from the passed in executor- process through all the actions blocking until the `worker()` completes- complete and return the thread back to the poolnot sure if that would actually solve the problem but from my understanding is that we always need to serially execute queued up actions on any one worker || that all sounds right except the ""blocking until the worker() completes"" part that would okay in quasar but not with native threads it will need to behave like `observeon` where it releases the thread (think of it as an event loop) and then reschedules back on a thread the next time it receives an `onnext`see observeon here:  || @benjchristensen yeah ok that makes sensei still think it should be noted that people should try to avoid `executors` where possible it should be a ""when you really have too"" || i guess we need to make sure executing a tasks by the same worker shouldnt hop threads right? i see a few problems:- generally threads can die from executing non rxjava tasks and get replaced by fresh threads so thread ""hopping"" is more likely to occur than with the standard schedulers- since most executors use a single work queue work might be dequeued by any of the threads even if a work item can tell where it should run one would need some mechanism to toss the work over to the target thread at which point task reordering can happen   - maybe a write-cursor and read-cursor pairs may help plus each worker thread needs dedicated queue with every instance of schedulerworker assigned to it these queues may then be processed round-robin  - even if this worker thread affinity is established one would need constantly running tasks that poll these queues or blocking ones that get unblocked by yet another queue since we dont know how many threads there are in the executor it becomes difficult to schedule such processing routines if necessary and even so they will block out other tasks submitted from elsewhere to the same executorbottom line is in my opinion that there arent any good ways to ensure worker affinity on an executor whose internal threads and queueing we cant control || as far as i am concerned the needs i have is:- i have to serialize all my bluetooth low energy communications on android and requests can come from multiple threads id like my observables to be scheduled one after the other- in [cgeo]( i do not want more than 5 (or 10) concurrent  download connections from android as i download large images and the memory pressure will be too high if i download more of them at the same timeis there a way to achieve those two goals easily without an executor? || @samueltardieu this high jacks the issue somewhat but the `computation` scheduler only runs as many concurrent threads as there are cores on the device (2-4) for most android devicesthe whole point of the new schedulers is that they execute in order which executors are not guaranteed to doi would use either an io or trampoline scheduler for your btle comms (also remember to bind the `observable` if youre passing it off to the ui thread @mattias provided that one) as for  either use computation scheduler or your own scheduler we solved the problem in retrofit by using the executor in the `onsubscribe()` method see [rxsupport]( || there have been a few prs proposing a scheduler with  thread count and another with thread-caching support the latter can be extended to put an upper limit on the active thread count if necessary but unfortunately these efforts are blocked on the enhancement quest to add load-balancing to the base computation scheduler and the usual concerns about api size and features to expose ive been fiddling with an idea for some time to ask for a contrib-experimental module where all these ""outcasts"" and other stuff may be put || @akarnokd i quite like that idea keep the main lib lean im sure a _contrib-concurrency_ would not be overkilli mean i always use proguard so bloat isnt so much of an issue for me but its great you guys are thinking about it || all interested in this please try out the new implementation via `schedulersnewexecutor` as implemented by @akarnokd in   || should we rename `schedulersnewexecutor` to something else? reason im asking is that it doesnt actually create a new `executor` like `newthread` does it is a new `scheduler` around a given `executor` perhaps it is instead `schedulersfromexecutor(executor e)` or just `schedulersexecutor(executor e)`? || i like `schedulersfrom(executor e)` || @headinthebox +1 very consistent! || i believe this is done so closing out  || -keep class rxinternalutil*\* { * } add it in proguard to resolve few problems || ";;;;0;1;;
1219;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored some dialogs;extracted some code to methods.;;117.0;add regression test for issue #1174;regression that shows the issue of #1174 i am unable to reproduce this locally lets see what travis sayscloses #1174;  thank you! ||;nullpointerexception when using argthat() for long parameter in verify;a minimal code example:``` java  @test  public void shouldnotbebroken() throws exception {    takesalong takesalong  mock(takesalongclass)    verify(takesalong)call(argthat(corematchersequalto(11l)))  }  static interface takesalong {    void call(long l)  }```this leads to an npe logged as happening at the verify call which made me think that the the result of `verify(takesalong)` was null but it seems like the npe has a somewhat incomplete stack trace variations that dont show this problem include:- changing the interface to take a `long` instead of a `long` or- using `longthat(matcher<long>)` instead of `argthat()`if it is considered an error to use `argthat` where youre passing in a long then i think at least there should be a better error message;"i agree that better error message would be great do you have suggestions how to implement it?theres a longthat method that can be used in this contexthope that helps! || is that `longthat` method different from the one i mentioned in the bug report? ive been able to solve my problem (iirc i used the `longthat(matcher<long>)` version) so the point of this report is to help prevent others from running into the same issuei dont have any suggestions for how to implement it - the stack trace confuses me a lot and i wouldnt know where to start looking for the problem do you have any pointers where to start? im completely unfamiliar with the mockito source unfortunately || thanks for reporting the issue! it is very useful to build this documentationim not sure if it is feasible to improve the error message in this case eg the implementation of argthat() does not know the receiver object nor the method i used to think that this is not possible however your initial report got me thinking perhaps we can inspect the generic type of the matcher and if it is a primitive wrapper it can return 0 or false we would really appreciate your contribution :)you could start with a failing test case (you have it already) and try to add some smartness to the implementation of argthat method || > perhaps we can inspect the generic type of the matcher and if it is a primitive wrapper it can return 0 or falsethat is probably feasible but this wont be of any use in most cases because most of us use existing _matchers_ where most are generic with an `object` upper bound || yeah it would be good who wants to contribute the fix?on fri apr 3 2015 07:35 brice dutheil notifications@githubcom wrote:> perhaps we can inspect the generic type of the matcher and if it is a> primitive wrapper it can return 0 or false> > that is probably feasible but this wont be of any use in most cases> because most of us use existing _matchers_ where most are generic with an> object upper bound> > ## > > reply to this email directly or view it on github>  || is this still an ongoing issue? i am willing to do some investigation on this one || i did some investigation and the problem is at [the generictypeextractor]( executing the posted testcase the matcher that is created is [isequal]( executing `getactualtypearguments()` on `basematchersclass` it returns `type {typevariableimpl}` with name `t` as `basematchers` is the declared superclass of `isequal`this behaviour is because `isequal` is declared as generic with `<t>` therefore i sadly dont see a feasible solution and would alter the documentation to state that primitives should use the other methods such as `longthat(long)` || ah i had high hopes for the type extracting :( looks like the argxxx methods need to be included in mockitohamcrest do you want to contribute?  || i can contribute yes (but have a lot of prs open already might cause some flooding) but what do you mean with `argxxx`?do you mean a signature like `public static long argthat(matcher<long> matcher)`? i am not sure if it compiles but i can try it outstill i dont think the underlying issue is solved because `isequal<t>` with `tlong` will not match the `matcher<long>` but that would be left for experimentation || > do you mean a signature like public static long argthat(matcher<long> matcher)? i am not sure if it compiles but i can try it outit doesnt compile `argthat(matcher<long>)` has the same erasure as `argthat(matcher<t>)` i guess this issue cant be  the workaround is to use `mockitohamcrestlongthat(matcher<long>)` or better `mockitoeq(long)`imo this issue can be closed || i agree maybe with future jdk version we could do something not right now thanks @christianschwarz for this archeological dive in mockito issues ) || also remove `bug` label because its not really a bug in mockito || @bric3 please reopen> it doesnt compile argthat(matcher<long>) has the same erasure as argthat(matcher<t>) i guess this issue cant be fixed i was wrong after looking #246 i noticed that this issue can be fixed! two methods dont have the same erasure if the return type is different the java 8 compiler generates a warning in this case dont know about other versions we need to provide overloads for all primitives like this:```public static long argthat(matcher<long> matcher) {        reportmatcher(matcher)        return 0}```for the provided test case the expected `mockitoexception` _""wanted but not invoked ""_ is thrown || @christianschwarz nope that doesnt work while java byte code allows to have method based on the complete signature (ie name arg types and return type) the compiler just look at the name and arg typesthe following code dont compile : ```long argthat(matcher<long> matcher) {}int argthat(matcher<integer> matcher) {}``` || @bric3 crazy the jdt compiler has no problem with your sample it even works at runtime after some investigation i found this answer on [stackoverflow ]( it ~~should  worked with javac too~~ **worked until java 7** as the jls seems to allow it due to a hole in the specs (if i understand that correct)also interesting: [with generics the return type is part of the method signature]( i agree keep it closed for now || this hack does not work with java 8 || jup!its a bug in eclipse jdt that only occures with a non standard jre execution environment and compiler compliance setup i filed an issue for the jdt-team: [bug 499817]( || again something against eclipse its not the first bad bug using eclipse compiler-- briceon wed aug 17 2016 at 12:39 pm +0200 ""christian schwarz"" notifications@githubcom wrote:jup!its a bug in eclipse jdt that only occures with a non standard jre execution environment and compiler compliance setup i filed an issue for the jdt-team: bug 499817—you are receiving this because you were mentionedreply to this email directly view it on github or mute the thread || ";1;0;update genericsmockitoannotationstestjava;
1220;0;1;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;some cleanups;;;0;rfe [patch included] add more informational message to stopwatch-exceptions; when starting an already running stopwatch (or stopping a not-started one) an illegalstateexception is thrownthe javadoc explains why the exception is thworwn nevertheless i would find  it quite useful if i wouldnt just see an illegalstateexception but a more informative message like propoesed in the patch so that the exception explains that an already started stopwatch should not be started again etc; ;;;;0;1;;
1220;0;1;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;some cleanups;;;0;backport fixes from release/2x to master;because we should do this more frequent  ; merging 1220 ;;;;1;1;merge branch release/2x into backport-fixes;
1220;0;1;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;some cleanups;;;0;quarter() function doesnt work correctly;for some reason quarter() returns: 1/1 through 3/31  14/1 through 7/31  28/1 through 11/30  312/1 through 12/31  4it should be:1/1 through 3/31  14/1 through 6/30  27/1 through 9/30  310/1 through 12/31  4;are you running trunk?  i  some bugs in quarter while implementing the formal date time types || ah i think im a version behind  we are apparently updating next week so hopefully it gets resolved -  ill add some explicit tests for the bounds || fixed ||;;;;0;1;;
1220;0;1;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;some cleanups;;;0;shorter naming for toblockingobservable();"hi folksim exposing observables to my user and while this is awesome im realistic and know that a lot of them will fall back to blocking immediately either because they are migrating their blocking codebases or they just cant handle it properlywhile i think how rxjava exposes blocking is good i think there is also room for improvement to make it shorter for example consider the following:``` javacluster cluster  new couchbasecluster(""127001"")bucket bucket  clusteropenbucket()toblockingobservable()single()document doc  jsondocumentcreate(""hello"" jsonobjectempty()put(""hello"" ""world""))bucketupsert(doc)toblockingobservable()single()systemoutprintln(bucketget(""hello"")toblockingobservable()single())```especially if you are dealing a lot with just a single value something like `await()` on the observable would be good or some shorter way/alias name to be honest im not sure if this is possible but i also thought about shipping a helper class which just wraps the calls like `blockingutils(observable)single()` or something like this ";"@benjchristensen wdyt? || we specifically chose the explicit and long name `toblockingobservable` so people are fully aware of what theyre opting into we also consciously moved all of the blocking operators out of `observable` into `blockingobservable` so it is very clear what operators are blocking and which are notyou can however use `blockingobservablefrom(o)` which would be the same as `blockingutils(observable)`the `await` name isnt quite right as the method itself is not awaiting anything its just giving access to the blocking methods that would await we could suggest to the broader group to alias something shorter like `blocking()` or `toblocking()` to `toblockingobservable()` then it would be like this:``` javasystemoutprintln(bucketget(""hello"")blocking()single())``` || @benjchristensen makes sense! i really like `blocking()` it is much more concise can you bring that to a vote? || +1 for alias `toblocking()` and `toblockingobservable()`  || @chrisjenx what do you think about  just `blocking()`? || @daschl i think it needs to remain clear that its is _to_ a blocking observable as `blocking()` to me implies its an operator which it is not || @headinthebox @akarnokd @abersnaze @zsxwing any issues with aliasing `toblocking()` for `toblockingobservable()` to keep it shorter? || `toblocking()` is fine with me || `toblocking` +1 || i submitted a (simple) pr for this in case we get consensus || i vote no strongly autocomplete will type it for you and as ben says it should be there as a blinking danger sign to war you that you are doing something unsafe that why in haskell unsafeperformio has such a long name if you want to make it shorter i propose blocking() all caps || @headinthebox not sure i can follow while i can understand that it breaks the idea of async flows lots of applications sooner or later at the end of the chain will fall back to blocking so they can return it to a servlet or whateveri dont think we should make it hard on people sync programming is a legit concept even if it is not as powerful as rx || i also vote no `blockingobservablefrom()` is sufficient and avoids auto-complete-induced temptation ideally if you need blocking its in a single generic spot so it shouldnt even come up that often || @daschl won this one :-)we have deprecated `toblockingobservable()` in favor of `toblocking()` which is less annoying to use while still being clear and will better match the pattern with `toparallel()` that will come one day when i get around to it || see  for the change || @benjchristensen thanks for taking care of it my users will appreciate it || ";;;;0;1;;
1221;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;mockitoextension for junit5;445;;0;consistently apply @nullable to methods when they can return null; could you add @﻿nonnull or @﻿nullable annotations for the return types of functions this would make working with guava and annotation based null processing much easier and it would further help to document the interface of the functions @﻿parametersarenonnullbydefault only applies to the parameters and not the return type of the function that is why explicit annotations are neccessaryan example is the preconditions function checknotnull it will always return a non null result so it should be annotated that way@﻿nonnullpublic static &ltt> t checknotnull(t reference)or in immutablelist@﻿nonnullpublic static &lte> immutablelist&lte> of(e element) or optional@﻿nonnullpublic abstract t get()@﻿nonnullpublic abstract t or(t defaultvalue); i am somewhat inaccurately collapsing a bunch of nullability-annotation bugs into &lt my apologies for the oversimplification--- ;;;;0;1;;
1221;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;mockitoextension for junit5;445;;0;identity cast of hyperloglog fails;select cast(cast(null as hyperloglog) as hyperloglog)results in:query 20140422_220951_00004_n5kdf failed: cannot cast comfacebookprestospitypehyperloglogtype@74bebc01 to comfacebookprestospitypehyperloglogtype@74bebc01comfacebookprestosqlanalyzersemanticexception: cannot cast comfacebookprestospitypehyperloglogtype@74bebc01 to comfacebookprestospitypehyperloglogtype@74bebc01    at comfacebookprestosqlanalyzerexpressionanalyzer$visitorvisitcast(expressionanalyzerjava:570)    at comfacebookprestosqlanalyzerexpressionanalyzer$visitorvisitcast(expressionanalyzerjava:169)    at comfacebookprestosqltreecastaccept(castjava:46)    at comfacebookprestosqlanalyzerexpressionanalyzeranalyze(expressionanalyzerjava:166)    at comfacebookprestosqlanalyzerexpressionanalyzeranalyzeexpression(expressionanalyzerjava:813)    at comfacebookprestosqlanalyzertupleanalyzeranalyzeselect(tupleanalyzerjava:781)    at comfacebookprestosqlanalyzertupleanalyzervisitqueryspecification(tupleanalyzerjava:281)    at comfacebookprestosqlanalyzertupleanalyzervisitqueryspecification(tupleanalyzerjava:106)    at comfacebookprestosqltreequeryspecificationaccept(queryspecificationjava:99)    at comfacebookprestosqltreeastvisitorprocess(astvisitorjava:22)    at comfacebookprestosqlanalyzerstatementanalyzervisitquery(statementanalyzerjava:457)    at comfacebookprestosqlanalyzerstatementanalyzervisitquery(statementanalyzerjava:91)    at comfacebookprestosqltreequeryaccept(queryjava:80)    at comfacebookprestosqltreeastvisitorprocess(astvisitorjava:22)    at comfacebookprestosqlanalyzeranalyzeranalyze(analyzerjava:49)    at comfacebookprestoexecutionsqlqueryexecutiondoanalyzequery(sqlqueryexecutionjava:199)    at comfacebookprestoexecutionsqlqueryexecutionanalyzequery(sqlqueryexecutionjava:184)    at comfacebookprestoexecutionsqlqueryexecutionstart(sqlqueryexecutionjava:145)    at comfacebookprestoexecutionsqlquerymanager$querystarterrun(sqlquerymanagerjava:391)    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:471)    at javautilconcurrentfuturetask$syncinnerrun(futuretaskjava:334)    at javautilconcurrentfuturetaskrun(futuretaskjava:166)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1145)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:615)    at javalangthreadrun(threadjava:722);;;;;0;1;;
1221;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;mockitoextension for junit5;445;;0;improved documentation for onerrorflatmap;we need to improve documentation for onerrorflatmap as per discussion at https://githubcom/netflix/rxjava/issues/1002#issuecomment-39266024;"see  for the wiki version of the onerrorflatmap docs || thats a good explanation but it probably wont make sense to people who dont already understand can you perhaps add an example such as how `flatmap` or `merge` prevent this from working? || how does this sound?:""note that you should apply onerrorflatmap( ) directly to the pathological source observable and not to that observable after it has been modified by additional operators as such operators may effectively renormalize the source observable by unsubscribing from it immediately after it issues an error below for example is an illustration showing how onerrorflatmap( ) will respond to two error-generating observables that have been merged by the merge( ) operator note that it will not react to both errors generated by both observables but only to the single error passed along by merge( ):""( || we are removing onerrorflatmap ->  || ";;;;0;1;;
1221;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;mockitoextension for junit5;445;;445.0;mockitoextension for junit5;"445discussion:  of all thanks to the junit5-team (@sbrannen) for that great api! the implementation was straight forward and the docu is top notch not comparable to a junitrule or runner implementation one can feel the hard work ----the here provided `mockitoextension` allows to mock/spy/validate like the well known mockito-junitrule/runner this is still ""work in progress"" feel free to commentusage:```java@extendwith(mockitoextensionclass)class junit5test {   @mock  private dependency mock   @test  void checkmockcreation(){    when(mockfoo())thenreturn(""hello junit5"")    mockfoo()    verify(mock)foo()  }}```";"possibly we need an annotation on class or method level to provide control of the ""strictness"" eg:```@extendwith(mockitoextensionclass)@mockitostrictness(warn)class junit5test {    @mockitostrictness(strict_stubs)    void testwithlocaldefinedstrictness(){    }}``` ||  merging 1221                             release/2x    #1221   +/-   ##  coverage ! || ";introduce mockitoextension for junit jupiter (aka junit 5);## new features in junit 5the junit jupiter extension model in junit 5 introduces support for constructor and method parameter resolution (ie dependency injection)specifically third parties can implement the `parameterresolver` extension api to inject dependencies mocks etc into constructors and methods in addition the `testinstancepostprocessor` extension api can be implemented to post-process a test instance (eg to perform field injection)## status quomockito supports _field injection_ for mocks via the `@mock` annotation in addition #438 allows `@mock` to be declared on parameters for constructors and methods which makes `@mock` support an ideal candidate for both the `testinstancepostprocessor` and `parameterresolver` extension apis in junit jupiter in fact the junit team has already developed a proof of concept: see the `mockitoextension` in the [junit5-mockito-extension]( sample project## deliverables-  introduce an official `mockitoextension` for junit jupiter to replace the proof of concept from the junit team;"i think this issue can be merged with #390 our plan there was to introduce junit 5 compatibility in mockito 30 (since 20 is on the verge on being released in a couple of weeks) || sorry: i overlooked #390feel free to _merge_ it as you see fit lets track the junitextension in this issue and list the specifications of the `mockitoextension` for junit 5 the first point is to improve parameterized compatibility || @sbrannen any news on this ? || @bric3 the `mockitoextension` from the junit team is usable with mockito 20 snapshots and current versions of junit jupiter (junit 5)so its really up to the mockito team to decide when they want to take it over || @sbrannen this one -> [example/mockito/mockitoextension]( ? || yep thats the one || thanks @sbranneni was wondering if any api change would happen on junit 5 we will take over in mockito 3 once we are ready to switch branches for mockito 2 || > i was wondering if any api change would happen on junit 5well thats the million dollar question -- isnt it? 😉 all kidding aside we are currently working on junit jupiter 50 m3 but we still have quite a way to go before a ga release so although i cannot promise that the `extension` apis wont change any before ga it appears that the apis currently implemented by the `mockitoextension` should remain rather stable || ok thats good to know anyway we have to release 21 before starting 30 anyway and a some api design work on 21 too that may delay junit5 integration in the 30 beta phase || shall we start with fleshing out the specifications of the extension? would like to have a working prototype when junit 5 is released eta q1 2017 || yes go for it ill create a submodule junit 5 at this time since junit 5 is a near complete rewrite with a lot of binary incompatibilities || +1do we want to completely decouple mockito-core module from junit? || @szczepiq i am not sure but supporting both `junit4` and `junit5` in `mockito-core` seems problematic we have seen similar issues with `spring` having to support both mockito 1 and 2 therefore i think it is better to refactor mockito 3 such that we publish 2 new artifact: `mockito-junit4` and `mockito-junit5` which provide the integration layer between mockito and junit@sbrannen are you aware of other framework users depending on junit which employ this approach or is there a different and better solution? || in the `spring-test` module for the spring framework we provide support for testng junit 4 and junit jupiter (what you call junit 5) alongside each other just in different packages thats all within a single jar and there are no issues since each of those is an optional dependency (in terms of the maven pom)thus projects that consume `spring-test` can pick which testing framework they wish to use (or potentially use testng junit 4 and junit jupiter all simultaneously  however unlikely that may be)as long as its clear what developers need to consume for a given testing framework it shouldnt be a problem having a single artifact for example with spring junit 4 users use the `springrunner` whereas junit jupiter users use the `springextension` || if you do opt for separate modules (ie maven artifacts) i would recommend against `mockito-junit5` since what you are really providing is an extension for junit jupiter -- which is the new programming model in junit 5the problem with naming such an artifact `mockito-junit5` is that there may well be a junit 6 or 7 still based on the junit jupiter programming and extension models and then the artifact name containing a `5` would no longer make sensefyi: i have just changed the title of this issue to reflect this fact || okay that seems reasonable so lets take the package approach! my experience with jar configurations is limited so in terms of the configuration of users `pomxml` i do not  ";1;0;process @mockitoguy feedback;
1227;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed some unused fields and parameters;;;0;initial value enhancement for table (or a multitable?); i am trying to port existence code to guava i am not considering myself a guava expert but what i need is simply iterating over existence collection and constructing a tablemy preliminary implemention is as follows: &nbsp&nbsptable&ltinteger integer set> setperuser  hashbasedtablecreate()&nbsp&nbspfor(conversation conversation : conversations) {&nbsp&nbsp&nbsp&nbsp&nbspset uci  setperuserget(conversationx conversationy)&nbsp&nbsp&nbsp&nbsp&nbspif(uci  null) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspuci  new hashset()&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspsetperuserput(conversationx conversationy uci)&nbsp&nbsp&nbsp&nbsp&nbsp}&nbsp&nbsp&nbsp&nbsp&nbspuciadd(conversationid)&nbsp&nbsp}since the inner if insider for loop seems little problematic i am feeling that i am in wrong directionsean from stackoverflow suggested such a more generic solution as this:public static &ltx y z s extends collection&ltz>> void addcellvalue(&nbsp&nbsp&nbsp&nbsptable&ltx y s> table x rowkey y colkey z value supplier&lts> supplier) {```final s dataif (tablecontains(rowkey colkey)) {    data  tableget(rowkey colkey)} else {    data  supplierget()    tableput(rowkey colkey data)}dataadd(value)```}honestly i am not satisfied what i was considering is something similar to multimap namely multitable which is creating necessary in case a needanother solution would be using an initial value by supplier but this is not consistent with the other part of the libraryand last it would be great to have transformation methods for table too; i have another use case for multitable: verification of multiple queues header values that are coming in random order  || ";;;;0;1;;
1227;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed some unused fields and parameters;;;0;update license plugin and add missing license headers;the license plugin could be updated to later versions as we dropped jdk6 on travis moreover quite some licenses were reported missing so i ran `/gradlew licenseformatmain licenseformattest` to add them;  thank you! ||;;;;1;1;update license plugin and add missing license headers;
1227;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed some unused fields and parameters;;;0;implement tostring for hll;;;;;;1;1;implement tostring for hll;
1227;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;removed some unused fields and parameters;;;0;version 019;"the next release will be 019 issues being tracked for it are in  performance and object allocationfairly significant object allocation improvements are included in this release which reduce gc pressure and improve performancetwo pull requests (amongst several) with details are:-  reduce subscription object allocation-  moved to atomic field updaterswith the following simple test code relative performance has increased as shown below:``` javaobservable<integer> o  observablejust(1)omap(i -> {    return stringvalueof(i)})map(i -> {    return integerparseint(i)})subscribe(observer)```###### rx 019```run: 10 - 10692099 ops/sec run: 11 - 10617627 ops/sec run: 12 - 10938405 ops/sec run: 13 - 10917388 ops/sec run: 14 - 10783298 ops/sec ```###### rx 0184```run: 11 - 8493506 ops/sec run: 12 - 8403361 ops/sec run: 13 - 8400537 ops/sec run: 14 - 8163998 ops/sec ```###### rx 0176```run: 10 - 4930966 ops/sec run: 11 - 6119951 ops/sec run: 12 - 7062146 ops/sec run: 13 - 6514657 ops/sec run: 14 - 6369426 ops/sec ```###### rx 0161```run: 10 - 2879355 ops/sec run: 11 - 3236245 ops/sec run: 12 - 4468275 ops/sec run: 13 - 3237293 ops/sec run: 14 - 4683840 ops/sec ```note that these numbers are relative as they depend on the jvm and hardware ### scala changesmany missing operators have been added to the rxscala apis along with fixes and other maturation### toblockingobservable() -> toblocking()the `toblockingobservable()` method has been deprecated in favor of `toblocking()` for brevity and fit better with possible future additions such as `toparallel()` without always needing the `observable` suffix### foreach`foreach` as added as an alias for `subscribe` to match the java 8 naming conventionthis means code can now be written as:``` javaobservablefrom(1 2 3)limit(2)foreach(systemout::println)```which is an alias of this:``` javaobservablefrom(1 2 3)take(2)subscribe(systemout::println)```since `foreach` exists on `blockingobservable` as well moving from non-blocking to blocking looks like this:``` java// non-blockingobservablefrom(1 2 3)limit(2)foreach(systemout::println)// blockingobservablefrom(1 2 3)limit(2)toblocking()foreach(systemout::println)```### schedulersthread caching is restored to `schedulersio()` after being lost in v018a replacement for `executorscheduler` (removed in 018) is accessible via `schedulersfrom(executor e)` that wraps an `executor` and complies with the rx contract ### replaysubjectall ""replay"" functionality now exists directly on the `replaysubject` rather than in an internal type this means there are now several different `create` methods with the various overloads of size and time ### changelist- [pull 1165]( rxscala: add dropuntil contains repeat doonterminate startwith publish variants- [pull 1183]( notificationliteaccept performance improvements- [pull 1177]( groupbyuntil to use bufferuntilsubscriber- [pull 1182]( add facilities for creating observables from javafx events and observablevalues- [pull 1188]( rxscala schedulers changes- [pull 1175](  synchronous connectableobservableconnect problem- [pull 1172]( observeon: change to batch dequeue- [pull 1191]( fix attempt for operatorpivottest- [pull 1195]( swingscheduler: allow negative schedule- [pull 1178]( fix rxscala bug- [pull 1210]( add more operators to rxscala- [pull 1216]( rxscala: exposing publishsubject- [pull 1208]( operatortoobservablelist: use linkedlist to buffer the sequence’s items- [pull 1185]( behavior subject time gap fix 2 - [pull 1226]( fix bug in `zipwithindex` and set `zip(that selector)` public in rxscala- [pull 1224]( implement shorter toblocking as shorter alias for toblockingobservable- [pull 1223]( replaysubject enhancement with time and/or size bounds- [pull 1160]( add `replay` and `multicast` variants to rxscala- [pull 1229]( remove ambiguous subscribe overloads with scheduler- [pull 1232]( adopt limit and foreach java 8 naming conventions- [pull 1233]( deprecate toblockingobservable in favor of toblocking- [pull 1237]( safesubscriber memory reduction- [pull 1236]( compositesubscription with atomic field updater- [pull 1243]( remove subscription wrapper from observablesubscribe- [pull 1244]( observablefrom(t) using observablejust(t)- [pull 1239]( rxscala: update docs for ""apply"" and add an example- [pull 1248]( fixed testconcurrentonnextfailsvalidation - [pull 1246]( moved to atomic field updaters- [pull 1254]( zipiterable unsubscription fix- [pull 1247]( add zip(iterable selector) to rxscala- [pull 1260]( fix the bug that blockingobservablesingleordefault doesnt call unsubscribe- [pull 1269]( fix the bug that int overflow can bypass the range check- [pull 1272]( executorscheduler to wrap an executor- [pull 1264]( observeon scheduled unsubscription- [pull 1271]( operator retry with predicate- [pull 1265]( add more operators to rxscala- [pull 1281]( reduce subscription object allocation - [pull 1284]( lock-free mpsc-queue- [pull 1288]( ensure stringobservablefrom() does not perform unnecessary read- [pull 1286]( rename some operator\* classes to onsubscribe*- [pull 1276]( cachedthreadscheduler- [pull 1287]( replaysubject remove replaystate chm and related subjectobserver changes- [pull 1289]( schedulersfrom(executor)- [pull 1290]( upgrade to jmh 073- [pull 1293]( fix and update jmh perf tests - [pull 1291]( check unsubscribe within observable from future- [pull 1294]( rxoperators -> rxinternaloperators- [pull 1295]( change `void accept` to `boolean accept`- [pull 1296]( move re-used internal scheduler classes to their own package- [pull 1298]( remove bad perf test- [pull 1301]( rxscala: add convenience method for adding unsubscription callback- [pull 1304]( add flatmap and concatmap to rxscala- [pull 1306]( hooked rxjavaplugins errorhandler up within all operators that swallow onerrors- [pull 1309]( hide chainedsubscription/subscriptionlist from public api";"i think were close to being able to release 0190 and then allow further iteration on 019x releases is there anything outstanding that we must absolutely have done before 0190 is released? in particular:- any major performance work still outstanding?- any blocker bugs im missing?- anything we should deprecate that we havent already?- any breaking changes to core or language adaptors such as scala?once 0190 is released i intend on only one more round (020x) before we hit 10 release candidate as per plan here:  || @headinthebox @akarnokd i dont see anything blocking release of 0190 anything from your side or should i proceed? || im good to go || go for it!  || alright  ill finish the release notes and release it  are we okay with the `chainedsubscription` and `compositesubscription` signatures? we change `chainedsubscription` to `subscriptionlist`? || in 018x i did it as `subscriptionlist` so i think we should at least change to that `chainedsubscription` is wrong || here is where this topic started being discussed:  hold off on releasing until we finalize thispull request with subscriptionlist here:  this matches what was released in 0184 || @benjchristensen convinced me we cannot use `compositesubscription` and have a subtype that supports removal so thats off the table second best for me is simply `subscriptions` but i doubt that will fly -) so maybe `subscriptioncohort` (""a group of people banded together or treated as a group"")  for me _list_ implies some form of linearity and _set_ duplicate elimination || here is another option:  made `subscriptionlist` an internal implementation details and removed it from the public api so we can proceed with the release and expose it later if we wantthe `compositeexception` is not changed and i imagine we should leave it as is || just want to say a big ""thank you"" to all the contributors for this release it is totally awesome to see the ""pulse"" of rxjava || @headinthebox :+1: its awesome to see whats going on with the project makes me very confident i bet on the right horse for the next years to come :) || ";;;;0;1;;
1228;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;add @checkreturnvalue to stubbing/verification methods;introduce a new annotation  @checkreturnvalue  and add this to methods like  when  and  verify  such that static analysis can verify the value is actually used ( this makes sure developers can get warnings on build-time instead of run-time (with our internal  validatestate );;0;abstractcachesimplestatscounter longaddr usage of striped64 breaks on android; im using cachebuilder in an android app and when i use cachebuilderrecordstats() it fails because simplestatscounter uses striped64 which uses unsafe which isnt present on android (or at least doesnt work in the same way)ideally the api would allow me to _easily_ provide an alternatice implementation but i currently have to do some oo gymnastics to make it work (or not use stats at all) for example recordstats(statssupplier) would fit into the current builder api style; if there is no other option other than to wait for the guava 14 backport then i suppose thats all we can do  how soon is soon?  :)if i had my way we would abandon android api 8 but we still have enough customers with older devices (barely) to make that not an optionwe have a completely revamped version of our app which is supposed to be code complete soon (theres that word again) and i would feel all warm and fuzzy if i could see the cache stats before it goes live but you know what mick jagger says about getting stuff you wantwe love guava  its been a year or two since we integrated it into our product and its been great  especially the caching - which we use like crazy   ";;;;0;1;;
1228;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;add @checkreturnvalue to stubbing/verification methods;introduce a new annotation  @checkreturnvalue  and add this to methods like  when  and  verify  such that static analysis can verify the value is actually used ( this makes sure developers can get warnings on build-time instead of run-time (with our internal  validatestate );;0;fix hive connector partition lookup;use slicetostringutf8() instead of tostring() this fixes an issue whereall queries to the hive connector that used a where clause on a stringpartition column would return no results;;;;;0;1;;
1228;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;add @checkreturnvalue to stubbing/verification methods;introduce a new annotation  @checkreturnvalue  and add this to methods like  when  and  verify  such that static analysis can verify the value is actually used ( this makes sure developers can get warnings on build-time instead of run-time (with our internal  validatestate );;0;git reformats this file;;;;;;1;1;git reformats this file;
1228;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;add @checkreturnvalue to stubbing/verification methods;introduce a new annotation  @checkreturnvalue  and add this to methods like  when  and  verify  such that static analysis can verify the value is actually used ( this makes sure developers can get warnings on build-time instead of run-time (with our internal  validatestate );;1130.0;add @checkreturnvalue to stubbing/verification methods;introduce a new annotation `@checkreturnvalue` and add this to methods like `when` and `verify` such that static analysis can verify the value is actually used ( this makes sure developers can get warnings on build-time instead of run-time (with our internal `validatestate`)1130; merging 1228 ;mockito should annotate when() methods with a custom annotation @checkreturnvalue;static code checkers like error-prone and findbugs will help detecting invalid usage of mockito in single-call situations if mockito source code were annotated with @checkreturnvaluesee:*     like for assertj any annotation with name should do no need to depend on a specific library with  @checkreturnvalue;that seems fine to me please submit a pull request    ||;1;0;clarify documentation on annotation;
1231;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;invocationsprinter string concatination;replace string concatination inside an append call with a chained  append  calls to make the code a tad easier to read  so the reader isn t left wondering why some of the concatinations  with  append s and some with the  +  operator.;;0;patch for /guava/src/com/google/common/net/internetdomainnamejava;samb@ so that we can override this to use custom tldpatterns (may be from a file); no response--- ;;;;0;1;;
1231;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;invocationsprinter string concatination;replace string concatination inside an append call with a chained  append  calls to make the code a tad easier to read  so the reader isn t left wondering why some of the concatinations  with  append s and some with the  +  operator.;;0;invocationsprinter string concatination;replace string concatination inside an append call with a chained `append` calls to make the code a tad easier to read so the reader isnt left wondering why some of the concatinations  with `append`s and some with the `+` operator; merging 1231 ` ;;;;1;1;invocationsprinter string concatinationreplace string concatination inside an append call with a chainedappend calls to make the code a tad easier to read so the readerisnt left wondering why some of the concatinations  withappends and some with the + operator;
1231;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;invocationsprinter string concatination;replace string concatination inside an append call with a chained  append  calls to make the code a tad easier to read  so the reader isn t left wondering why some of the concatinations  with  append s and some with the  +  operator.;;0;fix memory leak in bootstrapfunctionbinder;; this fix doesnt actually work abandoning it ||;;;;0;1;;
1231;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;invocationsprinter string concatination;replace string concatination inside an append call with a chained  append  calls to make the code a tad easier to read  so the reader isn t left wondering why some of the concatinations  with  append s and some with the  +  operator.;;0;operator alias: share;as per discussion in #682;#1133;;;;1;1;operator alias: share;
1238;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added integrity checker to detect html encoded characters in fields;based on discussions in #1188;;0;add putall(iterable<k> v) to map/immutable map builders;robbzkup@ this would avoid the need of a temporary variable to assign multiple keys to the same value for example:private static final map&ltstring zipfile> mapstatic {&nbsp&nbsp&nbsp&nbspzipfile zf  new zipfile(""datazip"")&nbsp&nbsp&nbsp&nbspimmutablemap&ltstring zipfile> builder()&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspput(""file 1"" zf)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspput(""file 2"" zf)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspbuild()}vs:private static final map&ltstring zipfile> map  immutablemap&ltstring zipfile> builder()&nbsp&nbsp&nbsp&nbspputall(arraysaslist(""file 1"" ""file 1"") new zipfile(""datazip""))&nbsp&nbsp&nbsp&nbspbuild()"; we seem to have an acceptable workaround in comment #﻿4--- ;;;;0;1;;
1238;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added integrity checker to detect html encoded characters in fields;based on discussions in #1188;;0;backport fixes release/2x to master;- update licenses- remove unused `buildsrc`- remove old gradle files- add some more tests- fix coverage;this pr is blocked on #1174 ||  merging 1238  this pr tomorrow if no issues are found || lgtm (from the birds eye view)thanks for taking care about that the need to switch to 3x is just a matter of time `*` and your work will be priceless then `*` - years are still a matter of time ) ||;;;;1;1;disable broken test for now;
1238;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added integrity checker to detect html encoded characters in fields;based on discussions in #1188;;0;exchange client improvements;;i finished the review but i think we need to find a solution to the timing problem ||;;;;1;1;fail queries after too many exchangeclient errorsa query will fail if errors continue for longer than the minimum duration;
1238;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added integrity checker to detect html encoded characters in fields;based on discussions in #1188;;0;should rescheduling buffer() with time work?;"i have a simple test:``` java    @test    public void t1() throws interruptedexception {        final atomiclong ret  new atomiclong()        final publishsubject<long> num  publishsubjectcreate()        numbuffer(100 timeunitmilliseconds)subscribeon(schedulerscomputation())subscribe(new action1<list<long>>() {            @override            public void call(list<long> list) {                for (long l : list) {                    if (l < 3) {                        systemoutprintln(""l"" + l)                        numonnext(l + 1)                    } else {                        retset(l)                    }                }            }        })        numonnext(1l)        threadsleep(1000)        assertassertequals(3 retget())    }```if i remove the `subscribeon()` invocation then everything works well with the `scheduleon` the action never runs is this the expected behavior?";"subscribeon will delay the subscription to the buffered num and thus miss the first 1l from the publishsubject if you give it some time before the `numonnext(1l)` it passes || yes this is just a race condition publishsubject is ""hot"" which means it will send the event through even if the `subscribeon` is still in the process of subscribing (even if just microseconds) which means the `1l` gets dropped on the floor with no subscribers when using `publishsubject` it is always easy to end up with race conditions || you can see the race condition by putting this in there: ``` javathreadsleep(1)numonnext(1l)```that works about 2/3s of the time on my machine changing it to `sleep(2)` works all the time@akarnokd i dont think there is anything we can do about this is there? we cant use `bufferuntilsubscriber` as that would mean were subscribing to the origin on the calling thread rather than the given `scheduler` i think this really is just a side-effect of `publishsubject` being ""hot""@andrask using `publishsubject` is generally for one of two scenarios:1) multicasting and subscribers come and go and just pick up wherever they can but with no expectation of guaranteed delivery prior to subscription2) multicasting to a defined set of subscribers who receive all data from the start this is done generally with the `publish()` operator (uses `multicast()` under the covers) that returns a `connectableobservable` that you call `connect()` on once all `subscriber`s have subscribed so that you control the race condition and when to start the data flowingin other words if you need to guarantee delivery of the data from the start youll want to use a regular `observablecreate` so its ""cold"" and starts on subscription or something like a `replaysubject` or ensure all subscriptions are in place before starting to emit data to `publishsubject` || i feel like there are a lot of ambiguous methods in the api without reading every bit of the javadoc and in this case _asynchronously subscribed_ is still not something i would understand without @akarnokds explanationim trying hard not to use `publishsubject` but there are a vegillion cases when for example i need to provide an `observable` that the outside world can use but the events are sent into it from a completely different part of the class where i have no clue about the subscribers ive been thinking about this a lot but cannot figure out a better solutionfor a more concrete example: lets say i have a lifecycle signal that i use to send the state that the object has just got in this signal is completely independent from the execution of the business logic and i have to have a way to send to it while the logic is running the trivial solution is to use a behaviorsubject and show only the observable interface for the outside world what else could i do?id highly appreciate if you could share some better solution here || > a lot of ambiguous methods in the api without reading every bit of the javadoccan you provide examples of what is problematic and how you would improve/change them?> id highly appreciate if you could share some better solution hereit really depends on what youre trying to do in the example you gave it sounds like a `behaviorsubject` or `replaysubject` would be perfect as it guarantees delivery even if they subscribe after the event and youre not sending enough data to worry about a memory leak with `replaysubject` (and `behaviorsubject` never has that issue) the use of `publishsubject` and `replaysubject` both require consideration on `publishsubject` it is easy to lose data  think of it as a ""hot"" data flow and there is no guarantee anyone will ever receive the data but its also never going to cause a memory leak using `replaysubject` on the other hand allows you to ensure delivery and act like a ""cold"" data source so each `subscriber` gets all data from the start (or within the time/count criteria you give it) but you then must consider the memory leak (in the unbounded case) || ill keep on opening issues when i find something confusing thank you for your help i really appreciate it || ";;;;0;1;;
1247;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove several container classes and inline code;remove several classes that were containers for code that is easier to be inlined. they were only referenced once  or never at all. this makes it easier to reason about the code  while also maintaining less code and classes.;;0;adding a method to reflectclasspath to get the definition of a class (if possible) as a byte array; im using asm to do some decompiling/analysis of certain classes at runtimehaving a javalangclass and being able to get the byte definition of the class is a bit of workit would be really nice if guava could provide a helper method such asclasspath {&nbsp&nbsppublic static byte finddefinition(class<?> class)}if the class has been generated on runtime and no class file could be found it should just return nullsee also thishttp://stackoverflowcom/questions/2036108/convert-class-object-to-bytes;benyu@ we are planning to add resourceinfo which will have a url() method for each resource that should make it easy to get the bytes given a classinfo though the conversion from class -> classinfo is still inconvenient but well see how often it comes up--- ;;;;0;1;;
1247;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove several container classes and inline code;remove several classes that were containers for code that is easier to be inlined. they were only referenced once  or never at all. this makes it easier to reason about the code  while also maintaining less code and classes.;;0;hive timestamp fixes;;;;;;1;1;handle broken timestamp objectinspectors;
1247;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove several container classes and inline code;remove several classes that were containers for code that is easier to be inlined. they were only referenced once  or never at all. this makes it easier to reason about the code  while also maintaining less code and classes.;;0;add zip(iterable selector) to rxscala;- add `zip(iterable selector)` to rxscala- use `zip(iterable selector)` to reimplement `zipwithindex` to resolve the issue mentioned in #1226/cc @samuelgruetter;#1147  for zipping with an observable we have``` scaladef zip[u](that: observable[u]): observable[(t u)]def zipwith[u r](that: observable[u] selector: (tu) > r): observable[r]```so to be consistent the signatures for zipping with an iterable should be:``` scaladef zip[u](that: iterable[u]): observable[(t u)]def zipwith[u r](that: iterable[u] selector: (tu) > r): observable[r]``` || and you could add a good and bad example to rxscalademo: bad zips an observableinterval with an infinite observable (and thus the same happens as with the previous zip version) and good zips observableinterval with an infinite iterable || agreed  || ill wait until a go ahead to merge this as it seems there are additions to make || already updated || #1151 we should wait with this until  is  || is this now ready to merge since #1253 is merged? || yes it delegates to the java one ||;;;;1;1;rename to zipwith  add zip(iterable) add examples;
1247;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;remove several container classes and inline code;remove several classes that were containers for code that is easier to be inlined. they were only referenced once  or never at all. this makes it easier to reason about the code  while also maintaining less code and classes.;;904.0;remove several container classes and inline code;remove several classes that were containers for code that is easier to be inlined they were only referenced once or never at all this makes it easier to reason about the code while also maintaining less code and classescloses #904; merging 1247 ;remove unnecessary classes;looking at  and sorting it by coverage it appears that there are some classes that are completely untested taking another closer look reveals some candidate classes that can be removed for example `mockitolimitations` is [only used in the reporter]( the field can therefore be placed in the reporter directlythere are also some debugging and util classes that seem unused if we do decide to retain them i think we should test them to actually make sure they are working properly;;1;0;remove several container classes and inline code;
1257;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1254 and #1256: improved check for self-invocation.;better checks for recursive calls and guards internally used jdk types.;;0;session cleanups;;;;;;1;1;rename session to connectorsession;
1257;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1254 and #1256: improved check for self-invocation.;better checks for recursive calls and guards internally used jdk types.;;0;ambiguity in observablecreate() in java 8;the following (java 8) code leads to a compiler error because of the deprecated `observablecreate(onsubscribefunc<t>)` method specifically i get this: _reference to create is ambiguous  both method <t>create(rxobservableonsubscribe<t>) in rxobservable and method <t>create(rxobservableonsubscribefunc<t>) in rxobservable match_``` javapublic static observable<status> twitterobservable() {        return observablecreate( subscriber -> {            final twitterstream twitterstream  new twitterstreamfactory()getinstance()            twitterstreamaddlistener(new statusadapter() {                public void onstatus(status status) {                    if(subscriberisunsubscribed()) {                        twitterstreamcleanup()                    }                    subscriberonnext(status)                }                public void onexception(exception ex) {                    subscriberonerror(ex)                }            })            twitterstreamsample()        })    }```am i missing something? i must say i find the documentation of rxjava somewhat lacking it only covers a few basic examples for creating observables (mostly with `observablefrom()`) and only gives examples in one or a couple of languages (mostly groovy it seems) its the different language intricacies that make it difficult to make proper use of rxjava;"hi this is a known bug with javac: overload resolution doesnt account for the lambda return type being void update 8u20 should resolve this soon || it will also go away once we delete the deprecated create overload what would you suggest to be added to the documentation? i appreciate the criticism but it would be more helpful if you provide examples of what you were looking for and couldnt find  || thanks for the answers! [this is the actual javac bug]( for future reference for now ill just do a cast to force the compiler to acknowledge the right overload that seems to work :) and then ill just have to wait for either a rxjava release with the @deprecated method removed or java 8u20with regards to the documentation: at first i thought i was in error with the way i was using `observablecreate()` in java 8 and i had no way to check if that was the case because [the documentation]( only provides an example in _groovy_ i was left wondering if i missed some implementation intricacy specific to java 8 what i would like is that those example code snippets were to be provided in each supported jvm lang a bit like [the apache spark documentation is doing]( furthermore it would be great if there would be some more comprehensive/real world examples on how to use rxjava maybe a tutorial of some kind where you actually build something (small) using rxjava || > > that those example code snippets were to be provided in each supported jvm langwe are working on that> > it would be great if there would be some more comprehensive/real world examplesnot sure the docs are the right place for that google is your friend || > not sure the docs are the right place for that google is your friendit should be (my friend that is) but surprisingly little comprehensive examples and/or tutorials are to be found using google especially no recent onesi did find your lessons on using rx in the reactive programming course on coursera very useful though so thanks for that :) the api seems to have changed quite a bit since then though || if you want _real_ examples look at things like  imo the docs should have small snippets only and don t try to pretend anything ""real world"" real world code is not a good medium to convey basic principles because  all the real world aspects it needs to deal with || thanks for the example!i think documentation could (and maybe should) have both there should be a part of the documentation where basic principles are explained (like on the wiki right now but with snippets in all supported languages) and a part where a more comprehensive working example is portrayed || > and a part where a more comprehensive working example is portrayed> we take pull requests -) note there are plenty of those examples around if you search (in various rx implementations across languages) || i will see if i can cook up some examples once i have a better handle on stuff :) || jafar has this nice interactive tutorial for rx in javascript || those are fantastic! (but not real world) || we want to achieve the same thing as spark is doing and are working towards that right now my focus is on getting 10 out the door and over time the plan is for the broader rx community to come together to unify our documentation and examples || sounds great! || closing out as the root problem will be solved when we delete the deprecated code (or java 8 fixes itself) || ";;;;0;1;;
1257;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1254 and #1256: improved check for self-invocation.;better checks for recursive calls and guards internally used jdk types.;;1254.0;1254 and #1256: improved check for self-invocation;better checks for recursive calls and guards internally used jdk types1254 fixes #1256; merging 1257 ! ||;wanted but not invoked on 2120 but not on 2110;after updating mockito from 2110 to 2120 the following test fails with `wanted but not invoked`the weird thing is this happens only when running tests using gradle android studio runs the same test as successful just like #1183```javapackage packageredactedimport orgjunittestimport orgmockitomockitopublic class viewmodeltest {    class view {        private runnable actioncallback  null        void callaction(runnable callback) {            actioncallback  callback        }        void simulateactioncalled() {            if (actioncallback ! null) {                actioncallbackrun()            }        }        void showresult() {        }    }    class viewmodel {        public viewmodel(final view view) {            viewcallaction(new runnable() {                @override                public void run() {                    viewshowresult()                }            })        }    }    @test public void test() {        view view  mockitospy(new view())        viewmodel viewmodel  new viewmodel(view)        viewsimulateactioncalled()        mockitoverify(view)showresult()    }}``````wanted but not invoked:viewshowresult()-> at packageredactedviewmodeltest$viewshowresult(viewmodeltestjava:22)however there were exactly 2 interactions with this mock:viewcallaction(    packageredactedviewmodeltest$viewmodel$1@26645040)-> at packageredactedviewmodeltest$viewmodel<init>(viewmodeltestjava:28)viewsimulateactioncalled()-> at packageredactedviewmodeltesttest(viewmodeltestjava:41)	at packageredactedviewmodeltest$viewshowresult(viewmodeltestjava:22)	at packageredactedviewmodeltesttest(viewmodeltestjava:43)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)	at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orggradleapiinternaltaskstestingjunitjunittestclassexecuterruntestclass(junittestclassexecuterjava:114)	at orggradleapiinternaltaskstestingjunitjunittestclassexecuterexecute(junittestclassexecuterjava:57)	at orggradleapiinternaltaskstestingjunitjunittestclassprocessorprocesstestclass(junittestclassprocessorjava:66)	at orggradleapiinternaltaskstestingsuitetestclassprocessorprocesstestclass(suitetestclassprocessorjava:51)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)	at orggradleinternaldispatchcontextclassloaderdispatchdispatch(contextclassloaderdispatchjava:32)	at orggradleinternaldispatchproxydispatchadapter$dispatchinginvocationhandlerinvoke(proxydispatchadapterjava:93)	at comsunproxy$proxy1processtestclass(unknown source)	at orggradleapiinternaltaskstestingworkertestworkerprocesstestclass(testworkerjava:108)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)	at orggradleinternalremoteinternalhubmessagehubbackedobjectconnection$dispatchwrapperdispatch(messagehubbackedobjectconnectionjava:146)	at orggradleinternalremoteinternalhubmessagehubbackedobjectconnection$dispatchwrapperdispatch(messagehubbackedobjectconnectionjava:128)	at orggradleinternalremoteinternalhubmessagehub$handlerrun(messagehubjava:404)	at orggradleinternalconcurrentexecutorpolicy$catchandrecordfailuresonexecute(executorpolicyjava:63)	at orggradleinternalconcurrentmanagedexecutorimpl$1run(managedexecutorimpljava:46)	at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)	at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)	at orggradleinternalconcurrentthreadfactoryimpl$managedthreadrunnablerun(threadfactoryimpljava:55)	at javalangthreadrun(threadjava:748)```;"im observing a similar issue only happens with `mockito-inline` dont have time right now to distill the affected tests into a minimal reproduction case maybe @raphw has a hunch || alright decided to look for a minimal reproduction case after all this is what i came up with:```javapackage comexampleimport static orgmockitoargumentmatcherseqimport static orgmockitomockitospyimport static orgmockitomockitoverifyimport orgtestngannotationstestpublic final class mockitoissue1254test {    @test    public void test() {        dummy d  spy(new dummy())        dfoo()        verify(d)bar(eq(""baz""))    }    static class dummy {        public void foo() {            bar(""baz"")        }        // also fails if public        void bar(string s) {}    }}```causes:```wanted but not invoked:dummybar(""baz"")-> at comexamplemockitoissue1254test$dummybar(mockitoissue1254testjava:23)however there was exactly 1 interaction with this mock:dummyfoo()-> at comexamplemockitoissue1254testtest(mockitoissue1254testjava:13)```this test does pass with mockito 2110 it also passes with mockito 2120 provided `mockito-inline` is disabled || probably another error in the logic for self-invocation detection i will have a look! || ok this was just me forgetting how my implementation intially worked i  it locally and will push a fix soon || same for mocked methods on spy on 2120 real method is called || when is this going to be on maven central? || we could trigger a new release @timvdlippe would you find some time? || yeah i can try it tomorrow :)op di 5 dec 2017 om 20:55 schreef rafael winterhalter <notifications@githubcom>:> we could trigger a new release @timvdlippe> < would you find some time?>> —> you are receiving this because you were mentioned>>> reply to this email directly view it on github> < or mute the thread> < > || version 2130 should be published and available soon in maven central!ps @mockitoguy the `[ci maven-central-release]` was working flawlessly    || danke! bedankt! many  can confirm that finally our suite of 13+ k kotlin tests work after fixing #1183 and this one ✨ thanks! || >ps @mockitoguy the [ci maven-central-release] was working flawlessly 🎉awesome! thank you for pushing out the version! || ";1;0;1254 and #1256: improved check for self-invocation;
1257;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1254 and #1256: improved check for self-invocation.;better checks for recursive calls and guards internally used jdk types.;;1256.0;1254 and #1256: improved check for self-invocation;better checks for recursive calls and guards internally used jdk types1254 fixes #1256; merging 1257 ! ||;unbounded recursion when spying with `mockito-inline`;"consider the following code:```java@testpublic void test() {    concurrentmap<string string> map  spy(new concurrenthashmap<>())    mapputifabsent(""a"" ""b"")}```running it causes a `stackoverflowerror`:```configuring testng with: testng60configuratorexception in thread ""testng-testsurefire test-1"" javalangstackoverflowerror        at orgmockitointernalcreationbytebuddymockmethoddispatcherget(mockmethoddispatcherjava:20)        at javautilconcurrentconcurrenthashmapcontainskey(concurrenthashmapjava:964)        at orgmockitointernalutilconcurrentweakconcurrentmapcontainskey(weakconcurrentmapjava:74)        at orgmockitointernalutilconcurrentweakconcurrentmap$withinlinedexpunctioncontainskey(weakconcurrentmapjava:261)        at orgmockitointernalcreationbytebuddymockmethodadviceismock(mockmethodadvicejava:116)        at orgmockitointernalcreationbytebuddymockmethodadviceismocked(mockmethodadvicejava:121)        at javautilconcurrentconcurrenthashmapcontainskey(concurrenthashmapjava:964)        at orgmockitointernalutilconcurrentweakconcurrentmapcontainskey(weakconcurrentmapjava:74)        at orgmockitointernalutilconcurrentweakconcurrentmap$withinlinedexpunctioncontainskey(weakconcurrentmapjava:261)        at orgmockitointernalcreationbytebuddymockmethodadviceismock(mockmethodadvicejava:116)        at orgmockitointernalcreationbytebuddymockmethodadviceismocked(mockmethodadvicejava:121)        at javautilconcurrentconcurrenthashmapcontainskey(concurrenthashmapjava:964)        ```tested with mockito 2110 and 2120 do not happen if i disable `mockito-inline` cc @raphw";i will have a look  the problem is that we use a hash map internally to store mock dispatchers we need to exclude this map from checking for being a mock explicitly as the check involves reading from the map what triggers the recursion ||;1;0;1254 and #1256: improved check for self-invocation;
1258;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;prevent class loading race condition;allow singleton locking in context with class loading races.;;0;cleanup date time functions;;;;;;1;1;remove millis_to_time functions;
1258;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;prevent class loading race condition;allow singleton locking in context with class loading races.;;0;rxscala: subscription add with block expression;```final def add(s: subscription): unit  {    asjavasubscriberadd(sasjavasubscription)  }```add```final def add(s: >unit): unit  ```so you can write `sadd{ blah blah }`;ill take a stab at this issue || cool ||;;;;0;1;;
1258;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;prevent class loading race condition;allow singleton locking in context with class loading races.;;106.0;prevent class loading race condition;allow singleton locking in context with class loading races1067;"fully agree will do soon ||  merging 1258  <  ";partial;"hi heres the implementation of the partial mock support i was talking about:```partialmock(class)partialmock(object enclosinginstance class innerclass)```the second overload is the one solution to the arbitrary constructor parameter issue:```@mock private collaborator1 mockcollaborator1@mock private collaborator2 mockcollaborator2@partialmock private mockworker workerabstract class mockworker extends worker {  mockworker() {    super(mockcollaborator1 mockcollaborator2)  }}```i didnt name it spy() for the following reasons:1 spy() doesnt work for final methods it would be surprising if users partial mock works without ""final"" and stops working when ""final"" is added the non-abstract methods arent meant to be mocked after all2 with partial mock one goal is to allow having state in the object the shallow copying of spy() wont always work when there is mutable state especially if there are private methods in the class that spy cannot intercept3 ""spy"" conceptually needs a target object to spy on without a target spy(fooclass) feels non-intuitive4 all the use cases i know of for partial mocking dont need spying5 if really needed one can always explicitly `spy(partialmock(fooclass))`annotation support isnt added yet";"another use case i considered but would like to get some feedback before adding to the javadocas the faq puts it:> technically speaking mockito is a test spy framework> test spy framework allows to verify behaviour (like mocks) and stub methods (like good old hand-crafted stubs)but it leaves one question open: should one ever use the ""good old hand-crafted stubs"" at all? if yes under what scenario?a main reason that people use the `when()thenreturn()` dsl instead of the hand-crafted stubs is that for interfaces with many methods hand-crafting the stub means to write lots of extra boilerplate override methods that arent interesting to the testbut with partial mock the above is no longer true its easy enough to hand-roll an abstract stub class implementing only the interesting methods and then partialmock() itbetween the two different ways of stubbing (plain old `@override` vs `when()thenreturn()`) heres a guideline ive been following with success:- `when()thenreturn()` is best used to stub data logically related to the current test that is its best used in the individual test methods the dsl reads nicely in the bdd given-when-then style- for stubbing shared data that arent logically specific to any individual test plain old abstract classes work better because the `when()thenreturn()` dsl can usually lead to messy setup() method with stubbing of several different objects crammed together in other words prefer `partialmock(stubfooclass)` over `when()thenreturn()` statements in setup() || heythanks so much for taking the time to implement this heres some feedback about your design decisions:1 i respect the arguments for avoiding reusing spy nomenclature for good or bad mockito spies are called partial mocks this pattern is also used in other mocking libraries like spock imho adding a separate method may confuse users2 i think that the message that hand stubs are recommended for stubbing that typically ends up in setup() method is a bit too strong from my experience rolling out hand stubs typically indicates design smell - theres too much ask style interactions and too little tell style interactions the latter better isolate responsibilities leading to cleaner designnow lets look into the code :) || oh right i reviewed the codes :)one thing that stands out is that partial mock seems to be driving the api and the implementation towards a new kind of mock ideally we would like to avoid it in mockito were trying to generalize more and avoid creation of new kinds of mocksto accept the pr we would like to simplify the api and implementation api:1 mockitospy(fooclass object  constructorargs)2 withsettings()constructorargs(object  args)3 withsettings()outerinstance(object object)1) delegates to: mock(fooclass withsettings()constructorargs(object  constructorargs)defaultanswer(calls_real_methods)also this should work with regular mocks too eg if someone specifies the constructorargs (we can call it differently eg usesconstructor etc) then the instance is created via the constructor instead of by using the objenesisthis can be implemented incrementally for example:1 add constructorargs/usesconstructor support2 add outerinstance/enclosinginstance support3 add spy methodthis is great stuff thanks for this pr sorry i cannot merge it in this form just yet perhaps ill add some code to get this started || thanks for spending the time reviewing this code!i was thinking that i cannot make spy work while also keeping final methods in fakes workbut reading your reply a few times convinced me that i misunderstood how spies work and its actually pretty trivial to implement so in short i was wrong `spy(class)` tastes sweet!what do you think of the new revision?- mockitospy(fooclass object  constructorargs)again i dont feel we need to support arbitrary constructor args its not statically type safe or refactoring friendly there are ambiguity issues wrt constructor overloads  and lastly while 0-constructor-arg abstract classes without state can be fine (like abstractlist) abstract classes with state feels more often a design smell- withsettings()outerinstance(object object)hmm kinda feel that the api of `spy(outer innerclassclass)` reads more intuitive: the outer object is the qualifier for the inner class just as how we say `outernew innerclass()`also unlike other mock settings that apply to every method that accepts it outerinstance() is only meaningful to `spy() mock(fooclass settingsouterinstance(outer))` would be meaningless || on my radar ill reply tomorrow )on sat oct 18 2014 at 1:31 am fluentfuture notifications@githubcomwrote:> thanks for spending the time reviewing this code!> > i was thinking that i cannot make spy work while also keeping final> methods in fakes work> > but reading your reply a few times convinced me that i misunderstood how> spies work and its actually pretty trivial to implement> > so in short i was wrong i like spy()!> > what do you think of the new revision?> > about the 3 items in your suggested api:> 1 mockitospy(fooclass object  constructorargs)> > again i dont feel we need to support arbitrary constructor args its> not type safe i fear that adding this support would encourage bad-designed> abstract classes if 0-constructor-arg abstract classes without state are> fine (like abstractlist) abstract classes with state feel almost always a> smell> 1 withsettings()outerinstance(object object)> > hmm kinda feel that the api of spy(outer innerclassclass) reads more> intuitive: the outer object is the qualifier for the inner class just as> how we say ""outernew innerclass()"" agree? its your call if you prefer> outerinstance() ill change> > ## > > reply to this email directly or view it on github>  szczepan fabercore dev@gradle founder@mockito || > again i dont feel we need to support arbitrary constructor args its not statically type safe or refactoring friendly there are ambiguity issues wrt constructor overloads  and lastly while 0-constructor-arg abstract classes without state can be fine (like abstractlist) abstract classes with state feels more often a design smelli agree with everything you wrote thing is we cannot really objectively say that stateful abstract classes are ok only when have 0-arg constructor consequently we cannot restrict the api based on this assumption users will come up with use case for argumented abstract classes and it will be hard to defend it also mockito needs to balance out the toolkit approach (unopinionated) with framework approach (opinionated) to describe this further: from the standpoint of api design we _can_ declare that in our opinion mocking abstract classes is a design smell and we dont want to support it officially (we could however open some extension points for users to implement it unofficially) but we cannot really say that _some_ abstract classes are ok to mock and some not at least this is my view on the subject and i respect if you have a different povimho we dont have to provide constructor args in the first iteration but we should plan for it api-wise so that adding this feature later does not incur any deprecation or api awkwardness we should also avoid documenting that we are not planning to do the constructor args because we believe it is a smell however we can document that _typically_ mocking abstract classes hints at design smell etc> hmm kinda feel that the api of spy(outer innerclassclass) reads more intuitivespy() method and the withsettings() method are not ""alternative"" implementations :) all spy() methods need to delegate to a mock() method that has specific spy-related withsettings() other words: every possible kind of mock can be created using this entry point of the api:  think about the spy() method (and overloaded mock() methods) as a convenience methods / syntax sugar over the main mock creation entry point> spy(outer innerclassclass)id rather avoid overloaded spy() method that uses outer instance initially it feels that mocking inner abstract classes is somewhat an edge case (arguably) we could provide an api for this via withsettings() though from my objective standpoint it feels that its more important to support constructor arguments than to support mocking inner classes (eg i would dare to say that there are more use cases that support the former feature)i havent yet looked in the code :) || i reviewed the code please dont get disheartened by the amount of review items :) im enjoying this conversation immensely and im really happy that you will contribute it! it will be a great feature in mockitoive done some refactorings in mockito regarding mock initialization and i will push it now merging your stuff will be hard and im sorry for this i hope that the code after the refactorings will be easier for you to implement the feature ) || pushed take a look at orgmockitointernalcreationcglibclassimposterizertest#shouldcreateclassbyconstructor || thanks for explaining the rationale so clearly and patiently! some further clarifications below in hope that i could sell the idea better :)ill work on the refactoring and merging later> thing is we cannot really objectively say that stateful abstract classes are ok only when have 0-arg constructor consequently we cannot restrict the api based on this assumption users will come up with use case for argumented abstract classes and it will be hard to defend it also mockito needs to balance out the toolkit approach (unopinionated) with framework approach (opinionated) to describe this further: from the standpoint of api design we can declare that in our opinion mocking abstract classes is a design smell and we dont want to support it officially (we could however open some extension points for users to implement it unofficially) but we cannot really say that some abstract classes are ok to mock and some not at least this is my view on the subject and i respect if you have a different povagreed the ""opinion"" is but one reason though another one is that its not type safe and would pose a difficulty to tools like ide later when someone is trying to find references to a constructorwhile mockito doesnt need to be an opinionated framework i think its fair to say that mockito can choose to only implement a feature that it does better than alternativesi imagine if someday someone wants to spy a class with constructor args my suggestion would be to create a simple subclass wrapper:```@mock private collaborator collaborator@spy private mockfoo fooabstract class mockfoo extends abstractfoo {  mockfoo() {    super(collaborator blah)  }}```this way everything is still nicely compiler and tool friendly one major difference between mockito/easymock and jmock (at least the earlier versions) is that they are type safe supporting arbitrary constructor args using object takes a step away from the type safetythere may still be the  ";1;0;simplified locking during class generationlets optimise the implementation for correctness rather than performance especially if we dont have evidence that using classloader objects as the monitor makes mockito faster i made tests on our own build and the execution of tests takes exactly the same;
1268;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1262: update doc for answers.calls_real_methods;update the documentation for the answers.calls_real_methods according to #1262 and also included a note with recommendation not to use when().thenreturn() for partial mock.;;0;fixes;;;;;;1;1;add slice to parent first class list;
1268;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1262: update doc for answers.calls_real_methods;update the documentation for the answers.calls_real_methods according to #1262 and also included a note with recommendation not to use when().thenreturn() for partial mock.;;0;cursor observable for android;change version of scala to newest 211 for properly work and gradle executionadd cursorobservable for observing android cursor changes;#1163 #1167 #1168 it seems like cloudbees says about core tests failure i can not understand why there is no problems on my machine || /cc @mttkay @zsxwing || why update scala to 211? || could you revert the change of scala version? even if you have compelling reasons its better that updating scala version in another pr so that we can discuss it there || @zsxwing should i create two new pr or just revert my changes in buildgradle and create new about new scala? || besides a few style things i commented on i think this looks like a good solution to lifting queries to a `contentprovider` into an observable call chaini have a general question though (maybe more for @benjchristensen): is there a general policy for adding new functionality to the library? id be a bit wary by adding stuff thats only used by a single product were moving away from contentproviders in our app so i probably wont be able to give this a shot in practice any time sooni think it would be good if someone could incorporate this into their app and give first hand feedback?also i would definitely want to see tests added before landing this || > @zsxwing should i create two new pr or just revert my changes in buildgradle and create new about new scala?maybe you can just override the commits in this pr the following commands can help you clean up this pr``` shellgit checkout cursor-observablegit reset head~2git checkout -- language-adaptors/rxjava-scala/buildgradlegit add rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/cursorobservablejavagit commit --amendgit push --force <your_remote_repository_name> cursor-observable``` || [rxjava-pull-requests #1171  thank you but im already had some fail with it (use head~5  instead of head~4) and add cursorobservablejava to davidmgrosss commit ill fix it soon || [rxjava-pull-requests #1172 may be it will be good to add tests for cursorobservable and create new pr without my stupid fails ||;;;;0;1;;
1268;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1262: update doc for answers.calls_real_methods;update the documentation for the answers.calls_real_methods according to #1262 and also included a note with recommendation not to use when().thenreturn() for partial mock.;;1262.0;1262: update doc for answerscalls_real_methods;update the documentation for the answerscalls_real_methods according to #1262 and also included a note with recommendation not to use when()thenreturn() for partial mock;  hey @seriybg this is a nice change! sorry we have not reviewed earlier it must have slipped our radar continually improving documentation is absolutely important thank you for contributing! ||;improve documentation about partial mocks and doreturn() style of stubbing;i think the documentation here is wrong: i believe the doreturn() syntax should be used there instead at least when i do that it works but when i do the when(myfoomymethod())thenreturn() that line itself runs the real impl of mymethod; here: #1268 || thanks!on fri dec 15 2017 at 7:28 am serge bishyr <notifications@githubcom>wrote:> fixed here: #1268 < —> you are receiving this because you authored the thread> reply to this email directly view it on github> < or mute the thread> < > ||;1;0;1262: update doc for answerscalls_real_methods;
1270;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleaner code for mockito users by better integration with static code checkers  more @checkreturnvalue;builds on #1130  #1228.;;0;firstnonnull to deal with lists; i am using objectsfirstnonnull to deal with results from java persistence but i have to add extra check to deal with list to get first element from it i use something like this:public t firstnonnullcollection(collection&ltt> c t t) {&nbsp&nbspif (c  null || cisempty()) {&nbsp&nbsp&nbsp&nbspreturn objectsfirstnonnull(t)&nbsp&nbsp}&nbsp&nbspreturn citerator()next()}what do you think of this idea? does it make any sense?; ;;;;0;1;;
1270;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleaner code for mockito users by better integration with static code checkers  more @checkreturnvalue;builds on #1130  #1228.;;0;error message not clear when casting to invalid type;simplifying my query to provide repro steps:``` sqlselect 2 * (1 / (1 + exp(-1 * cast(01 as float)))) - 1```returns: query 20140502_003330_00053_mk564 failed: line 1  no viable alternative at input 1it is an user error since i did cast(01 as float) should be doing cast(01 as double) but it took a while to figure this out since the error kept on pointing towards the wrong location the following sql works:``` sqlselect 2 * (1 / (1 + exp(-1 * cast(01 as double)))) - 1```returns: 0049958374957880025;this now prints:```query  failed: unknown type: float``` ||;;;;0;1;;
1270;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleaner code for mockito users by better integration with static code checkers  more @checkreturnvalue;builds on #1130  #1228.;;0;rename operatormulticast and operatormulticastselector?;was looking at the source of [operatormulticast]( and  [operatormulticastselector]( and neither implements `operator` is a rename in order here or are they going to be made into `operator`s soonish?;"they cant be operators because they need to be `connectableobservable`s i think the naming is just stuck so they dont stand out of the other operatorxyz classes btw there are a bunch of operatorxyz which implement onsubscribe only yet they are called operator || yep youre quite right of the 93 operator\* classes in the `operator` package roughly 22 do not implement `operator` this is a lot of hiding though perhaps some are candidates to implement `operator` in the near future why not rename everything that is not an `operator` (and not a candidate for conversion to `operator`)?  might prompt a new package or two to contain these beasts  in the case of the classes above id prefer to see them as `connectableobservablemulticast` and `connectableobservablemulticastselector` || heres a quick list might have missed some:```operatorambjava:public final class operatoramb<t> implements onsubscribe<t>{operatorcachejava:public final class operatorcache<t> implements onsubscribe<t> {operatorcombinelatestjava:public final class operatorcombinelatest<t r> implements onsubscribe<r> {operatordeferjava:public final class operatordefer<t> implements onsubscribe<t> {operatordelayjava:public final class operatordelay<t> implements onsubscribe<t> {operatordelayjava:    public static final class emitter<t> implements onsubscribe<t> action0 {operatordelaysubscriptionjava:public final class operatordelaysubscription<t> implements onsubscribe<t> {operatordelaywithselectorjava:public final class operatordelaywithselector<t u v> implements onsubscribe<t> {operatorgroupjoinjava:public final class operatorgroupjoin<t1 t2 d1 d2 r> implements onsubscribe<r> {operatorjoinjava:public final class operatorjoin<tleft tright tleftduration trightduration r> implements onsubscribe<r> {operatormulticastjava:public final class operatormulticast<t r> extends connectableobservable<r> {operatormulticastselectorjava:public final class operatormulticastselector<tinput tintermediate tresult> implements onsubscribe<tresult> {operatorparallelmergejava:public final class operatorparallelmerge {operatorrefcountjava:public final class operatorrefcount<t> implements onsubscribe<t> {operatorreplayjava:public final class operatorreplay {operatorsequenceequaljava:public final class operatorsequenceequal {operatorskipjava:public final class operatorskip<t> implements observableoperator<t t> {operatortakeuntiljava:public final class operatortakeuntil {operatortimeroncejava:public final class operatortimeronce implements onsubscribe<long> {operatortimerperiodicallyjava:public final class operatortimerperiodically implements onsubscribe<long> {operatortomapjava:    public static final class defaulttomapfactory<k v> implements func0<map<k v>> {operatortomultimapjava:    public static final class defaulttomultimapfactory<k v> implements func0<map<k collection<v>>> {operatortomultimapjava:    public static final class defaultmultimapcollectionfactory<k v>operatortoobservablefuturejava:public class operatortoobservablefuture {operatorusingjava:public final class operatorusing<t resource extends subscription> implements onsubscribe<t> {``` || these operators are considered internal implementation and unless you are a hard-core rxjava-core developer you dont need to worry about what is in `rxoperators` many of these operators dont implement operator because the behavior they need to perform can only be done while in onsubscribecall() there is no one to pass a subscriber further up since they behave basically as sources || the ones that implement `onsubscribe` could be renamed from `operator*` to `onsubscribe*`more importantly though these should never be relied upon publicly they are not part of the public api and can change at any time even once we hit 10 || so i dont have hard core understanding of the rxjava code base but im using it on a a lot of projects at work and to develop with rxjava i very frequently dig small holes into the source code to understand what im using and i use the source as a cookbook i cant imagine developing with the library without the source code given that id like to see those spades called spades to minimize a bit of possible confusion (eg why is `observablecreate` being called with an `operator` what overload is that?) happy to knock up a pull request if this has support || im okay with a change that makes the `onsubscribe` implementations start with `onsubscribe`so that this is clean please do not mix any other changes with it just renaming those ~20 files that should start with `onsubscribe` instead of `operator`example `operatoramb` -> `onsubscribeamb`@akarnokd do you have an issue with this? it seems to be clearer and matches the intent of of classes such as `onsubscriberange` and `onsubscribefromiterable` already there ||  for me using operator as prefix is simpler so no need to remember the base interface for each operator id even drop the prefix but i guess that would just complicate auto-complete in ides || these classes are internal and referenced from a single place `observable` so im fine either way i think we should either give them a completely generic prefix (i cant think of one right now) or make the `onsubscribe*` and `operator*` prefix consistent as suggested in this issue || the generic prefix idea is not attractive to me because i lose visibility at a glance of what types the classes are i end up in the same place as i am now dropping the prefix would do the job if we moved non-operators out of the operator package to an onsubscribe package my preference at the moment is operator -> onsubscribe || im fine with you changing the prefixes if you want to contribute that || sounds good || now that we have `rxinternal` should we move `rxoperators` to `rxinternaloperators` alongside `rxinternalutil`? this way it is very clear that these are internal and not part of the public api? || fine with me || sounds good || sounds goodon 31 may 2014 03:33 ""headinthebox"" notifications@githubcom wrote:> sounds good> > —> reply to this email directly or view it on github>  || ill make this change || ";;;;0;1;;
1270;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;cleaner code for mockito users by better integration with static code checkers  more @checkreturnvalue;builds on #1130  #1228.;;1130.0;cleaner code for mockito users by better integration with static code checkers more @checkreturnvalue;builds on #1130 #1228;"note that almost all non-`void` `orgmockitomockito` methods are now annotated `@checkreturnvalue` you could consider going the other way by annotating the class as a whole `@checkreturnvalue` and adding [`@canignorereturnvalue`]( to the non-`void` methods that form the complement ||   context for this change: within a company-internal pr i found an unused `mock(someclass)` statement and thought ""itd be nice if mockito supported `@checkreturnvalue`"" then i found #1228 but noticed that the `#mock` methods werent annotated in fixing that i decided to go over the whole class for each method annotated in this pr i traced its logic most are side-effect free while the remainder throw an exception in case of misuse the only non-`void` method in `orgmockitomockito` i did not annotate is `#ignorestubs` because it returns its input  || the reason i did not include these methods in #1228 was because there were no side-effects checking them would therefore not required as it would be perfectly okay (from a mockito-perspective) that these methods are invoked and then discarded the methods i annotated do have side-effects and thus are harmful if you discard the return valuetherefore i am hesitant to accept this pr as (to my knowledge) these methods are pure and are not harmful for mockito to be invoked a lot of times || invoking these methods many times may not be harmful in a functional sense but imho `@checkreturnvalue` is more about establishing correctness ignoring the return value of any of these methods indicates a human error leading to cluttered tests in the best case and a false sense of security in the worst caselooking at guava that seems to be the way how they use the annotation for example it is applied to the whole package `comgooglecommoncollect` with some methods within that package annotated `@canignorereturnvalue` none of those are pure || i do understand that point-of-view however in that case we would need to update every public api that is non-void to have this annotation which seems counter-intuitiveanyways these are my 2 cents paging @mockito/core to give their opinion    || > \[\] in that case we would need to update every public api that is non-void to have this annotation \[\]well a single annotation in `package-infojava` takes care of that ([example]( :dbut indeed lets see how others feel about it || interesting discussion! heres how i would summarize the decision point: - a) benefit: a chance of making our customers code cleaner because they could identify and remove dead code - b) downside: hard to apply this strategy consistently we would have to review all public api and always remember to use those annotations when adding new apigiven that we already started using the annotations the downside b) already applies merging the pr does not make it any worse hence the downside can be discounted and we only have the benefit :)+1 im in favor of merging the prthank you @stephan202 for tracing the public api methods and coming up with the pr! || @timvdlippe the current `master`s last commit is e51a0515ac8440572cf1af80f7aa620d51e8075e but `git grep -i prone` doesnt show an error prone integration cant find another applicable branch using `git log -s prone -i  --all` either am i looking cross-eyed or? :) || ah my brain was derping i was working on #1339 and thought i merged it but i did not so we have to rebase after that pr is merged sorry for the confusion || no worries   i see #1339 also targets the `release/2x` branch so i wont need to switch the target branch for this pr(and indeed that pr contains a bunch of `@suppresswarnings(""checkreturnvalue"")` this pr will almost certainly force the addition of a bunch more of those)ive subscribed to the other pr and will rebase again once its  ";mockito should annotate when() methods with a custom annotation @checkreturnvalue;static code checkers like error-prone and findbugs will help detecting invalid usage of mockito in single-call situations if mockito source code were annotated with @checkreturnvaluesee:*     like for assertj any annotation with name should do no need to depend on a specific library with  @checkreturnvalue;that seems fine to me please submit a pull request    ||;1;0;add @checkreturnvalue to additional mockito methodsbuilds on #1130 #1228;
1272;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;strictness configurable per mock / stubbing;792;;1219.0;executorscheduler to wrap an executor;for issue #1219 (and #1206)this implementation should conform with the scheduler contract except it is not possible to avoid thread-hopping (dont worry the tasks execute serially but maybe not on the same physical thread)few open improvement possibilities:- usage of `mpsclinkedqueue` once available- a better performing subscription container for this kind of queue-drain task tracking instead of `compositesubscription`- ability to remove a `subscription` from a `compositesubscription` without it calling unsubscribe on the removed subscription á la `multipleassignmentsubscriptionset()`;#1170  thanks @akarnokd for this looks good for a first cut the trade-offs (thread hopping) are expected and why we wont use this as a default for anything and agreed on possible improvements but those can come later ||;new executorscheduler implementation;it turns out a lot of people used `executorscheduler` despite its problems (#711 & #713) we need to bring it back but in a way that is compliant with the contractthis will mean that each `worker` from the `executorscheduler` will need to maintain its own queue outside of the `executor` (similar to `observeon`) and then recurse on the `executor` only a single task per `worker` can be scheduled/enqueued on an `executor` and when it completes then it should recurse pulling items from the `worker` queue when the queue is empty it can stop processing when a new task is enqueued on the `worker` then it can schedule against for execution on the `executor`we will be working against the default behavior of the `executor` but need to do that to maintain the single-threaded contract of a `schedulerworker`;"@benjchristensen youve probably already investigated but does any of the quasar work help or the backported `forkjoin` for jre6? || my understanding of `forkjoin` is that it would still have the same need for us to manage a queue externally otherwise it will process the items on multiple threads concurrently if we put them into the `forkjoin` queue || @benjchristensen your rightso idea i have at present is you spawn a new `serialexecutor` for each worker - pass in a executor into the scheduler- create `worker()` this creates a `serialexecutor` that _sits on_ a thread from the passed in executor- process through all the actions blocking until the `worker()` completes- complete and return the thread back to the poolnot sure if that would actually solve the problem but from my understanding is that we always need to serially execute queued up actions on any one worker || that all sounds right except the ""blocking until the worker() completes"" part that would okay in quasar but not with native threads it will need to behave like `observeon` where it releases the thread (think of it as an event loop) and then reschedules back on a thread the next time it receives an `onnext`see observeon here:  || @benjchristensen yeah ok that makes sensei still think it should be noted that people should try to avoid `executors` where possible it should be a ""when you really have too"" || i guess we need to make sure executing a tasks by the same worker shouldnt hop threads right? i see a few problems:- generally threads can die from executing non rxjava tasks and get replaced by fresh threads so thread ""hopping"" is more likely to occur than with the standard schedulers- since most executors use a single work queue work might be dequeued by any of the threads even if a work item can tell where it should run one would need some mechanism to toss the work over to the target thread at which point task reordering can happen   - maybe a write-cursor and read-cursor pairs may help plus each worker thread needs dedicated queue with every instance of schedulerworker assigned to it these queues may then be processed round-robin  - even if this worker thread affinity is established one would need constantly running tasks that poll these queues or blocking ones that get unblocked by yet another queue since we dont know how many threads there are in the executor it becomes difficult to schedule such processing routines if necessary and even so they will block out other tasks submitted from elsewhere to the same executorbottom line is in my opinion that there arent any good ways to ensure worker affinity on an executor whose internal threads and queueing we cant control || as far as i am concerned the needs i have is:- i have to serialize all my bluetooth low energy communications on android and requests can come from multiple threads id like my observables to be scheduled one after the other- in [cgeo]( i do not want more than 5 (or 10) concurrent  download connections from android as i download large images and the memory pressure will be too high if i download more of them at the same timeis there a way to achieve those two goals easily without an executor? || @samueltardieu this high jacks the issue somewhat but the `computation` scheduler only runs as many concurrent threads as there are cores on the device (2-4) for most android devicesthe whole point of the new schedulers is that they execute in order which executors are not guaranteed to doi would use either an io or trampoline scheduler for your btle comms (also remember to bind the `observable` if youre passing it off to the ui thread @mattias provided that one) as for  either use computation scheduler or your own scheduler we solved the problem in retrofit by using the executor in the `onsubscribe()` method see [rxsupport]( || there have been a few prs proposing a scheduler with  thread count and another with thread-caching support the latter can be extended to put an upper limit on the active thread count if necessary but unfortunately these efforts are blocked on the enhancement quest to add load-balancing to the base computation scheduler and the usual concerns about api size and features to expose ive been fiddling with an idea for some time to ask for a contrib-experimental module where all these ""outcasts"" and other stuff may be put || @akarnokd i quite like that idea keep the main lib lean im sure a _contrib-concurrency_ would not be overkilli mean i always use proguard so bloat isnt so much of an issue for me but its great you guys are thinking about it || all interested in this please try out the new implementation via `schedulersnewexecutor` as implemented by @akarnokd in   || should we rename `schedulersnewexecutor` to something else? reason im asking is that it doesnt actually create a new `executor` like `newthread` does it is a new `scheduler` around a given `executor` perhaps it is instead `schedulersfromexecutor(executor e)` or just `schedulersexecutor(executor e)`? || i like `schedulersfrom(executor e)` || @headinthebox +1 very consistent! || i believe this is done so closing out  || -keep class rxinternalutil*\* { * } add it in proguard to resolve few problems || ";1;0;executorscheduler to wrap an executor;
1272;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;strictness configurable per mock / stubbing;792;;1206.0;executorscheduler to wrap an executor;for issue #1219 (and #1206)this implementation should conform with the scheduler contract except it is not possible to avoid thread-hopping (dont worry the tasks execute serially but maybe not on the same physical thread)few open improvement possibilities:- usage of `mpsclinkedqueue` once available- a better performing subscription container for this kind of queue-drain task tracking instead of `compositesubscription`- ability to remove a `subscription` from a `compositesubscription` without it calling unsubscribe on the removed subscription á la `multipleassignmentsubscriptionset()`;#1170  thanks @akarnokd for this looks good for a first cut the trade-offs (thread hopping) are expected and why we wont use this as a default for anything and agreed on possible improvements but those can come later ||;what should i use for thread pool execution in new api?;what should i use for thread pool execution in new api?for example all  request in android recommended to be executed on cached thread pool;take a look at  and  item of interest is  || @lexer please try out the implemented just merged in @1272 and let us know if it gives you what you needwe are also still going to proceed with an improved io scheduler as per  || the `schedulersio()` scheduler will now cache threads again due to the work in #1140 there is also a new `executorscheduler`  that you can access using `schedulersfrom(executor)` ||;1;0;executorscheduler to wrap an executor;
1272;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;strictness configurable per mock / stubbing;792;;792.0;strictness configurable per mock / stubbing;"792today we have strict stubs feature a key enabler for cleaner tests and improved debuggability strict stubs dont work well with ""common stubbing"" pattern they also dont like when we call stubbed methods with unexpected arguments - even though sometimes it is legit for more see #792 ### solution```java@test public void demo() {  //1 ""lenient()"" method on mocksettings interface:  foo mock  mockitomock(fooclass withsettings()lenient())  //2 ""lenient()"" method on mockito class:  mockitolenient()when(mockfoo(1))thenreturn(1)  mockitolenient()doreturn(1)when(mock)foo(1)}```for more see #792### public api changes- new methods:   - mockito#lenient()   - mocksettings#lenient()   - mockcreationsettings#islenient()   - stubbing#getstrictness()  - new interfaces:   - basestubber - extracted out from existing ""stubber"" interface so that we can reuse api with ""lenientstubber""   - lenientstubber - instance returned by ""mockitolenient()""- other changes:   - made @orgmockitonotextensible annotation public so that we can use it in subpackages"; merging 1272 ;new lenient() strictness setting available at mock and at stubbing level;"## problemsoverview of strictness: #7691 it is not possible to have any common stubbing when using strictnessstrict_stubs strict stubs is very useful and it is most likely the future default for mockito 3 common stubbing typically is a part of ""before"" method or a test utility class that generates mocks```javapublic mockitorule rule  mockitojunitrule()strictness(strictnessstrict_stubs)@before public void before() {  //a) common stubbing needed for most test methods  when(mockfoo())thenreturn(""bar"")  }```2 api caveats:```java@test public void demo() {  //b) not possible to stub the same method using when with different args:  when(mockfoo(1))thenreturn(1)  when(mockfoo(2))thenreturn(2) // <- will throw potentialstubbingproblem  //c) code under test cannot use stubbed call with different argument (sometimes we need it)  when(mockfoo(1))thenreturn(1)  mockfoo(2) // <- will throw potentialstubbingproblem whether we need it or not}```## suggested solutionnew public api overview:```java@test public void demo() {  //1 new method on mocksettings interface:  foo mock  mockitomock(fooclass withsettings()lenient())  //2 new method on mockito class:  mockitolenient()when(mockfoo(1))thenreturn(1)  mockitolenient()doreturn(1)when(mock)foo(1)}```details: - why 2 new public methods? sometimes common stubbing has a form of one or few stubbings in ""before"" method - its best to configure leniency per stubbing sometimes a mock object has many common stubbings (described in detail in the ticket thread below) - its best to configure leniency per mock## examples1 common stubbing```javapublic mockitorule rule  mockitojunitrule()strictness(strictnessstrict_stubs)@mock(lenient  true) foo mock@before public void before() {  //a) common stubbing needed for most test methods  when(mockfoo())thenreturn(""bar"")  }```2 api caveats:```java@test public void demo() {  //b) not possible to stub the same method using when with different args:  lenient()when(mockfoo(1))thenreturn(1)  when(mockfoo(2))thenreturn(2) // <- works!  //c) code under test cannot use stubbed call with different argument (sometimes we need it)  lenient()when(mockfoo(1))thenreturn(1)  mockfoo(2) // <- works!}```## original reportthe new unnecessarystubbingexception logic is great however it is sometimes useful to disable this detection for specific methods could it be possible to add an annotation that says ""unnecessary stubs should not be detected in this method""?this would also make it easier to migrate from mockito 1* to mockito 2 this is the case in the project i am currently working at where we have created some utility methods that creates a mock and configures it to fit most of our use cases as we use this method at many places where different configuration is needed it will cause a lot of unnecessary stubbing thus we would like to keep this method out of unneccessary stubbing-check while doing this check on the rest of the code base";"thank you very much for this feedback!do you use the silent junit runner currently to avoid the exception in your scenario?your feedback and recent code review from @bric3 made me think about enabling/disabling stubbing strictness per method or per class using annotations for example (brainstorming):```java@mockito(strictstubs  true)public class sometest {  @test  @mockito(strictstubs  false)  public void sometestmethod() {  }}``` || thanks for following up on this!yes we currently use the silent runner which works fine but of course lacks the stubbing checking that we would like to have on the rest of the methodsannotations for this sounds to me like a good solution to the problem it would be really great if this annotation could also be used on helper methods such as in our scenario:```@mockito(strictstubs  true)public class sometest {@testpublic void sometestmethod() {    code code  createcode(""a"")}@mockito(strictstubsfalse) private code createcode(string codetype) {    code code  mock(codeclass)    doreturn(codetype)when(code)getcodetype() // not always but in most cases invoked }}``` || thanks for the suggestions! my feedback / questions:1 is there a reason why you use the runner and not mockito junit rule?2 the annotation api would not work on the helper methods only on the test methods its because the rule only captures and provides the test method to the implementation || thanks for your feedback!1 no not really we have not really looked at the difference nor taken a conscious choice on this2 oh i see that means that it would be hard to use annotations to do this the way i was hoping was possible ideally it would be great if we could enable unnecessary stubbing in general but configure it so a developer could call the createcode method without having to mind the unnecessary stubbing here or perhaps by setting some properties on the junitrunner? so that createcode could be something like    ```java    private code createcode(string codetype) {       junitrunnerdisable_stubbing_check()       code code  mock(codeclass)       doreturn(codetype)when(code)getcodetype() // not always but in most cases invoked       junitrunnerenable_stubbing_check()    }    ```i am not that into the mockito codebase but i would guess that this could require quite some rewrite? (and it also indicates that our usage of helper methods are probably not a smart path to follow) || my point on helper method or helper object for mocks is usually that the model shows mock anti pattern or that the granularity of the test is not narrow enough usually that means that a concrete object should be **built** instead not a mockthe idea may be intersting though probably not in mockito 2 in mockito 3 (jdk8) maybe we could introduce apis like this :```javamockitoruleinconfiguration()                     strictness(strictnesslenient)                     stub(() -> {                            doreturn(codetype)when(code)getcodetype() // possible stub                           //                      })```_the above snippet is mostly exploring idea for this kind of api as i dont have these kind of needs at this time it may be just wrong in many aspects_ || see #840 - i created a proposal for solving this use case for junit rules || as an alternative solution could you use the mocksettings? eg something like ```code code  mock(codeclass withsettings()nounnecssarystubbing())``` || i also found a use case:im mocking zk which uses a lot of map-like structures which are exposed via accessors (`getattributes()` `getattribute(string)` `getattribute(string boolean)` `setattribute()` )in my test setup i create a map and im using `thenanswer()` and `doanswer()` to link the accessor methods to my test map the code then looks like this:```    private map<string object> desktopattributes  new linkedhashmap<>()            desktopattributesput(attr_event_queues desktopeventqueues)            mockdesktop desktop  mock(mockdesktopclass)            when(desktopgetattributes())thenreturn(desktopattributes)            when(desktopgetattribute(argumentmatchersanystring()))            thenanswer(answer -> {                string name  answergetargument(0)                object value  desktopattributesget(name)                return value            })            when(desktopgetattribute(argumentmatchersanystring() mockitoanyboolean()))            thenanswer(answer -> {                string name  answergetargument(0)                object value  desktopattributesget(name)                return value            })            doanswer(answer -> {                string name  answergetargument(0)                object value  answergetargument(1)                desktopattributesput(name value)                return null            })when(desktop)setattribute(mockitoanystring() mockitoany())            doanswer(answer -> {                string name  answergetargument(0)                object value  answergetargument(1)                desktopattributesput(name value)                return null            })when(desktop)setattribute(mockitoanystring() mockitoany() mockitoanyboolean())            when(desktophasattribute(mockitoanystring()))            thenanswer(answer -> {                string name  answergetargument(0)                return desktopattributescontainskey(name)            })            when(desktophasattribute(mockitoanystring() mockitoanyboolean()))            thenanswer(answer -> {                string name  answergetargument(0)                return desktopattributescontainskey(name)            })```i need this code block three times (desktop attribute map session attributes servlet context attributes) i prefer mocking over mock objects since the interfaces have hundreds of methodsi have put this code into a shared junit rule its lazy but its also generic: since the rule doesnt know what parts of zk the test will call it cant tell which accessor methods will be needed but i still need to know when a method is called which wasnt mockedtherefore i need a way to tell mockito ""there might be unused stubs in the following code block but thats ok since its shared by many tests"" an annotation on the test wont work since the code is in a junit rule i could pass the mockitorule to my rule so this approach would work:    mockitorulelenientstubbing(() -> {  }) || @digulla thank you for reporting! some feedback:- the code looks really hard to read (many lines of mock interactions) i suggest to rethink testing strategy refactor the code under test so that it is easier to test or roll out hand mocks- given above we cannot consider it as a legit use case we want to avoid implementing features / api for code that should be cleaned up / refactored for simplicity and testability- given that #840 solves this use case (strictness method on the rule object) im closing this ticketah it was interesting to refresh my memory about this ticket :) hope that helps! || @mockitoguy  sorry that doesnt help at allwith ~200k on stackoverflow that was the most simple solution i could come up with youre welcome to show me a better solutionthe testing strategy is sound it doesnt break easily or unexpectedly and is easy to understand for new members of the team i could copy only the necessary lines to new tests but that would mean i would be the only one who can write new tests also: violates dryrefactoring is not possible zk is a ui framework with a huge code base and many projects use it asking to change the api is like asking to ""fix"" the java collections api: understandable maybe even reasonable but unrealistichand mocks would mean i would have to write about a lot of useless code which violates your own rule to keep tests simpleso im between a rock and a hard place: youre right for open source projects which no one uses or green field commercial projects for existing commercial projects that i cant move its not helpful they have ugly and unmodifiable apis so i have to move the only place where i have influence: thats the testsso for now i have to disable a good feature of mockito and can no longer make sure that my tests stay clean that really sucks || thank you for describing your context! let me think about this and ill get back || i guess my use case is ""im writing a mocking framework for some commercial api which helps other developers to write tests"" that means ill always overmock in my case i have to mock several map-like apis which are exposed in several beans without a common interface (just like the attribute maps in j2ee servletcontext and servletrequest and the headers in servletresponse) || @digulla that pretty much matches my use case too imho a good solution would be to be able to specify ‘silent’ at mocked object level rather that the test class level  || i like the idea of adding new public api for this use case@digulla with my earlier reply i did not intend to depreciate your efforts in getting clean tests for your entire team it’s great that you’re pushing for this!the use case you describe could be solved more cleanly with hand stubs sometimes simpler code is actually more code :) what do you think about this idea: - noop implementation of the 3rd party interface generated automatically with ide cheap to maintain regardless of amount of methods because they are all noop low to zero cognitive overhead for the team - hand stub implementation extends the noop implementation tailored for what exactly the tests needcoming back to mockito for this use case i bet that our users would disable strictness per entire test rather than build hand stubs (even if hand stubs would be a better solution) disabling strictness per entire test nullifies strictness benefits to provide best dev experience mockito should honor this use case and offer a better apithere are 2 main alternatives:1) strictness per mock as suggested```javamock(fooclass withsettings()strictness(strictnesslenient))mock(fooclass withsettings()lenient()) //alias```2) strictness per stubbing for example:```javalenient()when(mockfoo())thenreturn(“boo”)lenient()doreturn(“boo”)when(mock)foo()```any feedback?thank you guys for feedback and for pushing us to reconsider were trying to keep mockito api slim and avoid solving use cases better solved by refactoring / cleanup the code || i did wonder about something like ```@mock (strictness strictnesslenient) private foo mockfoo```as well but i wonder if that syntax would over-encourage people to use the feature ime i think the sort of test frameworks fixtures etc where i see this to be most useful probably use the mock(fooclass) mechanism for instantiating mocks  || @mockitoguy >there are 2 main alternatives:i see a third one as discussed in the junit 5 pr (#1221) and the [mockito google group]( i would like to propose an annotation base approach that can be applied also at test-class and test-method level this keeps the api consistent and slim (at least when junit5 is used)```@mock@strictness(lenient)foo mock``` || @christianschwarz youre right! sorry for discounting the annotation option || i plan to tidy up this ticket in the next few days so that it documents the use case the implementation options and the desired implementation@christianschwarz strictness per method is not an ideal solution for the use case described in this ticket: 1 every time someone uses shared stub object he needs to remember to use lenient strictness on the method level 2 method level strictness turns off useful stubbing validation for all mocks in the method rather than only for the mocks that really need it 3 it does not communicate the intent well the reader of the test method does not know why lenient strictness is needed for method this also can lead to cargo culting - developer copy paste-ing test methods along with strictness setting without known why they need iti must admit that the @strictness annotation does look handsome in the test :)what do you think about option 1 and 2? do we want to implement both? perhaps we start with mock level annotation for now it solves the use case very well and is not very controversial || @mockitoguy > @christianschwarz strictness per method is not an ideal solution for the use case described in this ticket:thats why i proposed to use the `@strictness` annotation at field level for this use-case too the `@strictness` annotation at field level would also fit into the annotation proposal for junit5  this in return would lead to a clean single api where strictness is defined at field method and class level the same way using `@strictness`> what do you think about option 1 and 2? i would prefer option 1 cause: * it feels consistent with other mock setting configurations * it allows to implement the annotation based proposal too * option 2 would add an other alias like api for stubbing thats uncool>do we want to implement both? option1 + `@strictness` ? yes!>perhaps we start with mock level annotation for now it solves the use case very well and is not very controversial`@mock` + `@strictness()`  or `@mock(strictness)` ? i would opt for `@strictness()`  cause it allows more uses cases || >thats why i proposed to use the @strictness annotation at field level for this use-case toothats fair!lets discuss the 2 contention points:1 it is awkward that some mock properties are configured as parameter of the existing @mock annotation while some other (strictness) is a standalone annotation2 we need to support strictness at mock level via imperative api eg ""withsettings()lenient()"" method (or something like that) this is one of our principles of api development (which we should document :) annotations are ""syntax sugar"" - all mockito features are available via imperative api given that we implement ""withsettings()lenient()"" why do we need @strictness annotation at all? im pushing on this because the only thing better than clean api is clean and simple api the less methods annotations complexity - the better! || @mockitoguy  re ""hand stubbed"": that doesnt work since java doesnt allow multiple inheritance i just pasted a small part of the actual test setup my setup class can mock several aspects of the zk api: session and request attributes event queues view models injection what i end up with a mix of lenient and dedicated mockswith a hand stubbed approach i would have to copy a lot of code from test to test my goal is to have lenient mocks for unimportant parts like session attributes (code under test will complain when they are missing) but strict checking for things like events published (i really dont want to miss those)the test can then say ""hey wire up event publishing"" if they expect events without the setup any code using events will just crash with npe with the setup mockito should complain when no events related code was executed to keep the tests clean (to avoid devs doing copy&paste of code they dont understand)re annotations: i dont think that the annotations are a good solution here they are nice for code which needs to be migrated from old mockito but for new code they are too coarse for all my use caseson the other hand i dont like the idea of having to add `withsettings()lenient()` in many places it would be great if i could execute a bunch of stub calls in a single lenient code block if that was possible id opt for an annotation on the setup method which calls the `when()`/`doreturn()` but i dont think there is an easy way to implement this when the setup method is not inside the test class but in a junit `@rule` implementation || thank you for reply! im still interested in your use case hence my further questions>with a hand stubbed approach i would have to copy a lot of code from test to test why? hand stub implementation should have all the common reusable code in the test you can just call ""mocksetupeventpublishing()"" or something like that>on the other hand i dont like the idea of having to add withsettings()lenient() in many places it would be great if i could execute a bunch of stub calls in a single lenient code blockprovided that we add both: stubbing + mock level strictness setting then you have 2 options:1 only add ""withsettings()lenient()"" at mock creation time only for mocks that act as ""reusable business stubs"" (wasnt sure how to call them) when you write stubbings you dont specify ""lenient()""2 for other cases where you have a default stubbing reused in most of the test methods you declare the default stubbing using ""lenient()"" method at the stubbing levelthoughts? || @mockitoguy thanks i feel that i dont have a completely clear picture yet> hand stubso a base class with a lot of empty methods and then using spy() to overwrite them? that might work but i dont like spy() (had too many problems with that approach in the past)it still feels like more effort than simply wire some map methods to api methods using `answer`> 2 optionsoption #1 is too coarse for me with option #2 i would have to add 7 lines of code to the block in  and you were complaining that the code was already too complicated :-)thats why i suggested to have an ""enable some options for a code"" block approach in my case i could then wrap the call to the `setupdesktopattributes()` method with that || >so a base class with a lot of empty methods and then using spy() to overwrite them?hand stub/mock is a class that is completely tailored for the business of your tests sometimes referred as ""test fixture code"" ""test utils"" ""test support classes"" hand mocks dont use mockito not even spy() hand stub needs to be coded and maintained but it provides superior readability and usefulness because it is tailored to your domain>option #1 is too coarse for me with option #2 i would have to add 7 lines of code to the blockwe could potentially provide a method like:```javamockitolenient(() -> {  })```not sure about this though its a very different api than what we have so far per-mock + per-stubbing leniency feels like a happy medium: if repeated ""lenient()"" is a problem you can configure it per the entire mock per-mock is coarse grained but on the other hand it is conventional and simple big ""lenient"" block might lead to weird test code developers putting more code inside the block the intent of the code getting obscured || updated the description with the problem statement and proposed api changes feedback before we start coding? || update: work in progress in pr #1272friendly ping for review of the design outlined in this ticket description! || im pondering the two api designs: `mock( withsettings()lenient())` and `lenient()when()`i feel it would be better if the two were more similarwhy not `when( withsettings()lenient())`? that way the api would be more symmetric when adding more settings they would naturally flow into the existing code but it would be hard to add options only for `mock()` ( problems can only be discovered at runtime)what about  `mock()lenient()`? or `lenient()mock()`? that would be the opposite approach to make the two apis similar here the chaining pattern can make sure that you cant use options that are illegalalso this is shorter i feel `withsettings()` adds a lot of visual bloat || > im pondering the two api designs: mock( withsettings()lenient()) and lenient()when()i feel it would be better if the two were more similaryeah possibly we also want to have those new api methods consistent / similar with the existing api: - currently the way to configure mocks is: withsettings() or annotation - stubbing is inconsistent (when vs doreturn when vs given) due to the api evolution and java limitations there is no concept of configuring a ""stubbing"" in mockito api currently (assuming that declaring what happens when stubbed method is called is part of the stubbing and not an operation of ""configuring stubbing"")> why not ```when( withsettings()lenient())?```how would this play with doreturn syntax?> what about ```mock()lenient()?``` or ```lenient()mock()?```the former is not possible because ```mock()``` returns the type were mocking the latter is interesting problem is that it is inconsistent with how currently mocks are configured (withsettings())thank you for thoughtful feedback! || how about a fluent api to mock several methods of a mock at once? that way i could specify the lenient once at the top? || >how about a fluent api to mock several methods of a mock at once? that way i could specify the lenient once at the top?can you write a comment with an example how it would look? this would help us make a decision sorry for late answer xmas break :) i made progress on the ticket though! || im finalizing the implementation in #1272 it will be released within days || ";1;0;made documentation consistent;
1272;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;strictness configurable per mock / stubbing;792;;0;minor cleanup;;;;;;1;1;replace instanceof with checktype in hive connector;
1272;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;strictness configurable per mock / stubbing;792;;0;npe in joiner;dpar@ joineron()usefornull("""")join(nullnullnull) will fail with a npe because of  one more or one fewer null will succeed"; _issue #1672 has been merged into this issue_ || ";;;;0;1;;
1280;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;update strict_stubs documentation for verifynomoreinteractions;1086;;0;classpath throws npe for classpathfrom(objectclassgetclassloader())getresources()); i dont know what the correct behavior should be but im pretty sure a npe is not the right one;benyu@ sorry i meant to say ""classpath isnt designed to return bootstrap types"" because use cases we have so far dont need to enumerate through built-in types || ";;;;0;1;;
1280;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;update strict_stubs documentation for verifynomoreinteractions;1086;;0;error code improvements;;;;;;1;1;add validation to errorcode;
1280;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;update strict_stubs documentation for verifynomoreinteractions;1086;;0;unbounded buffer for time gap issue;"to solve the ""time gap"" issue (#844) we have accepted having an unbounded buffer:  is a preferable tradeoff to non-deterministic data loss and easier to explain to people it can however kill a system if a `groupedobservable` is filtered/skipped and emits a large amount of data to itwe need a mechanism such as:- auto-unsubscribe if more than n elements are emitted and its not consumed (nuanced so probably not wanted)- emit an error if more than n elements are emitted and not consumed (clear and forces the developer to do something about it)likely the contract needs to be that when using `groupby` every `groupedobservable` needs to be subscribed to even if its with `take(0)` to signal that group is being purposefully ignored this would apply anywhere this use case occurs";"am i right that this means the explanation at now unnecessary/inaccurate?(""note that when groupby( ) or groupbyuntil( ) splits up the sourceobservable into an observable that emits observables it begins to emititems from the source observable onto these emitted observablesimmediately that is to say it does not wait for any subscribers tosubscribe so if you want to ensure that you see all of the items that areemitted on these new observables you should take care to subscribe to themright away"")on thu may 29 2014 at 9:41 am ben christensen notifications@githubcomwrote:> to solve the ""time gap"" issue (#844>  we have accepted having> an unbounded buffer:>  > this is a preferable tradeoff to non-deterministic data loss and easier to> explain to people it can however kill a system if a groupedobservable is> filtered/skipped and emits a large amount of data to it> > we need a mechanism such as:> - auto-unsubscribe if more than n elements are emitted and its not>   consumed (nuanced so probably not wanted)> - emit an error if more than n elements are emitted and not consumed>   (clear and forces the developer to do something about it)> > likely the contract needs to be that when using groupby every> groupedobservable needs to be subscribed to even if its with take(0) to> signal that group is being purposefully ignored this would apply anywhere> this use case occurs> > —> reply to this email directly or view it on github>  david m grossplp consulting || yes its now inaccurate i think we should clearly define in the `groupby` (and friends) javadoc and wiki that every `groupedobservable` must be subscribed to though that doesnt mean invoking `subscribe` literally but that filtering them out will result in memory leaks and that each `groupedobservable` needs something done to it even if its `take(0)` || i like the `take(0)` idea better than dropping stuff on the floor (which you can never recover) || new explanation from wiki:""note that when groupby( ) or groupbyuntil( ) splits up the sourceobservable into an observable that emits groupedobservables each of thesegroupedobservables begins to buffer the items that it will emit uponsubscription for this reason if you ignore any of thesegroupedobservables (you neither subscribe to it or apply an operator to itthat subscribes to it) this buffer will present a potential memory leakfor this reason rather than ignoring a groupedobservable that you have nointerest in observing you should instead apply an operator like take(0) toit as a way of signalling to it that it may discard its buffer""and from the javadocs:``` * <em>note:</em> a {@link groupedobservable} will cache the items it```is to emit until such time as it     \* is subscribed to for this reason in order to avoid memory leaksyou should not simply ignore those     \* {@code groupedobservable}s that do not concern you instead you cansignal to them that they may     \* discard their buffers by applying an operator like {@link#take}{@code (0)} to themon thu may 29 2014 at 10:59 am headinthebox notifications@githubcomwrote:> i like the take(0) idea better than dropping stuff on the floor (which> you can never recover)> > —> reply to this email directly or view it on github>  david m grossplp consulting || i like those javadoc changes i see its already been added to the code (thanks @davidmgross!) so im closing this outbackpressure changes do not affect this as backpressure would only be able to stop the entire source stream not an individual child || ";;;;0;1;;
1280;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;update strict_stubs documentation for verifynomoreinteractions;1086;;108.0;update strict_stubs documentation for verifynomoreinteractions;1086; ;clarify spy vs mock calls_real_methods;id suggest adding a comment or side note in `[@injectmocks]( to explain that when you want to inject real instances (and not mocks) you have the choice (unless im mistaken) between `[@spy]( and `[@mock(answer  calls_real_methods)]( but the former is preferable because;injecting real instances is not supported by the current injection mechanism the things you mentioned are barely tricks so instead of promoting tricks it would make more sense to support real type injectionalso i find `@mock(answer  calls_real_methods)` to be somewhat bad practice i dont think we should expose that || its useful when di are not possible || which doesnt mean its a not a trick usually it means the production and/or test code need a serous refactoring and if its an external type that cannot be refactored then the following principle apply _dont mock types you dont own!_anyway im totally against exposing this bad practice in the doc as we want to develop a better code for our peers for the next one working on the matter ||;1;0;update strict_stubs documentation for verifynomoreinteractions1086;
1281;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;replace bibtexentryassert by overwriting bibentry.equals method;as proposed in #625 a proper bibentry.equals is provided in this pr and used for the tests.   this as a few advantages: - detect differences which are not visible in the canonical string representation (so far this hit empty fields and different line breaks) - get more meaningful test-failure messages for lists (instead of  expected 2 got 3  the added entry is displayed) - assert.assertequals just works and no custom written assertequals method has to be used  i clicked around a bit  but couldn t find any unexpected side effects due to the overwritten equals method.   if this pr is accepted  then i would inline the bibtexentryassert.assertequals methods. -   -   -   ();;0;fix verificationwithtimout javadoc comment;as opposed to verificationafterdelay verificationwithtimout doesnt support never(); ;;;;1;1;fix verificationwithtimout javadoc commentas opposed to verificationafterdelay verificationwithtimout doesnt support never();
1281;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;replace bibtexentryassert by overwriting bibentry.equals method;as proposed in #625 a proper bibentry.equals is provided in this pr and used for the tests.   this as a few advantages: - detect differences which are not visible in the canonical string representation (so far this hit empty fields and different line breaks) - get more meaningful test-failure messages for lists (instead of  expected 2 got 3  the added entry is displayed) - assert.assertequals just works and no custom written assertequals method has to be used  i clicked around a bit  but couldn t find any unexpected side effects due to the overwritten equals method.   if this pr is accepted  then i would inline the bibtexentryassert.assertequals methods. -   -   -   ();;0;finish properly parameterizing tupledomain;;;;;;1;1;finish properly parameterizing tupledomain;
1281;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;replace bibtexentryassert by overwriting bibentry.equals method;as proposed in #625 a proper bibentry.equals is provided in this pr and used for the tests.   this as a few advantages: - detect differences which are not visible in the canonical string representation (so far this hit empty fields and different line breaks) - get more meaningful test-failure messages for lists (instead of  expected 2 got 3  the added entry is displayed) - assert.assertequals just works and no custom written assertequals method has to be used  i clicked around a bit  but couldn t find any unexpected side effects due to the overwritten equals method.   if this pr is accepted  then i would inline the bibtexentryassert.assertequals methods. -   -   -   ();;0;reduce subscription object allocation;### changes- rewrite of `compositesubscription` and added `chainedsubscription`- significant reduction in object allocations- details on research available at  atomic state machine -> mutation & locksthe `compositesubscription` implementation was changed from using an atomic state machine to using locks the state machine requires immutable `state` that is swapped using cas this means an object allocation is needed each timeit now uses locks to protect mutable state so very few objects are created##### chainedsubscriptionthe `compositesubscription` requires support of randomly removing a `subscription` via the `remove` method the `subscriber` type does not expose this so can be optimized there is now a `chainedsubscription` that is used  subscriber` instead this allows using a `linkedlist` or `arraylist` rather than `hashset` as random access is never needed this provides a slight performance boost and reduces memory usage (1 minute test shows 165gb allocation for `composite` versus 144gc for `chained`)### allocation comparisonthis shows java flight recorder output from master without these changes:![master-without-changing-compositesubscription]( shows object allocation after changing `compositesubscription`:![master-with-new-compositesubscription ong]( throughput comparisontesting this code:``` java    public void maptransformation(usecaseinput input) throws interruptedexception {        inputobservablemap(i -> {            return stringvalueof(i)        })map(i -> {            return integerparseint(i)        })subscribe(inputobserver)        inputawaitcompletion()    }```##### rx 0161```run: 10 - 2879355 ops/sec run: 11 - 3236245 ops/sec run: 12 - 4468275 ops/sec run: 13 - 3237293 ops/sec run: 14 - 4683840 ops/sec ```##### rx 0176 - using onsubscribefunc```run: 10 - 3621876 ops/sec run: 11 - 6702412 ops/sec run: 12 - 7401924 ops/sec run: 13 - 6653359 ops/sec run: 14 - 5834305 ops/sec ```##### rx 0176 - using onsubscribe```run: 10 - 3320053 ops/sec run: 11 - 4520795 ops/sec run: 12 - 7107320 ops/sec run: 13 - 5089058 ops/sec run: 14 - 5534034 ops/sec run: 10 - 4930966 ops/sec run: 11 - 6119951 ops/sec run: 12 - 7062146 ops/sec run: 13 - 6514657 ops/sec run: 14 - 6369426 ops/sec ```##### rx 0183 - using onsubscribe```run: 10 - 4178854 ops/sec run: 11 - 4446420 ops/sec run: 12 - 5458515 ops/sec run: 13 - 8006405 ops/sec run: 14 - 7849293 ops/sec run: 10 - 4145936 ops/sec run: 11 - 6553079 ops/sec run: 12 - 7645259 ops/sec run: 13 - 7385524 ops/sec run: 14 - 7830853 ops/sec ```##### rx 019 master - compositesubscription state machine```run: 10 - 10576302 ops/sec run: 11 - 10518786 ops/sec run: 12 - 10554646 ops/sec run: 13 - 10314063 ops/sec run: 14 - 10666439 ops/sec ```##### rx 019 master - compositesubscription with synchronized hashset```run: 10 - 9949060 ops/sec run: 11 - 10122379 ops/sec run: 12 - 10018032 ops/sec run: 13 - 10072522 ops/sec run: 14 - 10132636 ops/sec ```##### rx 019 master - chainedsubscription with synchronized arraylist```run: 10 - 11086351 ops/sec run: 11 - 10932426 ops/sec run: 12 - 11002431 ops/sec run: 13 - 10888620 ops/sec run: 14 - 11157227 ops/sec run: 10 - 9371192 ops/sec run: 11 - 9829169 ops/sec run: 12 - 10139005 ops/sec run: 13 - 10099785 ops/sec run: 14 - 10017631 ops/sec ```##### rx 019 master - chainedsubscription with synchronized linkedlist```run: 10 - 10619431 ops/sec run: 11 - 11063293 ops/sec run: 12 - 11001463 ops/sec run: 13 - 11054243 ops/sec run: 14 - 10898826 ops/sec run: 10 - 10075465 ops/sec run: 11 - 9780716 ops/sec run: 12 - 9885134 ops/sec run: 13 - 9584143 ops/sec run: 14 - 10000700 ops/sec ```;grrr some unit tests are failing   ||  the failing unit tests  silly mistake thanks @akarnokd for getting involved in thisi agree we can further optimize this for example i think we should look at the data structure from  || anyone have a better name than `chainedsubscription` before this gets released and is permanent forever? || `subscriptionlist` and `subscriptionset` perhaps || i like `subscriptionset` || do you have a different take on how to solve #1204 based on the findings ive posted there? || what the difference with `compositesubscription`? || for immediate results using plain set and list based composites is okay we need to recheck the operators and use the appropriate one for the schedulers an mpsc-based queue still creates a lot of garbage my subscriptionqueue based on a ringbuffer avoids this issue at the expense of synchronization instead of atomics for even less allocation on the new composites we would need to implement a more light-weight hashset (eg a linear probing hashset although we would lose the benefits from the java 8 hashmap enhancements) || #1179  aside from the extra dependency disruptor seems like it would be a pretty decent model for the subscriptionqueue it would be interesting to see if itd perform well non-contending cases vs the mpsc queue || disruptors ringbuffer is bounded so youd need to either set it to a decent size or parametrize the schedulers in addition it is prone to deadlock because the reader may put new tasks into the queue in case of a recursive schedule || > for even less allocation on the new composites we would need to implement a more light-weight hashset agreed if we can come up with one that is better >  for the schedulers an mpsc-based queue still creates a lot of garbage my subscriptionqueue based on a ringbuffer avoids this issue at the expense of synchronization instead of atomicsyes i want to get those changes pulled in before we release> for immediate results using plain set and list based composites is okaywe can evaluate the mpsc queue to replace these before releasing> we need to recheck the operators and use the appropriate oneyes i only migrated the ones that directly injected a `compositesubscription` into `subscriber` || talking with @headinthebox he was wondering if we should remove the `remove`/`clear` methods from `compositesubcription` and leave that the default and have a more specific implementation for the few places needing `remove` functionality im averse to a breaking change of that kind even though were pre-10 as were so late in the game that breaking changes are really painfulwhat do you think? anyone else have an opinion on this?the two signatures are:``` javasubscriptiona { public synchronized boolean isunsubscribed() public void add(final subscription s) public void remove(final subscription s) public void clear() public void unsubscribe()}`````` javasubscriptionb { public synchronized boolean isunsubscribed() public void add(final subscription s) public void unsubscribe()}```the `subscriptionb` signature is the one most people probably need when they think of `compositesubscription` || #1180 #1181 looks good || i never used `clear` and cant see a need for it what i usually need is a `remove` variant that doesnt unsubscribe the subscription removed usually this comes into play when a scheduled action is finished and needs to remove itself from the tracking composite or a multi-stage scheduling happens || wouldnt the only use case subscriptionb be for an entirely linear observable chain (does not use merge zip groupby )? || > wouldnt the only use case subscriptionb be for which is almost all the time the `merge` operator for example will `add` a `subscriptiona` to the `subscriptionb` this way the right data structure is used in the right places || should we deprecate `remove()` and `clear()` on `compositesubscription` in 018x and leave something else to have the `remove` capability? || merging  then we can bike shed over naming before releasing 019 || @akarnokd there are several things as discussed above that we can improve here lets pick them up in separate pull requests and coordinate them with  ||;;;;1;1;reduce subscription object allocation- significant reduction in object allocations- details on research available at https://githubcom/netflix/rxjava/issues/1204;
1282;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1271: authors with compound first names are parsed properly;-   -   -   ();;0;@beta should accept a description;simonbr@ it would be useful for example to declare : @﻿beta(""since v34"")"; finish the quote from the @﻿beta documentation: ""it is generally safe for applications to depend on beta apis at the cost of some extra work during upgrades however it is generally inadvisable for libraries (which get included on users classpaths outside the library developers control) to do so""> what could these code analyzers want to do with this information> of the three examples youve listed only the second one needs any information about when the @﻿beta tag was added  but frankly we tend not to care about how long something has been in @﻿beta as much as how comfortable we feel with its api || ";;;;0;1;;
1282;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1271: authors with compound first names are parsed properly;-   -   -   ();;0;extra test case javadoc update;"lets keep adding test cases to ensure great coverage of the entire behavioralso updated documentation so that we consistently use the ""lenient"" vocabularystumbled upon it when working on #1272   ";is this intended to be merged before or after #1272? ||   >is this intended to be merged before or after #1272?yes to keep #1272 smaller i will be posting unrelated improvements in separate prs || @timvdlippe ok to merge? || thanks! merging ||;;;;1;1;updated documentationinformed that silent mode is effectively lenient strictnessstumbled on it when working on #1272;
1282;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1271: authors with compound first names are parsed properly;-   -   -   ();;0;http500;;see comments but ;;;;1;1;suppress exceptions closing record reader when handling an exception;
1282;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1271: authors with compound first names are parsed properly;-   -   -   ();;1199.0;utility function for creating observables for closeable resources;#1199 the answer to the issue was nagging at me when i tried to recommend it recently  i think @zsxwings solution was ok but would fail if there were repeated subscriptions to the observable returned  i created a utility function on stringobservable to make it easier to use `using()` for objects that implement the `autocloseable` interfaceps i made a breaking change to arguments of `join(observable<object>)` to `join(observable<string>)` and added a `observable<string> tostring(observable<object>)` to make up for itpps i made a `unsafefunc0<r>` scoped to this class but i would like to have `unsafefunc<n>` in the rxfunctions packages and have `func<n>` extends `unsafefunc<n>`   makes it clear to the compiler that we dont expect the code the users are giving us to always work this also helps the users because they dont have to always fill their closures with try catch blocks```() -> new filereader(file)```vs```() -> {    try {        return new filereader(file)    } catch (exception e) {        throw new runtimeexception(e)    }}```;#1182  #1186 can someone else involved in `stringobservable` review this please?also this needs to be rebased now as it collides with another change that was  #1191 whoops bad merge || [rxjava-pull-requests #1192 looks good || @davidmoten can you take a look? || yep will do || i see your point about the advantage when writing lambdas could you equivalently have a utility function that wrapped the lambda to do the wrapping with a runtimeexception as in:```toruntimeexception( () -> new filereader(file))```if it works you might get your code brevity back without your changes being necessary || ah i just looked up java 8 lambdas and checked exceptions and i see my suggestion has no legs || righto so ive tested the handling of lambdas and checked exceptions in java 8 and i can see this is a handy utility its a really interesting idea to then extend funcn from unsafefuncn and i can see this would work the more extreme implementation would be to add `throws exception` to the definition of funcn perhaps the enforced try catch in writing operators that call funcn will be worth the abbreviation for rxjava users what would steer us away from this?my only concern then is really the name because funcs are inherently unsafe as there is nothing in the contract for a func that says it cant throw a runtimeexception or error the alternative is something yuk like funccanthrowcheckedexception || how about checkedfunc?  i agree that i would like to see checkedfunc used in core where ever an runtimeexception from a func is caught and pushed down to onerror  the reasoning is that if the implementation is already wrapping calls with a try/catch then let the func throw whatever it wants || do you see an impediment to changing the signature of funcn to include throws exception? || adding to funcn directly would be too much  it forces operator implementations to always wrap exceptions even if they dont care about propagating runtimeexceptions up the call stack || theres the tradeoff i suppose between operator implentations and users using java 8 lambdas with rx operators and catching exceptions in theory thered be more of the latter right? || im thinking about `observablemap()` in particular and the plethora of java methods that throw checked exceptions would be nice to make lambda usage cleaner || the map operator explicit does a try catch around the func1 call so that would be a candidate for switching to checkedfunc1 || if we did map() id be tempted to do it everywhere might have to do an inventory of where func is used in the operators ||;rxjava-string: stringobservablefrom(inputstream) does not close inputstream;would be nice if `stringobservablefrom(inputstreamsize)` closed the `inputstream` once finished with it are there any obstacles to this being incorporated?the same again for the `stringobservablefrom(reader size)`line 62 //githubcom/netflix/rxjava/blob/master/rxjava-contrib/rxjava-string/src/main/java/rx/observables/stringobservablejava;"i think its better that leaving the user to close it sometimes the user may need to reuse the stream and if the user wants to close it once the observable finishes he can use `using` operator eg``` java    public void foo(final inputstream i) {        observableusing(new func0<subscription>() {                             @override                             public subscription call() {                                 return subscriptionscreate(new action0() {                                     @override                                     public void call() {                                         try {                                             iclose()                                         } catch (ioexception e) {                                             throw new runtimeexception(e)                                         }                                     }                                 })                             }                         } new func1<subscription observable<byte>>() {                             @override                             public observable<byte> call(subscription subscription) {                                 return stringobservablefrom(i)                             }                         }        )    }``` || i think this is best served by the practice of ""whoever opened it should close it""the `from(inputstream)` approach means the `observable` didnt open it and therefore shouldnt close itif it was `from(file)` then it is the `observable` who opens it and should close it || thanks @zsxwing  for the explicit example thats very helpful i expect that the use case where the user wants it closed will be common so for the convenience of the user i might make a pull request with additional methods like `fromandclose(inputstream)` so that users dont need to implement all that using code || >  i might make a pull request with additional methods like fromandclose(inputstream) so that users dont need to implement all that using codei suppose we also miss some document about `stringobservablefrom(inputstreamsize)` or `stringobservablefrom(reader size)` observables returned by them can only be subscribed once they can not be used directly with `repeat` `retry` || thanks for the answers looks fine to close || ";1;0;switch from autocloseable to closeable for java 6unsafefunc0 now extends callable;
1301;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;extend mockitosession(builder) api to enable usage by testing frameworks;the first commit in this pr 1232. in the additional commits  i ve taken the liberty to implement my proposals from https://github.com/mockito/mockito/issues/445#issuecomment-358407562:;;0;session carries arbitrary optional key value pairs;"after presto-066 connectorsession is under the api project and transparent between a client and plugin this was exciting improvement so that a plugin can act differently based on connectorsession it means based on userbase on that we might also want to pass arbitrary optional values to a plugin for various purpose for example we might want to pass additional user properties price plan a secure token or a metadata information etc more than the user identity sure a plugin might fetch additional information from the user identity but there would be a security issue and it would not easy to shared these information between the coordinator and the workersas x-amz-meta-_  header does in amazon s3 access if presto can send optional values as a form of  header with x-presto-option-_ and store onto the connectorsession a plugin should have more fine grained control with addition valuesat the presto-cli we could specify them with new command line option ```/presto-cli --catalogtpch --schematpch --useruserid --optionsname1 value2"one minor thing we should keep in mind is  header name must be case insensitive so name1 and name1 will be treated same and stored as lower case at the connectorsession";"our apologies for the delay on this we had a long discussion this morning and decided that options need to be scoped per connector instance (which currently means catalog)we can also have ""global"" or ""system"" session options that are only visible to the presto engine or non-connector objects like functions that are provided by plugins though this would be a separate change from connector scoped sessionsthe biggest complication in implementing this is that `connectorsession` is used everywhere in presto we will need to introduce a new `session` object and switch to using that which converts to `connectorsession` when necessary (we expected this would be necessary which is why `connectorsession` was named that and not `session` in the spi) || separation of a global session and connectorsession looks much better idea the main obstacles were trying to solve through this pull request were- the built-in or a custom presto console can set additional parameters to a query (most required)- user specific information which could be acquired at planning can be shared between presto workers (less required)thanks you for reviewing the pull request || do you need the session options available in the connector in the core presto engine or both? || i might need the optional values both in the core engine and the connector it would be great if connectorsession is empty or simple by default can be overridden by connector a console can set session and connectorsession in a way and session contains connectorsession instance an accessor like sessiongetconnectorsession could be used if the engine or internal plugin might need to access its connectorsession  || we are also looking for ways to have session settings and have openedthis issue couple of months back wehave now started working on it and have come up with attached proposal thebasic idea is to come with a system using which we can club a set ofqueries into one session and we support set operations (set var  literal) just like we have it in hive for such sessionsit would be great if you guys can look at the proposal and share yourfeedback i will soon wrap up the implementation and open a pull request@miniway - is this something which can resolve your problem- vikram_from:_ david phillips notifications@githubcom> _date:_ june 9 2014 at 11 09 am pdt> _to:_ facebook/presto presto@noreplygithubcom> _subject:_ _re: [presto] session carries arbitrary optional key value> pairs (#1301)_> _reply-to:_ facebook/presto <> reply@replygithubcom> > > our apologies for the delay on this we had a long discussion this morning> and decided that options need to be scoped per connector instance (which> currently means catalog)> > we can also have ""global"" or ""system"" session options that are only> visible to the presto engine or non-connector objects like functions that> are provided by plugins though this would be a separate change from> connector scoped sessions> > the biggest complication in implementing this is that connectorsession is> used everywhere in presto we will need to introduce a new session object> and switch to using that which converts to connectorsession when> necessary (we expected this would be necessary which is why> connectorsession was named that and not session in the spi)> > —> reply to this email directly or view it on github>  || some rough syntax ideas from our discussion:```set session global aaa  barset session catalogbbb  bar``` || set command looks very nice and it would be wonderful also if we can access these information both in the core engine and a plugin || the idea with this syntax is to show the difference between global properties which are only accessible to the engine and catalog properties which are only accessible to the connector instance for that catalog || i updated the example so that the properties have different names || i guess optional properties can be set from presto-078 || ";;;;0;1;;
1301;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;extend mockitosession(builder) api to enable usage by testing frameworks;the first commit in this pr 1232. in the additional commits  i ve taken the liberty to implement my proposals from https://github.com/mockito/mockito/issues/445#issuecomment-358407562:;;1232.0;extend mockitosession(builder) api to enable usage by testing frameworks;the first commit in this pr 1232 in the additional commits ive taken the liberty to implement my proposals from  add `mockitosessionbuildername(string)` to pass a name from the testing framework to the `mockitosession`- add `mockitosessionbuilderlogger(mockitosessionlogger)` to customize the logger used for hints/warnings produced when finishing mocking (useful for testing and to connect reporting capabilities provided by testing frameworks such as junit jupiter)- add `mockitosessionfinishmocking(throwable)` to avoid potentially confusing warnings for failing tests- add `mockitosessionsetstrictness(strictness)` to change the strictness of the current session (there were two test cases requiring that)each of these changes is in a separate commit thus it should be relatively easy to take only those changes that you think good or just the first one to 1232to showcase that this new api is sufficient to implement an extension of a testing framework ive changed the `junitrule` implementation to use it;" merging 1301  || ";[junit5] mockitosession#initmocks should support multiple test instances;in order to support nested tests in junit5 (see #1221)  mockitosession#initmocks should allow to pass more than one test instance or allow multiple calls on initmocks with different test instancesin other words/code:``` mockitomockitosession()            initmocks(roottestinstance)            initmock(nestedtestinstance)```or ``` mockitomockitosession()            initmocks(roottestinstancenestedtestinstance)```;"related discussion from #1221 ----@timvdlippe  regarding #1232: another option would be to not support nesting of test classes i think we actively have to consider this option given our public api was apparently coupled to the junit4 implementation and we can not ship breaking changes per our policy----@marcphilipp  well its @incubating so you could still change it right? 😉> > besides i think neither of the two proposals would break compatibility would they? but then again we should discuss this over at #1232 🙂----@timvdlippe  hm looking at it again it seems that the breaking change is actually in an internal api namely testfinishedevent which is created in mockitosession as such i think we should be okay actually i will do a proper investigation this weekend (hopefully else next week) and update #1221 i hope you are okay with that @christianschwarz ? once that is done i can more definitively say the impact on our api and whether we are risking a breaking change i have good hopes now we might actually dodge that----@marcphilipp  `testfinishedeventgettestclassinstance()` and `testfinishedeventgettestmethodname()` are currently only used (twice) like this:> > ```> string testname  eventgettestclassinstance()getclass()getsimplename() >                   + """" + eventgettestmethodname()> ```>> currently `defaultmockitosession `always uses null for `testfinishedeventgettestmethodname() `which strikes me as odd i think it would be better if testfinishedevent only had two methods: `getfailure()` and gettestname() then mockitosessionbuilder could get a testname(string) builder method and defaultmockitosessionbuilder could pass it to defaultmockitosession and so on> > alternatively `mockitosessionbuilder `could get a `testmethodname()` builder method and pass that on> > moreover i think `mockitosessionbuilder `should allow to configure a `mockitologger` this way frameworks like junit could pass in a custom implementation for junit jupiter a `mockitologger `that publishes report entries instead of writing to stdout (which causes problems will parallel execution) comes to mind> > thoughts? || @timvdlippe > i will do a proper investigation this weekend (hopefully else next week) and update #1221 i hope you are okay with that @christianschwarz ?of coursego ahead! || @marcphilipp >moreover i think `mockitosessionbuilder` should allow to configure a `mockitologger`>>thoughts?make sense should be a new issue || hey guys! whats the next step for closing this issue getting us closer to supporting junit5?@christianschwarz - can you update the ticket and clarify the public api change? do you suggest adding new ""initmock()"" method? do you suggest vararg or consecutive invocation or both? i would suggest to go for the simplest compatible api change - keeping the existing method just making it vararg will you be able to work on this?@marcphilipp - thank you for suggestions! for internal refactorings we are pretty open - do what you think is good for the codebase for public api changes/additions we push back by default and we make sure that the use case is very compellingthanks!!! || i would say we can change it to a vararg this ticket basically addresses  which is unfortunate to do right now if we change it to vararg we can transform the `testclassinstances` list to an array and make it work    || ";1;0;merge branch release/2x into issues/1232-session-additions;
1301;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;extend mockitosession(builder) api to enable usage by testing frameworks;the first commit in this pr 1232. in the additional commits  i ve taken the liberty to implement my proposals from https://github.com/mockito/mockito/issues/445#issuecomment-358407562:;;1258.0;rxscala: add convenience method for adding unsubscription callback;implements enhancement detailed in #1258 now with less git screw ups;#1201   @headinthebox does this achieve what you wanted in #1258 and should it be merged?thanks @zsxwing for the review and @jbripley for doing this || yup ||;rxscala: subscription add with block expression;```final def add(s: subscription): unit  {    asjavasubscriberadd(sasjavasubscription)  }```add```final def add(s: >unit): unit  ```so you can write `sadd{ blah blah }`;ill take a stab at this issue || cool ||;1;0;add convenience method for adding unsubscription callback;
1307;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;update public api of invocationfactory needed for android static mocking;1306;;0;add explicitly named static factories to stopwatch instead of the ambiguous ctor; how about we deprecate the constructor and then add two static creation methods named something like ""newunstartedinstance()"" and ""newstartedinstance()""?this cleanup would be a little hairy and the names arent quite perfect but maybe its worth doing? at least stopwatch is still @﻿beta(note we cant just throw an ise when calling methods on a non-started stopwatch since there are several use-cases where youd expect a non-started stopwatch to return 0 for elapsedmillis())lets discuss further at api review"; im late to the party but +1 nonetheless! || ";;;;0;1;;
1307;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;update public api of invocationfactory needed for android static mocking;1306;;0;create table as select with tablesample broken;originally reported by damien carol on the mailing list``` sqlcreate table trace_sample_10 as select * from trace_iforchqc_rc tablesample poissonized (10) rescaled``````2014-05-16t15 13433+0200     warn    orgeclipsejettyservletservlethandler        /v1/task/20140516_133613_00037_a7n6914javalangillegalargumentexception: key $sampleweight not present in map        at comgooglecommonbasepreconditionscheckargument(preconditionsjava:148) ~[guava-1601jar:na]        at comgooglecommonbasefunctions$functionformapnodefaultapply(functionsjava:116) ~[guava-1601jar:na]        at comgooglecommoncollectiterators$8transform(iteratorsjava:794) ~[guava-1601jar:na]        at comgooglecommoncollecttransformediteratornext(transformediteratorjava:48) ~[guava-1601jar:na]        at comgooglecommoncollectimmutablecollection$builderaddall(immutablecollectionjava:301) ~[guava-1601jar:na]        at comgooglecommoncollectimmutablelist$builderaddall(immutablelistjava:691) ~[guava-1601jar:na]        at comgooglecommoncollectimmutablelistcopyof(immutablelistjava:275) ~[guava-1601jar:na]        at comgooglecommoncollectimmutablelistcopyof(immutablelistjava:226) ~[guava-1601jar:na]        at comfacebookprestoutiliterabletransformerlist(iterabletransformerjava:116) ~[presto-main-068jar:068]        at comfacebookprestosqlplannerlocalexecutionplanner$visitorgetsymboltypes(localexecutionplannerjava:1230) ~[presto-main-068jar:068]        at comfacebookprestosqlplannerlocalexecutionplanner$visitorgetsourceoperatortypes(localexecutionplannerjava:1225) ~[presto-main-068jar:068]        at comfacebookprestosqlplannerlocalexecutionplanner$visitorcreateinmemoryexchange(localexecutionplannerjava:1134) ~[presto-main-068jar:068]        at comfacebookprestosqlplannerlocalexecutionplanner$visitorvisittablewriter(localexecutionplannerjava:1104) ~[presto-main-068jar:068]        at comfacebookprestosqlplannerlocalexecutionplanner$visitorvisittablewriter(localexecutionplannerjava:311) ~[presto-main-068jar:068]        at comfacebookprestosqlplannerplantablewriternodeaccept(tablewriternodejava:149) ~[presto-main-068jar:068]        at comfacebookprestosqlplannerlocalexecutionplanner$visitorvisitsink(localexecutionplannerjava:1080) ~[presto-main-068jar:068]        at comfacebookprestosqlplannerlocalexecutionplanner$visitorvisitsink(localexecutionplannerjava:311) ~[presto-main-068jar:068]        at comfacebookprestosqlplannerplansinknodeaccept(sinknodejava:67) ~[presto-main-068jar:068]        at comfacebookprestosqlplannerlocalexecutionplannerplan(localexecutionplannerjava:193) ~[presto-main-068jar:068]        at comfacebookprestoexecutionsqltaskexecution<init>(sqltaskexecutionjava:214) ~[presto-main-068jar:068]        at comfacebookprestoexecutionsqltaskexecutioncreatesqltaskexecution(sqltaskexecutionjava:126) ~[presto-main-068jar:068]        at comfacebookprestoexecutionsqltaskmanagerupdatetask(sqltaskmanagerjava:296) ~[presto-main-068jar:068]        at comfacebookprestoservertaskresourcecreateorupdatetask(taskresourcejava:89) ~[presto-server-068jar:068]        at sunreflectgeneratedmethodaccessor221invoke(unknown source) ~[na:na]        at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43) ~[na:170_45]        at javalangreflectmethodinvoke(methodjava:606) ~[na:170_45]        at comsunjerseyspicontainerjavamethodinvokerfactory$1invoke(javamethodinvokerfactoryjava:60) ~[jersey-server-1171jar:1171]        at comsunjerseyserverimplmodelmethoddispatchabstractresourcemethoddispatchprovider$responseoutinvoker_dispatch(abstractresourcemethoddispatchproviderjava:205) ~[jersey-server-1171jar:1171]        at comsunjerseyserverimplmodelmethoddispatchresourcejavamethoddispatcherdispatch(resourcejavamethoddispatcherjava:75) ~[jersey-server-1171jar:1171]        at comsunjerseyserverimplurirules ~[jersey-server-1171jar:1171]        at comsunjerseyserverimplurirulesrighthandpathruleaccept(righthandpathrulejava:147) ~[jersey-server-1171jar:1171]        at comsunjerseyserverimplurirulesresourceclassruleaccept(resourceclassrulejava:108) ~[jersey-server-1171jar:1171]        at comsunjerseyserverimplurirulesrighthandpathruleaccept(righthandpathrulejava:147) ~[jersey-server-1171jar:1171]        at comsunjerseyserverimplurirulesrootresourceclassesruleaccept(rootresourceclassesrulejava:84) ~[jersey-server-1171jar:1171]        at comsunjerseyserverimplapplicationwebapplicationimpl_handlerequest(webapplicationimpljava:1511) ~[jersey-server-1171jar:1171]        at comsunjerseyserverimplapplicationwebapplicationimpl_handlerequest(webapplicationimpljava:1442) ~[jersey-server-1171jar:1171]        at comsunjerseyserverimplapplicationwebapplicationimplhandlerequest(webapplicationimpljava:1391) ~[jersey-server-1171jar:1171]        at comsunjerseyserverimplapplicationwebapplicationimplhandlerequest(webapplicationimpljava:1381) ~[jersey-server-1171jar:1171]        at comsunjerseyspicontainerservletwebcomponentservice(webcomponentjava:416) ~[jersey-servlet-1171jar:1171]        at comsunjerseyspicontainerservletservletcontainerservice(servletcontainerjava:538) ~[jersey-servlet-1171jar:1171]        at comsunjerseyspicontainerservletservletcontainerservice(servletcontainerjava:716) ~[jersey-servlet-1171jar:1171]        at javaxservlet ~[javaxservlet-api-310jar:310]        at orgeclipsejettyservletservletholderhandle(servletholderjava:738) ~[jetty-servlet-914v20140401jar:914v20140401]        at orgeclipsejettyservletservlethandler$cachedchaindofilter(servlethandlerjava:1651) ~[jetty-servlet-914v20140401jar:914v20140401]        at orgeclipsejettyservletsuseragentfilterdofilter(useragentfilterjava:83) ~[jetty-servlets-914v20140401jar:914v20140401]        at orgeclipsejettyservletsgzipfilterdofilter(gzipfilterjava:298)```;;;;;0;1;;
1307;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;update public api of invocationfactory needed for android static mocking;1306;;0;testnotificationdelay - attempt at determinism;trying to make this deterministic  i think it was possible for scheduling in the executor to cause different threads to be used even when queueing happened this forces the same thread to be used as it is different executors;;;;;1;1;testnotificationdelay - attempt at determinism;
1307;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;update public api of invocationfactory needed for android static mocking;1306;;1306.0;update public api of invocationfactory needed for android static mocking;1306a real method might throw a throwable but the invocations produced byinvocationfactory call the real method via a callable that can onlythrow a exceptionhence add a new method to invocationfactory that allows to createinvocations with a realmethodbehavior  a callable that throws athrowable;" merging 1307  thanks for review! || ";invocationfactorycreateinvocations realmethod cannot throw a throwable;invocationfactorycreateinvocation takes a callable that is used to call the real method of the invocation if the invocation throws an exception the exception is forwarded from the callable unfortunately callable can only throw an exception not a throwablehence if the real method throws a throwable that is neither an error runtimeexception or exception it cannot be forwardedi recommend for invocationfactorycreateinvocation to take realmethod argument that can throw a full throwablethis is required for fixing: linkedin/dexmaker#64;;1;0;simplified the test;
1310;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;1295 npe when sorting tabs;- selected tab might be null when sorting tabs - the logic is really strange in general  so this fixes the problem but we need to rework the actions enabling in general imho.;;0;mpscpaddedqueue does not pad correctly;the padding should be done with a 3 class hierarchy like i explained in this issue: you may want to use 128 bytes for padding as some newer hw use 128 bytes cache-lines;@normanmaurer you mean to avoid dce? || @daschl dce ? || dead code elimination || @daschl nope reordering fields  check  || a pr is welcome || @akarnokd sure will do later today :) || would be nice to get the iterator() implementation as well so we can completly replace concurrentlinkedqueue with this class || our mpsc queue was not meant to be a replacement for clq just to be a simple offer/poll for serializing between threads (ie observeon serializedobserver custom scheduler) || ah wasnt aware of that || completed in  || anyone have opinions of the code from  ?ive been playing with them on another branch and they seem good i ask here as it relates to the same type of issues || @benjchristensen i can really recommend @nitsanws queues :) || would be very interested in being added as a dependency code should be on maven in the next few week in version 01 || @nitsanw i hope we can keep rxjava without dependencies :) || @daschl @normanmaurer @benjchristensen i appreciate we all want to make users life easier which is why a <my-lib-name>-alljar is a nice way to publish your artifact its easy enough to support via maven buildthe current practice of copying and pasting randomly old versions of dependencies seems worse imho (imagine a bug in version x  in version y which version did rxjava use?) ultimately there is nothing i can (or wish to) do to stop people you are always welcome to copy my code if thats how you roll -) || @daschl @normanmaurer @benjchristensenjctools now includes an unbounded mpsc: algorithm is the same as the one followed by rx/netty the class layout is different as both head/tail node references are fields of the main data structurefrom re-reading the code in rx/netty i believe you suffer from false sharing as the writes to the tail field invalidate the cache line holding the reference to the paddedreference to headalso note the queue class fields are themselves not padded leading to potential false sharing between the queue and its neighbors  || thanks for submitting a fix for this @nitsanw in  ||;;;;0;1;;
1310;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;1295 npe when sorting tabs;- selected tab might be null when sorting tabs - the logic is really strange in general  so this fixes the problem but we need to rework the actions enabling in general imho.;;1279.0;ensure isolation of stubbings;" compatibilityfor certain corner cases this bugfix may be incompatible we believe that the exposure is minimal (corner cases only possibly incorrect tests) and the bugfix important if your test fails after upgrading to mockito version that contains this fix please scrutinize the test - it is very likely that the test is incorrect we apologize for any compatibility problems arising from this change it is a hard decision to make when a bugfix changes the behavior in a way it may not be compatible with every mockito test in the worldwhen stubbing with answers that call different mocked methods:```javawhen(mockfoo())thenanswer(() -> { othermockbar() }```we need to ensure that ```mockfoo()``` and ```othermockbar()``` dont interfere prior to this bugfix this scenario resulted in various problems like: stack overflow error unexpected stubbings declared on different mock unexpected invalid return type errorsfor more details see #1279### solutionthe solution is based on great pr #1296 by @r-smirnov **huge thanks** to @r-smirnov for reporting the problem diligently then digging into the bowels of mockito to find a clean solution providing excellent test cases that demonstrate the problem when i initially saw the issue report i thought that its not fixable and we would close it as ""documented mockito syntax caveat"" thank you @r-smirnov for persistence and getting this !";"can we give an example of a test that breaks with this ""new"" behavior? ||  merging 1310  <  || ";cannot override stubbed method that calls a stubbed method;"mockito 2130overriding stubbed method that calls a stubbed method in its answer may result in a number of different failure modes:1) wrongtypeofreturnvalue is thrown```javaimport static orgjunitassertassertequalsimport static orgmockitomockitomockimport static orgmockitomockitowhenimport orgjunittestpublic class teststubbing {    @test    public void test() throws exception {        foo foo  mock(fooclass)        bar bar  mock(barclass)        when(foodofoo())thenanswer(invocation -> stringvalueof(bardobar()))        assertequals(""0"" foodofoo())        when(foodofoo())thenreturn("""")        assertequals("""" foodofoo())    }    interface foo {        string dofoo()    }    interface bar {        int dobar()    }}```2) wrong method is stubbed```javaimport static orgjunitassertassertequalsimport static orgmockitomockitomockimport static orgmockitomockitowhenimport orgjunittestpublic class teststubbing {    @test    public void test() throws exception {        foo foo  mock(fooclass)        bar bar  mock(barclass)        when(foodofoo())thenanswer(invocation -> bardobar())        assertequals(0 foodofoo())        assertequals(0 bardobar())        when(foodofoo())thenreturn(1)        assertequals(1 foodofoo())        assertequals(0 bardobar())    }    interface foo {        int dofoo()    }    interface bar {        int dobar()    }}```3) stackoverflowerror is thrown```javaimport static orgjunitassertassertequalsimport static orgmockitomockitomockimport static orgmockitomockitowhenimport orgjunittestpublic class teststubbing {    @test    public void test() throws exception {        foo foo  mock(fooclass)        bar bar  mock(barclass)        when(foodofoo())thenanswer(invocation -> bardobar())        assertequals(0 foodofoo())        when(foodofoo())thenanswer(invocation -> bardobar() + 1)        assertequals(1 foodofoo())    }    interface foo {        int dofoo()    }    interface bar {        int dobar()    }}```the cause is that in the mockingprogressimpl the ongoingstubbing for dofoo() invocation is replaced with the ongoingstubbing for dobar() invocation";"one potential solution is to restore the ongoingstubbing after evaluating the answer[mockhandlerimpljavapatchtxt]( || wow thank you for reporting and digging deep into this problem you nailed down another edge case of mockito syntax! (ping @timvdlippe youre collecting problems with existing syntax)one solution to this problem is using ""doreturn"" syntax however it does not really help the user at minimum the error message of wrongtypeofreturnvalue and friends should indicate this potential problem>one potential solution is to restore the ongoingstubbing after evaluating the answerthis is potentially a good idea can you hack it together and submit a pr? lets see if it breaks any existing testsim a little bit worried fixing this bug because it is an incompatible change and there might be tests out there that depend on the existing behaviorstackoverflowerror needs fixing too its great that you have found all problems with this use casebtw im traveling so please pardon spotty replies || i can confirm that the prototype in #1264 does not require any changes to make this work you can see the full passing test suite at  || created a pr #1296 with [the above patch]( applied || @r-smirnov thank you very much!!! ive opened a separate pr with your commits #1310 please take a look read the description and let me know if something is amissyour pr is a fantastic contribution (i thought that his problem is not fixable!!!) and im really looking forward to merging! || ";1;0;added code comment;
1310;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;1295 npe when sorting tabs;- selected tab might be null when sorting tabs - the logic is really strange in general  so this fixes the problem but we need to rework the actions enabling in general imho.;;1296.0;ensure isolation of stubbings;" compatibilityfor certain corner cases this bugfix may be incompatible we believe that the exposure is minimal (corner cases only possibly incorrect tests) and the bugfix important if your test fails after upgrading to mockito version that contains this fix please scrutinize the test - it is very likely that the test is incorrect we apologize for any compatibility problems arising from this change it is a hard decision to make when a bugfix changes the behavior in a way it may not be compatible with every mockito test in the worldwhen stubbing with answers that call different mocked methods:```javawhen(mockfoo())thenanswer(() -> { othermockbar() }```we need to ensure that ```mockfoo()``` and ```othermockbar()``` dont interfere prior to this bugfix this scenario resulted in various problems like: stack overflow error unexpected stubbings declared on different mock unexpected invalid return type errorsfor more details see #1279### solutionthe solution is based on great pr #1296 by @r-smirnov **huge thanks** to @r-smirnov for reporting the problem diligently then digging into the bowels of mockito to find a clean solution providing excellent test cases that demonstrate the problem when i initially saw the issue report i thought that its not fixable and we would close it as ""documented mockito syntax caveat"" thank you @r-smirnov for persistence and getting this !";"can we give an example of a test that breaks with this ""new"" behavior? ||  merging 1310  <  || ";add files via upload;applied patch from issue #1279; merging 1296  < ;1;0;added code comment;
1310;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;1295 npe when sorting tabs;- selected tab might be null when sorting tabs - the logic is really strange in general  so this fixes the problem but we need to rework the actions enabling in general imho.;;0;simplify sortedrangesetbuilder and add benchmark;collect ranges and do one pass at the end to merge adjacent and overlapping rangesthis improves performance for this class by about 6x for a synthetic benchmark with 10000 ranges```        benchmark                                            mode   samples   mean  mean error   unitsbefore: cfpsbenchmarksortedrangesetbenchmarkbuilder     avgt        10  5416       0150   ms/opafter:  cfpsbenchmarksortedrangesetbenchmarkbuilder     avgt        10  0867       0016   ms/op```;;;;;1;1;simplify sortedrangesetbuilder and add benchmarkcollect ranges and do one pass at the end to merge adjacent and overlapping rangesthis improves performance for this class by about 6x for a synthetic benchmark with 10000 ranges        benchmark                                            mode   samples   mean  mean error   unitsbefore: cfpsbenchmarksortedrangesetbenchmarkbuilder     avgt        10  5416       0150   ms/opafter:  cfpsbenchmarksortedrangesetbenchmarkbuilder     avgt        10  0867       0016   ms/op;
1310;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;1295 npe when sorting tabs;- selected tab might be null when sorting tabs - the logic is really strange in general  so this fixes the problem but we need to rework the actions enabling in general imho.;;0;joining charsources; any chance of getting a nice way to join charsources (eg similar to the method in charstreams for joining inputsuppliers)?  (and i guess bytesources also though im particularly only joining charsources); this is already available on master and will be available in 150 as byte/charsourceconcat:  `` ;;;;0;1;;
1319;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1314 : include all the invocation in mock verification error message;have changes the verify error message to include all the invocation instead of including just one undesired invocation.;;0;link between mapstomap and mapsasmap in documentation; i see two instances of immutablemapcopyof(mapsasmap()) internally (of ~40 total asmap() callers) thats not nearly as common as i feared but its something we could have anticipated and perhaps discouraged with better javadocyou can repeat my search with these regexes:immutablemapcopyof asmap[(][^)] mapsasmaporimmutablemapcopyof[^}]*asmap[(][^)] (pcre);@kevinb9n did this back in july 2013 ||;;;;0;1;;
1319;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1314 : include all the invocation in mock verification error message;have changes the verify error message to include all the invocation instead of including just one undesired invocation.;;0;extract native connector into separate plugin;;;;;;1;1;extract native connector into separate pluginthe native connector is now called raptor and lives in presto-raptor;
1319;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1314 : include all the invocation in mock verification error message;have changes the verify error message to include all the invocation instead of including just one undesired invocation.;;0;joins or | orwithdefault;hione area that is not looked into in creating joins in rx is how to deal with situation when one of the streams has an input and you want to update your processing based on it but using previous values for the other streams which is waiting for the next value also you might want to indicate the particular stream does not have a value in some cases by providing a default incase the previous has been consumed and another default if there has been no previous in the former case you need at least one previous all of the existing combiners can be then implemented using joins this is much more convenient if you have a large number of interacting / combining streams and the possible interactions are dynamic also certain combination can be re used through plansthis might be useful in a non joins context also hence and or combinators and - combine when all inputs are there or - combine when at least on input is there sequence(then) - sequence from different streams in order ie if a has a value then a followed by b from b  (these will be mainly aliased to current combiners in case this is added for consistency of naming between joins but not necessary)suminda;"theres ""combinelatest"" ( it wouldnt help with the problem of a participant observable thathasnt emitted any values yet  you could use ""startwith"" ( toprepend some ""hasnt started yet"" token to those observables and thendetect this in your combinelatest combine functionon wed jun 4 2014 at 8:28 am suminda dharmasena <notifications@githubcom> wrote:> > hi> > one area that is not looked into in creating joins in rx is how to deal> with situation when one of the streams has an input and you want to update> your processing based on it but using previous values for the other streams> which is waiting for the next value also you might want to indicate the> particular stream does not have a value in some cases by providing a> default> > this might be useful in a non joins context also hence and or combinators> and - combine when all inputs are there or - combine when at least on> input is there sequence(then) - sequence from different streams in order> ie if a has a value then a followed by b from b > > suminda> > —> reply to this email directly or view it on github>  david m grossplp consulting || the main idea of proposing this is that you can impliment all the patterns in  as plans the plans can be further composed this is a lot more flexible when dealing with function calls when the number of combinations are large and the possible combination are dynamicyou might need and or merge and a way to delay the errors and is like zip or is combinelatest must think through how the rest should fit in main thing is once you have a pattern object you can create others with different combination by adding them and creating new pattern objects once all of the patterns are in place then you start processing  imagine you have n items and some cases you have to select r out of this to zip or combine or perform some other operation these combination are again combined in the next level  (imagine you are using a dag as way to compute) if you are to code all the possible combination your code blows up in size and complexity which is increasing very rapidly so for very dynamic use cases with large number of possible combination which feed into other combination using static function call to do this is not elegant and not very understandable after a few weeks the process of composing streams and calculation itself should be composable! || the joins patterns are in a separate contribution module in the net world as well in rxjava they are not much used wed be delighted @sirinath if you would hack on those || one problem with the join patterns for me was that it is usually hard to predict which plan will take which value zip and combinelatest is much clearer || should be simple every time a new value arrives all patters are matched top to bottom first one wins || having a pattern object to pass around and work with is much easier when you get going with itmostly this would have not caught on since the functionality is limited you should be able to express what ever you do with rest of rx using this i am sure this will be what would be usedrx give the flexibility to compose streams extending this would give the power to compose the composition and also further optimise all the combinations and transformation || absolutely thats why we added join patterns to comega and `when` to rx seems like you have some kind of advanced api/dsl in mind for composing join patterns go for it! i assume you are aware of things like  || closing out as conversation died off if there is code to propose please open a pull request for a contrib module || ";;;;0;1;;
1319;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1314 : include all the invocation in mock verification error message;have changes the verify error message to include all the invocation instead of including just one undesired invocation.;;1314.0;1314 : include all the invocation in mock verification error message;have changes the verify error message to include all the invocation instead of including just one undesired invocationpreviously we have message like:```wanted 1 time:-> at but was 2 times undesired invocation:-> at ```this pr changes it to ```wanted 1 time:-> at but was 2 times:-> at -> at ```to make the error message consistent the similar changes was made for too little invocations casethe message:```wanted 3 times:-> at but was 2 times:-> at ```changed to:```wanted 3 times:-> at but was 2 times:-> at -> at ```; merging 1319 ;undesired invocation message improvements;let’s take a look at the following code```kotlinpackage whateverimport orgjunittestimport orgmockitomockitoclass multipleundesiredinvocations {    interface inner {        fun call()    }    interface sideeffect {        fun call()        class impl(private val inner: inner) : sideeffect {            override fun call()  innercall()        }    }    interface outer {        fun call()        class impl(private val inner: inner sideeffect: sideeffect) : outer {            init {                sideeffectcall()            }            override fun call() {                innercall()            }        }    }    @test    fun test() {        val inner  mockitomock(inner::classjava)        val sideeffect  sideeffectimpl(inner)        val outer  outerimpl(inner sideeffect)        outercall()        mockitoverify(inner)call()    }}```the `test` will fail of course the following message will be shown```orgmockitoexceptionsverificationtoomanyactualinvocations: innercall()wanted 1 time:-> at whatevermultipleundesiredinvocationstest(multipleundesiredinvocationskt:43)but was 2 times undesired invocation:-> at whatevermultipleundesiredinvocations$outer$implcall(multipleundesiredinvocationskt:30)```it is kind of fine but the undesired call (for me) is actually inside the `sideeffect` classis it possible to extend the message to show all undesired invocations somehow? it would be extremely helpful when debugging failed tests similar to the sample above — i e when a side-effect calls the target object;good idea do you want to submit a pr? || @mockitoguy i can work on italso to make it consistent i would suggest to extend the message to include all the invocations for other cases as example for `toolittleactualinvocations` || submitted pr #1319  ||;1;0;split the test for invocationfinder#getalllocations;
1320;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;avoid bytebuddy import issue to enable repackaging without bytebuddy;this allows libs that use alternate mockmakers do cleanly exclude the bytebuddy subdirectory.;;0;set operations with custom comparator; in my current project i have encountered a following problem:i need to intersect two sets of the same type but not with default equals()/compareto() methods but with external comparatorit would be nice to have in sets method like:set&ltt> intersection(set&ltt> set&ltt> comparator&ltt>)the same for difference and other set comparing methods; no treeset is implemented via treemap which uses no equals for its keys:treeset&ltstring> treeset  new treeset&ltstring>(stringcase_insensitive_order)treesetadd(""a"")treesetadd(""a"")assertequals(1 treesetsize()) || ";;;;0;1;;
1320;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;avoid bytebuddy import issue to enable repackaging without bytebuddy;this allows libs that use alternate mockmakers do cleanly exclude the bytebuddy subdirectory.;;0;refactor aggregations;introduce a new base class for aggregation functions that makes themsimpler to writeit looks like theres a small (~3% performance regression) but given how much this simplifies the code i think its worthwhile we could also try to get that back with byte code generationmaster:                  hand_tpch_query_1 :: 2907023 cpu ms :: in    6m   361mb   206m/s   124mb/s :: out     4    300b       1/s    103b/s                  hand_tpch_query_6 ::  308901 cpu ms :: in    6m   240mb   194m/s   778mb/s :: out     1      9b       3/s     29b/smy branch:                  hand_tpch_query_1 :: 2937362 cpu ms :: in    6m   361mb   204m/s   123mb/s :: out     4    300b       1/s    102b/s                  hand_tpch_query_6 ::  321828 cpu ms :: in    6m   240mb   186m/s   747mb/s :: out     1      9b       3/s     27b/s;;;;;1;1;refactor aggregationsintroduce a new base class for aggregation functions that makes themsimpler to write;
1320;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;avoid bytebuddy import issue to enable repackaging without bytebuddy;this allows libs that use alternate mockmakers do cleanly exclude the bytebuddy subdirectory.;;0;joins plan optimiser;hifor large number of composable joins you might need a plan optimiser (though in a different context  has such an optimiser)suminda;@sirinath the join patterns are modelled after haskell-style pattern matching they are matched top-to-bottom to optimize patterns you would have to put in more restrictions instead of doing optimizer magic yourselff you should look at claudios efficient implementation of the joins library  || also following links some additional papers too:  also worthwhile looking at the project also to get some ideas || also a optimiser would be more efficient than hand composing the transformations and combinations also it can optimise this against workload and resource availability  || @headinthebox and @sirinath is there anything about this that requires further discussion? || not from my side this would be an interesting vc-funded project || im closing this out as this feels out of scope for rxjava itself @sirinath if you want to propose and lead a contrib module or a sibling project id be interested in that  ||;;;;0;1;;
1320;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;avoid bytebuddy import issue to enable repackaging without bytebuddy;this allows libs that use alternate mockmakers do cleanly exclude the bytebuddy subdirectory.;;111.0;avoid bytebuddy import issue to enable repackaging without bytebuddy;"this allows libs that use alternate mockmakers do cleanly exclude the bytebuddy subdirectorytest: grep -r -e ""import org\mockito\internal\creation\bytebuddy\[^\]*$"" src/main does not return anythingoffers workaround for #1112";" merging 1320 ` ! || ";improve automation: fix binary comparison - avoidance of uncessary publication;the binary comparison does not work:- some problem with serializablenoop- poms are always different due to changed version;@szczepiq want to close this one ? || yes its done ;1;0;"issue #1112: dont import orgmockitointernalcreationbytebuddythis allows libs that use alternate mockmakers do cleanly exclude thebytebuddy subdirectorytest: grep -r -e ""import org\mockito\internal\creation\bytebuddy\[^\]*$"" src/main      does not return anything";
1324;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;improved stubbing internals and test coverage;some improvements in exception-stubbing code:;;0;executionlist is not threadsafe; (guava 140)executionlistexecute() polls it ""runnables"" instance field without synchronizing on it since this is a javautillinkedlist which is not thread-safe then executionlist is not thread-safenon-safety could occur if :- a thread a is executing executionlistexecute() regularly polling the linkedlist without synchronizing access on it- another thread b executes executionlistadd() which adds an element to the linkedlist after synchronizing on it"; ;;;;0;1;;
1324;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;improved stubbing internals and test coverage;some improvements in exception-stubbing code:;;0;improved stubbing internals and test coverage;some improvements in exception-stubbing code:- clarify intentions in basestubbing:  - replace an obsolete todo with a clarifying comment and add some tests covering related test cases  - extract the code aborting the ongoing stubbing in a separate method that always throws use return `abortnullexceptiontype` so that static-analysis tools (eg idea) yield no false-positives- clarify that throwsexception always returns the _same_ throwablethe previous `#answer` implementation might give an illusion that `throwable#fillinstacktrace` produces a new throwable but that is not correct — it always returns `this`- also replace a possible npe with a descriptive illegalstateexception; merging 1324  < ;;;;1;1;add a comment explaining the test scenarios;
1324;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;improved stubbing internals and test coverage;some improvements in exception-stubbing code:;;0;add more configurable learn methods for ml plugin;;;;;;1;1;add function to train libsvm modelsadd special learning functions that allow you to configure thehyperparameters of the model;
1324;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;improved stubbing internals and test coverage;some improvements in exception-stubbing code:;;0;trampolinescheduler & unsubscribe;unsubscribing should prevent new additions to a worker but not prevent already scheduled work and definitely not affect other workers using the same thread (by modifying the threadlocal as it was doing)see the unit test for details of how unsubscribing 1 worker could prevent work from being done on a completely separate worker;;;;;1;1;trampolinescheduler & unsubscribeunsubscribing should prevent new additions to a worker but not prevent already scheduled work and definitely not affect other workers using the same thread (by modifying the threadlocal as it was doing)see the unit test for details of how unsubscribing 1 worker could prevent work from being done on a completely separate worker;
1327;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;1326 : reduce the allocation rate for the typical use of locat…;…ionimpl;;0;new public suffixes for internetdomainname sometime after april 23; icann is expected to announce new top-level public suffixes (things like ""shop"" etc) on april 23 its possible that a company wishing to use the suffix itself (rather than just run a registry) will start doing so arbitrarily soon after that date we should keep an eye on the news:  http://wwwicannorg/en/news";;;;;0;1;;
1327;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;1326 : reduce the allocation rate for the typical use of locat…;…ionimpl;;0;remove dual connector;;can you add an error message to `tupleanalyzervisittable` that lets users know that the dual table is no longer supported and they can use from-less select or values(x) instead? || ;;;;1;1;remove dual connector;
1327;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;1326 : reduce the allocation rate for the typical use of locat…;…ionimpl;;1318.0;join patterns extension for 49 and n arity joins;issue #1318i made some potential breaking changes:- made classes final- made most methods protected or package private;#1219  #1220 wow thats a lot of typingsince this is a contrib module that you primarily manage im assuming its all good and merging ||;joins - only plan upto 3 implemented in rxjava but rx has 16;is it possible to have larger plans for joins(also besace it is not is the core concerned about how optimised the implementation is);that 3 was tedious to implement and there was no one at the time who needed it or understood its use case || if you try to zip together about 16 streams in different combinations like dag you will see how useful this is ideally there should a lot more than 16 as you will be dealing with a large number of streams to coordinate between in some cases || one problem is that the operator requires a function callback with that arity but we have only up to func9 i didnt understand the operator enough so i could try with funcn: there might be no good way to generalize to any arity with funcn adding the remaining 4-9 arity version is mostly mechanical one could always use rxnet as cheat-sheet but writing tests is cumbersome || ib be really surprised any human can patterns over more than 3 streams by hand because of the combinatorial explosion are you generating the code? || i certainly didnt i saw rxnet use code generators on this im not sure if we have anything similar available with gradle and/or annotation processing || then stop at 9 and n when you have more function arity then add accordingly || up to 9 was added  closing out ||;1;0;crlf fix;
1327;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;1326 : reduce the allocation rate for the typical use of locat…;…ionimpl;;1326.0;1326 : reduce the allocation rate for the typical use of locat…;…ionimpla trivial one but should be very useful as i noticed this class being instantiated quite a lot; merging 1327  < ;reduce memory consumption of the typical locationimpl;i recently noticed very heavy memory usage on our testsuite (which is using mockito) so i started profilingi eventually found #1313 but thats already being worked on also spotted a low hanging fruit: our testsuite is allocating about 6 *million* instances of `locationimpl`it looks like i cant avoid that easily however each `locationimpl` also allocates a new `stacktracefilter` which can be easily avoided when the default is being applied sending a pr shortlythis should save us about 6 million empty and pointless `stacktracefilter` :);;1;0;1326 : reduce the allocation rate for the typical use of locationimpl;
1339;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;enable errorprone build;- fix up issues found;;0;enable errorprone build;- fix up issues found- placate error prone warning where we know we do something funky- ignore two tests as it is not immediately clear what is broken  - orgmockitousagebugsvarargsvarargsnotplayingwithanyobjecttest#shouldnotallowusinganyobjectforvarargs  - orgmockitointernalutilprimitivestest#should_check_that_value_type_is_assignable_to_wrapper_referencenote: please carefully review the changes made to the code i  them up as good as i could but a real mockito expert need to verify them; merging 1339 ;;;;1;1;preserved current functionality;
1339;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;enable errorprone build;- fix up issues found;;0;add missing presto-main dependency to presto-server;this was missed in the refactoring that moved the server code to presto-mainas a result the server fails to start when run via the launcher;;;;;1;1;add missing presto-main dependency to presto-serverthis was missed in the refactoring that moved the server code to presto-mainas a result the server fails to start when run via the launcher;
1339;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;enable errorprone build;- fix up issues found;;0;rxscala: onerrorflatmap;why is the signature so weird?```def onerrorflatmap[u >: t](resumefunction: (throwable option[any]) > observable[u]):```;do you mean `[u >: t]` or `resumefunction: (throwable option[any]) > observable[u]`? || `(throwable option[any])` || its `onerrorthrowable` in rxjava `onerrorthrowable` actually is a tuple of (error value) however some error may be not associated with a value so here i used `option[any]` || id used a property of type option[any] so you can get at it via a real name instead of `_2` and stay closer to rxjava but dont think it is such a big deal ||;;;;0;1;;
1349;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1347 open urls does not work with query strings;this should work with query strings like    and normal urls.  however  the question is: does this impact the opening of any other file path or anything? we need to be careful as this is a generic open method. maybe that s also the problem because it needs to handle any kind of uri.  @siedlerchr @tobiasdiez please take a look.;;0;add register(object listener executor listenercaller) to asynceventbus; currently asynceventbus simply calls listeners in the separate executor as provide in the constructer yet there is no way for listeners to individually control what executor should be used to call them ideally wed have something like addcallback where a listener can provide a a specific executor this gives the possibility for the listener to control what executor is calling and at the same time makes asynceventbus faster as the posting executor is not blocked by a listener; sounds lovely! || im closing this issue because we are no longer going to be making changes to `eventbus` other than important bug fixes the reasons were discouraging it and some alternatives are listed in the [eventbus javadoc]( ||;;;;0;1;;
1349;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1347 open urls does not work with query strings;this should work with query strings like    and normal urls.  however  the question is: does this impact the opening of any other file path or anything? we need to be careful as this is a generic open method. maybe that s also the problem because it needs to handle any kind of uri.  @siedlerchr @tobiasdiez please take a look.;;0;blockbuilder should use underlying slice size;to calculate exact memory usages widthblockbuilder and variablewidthblockbuilder should return underlying slice sizeeven though pagebuilder list could be negligible compared to other array fields it would have take growing spaces in a way;rebased and ;;;;0;1;;
1349;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1347 open urls does not work with query strings;this should work with query strings like    and normal urls.  however  the question is: does this impact the opening of any other file path or anything? we need to be careful as this is a generic open method. maybe that s also the problem because it needs to handle any kind of uri.  @siedlerchr @tobiasdiez please take a look.;;0;rxscala: buffer(timespantimeshift) raises illegalargumentexception for timeshift < 1 second;im on 016 the following code will throw an illegalargumentexception:```scala> val obs  observableinterval(100 milliseconds)buffer(3 seconds 500 milliseconds)obs: rxlangscalaobservable[seq[long]]  rxlangscalajavaconversions$$anon$1@6f6b1731scala> obssubscribe{x >println(x)}rxexceptionsonerrornotimplementedexception    at rxobservable$25onerror(observablejava:6805)    at rxobserverssafesubscriber_onerror(safesubscriberjava:124)    at rxobserverssafesubscriberonerror(safesubscriberjava:93)    at rxobservable$2call(observablejava:280)    at rxobservable$2call(observablejava:268)    at rxobservablesubscribe(observablejava:7076)    at rxobservableprotectivelywrapandsubscribe(observablejava:5396)    at rxobservablesubscribe(observablejava:6796)    at rxlangscalaobservable$classsubscribe(observablescala:132)    at rxlangscalajavaconversions$$anon$1subscribe(javaconversionsscala:53)    at <init>(<console>:14)    at <clinit>(<console>)    at <init>(<console>:7)    at <clinit>(<console>)    at $print(<console>)    at sunreflectnativemethodaccessorimplinvoke0(native method)    at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:57)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javalangreflectmethodinvoke(methodjava:606)    at scalatoolsnscinterpreterimain$readevalprintcall(imainscala:734)    at scalatoolsnscinterpreterimain$requestloadandrun(imainscala:983)    at scalatoolsnscinterpreterimainloadandrunreq$1(imainscala:573)    at scalatoolsnscinterpreterimaininterpret(imainscala:604)    at scalatoolsnscinterpreterimaininterpret(imainscala:568)    at scalatoolsnscinterpreteriloopreallyinterpret$1(iloopscala:756)    at scalatoolsnscinterpreteriloopinterpretstartingwith(iloopscala:801)    at scalatoolsnscinterpreteriloopcommand(iloopscala:713)    at scalatoolsnscinterpreteriloopprocessline$1(iloopscala:577)    at scalatoolsnscinterpreteriloopinnerloop$1(iloopscala:584)    at scalatoolsnscinterpreterilooploop(iloopscala:587)    at scalatoolsnscinterpreteriloop$$anonfun$process$1apply$mcz$sp(iloopscala:878)    at scalatoolsnscinterpreteriloop$$anonfun$process$1apply(iloopscala:833)    at scalatoolsnscinterpreteriloop$$anonfun$process$1apply(iloopscala:833)    at scalatoolsnscutilscalaclassloader$savingcontextloader(scalaclassloaderscala:135)    at scalatoolsnscinterpreteriloopprocess(iloopscala:833)    at scalatoolsnscmaingenericrunnerruntarget$1(maingenericrunnerscala:83)    at scalatoolsnscmaingenericrunnerprocess(maingenericrunnerscala:96)    at scalatoolsnscmaingenericrunner$main(maingenericrunnerscala:105)    at scalatoolsnscmaingenericrunnermain(maingenericrunnerscala)caused by: javalangillegalargumentexception    at javautilconcurrentscheduledthreadpoolexecutorscheduleatrate(scheduledthreadpoolexecutorjava:562)    at rxschedulersexecutorschedulerscheduleperiodically(executorschedulerjava:75)    at rxoperatorschunkedoperation$timebasedchunkcreator<init>(chunkedoperationjava:579)    at rxoperatorsoperationbuffer$7onsubscribe(operationbufferjava:360)    at rxobservable$1call(observablejava:235)    at rxobservable$1call(observablejava:231)    at rxobservable$2call(observablejava:272)     35 more```looking at the implementation of the scheduler the error is raised when the argument is less than zero so there appears to be a problem causing the `timeshift` to be rounded down if you change the `timeshift` to 1 second or larger it works fine;good catch thanks for pointing it out the implementation uses `timespanunitconvert` which is wrong because it might do rounding appears several times in observablescala || which is why i proposed to have `public final observable<list<t>> buffer(long timespan long timeshift timeunit unit)` take _two_ time units one for the `timespan` one for the `timeshift` having just one is like having `exchangerate(decimal from decimal to currency unit)` || is someone going to fix anything about this and what is considered the right fix? in rxscala its fine to pursue new signatures but in java we have already debated this and decided to stay with the java contention of a single timeunit for the method || ill double check all uses of timespan in the scala bindings || @headinthebox can this get finished today or should i release 020 without this? || opened issue on new rxscala project:  ||;;;;0;1;;
1349;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1347 open urls does not work with query strings;this should work with query strings like    and normal urls.  however  the question is: does this impact the opening of any other file path or anything? we need to be careful as this is a generic open method. maybe that s also the problem because it needs to handle any kind of uri.  @siedlerchr @tobiasdiez please take a look.;;1346.0;1346 - different mocks are used for @mock and @injectmock in the same test class with junit 5 extension;1346 - fix `mockitoextension` which has init mocks with two identical test instances which cause the mock to be initialized and injected two times;  sadly this doesnt cover the case where we are using `@testinstance(testinstancelifecycleper_class)`>  ||;different mocks are used for @mock and @injectmock in the same test class with junit 5 extension;"ive been playing with the new junit 5 support in mockito 2170 i have found that with `@mock` and `@injectmocks` used in the same test class different mocks are injected i would expect to have the same mock reused (as it works with junit 4 or manual `@mock` initialization)sample code:```@extendwith(mockitoextensionclass)public class spaceship5bugminitest {    @injectmocks    private spaceship spaceship    @mock    private tacticalstation tacticalstation    @test    public void shouldinjectmocks() {        assertthat(tacticalstation)isnotnull()        assertthat(spaceshipgettacticalstation())isequalto(tacticalstation)          //bug ↑ - different mocks are use in @mock and @injectmock    }}```error message:```orgopentest4jassertionfailederror: expecting: <""tacticalstation (tacticalstation$mockitomock$991606095@61d6015a)"">to be equal to: <""tacticalstation (tacticalstation$mockitomock$991606095@b62d79)"">but was notexpected :tacticalstationactual   :tacticalstation```the minimal (non-)working example is available [here]( do you have an idea what could be wrong?mockito 2170 (2171 is not being released due to ( junit-jupiter 510 openjdk 180_161 linux### checklist: -  the mockito message in the stacktrace have useful information but it didnt help -  the problematic code (if thats possible) is copied here       note that some configuration are impossible to mock via mockito -  provide versions (mockito / jdk / os / any other relevant information) -  provide a [short self contained correct (compilable) example]( of the issue       (same as any question on stackoverflowcom) -  read the [contributing guide](https://githubcom/mockito/mockito/blob/master/github/contributingmd)";hm that seems really weird could you please post the implementation of `tacticalstation` and `spaceship` (although i am assuming they are simple pojos?) || (oh never mind i missed the small link at the end of the example to  ) || @szpak please see  for a working test i could make these tests fail with adding `final` to the field declaration so that is what is going wrong removing `final` makes the tests passwhat i do not understand is how this could work with junit 4 as we have not changed any of that code we are completely reusing all of that logic || it also works with `final` if `mockitoannotationsinitmocks(this)` is used therefore i would suspect the way how it is triggered/executed in junit 5 extension || @timvdlippe @szpak i have debugged this issue a bit here is what i found: it does look like the problem is with triggering the same logic from `mockitoextensionclass` the root cause of the problem is that `beforeeach` creates two `testinstances` of the same test class for each test looks like method `collectparenttestinstances` is adding the same testinstance to the list of test instancesi can try to work on this issue if no one is assigned to is already || prs appreciated!on mon 26 mar 2018 10:55 serge bishyr <notifications@githubcom> wrote:> @timvdlippe < @szpak> < i have debugged this issue a bit here is what> i found: it does look like the problem is with triggering the same logic> from mockitoextensionclass> the root cause of the problem is that beforeeach creates two testinstances> of the same test class for each test> looks like method collectparenttestinstances is adding the same> testinstance to the list of test instances> i can try to work on this issue if no one is assigned to is already>> —> you are receiving this because you were mentioned>>> reply to this email directly view it on github> < or mute the thread> < > || have added pr #1349 with the fix for the issue || it works flawlessly thanks @seriybg!@timvdlippe as this bug can impact all those people preferring a constructor injection what do you thing about releasing the new minor version (eg after #1350 is hopefully merged :) ) to maven central? || @szpak yes after #1350 we will probably publish a new version you can however already use the latest version from bintray || i know tim that i can but junit 5 support is a notable feature and having it working correctly in the latest non-development version (available in maven central) seems very sensible for me great that we agree on releasing a new stable (but ihmo still 217x) version soon || im seeing this same bug when using `springextensionclass` along with `mockitoextensionclass`:```@extendwith({mockitoextensionclass springextensionclass})public class injectmockstest {  static class tacticalstation {}  static class spaceship {    private final tacticalstation tacticalstation    public spaceship(final tacticalstation tacticalstation) {      thistacticalstation  tacticalstation    }    public tacticalstation gettacticalstation() {      return tacticalstation    }  }  @injectmocks  private spaceship spaceship  @mock  private tacticalstation tacticalstation  @test  public void shouldinjectmocks() {    assertthat(tacticalstation)isnotnull()    assertthat(spaceshipgettacticalstation())isequalto(tacticalstation)    //bug ↑ - different mocks are use in @mock and @injectmock  }}```this is using mockito 310 junit 560 and spring boot 530release || > im seeing this same bug when using `springextensionclass` along with `mockitoextensionclass`:> > ```> @extendwith({mockitoextensionclass springextensionclass})> public class injectmockstest {>   static class tacticalstation {}> >   static class spaceship {>     private final tacticalstation tacticalstation> >     public spaceship(final tacticalstation tacticalstation) {>       thistacticalstation  tacticalstation>     }> >     public tacticalstation gettacticalstation() {>       return tacticalstation>     }>   }> >   @injectmocks>   private spaceship spaceship> >   @mock>   private tacticalstation tacticalstation> >   @test>   public void shouldinjectmocks() {>     assertthat(tacticalstation)isnotnull()>     assertthat(spaceshipgettacticalstation())isequalto(tacticalstation)>     //bug ↑ - different mocks are use in @mock and @injectmock>   }> }> ```> > this is using mockito 310 junit 560 and spring boot 530releaseyes i am also facing this issue mine is also exactly the same scenario below are my dependenciesorgjunitjupiter:junit-jupiter-engine spring-boot-starter spring-boot-starter-test mockito-junit-jupiter:310 ||;1;0;1346 - different mocks are used for @mock and @injectmock in the same test class with junit 5 extension;
1350;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix npe on selecting invalid jstyle;follow up from #1294   npe was raised in comparator because name was initialized with null instead of empty string only store preferences if style is valid  @oscargus  the fix has the side effect that a file where the name can not be parsed correctly is displayed as  empty style . i attached the problematic style file which was provided in #1294  however: valid still returns true.  as you have worked recently with the styles things  do you know what is required for a jstyle? @koppor  maybe you know this? then we could improved the validity check   [campus_format.english.txt]( ![emptyjstyle](https://cloud.ent.com/assets/320228/14995084/4d8c3a3e-1173-11e6-8eb6-e8f5490ffa5e.png);;0;about presto configuration;hi i have 8 machines(centos65) with 32 cores and 220g memory of each machine，i wonder how to configure presto my configuration is below:configurepropertis of server:coordinatortruenode-schedulerinclude-coordinatorfalse of worker:coordinatorfalse of all:-server-xmx150g-xms150g-xx:+useconcmarksweepgc-xx:+explicitgcinvokesconcurrent-xx:+cmsclassunloadingenabled-xx:+aggressiveopts-xx:+heapdumponoutofmemoryerror-xx:onoutofmemoryerrorkill -9 %p-xx:permsize2048m-xx:maxpermsize51200m-xx:reservedcodecachesize2048m-xbootclasspath/p:/home/hadoop/presto/presto-server-069/lib/floatingdecimal-01jarwith above configuration i used tpc-ds to generate 2tb data and run some of tpc-ds queries  it failed for most time and it took longer time to execute queriesdoes anybody help me out? and what is wrong with my configuration and any suggestion?thx;closing this as the issue is being discussed on the group ||;;;;0;1;;
1350;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix npe on selecting invalid jstyle;follow up from #1294   npe was raised in comparator because name was initialized with null instead of empty string only store preferences if style is valid  @oscargus  the fix has the side effect that a file where the name can not be parsed correctly is displayed as  empty style . i attached the problematic style file which was provided in #1294  however: valid still returns true.  as you have worked recently with the styles things  do you know what is required for a jstyle? @koppor  maybe you know this? then we could improved the validity check   [campus_format.english.txt]( ![emptyjstyle](https://cloud.ent.com/assets/320228/14995084/4d8c3a3e-1173-11e6-8eb6-e8f5490ffa5e.png);;0;baseline performance tests;start of suite of general performance tests for comparing overall changes;#1263 ;;;;1;1;baseline performance testsstart of suite of general performance tests for comparing overall changes;
1350;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix npe on selecting invalid jstyle;follow up from #1294   npe was raised in comparator because name was initialized with null instead of empty string only store preferences if style is valid  @oscargus  the fix has the side effect that a file where the name can not be parsed correctly is displayed as  empty style . i attached the problematic style file which was provided in #1294  however: valid still returns true.  as you have worked recently with the styles things  do you know what is required for a jstyle? @koppor  maybe you know this? then we could improved the validity check   [campus_format.english.txt]( ![emptyjstyle](https://cloud.ent.com/assets/320228/14995084/4d8c3a3e-1173-11e6-8eb6-e8f5490ffa5e.png);;1348.0;support local parameters in test methods with junit jupiter;note that this implementation differs from the prototype implementation of the junitteam ( instead it will do not do any parameter resolution between test methods1348;" merging 1350  || ";support @mock injection in junit 5 method parameters;"junit 5 has the ability to ""inject"" parameters into test methods via an extensible ``parameterresolver`` interface  the junit 5 users guide provides an example that shows how such a ``parameterresolver`` can supply mock objects as test parameters as follows (shamelessly copied from  mymockitotest {    @beforeeach    void init(@mock person person) {        when(persongetname())thenreturn(""dilbert"")    }    @test    void simpletestwithinjectedmock(@mock person person) {        assertequals(""dilbert"" persongetname())    }}```the prototype ``mockitoextension`` provided in the junit 5 samples project shows a simple implementation of the required ``supportsparameter()`` and ``resolveparameter()`` methods (see:  ]   add the ability to inject mock objects into test method parameters to the official ``mockitoextension``  references #445";"i am 👍 for this feature with the following use case:initialization of local variable mocks previously this would be `mock<generic> mock  mock(mockclass)` however this loses the type-signature of `generic` with parameter mocks we can do `@mock mock<generic> mock` and still maintain the generic type signature || i should also note that i havent personally used parameter resolution the way its shown above  our team generally either injects the mock object at the class level and configures it in ``@beforeeach`` **or** we inject the mock object in the test method and configure it at the top of the test methods block || yes agreed rather than some ""magic"" shared by methods i think a generics-type-safe replacement for local mock initialization is a lot better || i just edited the description of this issue to include a link to the sample ``mockitoextension`` (i had intended to provide that reference originally)  i dont know if id refer to the the methods sharing the parameter instance as ""magic"" but without looking at the code it certainly isnt clear that the parameters are the shared if the types and names match  i definitely think that there are use-cases for this technique and the use of ``extensioncontextstore`` is a great way to provide references to objects from different methods  my main concern is that when there is a name collision and the types match you might end up with behavior thats really hard to understand (without knowing how the underlying extension works)im not sure im a fan of the syntax you described above as it seems more redundant than ``@mock myweirdthing myweirdmock`` - im guessing im misunderstanding your intention (i get the erasure part) || in junit 4 local mock initialization would be ```javaclass test {  @test  public void test() {    mock<string> mock  mockitomock(mockclass)  }  class mock<t> {}}```this would issue a warning saying that the generic type of `string` is not correctly created  mockitomock` (even though we know that our mocks will work)with this feature in junit 5 we can have:```javaclass test {  @test  public void test(@mock mock<string> mock) {  }  class mock<t> {}}```and the compiler will not warn any longer || i dont remember ever seeing that warning - perhaps because ive always used the mockito runner or rule? || correct you do not get that warning when using the runner but then you have mocks that are used in every single test this targets the use case where you need 1 extra mock in only 1 testcase || and if the ``mockitoextension`` is the junit 5 replacement for the runner or rule why wouldnt those warnings also be suppressed? || because the point of mock initialization is different junit 4 only supported for attributes we are now talking about method parameters hopefully when i implement this logic it is more clear to you 😄  || im not trying to be argumentative  but as a pretty heavy user of the prototype ``mockitoextension`` in the  project wed have a lot of tests to update with this syntax  well also need to make sure the example in the users guide and (if theyre kept) the code in the junit-samples project matches the official implementation  at this point i should probably let junit-team (i wish i could use a mention here) coordinate that with you@sbrannen @marcphilipp @sormuras || looking at the source of  i think we should be fine i will let you know when the pr is open so that you can test that outone note: the mockito team was not involved with the development of the prototype but i think we will approach very similar capabilities || i was looking at  because its got a bunch of use cases including test-local mocks and the ""magic"" you referred to above  thinking though the syntax change youre describing ill assume that the tests would still run but with the same warning?i do realize that the mockito team didnt produce the prototype and it would be unrealistic to think that you should be permanently limited by it architecturally  i did however think that the syntax ""proposed"" by the prototype was consistent with the field injection that already existed in mockito  im going to assume that what is produced as the official extension will be well integrated and well maintained - and i never complain about stable tooling! || opened #1350 with a proposal implementation || okay to write down the reason i think mock sharing by parameter is not a good idea:first of all there is a lot of duplicate code for every test method you need to list the mocks which results in duplicate rather using fields for these mocks removes the duplicationsecondly by relying on fields the compiler will complain when you make a typo (or change a type) with parameters you rely on the name (string-based) and the type declared both are not compiler safelastly because you can rely on fields refactoring is a lot easier as ides support renaming by field this is not possible for parametersfor these 3 reasons i see field mock sharing superior to parameter mock sharing and am therefore against introducing this logic in the parameter resolution || > for these 3 reasons i see field mock sharing superior to parameter mock sharing and am therefore against introducing this logic in the parameter resolutioni totally understand the rationale  what about support for `@spy` and `@captor`? should new issues be created or can it be part of this one? || `@spy` makes no sense as it requires a concrete instance `@captor` could be done lets discuss that in a different issue :+1: as this issue has been resolved || my memory was incorrect as #1350 has not been merged yet || >`@spy` makes no senseyou are completely right 😄ive created #1382 for adding support for `@captor` || theres `mockitospy(class)` which would work for a method parameter || @marcphilipp ah yes i see now not sure how useful that actually is as i only learned today we expose that api 😂  || ";1;0;merge branch release/2x into junit-jupiter-parameter-resolution;
1355;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;update preview panel on generate bibtexkey;fix for #1353 fixed some missing unlocks some formatting -  ;;0;bimapgetkey(value); hii would like to see a new method in bimap offering the capability to get from a given value the corresponding key (getkey(value)) this functionality is offered with bidimap from apache commons-collections but bimap is in general a cleaner solution than the bidimapsee: http://commonsapacheorg/proper/commons-collections/javadocs/api-release/org/apache/commons/collections/bidimaphtml; probably? definitely--- ;;;;0;1;;
1355;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;update preview panel on generate bibtexkey;fix for #1353 fixed some missing unlocks some formatting -  ;;0;use javalangmethodhandleslookup::defineclass;use javalangmethodhandleslookup::defineclass if this mechanism is available on the current jvm this might not work when interoperating with foreign modules if those modules do not open and export their types most prominently the java core modules where there are introduced issues with serializationthis introduces a change in behavior for mockito when using java 9+ unfortunately i think that this is necessary for mockito to continue to function after introduction of the jpms for now it seems like this limitation only affects working with serializability in combination with platform types what is not too bad but there is a chance that we will discover issues once this new mechanism is picked up by the community; merging 1355 ;;;;1;1;added more documentation and refined exception;
1355;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;update preview panel on generate bibtexkey;fix for #1353 fixed some missing unlocks some formatting -  ;;0;implement simple version of greatest/least;only 2-arg versions for common types: double bigint timestamp (with tz) dateonce we support varargs well replace them with a generic version;" have we decided to go with oracle semantics for nulls?> on jun 3 2014 at 10:19 pm martin traverso notifications@githubcom wrote:> > only 2-arg versions for common types: double bigint timestamp (with tz) date> > once we support varargs well replace them with a generic version> > you can merge this pull request by running> >   git pull  greatest> or view comment on or merge it at:> >    > commit summary> > implement simple version of greatest/least> file changes> > m presto-main/src/main/java/com/facebook/presto/operator/scalar/datetimefunctionsjava (48)> m presto-main/src/main/java/com/facebook/presto/operator/scalar/mathfunctionsjava (43)> m presto-main/src/main/java/com/facebook/presto/operator/scalar/stringfunctionsjava (16)> m presto-main/src/test/java/com/facebook/presto/operator/scalar/testmathfunctionsjava (51)> m presto-main/src/test/java/com/facebook/presto/type/testdatejava (14)> m presto-main/src/test/java/com/facebook/presto/type/testtimestampjava (14)> m presto-main/src/test/java/com/facebook/presto/type/testtimestampwithtimezonejava (18)> patch links:> >   —> reply to this email directly or view it on github || give equality rules for timestamp with timezone i think it should return the first argument if they compare equal whole technically arbitrary this is makes more sense> on jun 3 2014 at 10:19 pm martin traverso notifications@githubcom wrote:> > only 2-arg versions for common types: double bigint timestamp (with tz) date> > once we support varargs well replace them with a generic version> > you can merge this pull request by running> >   git pull  greatest> or view comment on or merge it at:> >    > commit summary> > implement simple version of greatest/least> file changes> > m presto-main/src/main/java/com/facebook/presto/operator/scalar/datetimefunctionsjava (48)> m presto-main/src/main/java/com/facebook/presto/operator/scalar/mathfunctionsjava (43)> m presto-main/src/main/java/com/facebook/presto/operator/scalar/stringfunctionsjava (16)> m presto-main/src/test/java/com/facebook/presto/operator/scalar/testmathfunctionsjava (51)> m presto-main/src/test/java/com/facebook/presto/type/testdatejava (14)> m presto-main/src/test/java/com/facebook/presto/type/testtimestampjava (14)> m presto-main/src/test/java/com/facebook/presto/type/testtimestampwithtimezonejava (18)> patch links:> >   —> reply to this email directly or view it on github || yes oracle nulls (any null in input > null output)-ericfrom: david phillips <notifications@githubcom<mailto:notifications@githubcom>>reply-to: facebook/presto <reply@replygithubcom<mailto:reply@replygithubcom>>date: tuesday june 3 2014 11:43 pmto: facebook/presto <presto@noreplygithubcom<mailto:presto@noreplygithubcom>>cc: facebook <ehwang@fbcom<mailto:ehwang@fbcom>>subject: re: [presto] implement simple version of greatest/least (#1355)have we decided to go with oracle semantics for nulls?> on jun 3 2014 at 10:19 pm martin traverso <notifications@githubcom<mailto:notifications@githubcom>> wrote:> > only 2-arg versions for common types: double bigint timestamp (with tz) date> > once we support varargs well replace them with a generic version> > you can merge this pull request by running> > git pull  greatest> or view comment on or merge it at:> >  > commit summary> > implement simple version of greatest/least> file changes> > m presto-main/src/main/java/com/facebook/presto/operator/scalar/datetimefunctionsjava (48)> m presto-main/src/main/java/com/facebook/presto/operator/scalar/mathfunctionsjava (43)> m presto-main/src/main/java/com/facebook/presto/operator/scalar/stringfunctionsjava (16)> m presto-main/src/test/java/com/facebook/presto/operator/scalar/testmathfunctionsjava (51)> m presto-main/src/test/java/com/facebook/presto/type/testdatejava (14)> m presto-main/src/test/java/com/facebook/presto/type/testtimestampjava (14)> m presto-main/src/test/java/com/facebook/presto/type/testtimestampwithtimezonejava (18)> patch links:> >   —> reply to this email directly or view it on github—reply to this email directly or view it on github || i wouldnt say were going with ""oracle semantics"" but rather that were going with semantics that are consistent with sql and everything else we do in presto given that null means ""unknown"" calling greatest/least with a null as an argument _must_ return ""unknown"" || ";;;;0;1;;
1355;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;update preview panel on generate bibtexkey;fix for #1353 fixed some missing unlocks some formatting -  ;;0;dont add the subscriber to the manager if it unsubscribed during the on;start callthis may happen for example when subscribing to a replaysubject containing some elements and taking fewer elements than available in the original the logic opened a small window where the subjectsubscriber could get an onnext event even if the actual subscriber was already unsubscribed at that point;#1274 ;;;;1;1;dont add the subscriber to the manager if it unsubscribed during the onstart call;
1368;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;removed possibility to automatically add braces via option - preferen…;…ces - file - store the following fields with braces around capital letters. please use save actions instead for adding braces automatically.  refs #1351;;0;more refactoring of aggregations;;we should be able to support any reference type using `objectbigarray`  the only issue seems to be size estimation  i think the key to that is to move the estimation of the values to the grouped state object instance  we would need to add a size estimator interface an annotation value to the property to specify the estimator  then the generated setter would be something like:``` java    private final objectbigarray<value> property_array    private final estimator<value> property_estimator    private long property_size    void setproperty(value v) {        property_size + property_estimatorestimate(v)        property_size - property_estimatorestimate(property_arrayreplace(groupid v))    }``` || let me know when you have an update || id rename the `@defaultvalue` to `@initial<type>value` || ;;;;0;1;;
1368;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;removed possibility to automatically add braces via option - preferen…;…ces - file - store the following fields with braces around capital letters. please use save actions instead for adding braces automatically.  refs #1351;;0;from rxjava observable to rxscala observable;hey scala folksim relatively new to scala so bear with me i need to convert from an rxjava observable over to scala since i want to expose it nicely the shortest way that i found is like:``` scala  override def openbucket(name: string password: string): observable[bucket]  {    new observable[openbucketresponse] {      coresend[openbucketresponse](new openbucketrequest(name password))    }map(_ > new couchbasebucket(core name password))  }```so with the `new observable[t]` style is there a quicker or nice way with imports or so? i need to do this quite often;maybe with the implicit import?``` scala  override def openbucket(name: string password: string): observable[bucket]  {    toscalaobservable(coresend[openbucketresponse](new openbucketrequest(name password)))      map(_ > new couchbasebucket(core name password))  }``` || yup thats the right approach note that `implicit def toscalaobservable[t](observable: rxobservable[_ <: t]): observable[t]` so depending on how lucky you are you may be able to trigger the implicit conversion to kick in and dont need to write `toscalaobservable` but i prefer the little extra explicitness || ;;;;0;1;;
1368;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;removed possibility to automatically add braces via option - preferen…;…ces - file - store the following fields with braces around capital letters. please use save actions instead for adding braces automatically.  refs #1351;;1367.0;resolve the correct protection domain for the codegen package when using reflection;1367; merging 1368 ` ;interface mock in a child class loader fails since mockito 2180;"mocking an interface in a child classloader fails if the interface was already mocked in a parent class loader after upgrading to 2180i cant currently provide a reproducer as tests pass in isolation the test failure can be observed only running the whole test suite the issue occurs only with 2180 2170 worksexception message:```mockito cannot mock this class: interface orgeclipsepersistencejpajpaentitymanagermockito can only mock non-private & non-final classesif youre not sure why youre getting this error please report to the mailing listjava               : 18jvm vendor name    : oracle corporationjvm vendor version : 25151-b12jvm name           : java hotspot(tm) 64-bit server vmjvm version        : 180_151-b12jvm info           : mixed modeos name            : mac os xos version         : 10134underlying exception : javalangillegalstateexception: error invoking javalangclassloader#defineclass	at orgspringframeworkdatajpaproviderpersistenceproviderunittestsmockproviderspecificentitymanagerinterface(persistenceproviderunittestsjava:88)	at orgspringframeworkdatajpaproviderpersistenceproviderunittestsdetectseclipselinkpersistenceprovider(persistenceproviderunittestsjava:58)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)	at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)	at orgjunitinternalrunnersstatementsrunbeforesevaluate(runbeforesjava:26)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orgapachemavensurefirejunit4junit4providerexecute(junit4providerjava:236)	at orgapachemavensurefirejunit4junit4providerexecutetestset(junit4providerjava:134)	at orgapachemavensurefirejunit4junit4providerinvoke(junit4providerjava:113)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orgapachemavensurefireutilreflectionutilsinvokemethodwitharray(reflectionutilsjava:189)	at orgapachemavensurefirebooterproviderfactory$providerproxyinvoke(providerfactoryjava:165)	at orgapachemavensurefirebooterproviderfactoryinvokeprovider(providerfactoryjava:85)	at orgapachemavensurefirebooterforkedbooterrunsuitesinprocess(forkedbooterjava:103)	at orgapachemavensurefirebooterforkedbootermain(forkedbooterjava:74)caused by: javalangillegalstateexception: error invoking javalangclassloader#defineclass	at netbytebuddydynamicloadingclassinjector$usingreflection$dispatcher$directdefineclass(classinjectorjava:413)	at netbytebuddydynamicloadingclassinjector$usingreflectioninject(classinjectorjava:186)	at netbytebuddydynamicloadingclassloadingstrategy$default$injectiondispatcherload(classloadingstrategyjava:199)	at netbytebuddydynamictyperesolutionstrategy$passiveinitialize(typeresolutionstrategyjava:79)	at netbytebuddydynamicdynamictype$default$unloadedload(dynamictypejava:4225)	at orgmockitointernalcreationbytebuddysubclassbytecodegeneratormockclass(subclassbytecodegeneratorjava:124)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:37)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:34)	at netbytebuddytypecachefindorinsert(typecachejava:137)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:345)	at netbytebuddytypecachefindorinsert(typecachejava:160)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:354)	at orgmockitointernalcreationbytebuddytypecachingbytecodegeneratormockclass(typecachingbytecodegeneratorjava:32)	at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemocktype(subclassbytebuddymockmakerjava:71)	at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemock(subclassbytebuddymockmakerjava:42)	at orgmockitointernalcreationbytebuddybytebuddymockmakercreatemock(bytebuddymockmakerjava:25)	at orgmockitointernalutilmockutilcreatemock(mockutiljava:35)	at orgmockitointernalmockitocoremock(mockitocorejava:65)	at orgmockitomockitomock(mockitojava:1875)	at orgmockitomockitomock(mockitojava:1784)	 32 morecaused by: javalangsecurityexception: class ""orgmockitocodegenjpaentitymanager$mockitomock$2038182397""s signer information does not match signer information of other classes in the same package	at javalangclassloadercheckcerts(classloaderjava:898)	at javalangclassloaderpredefineclass(classloaderjava:668)	at javalangclassloaderdefineclass(classloaderjava:761)	at sunreflectgeneratedmethodaccessor28invoke(unknown source)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at netbytebuddydynamicloadingclassinjector$usingreflection$dispatcher$directdefineclass(classinjectorjava:409)	 51 more```link to test code:[persistenceproviderunittestsjava](https://githubcom/spring-projects/spring-data-jpa/blob/70d1012ac3ae12f7c7ad4060318ac61a8059db19/src/test/java/org/springframework/data/jpa/provider/persistenceproviderunittestsjava#l83)";@raphw probably yet another edge-case in bytebuddy    || ah of course we must not define a protection domain for the codegen package anymore since we have already defined a class in this package in order to resolve the method handle lookup in case of java 11 where the class now has mockitos protection domainthat is a trivial fix ||;1;0;resolve the correct protection domain for the codegen package when using reflection;
1369;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;1313: remove ui as the checkbox is no longer backed by a config …;…option  see #1313;;0;r14 jdk5 backport; kurt you were on the hook for this for some reason right?; appears to be working just fine  we plan on including it in our upcoming release  ;;;;0;1;;
1369;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;1313: remove ui as the checkbox is no longer backed by a config …;…option  see #1313;;0;add presto verifier;;;;;;0;1;;
1369;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;1313: remove ui as the checkbox is no longer backed by a config …;…option  see #1313;;0;debughook got miswired before;this was throwing classcastexceptions when used  now it works;#1295 ;;;;1;1;debughook got miswired before;
1369;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;1313: remove ui as the checkbox is no longer backed by a config …;…option  see #1313;;1364.0;performance improvements;use less expensive method graph compiler for inline mock maker update byte buddy for general performance improvements and bug fixes 1364 also fixes javadoc warning; merging 1369  < ;unable to mock interfaces in android instrumentation tests;"consider the following android instrumentation test:```@testpublic void testmockito() {    final collection mockcollection  mockitomock(collectionclass)    assertasserttrue(true)}```when run i see the following output:```testing started at 21:54 04/08 21 01: launching testmockito()no apk changes detected since last installation skipping installation of d:\code\testapp\app\build\outputs\apk\debug\app-debugapk$ adb push d:\code\testapp\app\build\outputs\apk\androidtest\debug\app-debug-androidtestapk /data/local/tmp/comexamplezolbrtestapptest$ adb shell pm install -t -r ""/data/local/tmp/comexamplezolbrtestapptest""successrunning tests$ adb shell am instrument -w -r   -e debug false -e class comexamplezolbrtestappexampleinstrumentedtest#testmockito comexamplezolbrtestapptest/androidsupporttestrunnerandroidjunitrunnerclient not ready yetstarted running testsorgmockitoexceptionsbasemockitoexception:mockito cannot mock this class: interface javautilcollectionmockito can only mock non-private & non-final classesif youre not sure why youre getting this error please report to the mailing listimportant information for android users:the regular byte buddy mock makers cannot generate code on an android vm!to resolve this please use the mockito-android dependency for your application:               : 09jvm vendor name    : the android projectjvm vendor version : 210jvm name           : dalvikjvm version        : 09jvm info           : nullos name            : linuxos version         : 31856+underlying exception : javalangillegalargumentexception: could not create typeat comexamplezolbrtestappexampleinstrumentedtesttestmockito(exampleinstrumentedtestjava:40)at javalangreflectmethodinvoke(native method)at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)at orgjunitrunnerssuiterunchild(suitejava:128)at orgjunitrunnerssuiterunchild(suitejava:27)at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)at orgjunitrunnerjunitcorerun(junitcorejava:137)at orgjunitrunnerjunitcorerun(junitcorejava:115)at androidsupporttestinternalrunnertestexecutorexecute(testexecutorjava:58)at androidsupporttestrunnerandroidjunitrunneronstart(androidjunitrunnerjava:375)at androidappinstrumentation$instrumentationthreadrun(instrumentationjava:2074)caused by: javalangillegalargumentexception: could not create typeat netbytebuddytypecachefindorinsert(typecachejava:139)at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:345)at netbytebuddytypecachefindorinsert(typecachejava:160)at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:354)at orgmockitointernalcreationbytebuddytypecachingbytecodegeneratormockclass(typecachingbytecodegeneratorjava:32)at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemocktype(subclassbytebuddymockmakerjava:71)at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemock(subclassbytebuddymockmakerjava:42)at orgmockitoandroidinternalcreationandroidbytebuddymockmakercreatemock(androidbytebuddymockmakerjava:39)at orgmockitointernalutilmockutilcreatemock(mockutiljava:35)at orgmockitointernalmockitocoremock(mockitocorejava:65)at orgmockitomockitomock(mockitojava:1875)at orgmockitomockitomock(mockitojava:1784) 28 morecaused by: javalangincompatibleclasschangeerror: the method int javalangobjecthashcode() was expected to be of type interface but instead was found to be of type virtual (declaration of netbytebuddydynamicscaffoldmethodregistry$handler$forimplementation appears in /data/app/comexamplezolbrtestapptest-ovcvugjejp8cyf6lgyt9pg/baseapk)at netbytebuddydynamicscaffoldmethodregistry$handler$forimplementationhashcode(unknown source:2)at javautilhashmaphash(hashmapjava:338)at javautilhashmapput(hashmapjava:611)at javautilhashsetadd(hashsetjava:219)at netbytebuddydynamicscaffoldmethodregistry$defaultprepare(methodregistryjava:409)at netbytebuddydynamicscaffoldsubclasssubclassdynamictypebuildermake(subclassdynamictypebuilderjava:162)at netbytebuddydynamicscaffoldsubclasssubclassdynamictypebuildermake(subclassdynamictypebuilderjava:155)at netbytebuddydynamicdynamictype$builder$abstractbasemake(dynamictypejava:2669)at orgmockitointernalcreationbytebuddysubclassbytecodegeneratormockclass(subclassbytecodegeneratorjava:123)at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:37)at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:34)at netbytebuddytypecachefindorinsert(typecachejava:137) 39 more```this only occurs when using mockito-android 2180:```androidtestimplementation orgmockito:mockito-android:2180```downgrading to 2170 fixes this issuethis occurs on a windows 10 dev machine running android studio 31";"this appears to be regression introduced in bytebuddy @raphw would you mind investigating? || i have same question can anyone help? || i identified the issue it has to do how hashcode and equals are invoked on interface types openjdk allows for a different convention then what android accepts i will fix that with the next release stick to the old version until then (it is already  on master for byte buddy but it is part of the build routine) || should be fixed in 2182 || when will 2182 be available? my project is unable to pick this version up:```failed to resolve: orgmockito:mockito-core:2181show in fileshow in project structure dialog```which makes sense since from the looks of it there is no `ci maven-central-release` commit for 2182 || it is availble on bintray you can add the bintray repository to yourpomxml to find iton wed 18 apr 2018 04:05 zach olbrys <notifications@githubcom> wrote:> when will 2182 be available? my project is unable to pick this version> up:>> failed to resolve: orgmockito:mockito-core:2181> show in file> show in project structure dialog>> which makes sense since from the looks of it there is no ci> maven-central-release commit for 2182>> —> you are receiving this because you commented>>> reply to this email directly view it on github> < or mute the thread> < > || ive downloaded the jar from here:  and added it to my project but the problem persists || with the same exception message? || stacktrace:```orgmockitoexceptionsbasemockitoexception:mockito cannot mock this class: interface comexampleiexamplemockito can only mock non-private & non-final classesif youre not sure why youre getting this error please report to the mailing listimportant information for android users:the regular byte buddy mock makers cannot generate code on an android vm!to resolve this please use the mockito-android dependency for your application:               : 09jvm vendor name    : the android projectjvm vendor version : 210jvm name           : dalvikjvm version        : 09jvm info           : nullos name            : linuxos version         : 4488-gda039c93611cunderlying exception : javalangillegalargumentexception: could not create typeat comexampleexampletest<init>(exampletestkt:35)at javalangreflectconstructornewinstance0(native method)at javalangreflectconstructornewinstance(constructorjava:334)at orgjunitrunnersblockjunit4classrunnercreatetest(blockjunit4classrunnerjava:217)at orgjunitrunnersblockjunit4classrunner$1runreflectivecall(blockjunit4classrunnerjava:266)at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)at orgjunitrunnersblockjunit4classrunnermethodblock(blockjunit4classrunnerjava:263)at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)at orgjunitrunnerssuiterunchild(suitejava:128)at orgjunitrunnerssuiterunchild(suitejava:27)at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)at orgjunitrunnerjunitcorerun(junitcorejava:137)at orgjunitrunnerjunitcorerun(junitcorejava:115)at androidsupporttestinternalrunnertestexecutorexecute(testexecutorjava:58)at androidsupporttestrunnerandroidjunitrunneronstart(androidjunitrunnerjava:375)at androidappinstrumentation$instrumentationthreadrun(instrumentationjava:2075)caused by: javalangillegalargumentexception: could not create typeat netbytebuddytypecachefindorinsert(typecachejava:140)at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:346)at netbytebuddytypecachefindorinsert(typecachejava:161)at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:355)at orgmockitointernalcreationbytebuddytypecachingbytecodegeneratormockclass(typecachingbytecodegeneratorjava:32)at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemocktype(subclassbytebuddymockmakerjava:71)at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemock(subclassbytebuddymockmakerjava:42)at orgmockitoandroidinternalcreationandroidbytebuddymockmakercreatemock(androidbytebuddymockmakerjava:39)at orgmockitointernalutilmockutilcreatemock(mockutiljava:35)at orgmockitointernalmockitocoremock(mockitocorejava:63)at orgmockitomockitomock(mockitojava:1729)at orgmockitomockitomock(mockitojava:1642) 28 morecaused by: javalangabstractmethoderror: abstract method ""netbytebuddydynamicloadingclassloadingstrategy orgmockitointernalcreationbytebuddysubclassloadergetstrategy(javalangclass)""at orgmockitointernalcreationbytebuddysubclassbytecodegeneratormockclass(subclassbytecodegeneratorjava:94)at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:37)at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:34)at netbytebuddytypecachefindorinsert(typecachejava:138) 39 more``` || it seems like you are using a new version of mockito core but an old version of mockito android we had to change an internal api that both versions require to communicate to fix another bug || ";1;0;performance improvements: use less expensive method graph compiler for inline mock maker update byte buddy for general performance improvements and bug fixes 1364 also fixes javadoc warning;
1377;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;merge master into javafx branch;<describe the changes you have made here:   > -   -   -   ();;0;iterable over an java array; i would suggest to add a method&nbsp&nbsp&nbspiterablesforarray(t )similar to iteratorsforarray(); @﻿pete> i didnt know that the impl for new arraylist(array) is _that_ efficient :-)careful there are two flavors of arraylist: javautilarraylist and javautilarrays$arraylistthe latter can only be instantiated through arraysaslist(array) and is a live view the former does not have an array constructor and it makes a copy of any data passed to the constructor ||;;;;0;1;;
1377;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;merge master into javafx branch;<describe the changes you have made here:   > -   -   -   ();;0;update byte buddy and cache some expensive values;this avoids the reallocation of certain objects that are expensive to compute also byte buddy is updated; merging 1377 ;;;;1;1;update byte buddy and cache some expensive values;
1377;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;merge master into javafx branch;<describe the changes you have made here:   > -   -   -   ();;0;add json_tuple function;a function similar to hives json_tuple function would be useful for extracting multiple values at once from a json string please see  table generating functions in general seems like a pretty big task but maybe there is a simpler way to implement json_tuple without full tgf support;is rewriting a query with json_tuple call as a query with multiple json_extract_scalar calls possible with the current source base? or it there even an easier way to implement a function that returns multiple columns with a single expression in a select statement? || rebased & opened a new pr #1724 ||;;;;0;1;;
1377;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;merge master into javafx branch;<describe the changes you have made here:   > -   -   -   ();;0;utility class for accessing unsafe;while working on code for v020 i have come across reasons for using sunmiscunsafe (such as #1372)this provides a common way for getting access to `sunmiscunsafe` as well as utility methods for commonly needed apis (that exist in java 8 but not java 6)i need someone to help me confirm whether this works on android and if not how we can make this be aware of what platform it is running on as per https://githubcom/netflix/rxjava/issues/1372#issuecomment-46717293;"/cc @daschl @akarnokd@mttkay will this work on android? if not can you provide some guidance please? || #1316  how do you get the object field offset or array offsets?i have mixed feelings about the implementation since intrinsics applied to incrementandget and co provide better performance automagically on later javas but we lock us out of it || @akarnokd you get the offset via `unsafe` though ive considered adding utility methods on `unsafeaccess` itself:``` java        private volatile indexsection next        private static final long _nextoffset        static {            try {                _nextoffset  unsafeaccessunsafeobjectfieldoffset(indexsectionclassgetdeclaredfield(""next""))            } catch (exception ex) {                throw new error(ex)            }        }``` || @nitsanw what is the right way to use `unsafe` when java 6 must be supported while not breaking performance optimizations done in java 7/8? particularly the question by @akarnokd above:> i have mixed feelings about the implementation since intrinsics applied to incrementandget and co provide better performance automagically on later javas but we lock us out of it || @benjchristensen for most methods i use on unsafe this is not an issue for incrementandget and getandset there were new intrinsics added in jdk8 you could support those via an unsafe wrapper with an implementation decided at runtime or by resorting to the field updater in these specific casesusing unsafe is wrong so theres no official right way to do this || ";;;;0;1;;
1378;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;avoid circularity: avoid endless loop during mock creation;if certain types a type for the first time during instrumentation while our mocking engine relies on the same types  this can cause a circularity as checking if an instance is a mock requires instances of the latter types what again returns to the latter mock checking routine what causes an endless loop. (described in comment.) 1240.;;0;updates for pr #999 - window functions with arguments;- move specification of argument channels to window function construction- split commit into one that adds the feature and one that adds the functions- simplify `first_value` and `last_value` by writing the value directly from the input pages index- add `nth_value` function;nthvaluefunctionjava 62: - is not followed by whitespace || ;;;;0;1;;
1378;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;avoid circularity: avoid endless loop during mock creation;if certain types a type for the first time during instrumentation while our mocking engine relies on the same types  this can cause a circularity as checking if an instance is a mock requires instances of the latter types what again returns to the latter mock checking routine what causes an endless loop. (described in comment.) 1240.;;0;bugfix: pivot concurrency;it wasnt serializing the `onnext`;;;;;1;1;bugfix: pivot concurrency;
1378;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;avoid circularity: avoid endless loop during mock creation;if certain types a type for the first time during instrumentation while our mocking engine relies on the same types  this can cause a circularity as checking if an instance is a mock requires instances of the latter types what again returns to the latter mock checking routine what causes an endless loop. (described in comment.) 1240.;;1240.0;avoid circularity: avoid endless loop during mock creation;if certain types a type for the first time during instrumentation while our mocking engine relies on the same types this can cause a circularity as checking if an instance is a mock requires instances of the latter types what again returns to the latter mock checking routine what causes an endless loop (described in comment) 1240it is a bit difficult to reproduce this issue in our tests it mainly happens with classes generated by kotlin or scala and requires the inline mock maker and a jdk 9 or older if we want to add such a test we can copy the test from https://githubcom/guenhter/mockito-final-class-kotlin-problem;> if we want to add such a test we can copy the test from  should be able to add this to the mockito-kotlin subproject i suppose? || does it use the inline mock maker? || true of course! || added a test || does that test really reproduce the issue? that seems awfully simple yet we did not encounter it thus far 😮  ||  merging 1378  < ;mockito inline cant mock finatra response class;seen a few of these lying around but my stacktrace is also differenti was trying to mock the finatra `responsebuilder` class```you are seeing this disclaimer because mockito is configured to create inlined mocksyou can learn about inline mocks and their limitations under item #39 of the mockito class javadocunderlying exception : orgmockitoexceptionsbasemockitoexception: could not modify all classes [class comtwitterfinatra interface comtwitterinjectlogging interface comtwitterutillogginglogging]	at <testclassjava>	at sunreflectnativeconstructoraccessorimplnewinstance0(native method)	at sunreflectnativeconstructoraccessorimplnewinstance(nativeconstructoraccessorimpljava:62)	at sunreflectdelegatingconstructoraccessorimplnewinstance(delegatingconstructoraccessorimpljava:45)	at javalangreflectconstructornewinstance(constructorjava:423)	at orgjunitrunnersblockjunit4classrunnercreatetest(blockjunit4classrunnerjava:217)	at orgjunitrunnersblockjunit4classrunner$1runreflectivecall(blockjunit4classrunnerjava:266)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersblockjunit4classrunnermethodblock(blockjunit4classrunnerjava:263)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orggradleapiinternaltaskstestingjunitjunittestclassexecuterruntestclass(junittestclassexecuterjava:114)	at orggradleapiinternaltaskstestingjunitjunittestclassexecuterexecute(junittestclassexecuterjava:57)	at orggradleapiinternaltaskstestingjunitjunittestclassprocessorprocesstestclass(junittestclassprocessorjava:66)	at orggradleapiinternaltaskstestingsuitetestclassprocessorprocesstestclass(suitetestclassprocessorjava:51)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)	at orggradleinternaldispatchcontextclassloaderdispatchdispatch(contextclassloaderdispatchjava:32)	at orggradleinternaldispatchproxydispatchadapter$dispatchinginvocationhandlerinvoke(proxydispatchadapterjava:93)	at comsunproxy$proxy2processtestclass(unknown source)	at orggradleapiinternaltaskstestingworkertestworkerprocesstestclass(testworkerjava:109)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)	at orggradleinternalremoteinternalhubmessagehub$handlerrun(messagehubjava:377)	at orggradleinternalconcurrentexecutorpolicy$catchandrecordfailuresonexecute(executorpolicyjava:54)	at orggradleinternalconcurrentstoppableexecutorimpl$1run(stoppableexecutorimpljava:40)	at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)	at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)	at javalangthreadrun(threadjava:745)caused by: orgmockitoexceptionsbasemockitoexception: could not modify all classes [class comtwitterfinatra interface comtwitterinjectlogging interface comtwitterutillogginglogging]	at netbytebuddytypecachefindorinsert(typecachejava:138)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:346)	at netbytebuddytypecachefindorinsert(typecachejava:161)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:355)	 43 morecaused by: javalangunsupportedoperationexception: class redefinition failed: attempted to change the schema (add/remove fields)	at suninstrumentinstrumentationimplretransformclasses0(native method)	at suninstrumentinstrumentationimplretransformclasses(instrumentationimpljava:144)	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortriggerretransformation(inlinebytecodegeneratorjava:117)	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratormockclass(inlinebytecodegeneratorjava:97)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:37)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:34)	at netbytebuddytypecachefindorinsert(typecachejava:138)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:346)	at netbytebuddytypecachefindorinsert(typecachejava:161)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:355)	at orgmockitointernalcreationbytebuddytypecachingbytecodegeneratormockclass(typecachingbytecodegeneratorjava:32)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakercreatemocktype(inlinebytebuddymockmakerjava:201)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakercreatemock(inlinebytebuddymockmakerjava:182)	at orgmockitointernalutilmockutilcreatemock(mockutiljava:35)	at orgmockitointernalmockitocoremock(mockitocorejava:63)	at orgmockitomockitomock(mockitojava:1729)	at orgmockitomockitomock(mockitojava:1642)	 43 more```;"im also unable to mock a final class im using jdk 9 and the project is using kotlin im not sure if its a related issue i did try to do some debugging but to no avail interestingly only the first mock fails```kotlintry {    mock<worldcontext>()} catch (e: throwable) {}// successval a  mock<worldcontext>()```complete stacktrace:```mockito cannot mock this class: class iopolymorphicpandafauxecsworldcontextcan not mock final classes with the following settings : - explicit serialization (eg withsettings()serializable()) - extra interfaces (eg withsettings()extrainterfaces())you are seeing this disclaimer because mockito is configured to create inlined mocksyou can learn about inline mocks and their limitations under item #39 of the mockito class javadocunderlying exception : orgmockitoexceptionsbasemockitoexception: could not modify all classes [class javalangobject class iopolymorphicpandafauxecsworldcontext interface iopolymorphicpandafauxecscontext]orgmockitoexceptionsbasemockitoexception: mockito cannot mock this class: class iopolymorphicpandafauxecsworldcontextcan not mock final classes with the following settings : - explicit serialization (eg withsettings()serializable()) - extra interfaces (eg withsettings()extrainterfaces())you are seeing this disclaimer because mockito is configured to create inlined mocksyou can learn about inline mocks and their limitations under item #39 of the mockito class javadocunderlying exception : orgmockitoexceptionsbasemockitoexception: could not modify all classes [class javalangobject class iopolymorphicpandafauxecsworldcontext interface iopolymorphicpandafauxecscontext]	at iopolymorphicpandafauxecsworldspec$1$worldcontext$2invoke(worldspeckt:91)	at iopolymorphicpandafauxecsworldspec$1$worldcontext$2invoke(worldspeckt:18)	at orgjetbrainsspekenginelifecyclelifecycleawareadapterinvoke(lifecycleawareadapterkt:21)	at orgjetbrainsspekenginelifecyclelifecycleawareadaptergetvalue(lifecycleawareadapterkt:17)	at iopolymorphicpandafauxecsworldspec$1$world$2invoke(worldspeckt:37)	at iopolymorphicpandafauxecsworldspec$1$world$2invoke(worldspeckt:18)	at orgjetbrainsspekenginelifecyclelifecycleawareadapterinvoke(lifecycleawareadapterkt:21)	at orgjetbrainsspekenginelifecyclelifecycleawareadaptergetvalue(lifecycleawareadapterkt:17)	at iopolymorphicpandafauxecsworldspec$1$1invoke(worldspeckt:40)	at iopolymorphicpandafauxecsworldspec$1$1invoke(worldspeckt:18)	at orgjetbrainsspekenginespektestengine$collector$action$action$1invoke(spektestenginekt:175)	at orgjetbrainsspekenginespektestengine$collector$action$action$1invoke(spektestenginekt:133)	at orgjetbrainsspekenginescope$actionexecute(scopekt:48)	at orgjetbrainsspekenginescope$actionexecute(scopekt:32)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorlambda$execute$3(hierarchicaltestexecutorjava:83)	at orgjunitplatformenginesupporthierarchicalsingletestexecutorexecutesafely(singletestexecutorjava:66)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorexecute(hierarchicaltestexecutorjava:77)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorlambda$null$2(hierarchicaltestexecutorjava:92)	at javabase/javautilstreamforeachops$foreachop$ofrefaccept(foreachopsjava:184)	at javabase/javautilstreamreferencepipeline$2$1accept(referencepipelinejava:177)	at javabase/javautiliteratorforeachremaining(iteratorjava:133)	at javabase/javautilspliterators$iteratorspliteratorforeachremaining(spliteratorsjava:1801)	at javabase/javautilstreamabstractpipelinecopyinto(abstractpipelinejava:484)	at javabase/javautilstreamabstractpipelinewrapandcopyinto(abstractpipelinejava:474)	at javabase/javautilstreamforeachops$foreachopevaluatesequential(foreachopsjava:151)	at javabase/javautilstreamforeachops$foreachop$ofrefevaluatesequential(foreachopsjava:174)	at javabase/javautilstreamabstractpipelineevaluate(abstractpipelinejava:234)	at javabase/javautilstreamreferencepipelineforeach(referencepipelinejava:430)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorlambda$execute$3(hierarchicaltestexecutorjava:92)	at orgjunitplatformenginesupporthierarchicalsingletestexecutorexecutesafely(singletestexecutorjava:66)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorexecute(hierarchicaltestexecutorjava:77)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorlambda$null$2(hierarchicaltestexecutorjava:92)	at javabase/javautilstreamforeachops$foreachop$ofrefaccept(foreachopsjava:184)	at javabase/javautilstreamreferencepipeline$2$1accept(referencepipelinejava:177)	at javabase/javautiliteratorforeachremaining(iteratorjava:133)	at javabase/javautilspliterators$iteratorspliteratorforeachremaining(spliteratorsjava:1801)	at javabase/javautilstreamabstractpipelinecopyinto(abstractpipelinejava:484)	at javabase/javautilstreamabstractpipelinewrapandcopyinto(abstractpipelinejava:474)	at javabase/javautilstreamforeachops$foreachopevaluatesequential(foreachopsjava:151)	at javabase/javautilstreamforeachops$foreachop$ofrefevaluatesequential(foreachopsjava:174)	at javabase/javautilstreamabstractpipelineevaluate(abstractpipelinejava:234)	at javabase/javautilstreamreferencepipelineforeach(referencepipelinejava:430)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorlambda$execute$3(hierarchicaltestexecutorjava:92)	at orgjunitplatformenginesupporthierarchicalsingletestexecutorexecutesafely(singletestexecutorjava:66)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorexecute(hierarchicaltestexecutorjava:77)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorexecute(hierarchicaltestexecutorjava:51)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestengineexecute(hierarchicaltestenginejava:43)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:170)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:154)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:90)	at orgjetbrainsspektoolingrunnerjunitjunitplatformspekrunnerrun(junitplatformspekrunnerkt:107)	at orgjetbrainsspektoolingmainktmain(mainkt:58)caused by: orgmockitoexceptionsbasemockitoexception: could not modify all classes [class javalangobject class iopolymorphicpandafauxecsworldcontext interface iopolymorphicpandafauxecscontext]	at netbytebuddytypecachefindorinsert(typecachejava:138)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:346)	at netbytebuddytypecachefindorinsert(typecachejava:161)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:355)	 52 morecaused by: javalangillegalstateexception: byte buddy could not instrument all classes within the mocks type hierarchythis problem should never occur for javac-compiled classes this problem has been observed for classes that are: - compiled by older versions of scalac - classes that are part of the android distribution	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortriggerretransformation(inlinebytecodegeneratorjava:120)	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratormockclass(inlinebytecodegeneratorjava:97)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:37)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:34)	at netbytebuddytypecachefindorinsert(typecachejava:138)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:346)	at netbytebuddytypecachefindorinsert(typecachejava:161)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:355)	at orgmockitointernalcreationbytebuddytypecachingbytecodegeneratormockclass(typecachingbytecodegeneratorjava:32)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakercreatemocktype(inlinebytebuddymockmakerjava:200)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakercreatemock(inlinebytebuddymockmakerjava:181)	at orgmockitointernalutilmockutilcreatemock(mockutiljava:35)	at orgmockitointernalmockitocoremock(mockitocorejava:65)	at orgmockitomockitomock(mockitojava:1821)	 52 morecaused by: javalangclasscircularityerror: java/lang/weakpairmap$pair$weak	at javabase/javalangweakpairmap$pairweak(weakpairmapjava:201)	at javabase/javalangweakpairmapputifabsent(weakpairmapjava:123)	at javabase/javalangmoduleimpladdreads(modulejava:396)	at javabase/javalangmoduleimpladdreads(modulejava:357)	at javabase/javalangsystem$2addreads(systemjava:2146)	at javabase/jdkinternalmodulemodulesaddreads(modulesjava:85)	at javabase/javalangreflectproxy$proxybuilderlambda$getdynamicmodule$4(proxyjava:884)	at javabase/jdkinternalloaderabstractclassloadervalue$memoizerget(abstractclassloadervaluejava:327)	at javabase/jdkinternalloaderabstractclassloadervaluecomputeifabsent(abstractclassloadervaluejava:203)	at javabase/javalangreflectproxy$proxybuildergetdynamicmodule(proxyjava:875)	at javabase/javalangreflectproxy$proxybuildermaptomodule(proxyjava:814)	at javabase/javalangreflectproxy$proxybuilder<init>(proxyjava:631)	at javabase/javalangreflectproxy$proxybuilder<init>(proxyjava:636)	at javabase/javalangreflectproxylambda$getproxyconstructor$0(proxyjava:415)	at javabase/jdkinternalloaderabstractclassloadervalue$memoizerget(abstractclassloadervaluejava:327)	at javabase/jdkinternalloaderabstractclassloadervaluecomputeifabsent(abstractclassloadervaluejava:203)	at javabase/javalangreflectproxygetproxyconstructor(proxyjava:413)	at javabase/javalangreflectproxynewproxyinstance(proxyjava:999)	at javabase/sunreflectannotationannotationparser$1run(annotationparserjava:305)	at javabase/sunreflectannotationannotationparser$1run(annotationparserjava:303)	at javabase/javasecurityaccesscontrollerdoprivileged(native method)	at javabase/sunreflectannotationannotationparserannotationformap(annotationparserjava:303)	at javabase/sunreflectannotationannotationparserparseannotation2(annotationparserjava:293)	at javabase/sunreflectannotationannotationparserparseannotations2(annotationparserjava:120)	at javabase/sunreflectannotationannotationparserparseannotations(annotationparserjava:72)	at javabase/javalangreflectexecutabledeclaredannotations(executablejava:605)	at javabase/javalangreflectexecutabledeclaredannotations(executablejava:603)	at javabase/javalangreflectexecutablegetdeclaredannotations(executablejava:591)	at javabase/javalangreflectconstructorgetdeclaredannotations(constructorjava:579)	at netbytebuddydescriptionmethodmethoddescription$forloadedconstructorgetdeclaredannotations(methoddescriptionjava:912)	at netbytebuddydescriptionmethodmethoddescription$abstractbaseastoken(methoddescriptionjava:695)	at netbytebuddydescriptionmethodmethoddescription$abstractbaseastoken(methoddescriptionjava:334)	at netbytebuddydescriptionmethodmethodlist$abstractbaseastokenlist(methodlistjava:53)	at netbytebuddydynamicscaffoldinstrumentedtype$factory$default$1represent(instrumentedtypejava:223)	at netbytebuddybytebuddyredefine(bytebuddyjava:698)	at netbytebuddybytebuddyredefine(bytebuddyjava:676)	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortransform(inlinebytecodegeneratorjava:167)	at javainstrument/javalanginstrumentclassfiletransformertransform(classfiletransformerjava:246)	at javainstrument/suninstrumenttransformermanagertransform(transformermanagerjava:188)	at javainstrument/suninstrumentinstrumentationimpltransform(instrumentationimpljava:550)	at javabase/javalangweakpairmap$pairweak(weakpairmapjava:201)	at javabase/javalangweakpairmapputifabsent(weakpairmapjava:123)	at javabase/javalangmoduleimpladdreads(modulejava:396)	at javabase/javalangmoduleimpladdreads(modulejava:357)	at javabase/javalangsystem$2addreads(systemjava:2146)	at javabase/jdkinternalmodulemodulesaddreads(modulesjava:85)	at javabase/jdkinternalmodulemodulestransformedbyagent(modulesjava:166)	at javainstrument/suninstrumentinstrumentationimplretransformclasses0(native method)	at javainstrument/suninstrumentinstrumentationimplretransformclasses(instrumentationimpljava:157)	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortriggerretransformation(inlinebytecodegeneratorjava:117)	 65 more``` || we are seeing the same issue using jdk 9 and kotlin || same issue for jdk10 and kotlin (and java) || @raphw i’ve just tried `2173` from `dlbintraycom/mockito/maven` with `bytebuddy:181` and this kind of errors still happens this happened for me after migrating from jdk 8 to jdk 9 a coworker of mine updated his android studio from 30 to 31 and observes the same thing in ide (running tests via gradle works fine though) this version of as actually bundles jdk 8 but the updated revision (i guess) we’ve tried the `2173` as well with no luck || seems like some jdk internals were switched out such that byte buddy tries to instrument classes that it needs itself to apply the instrumentation this requiressome whitelisting on our side i believe || also seeing this when running tests for spek 2x (spekframework/spek#318) on jdk9  tried forcing the byte buddy version to 183 but the problem remained<details><summary>complete stacktrace</summary><p>```mockito cannot mock this class: class orgspekframeworkspek2runtimelifecyclelifecyclemanagercan not mock final classes with the following settings : - explicit serialization (eg withsettings()serializable()) - extra interfaces (eg withsettings()extrainterfaces())you are seeing this disclaimer because mockito is configured to create inlined mocksyou can learn about inline mocks and their limitations under item #39 of the mockito class javadocunderlying exception : orgmockitoexceptionsbasemockitoexception: could not modify all classes [class orgspekframeworkspek2runtimelifecyclelifecyclemanager class javalangobject]"" type""orgmockitoexceptionsbasemockitoexception""><![cdata[orgmockitoexceptionsbasemockitoexception: mockito cannot mock this class: class orgspekframeworkspek2runtimelifecyclelifecyclemanagercan not mock final classes with the following settings : - explicit serialization (eg withsettings()serializable()) - extra interfaces (eg withsettings()extrainterfaces())you are seeing this disclaimer because mockito is configured to create inlined mocksyou can learn about inline mocks and their limitations under item #39 of the mockito class javadocunderlying exception : orgmockitoexceptionsbasemockitoexception: could not modify all classes [class orgspekframeworkspek2runtimelifecyclelifecyclemanager class javalangobject]	at orgspekframeworkspek2junittestdescriptoradapterfactorytestsetup(testdescriptoradapterfactorytestkt:57)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javabase/javalangreflectmethodinvoke(methodjava:564)	at orgjunitplatformcommonsutilreflectionutilsinvokemethod(reflectionutilsjava:389)	at orgjunitjupiterengineexecutionexecutableinvokerinvoke(executableinvokerjava:115)	at orgjunitjupiterenginedescriptorclasstestdescriptorinvokemethodinextensioncontext(classtestdescriptorjava:289)	at orgjunitjupiterenginedescriptorclasstestdescriptorlambda$synthesizebeforeeachmethodadapter$11(classtestdescriptorjava:277)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorlambda$null$2(testmethodtestdescriptorjava:132)	at orgjunitjupiterengineexecutionthrowablecollectorexecute(throwablecollectorjava:40)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorinvokebeforemethodsorcallbacksuntilexceptionoccurs(testmethodtestdescriptorjava:152)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorinvokebeforeeachmethods(testmethodtestdescriptorjava:131)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorexecute(testmethodtestdescriptorjava:106)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorexecute(testmethodtestdescriptorjava:57)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorlambda$execute$3(hierarchicaltestexecutorjava:83)	at orgjunitplatformenginesupporthierarchicalsingletestexecutorexecutesafely(singletestexecutorjava:66)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorexecute(hierarchicaltestexecutorjava:77)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorlambda$null$2(hierarchicaltestexecutorjava:92)	at javabase/javautilstreamforeachops$foreachop$ofrefaccept(foreachopsjava:184)	at javabase/javautilstreamreferencepipeline$2$1accept(referencepipelinejava:177)	at javabase/javautiliteratorforeachremaining(iteratorjava:133)	at javabase/javautilspliterators$iteratorspliteratorforeachremaining(spliteratorsjava:1801)	at javabase/javautilstreamabstractpipelinecopyinto(abstractpipelinejava:484)	at javabase/javautilstreamabstractpipelinewrapandcopyinto(abstractpipelinejava:474)	at javabase/javautilstreamforeachops$foreachopevaluatesequential(foreachopsjava:151)	at javabase/javautilstreamforeachops$foreachop$ofrefevaluatesequential(foreachopsjava:174)	at javabase/javautilstreamabstractpipelineevaluate(abstractpipelinejava:234)	at javabase/javautilstreamreferencepipelineforeach(referencepipelinejava:430)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorlambda$execute$3(hierarchicaltestexecutorjava:92)	at orgjunitplatformenginesupporthierarchicalsingletestexecutorexecutesafely(singletestexecutorjava:66)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorexecute(hierarchicaltestexecutorjava:77)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorlambda$null$2(hierarchicaltestexecutorjava:92)	at javabase/javautilstreamforeachops$foreachop$ofrefaccept(foreachopsjava:184)	at javabase/javautilstreamreferencepipeline$2$1accept(referencepipelinejava:177)	at javabase/javautiliteratorforeachremaining(iteratorjava:133)	at javabase/javautilspliterators$iteratorspliteratorforeachremaining(spliteratorsjava:1801)	at javabase/javautilstreamabstractpipelinecopyinto(abstractpipelinejava:484)	at javabase/javautilstreamabstractpipelinewrapandcopyinto(abstractpipelinejava:474)	at javabase/javautilstreamforeachops$foreachopevaluatesequential(foreachopsjava:151)	at javabase/javautilstreamforeachops$foreachop$ofrefevaluatesequential(foreachopsjava:174)	at javabase/javautilstreamabstractpipelineevaluate(abstractpipelinejava:234)	at javabase/javautilstreamreferencepipelineforeach(referencepipelinejava:430)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorlambda$execute$3(hierarchicaltestexecutorjava:92)	at orgjunitplatformenginesupporthierarchicalsingletestexecutorexecutesafely(singletestexecutorjava:66)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorexecute(hierarchicaltestexecutorjava:77)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorexecute(hierarchicaltestexecutorjava:51)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestengineexecute(hierarchicaltestenginejava:43)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:170)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:154)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:90)	at orgjunitplatformconsoletasksconsoletestexecutorexecutetests(consoletestexecutorjava:65)	at orgjunitplatformconsoletasksconsoletestexecutorlambda$execute$0(consoletestexecutorjava:57)	at orgjunitplatformconsoletaskscustomcontextclassloaderexecutorinvoke(customcontextclassloaderexecutorjava:33)	at orgjunitplatformconsoletasksconsoletestexecutorexecute(consoletestexecutorjava:57)	at orgjunitplatformconsoleconsolelauncherexecutetests(consolelauncherjava:85)	at orgjunitplatformconsoleconsolelauncherexecute(consolelauncherjava:75)	at orgjunitplatformconsoleconsolelauncherexecute(consolelauncherjava:48)	at orgjunitplatformconsoleconsolelaunchermain(consolelauncherjava:40)caused by: orgmockitoexceptionsbasemockitoexception: could not modify all classes [class orgspekframeworkspek2runtimelifecyclelifecyclemanager class javalangobject]	at netbytebuddytypecachefindorinsert(typecachejava:137)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:345)	at netbytebuddytypecachefindorinsert(typecachejava:160)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:354)	 59 morecaused by: javalangillegalstateexception: byte buddy could not instrument all classes within the mocks type hierarchythis problem should never occur for javac-compiled classes this problem has been observed for classes that are: - compiled by older versions of scalac - classes that are part of the android distribution	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortriggerretransformation(inlinebytecodegeneratorjava:120)	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratormockclass(inlinebytecodegeneratorjava:97)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:37)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:34)	at netbytebuddytypecachefindorinsert(typecachejava:137)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:345)	at netbytebuddytypecachefindorinsert(typecachejava:160)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:354)	at orgmockitointernalcreationbytebuddytypecachingbytecodegeneratormockclass(typecachingbytecodegeneratorjava:32)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakercreatemocktype(inlinebytebuddymockmakerjava:200)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakercreatemock(inlinebytebuddymockmakerjava:181)	at orgmockitointernalutilmockutilcreatemock(mockutiljava:35)	at orgmockitointernalmockitocoremock(mockitocorejava:65)	at orgmockitomockitomock(mockitojava:1855)	 59 morecaused by: javalangclasscircularityerror: java/lang/weakpairmap$pair$weak	at javabase/javalangweakpairmap$pairweak(weakpairmapjava:201)	at javabase/javalangweakpairmapputifabsent(weakpairmapjava:123)	at javabase/javalangmoduleimpladdreads(modulejava:396)	at javabase/javalangmoduleimpladdreads(modulejava:357)	at javabase/javalangsystem$2addreads(systemjava:2146)	at javabase/jdkinternalmodulemodulesaddreads(modulesjava:85)	at javabase/javalangreflectproxy$proxybuilderlambda$getdynamicmodule$4(proxyjava:884)	at javabase/jdkinternalloaderabstractclassloadervalue$memoizerget(abstractclassloadervaluejava:327)	at javabase/jdkinternalloaderabstractclassloadervaluecomputeifabsent(abstractclassloadervaluejava:203)	at javabase/javalangreflectproxy$proxybuildergetdynamicmodule(proxyjava:875)	at javabase/javalangreflectproxy$proxybuildermaptomodule(proxyjava:814)	at javabase/javalangreflectproxy$proxybuilder<init>(proxyjava:631)	at javabase/javalangreflectproxy$proxybuilder<init>(proxyjava:636)	at javabase/javalangreflectproxylambda$getproxyconstructor$0(proxyjava:415)	at javabase/jdkinternalloaderabstractclassloadervalue$memoizerget(abstractclassloadervaluejava:327)	at javabase/jdkinternalloaderabstractclassloadervaluecomputeifabsent(abstractclassloadervaluejava:203)	at javabase/javalangreflectproxygetproxyconstructor(proxyjava:413)	at javabase/javalangreflectproxynewproxyinstance(proxyjava:999)	at javabase/sunreflectannotationannotationparser$1run(annotationparserjava:305)	at javabase/sunreflectannotationannotationparser$1run(annotationparserjava:303)	at javabase/javasecurityaccesscontrollerdoprivileged(native method)	at javabase/sunreflectannotationannotationparserannotationformap(annotationparserjava:303)	at javabase/sunreflectannotationannotationparserparseannotation2(annotationparserjava:293)	at javabase/sunreflectannotationannotationparserparseannotations2(annotationparserjava:120)	at javabase/sunreflectannotationannotationparserparseannotations(annotationparserjava:72)	at javabase/javalangreflectexecutabledeclaredannotations(executablejava:605)	at javabase/javalangreflectexecutabledeclaredannotations(executablejava:603)	at javabase/javalangreflectexecutablegetdeclaredannotations(executablejava:591)	at javabase/javalangreflectconstructorgetdeclaredannotations(constructorjava:579)	at netbytebuddydescriptionmethodmethoddescription$forloadedconstructorgetdeclaredannotations(methoddescriptionjava:917)	at netbytebuddydescriptionmethodmethoddescription$abstractbaseastoken(methoddescriptionjava:695)	at netbytebuddydescriptionmethodmethoddescription$abstractbaseastoken(methoddescriptionjava:334)	at netbytebuddydescriptionmethodmethodlist$abstractbaseastokenlist(methodlistjava:53)	at netbytebuddydynamicscaffoldinstrumentedtype$factory$default$1represent(instrumentedtypejava:223)	at netbytebuddybytebuddyredefine(bytebuddyjava:698)	at netbytebuddybytebuddyredefine(bytebuddyjava:676)	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortransform(inlinebytecodegeneratorjava:167)	at javainstrument/javalanginstrumentclassfiletransformertransform(classfiletransformerjava:246)	at javainstrument/suninstrumenttransformermanagertransform(transformermanagerjava:188)	at javainstrument/suninstrumentinstrumentationimpltransform(instrumentationimpljava:550)	at javabase/javalangweakpairmap$pairweak(weakpairmapjava:201)	at javabase/javalangweakpairmapputifabsent(weakpairmapjava:123)	at javabase/javalangmoduleimpladdreads(modulejava:396)	at javabase/javalangmoduleimpladdreads(modulejava:357)	at javabase/javalangsystem$2addreads(systemjava:2146)	at javabase/jdkinternalmodulemodulesaddreads(modulesjava:85)	at javabase/jdkinternalmodulemodulestransformedbyagent(modulesjava:166)	at javainstrument/suninstrumentinstrumentationimplretransformclasses0(native method)	at javainstrument/suninstrumentinstrumentationimplretransformclasses(instrumentationimpljava:157)	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortriggerretransformation(inlinebytecodegeneratorjava:117)	 72 more```</p></details> || could someone create a reproduction of this issue in a small isolated repository? it seems like i cannot reproduce the issuealso i wonder what the remaining stack frames are could someone post these? || @raphw i created a repo which reproduces the problem:  || @mockitoguy the same issue was reproduced for mocking aspose library classes (comaspose) lib was compiled via aspose-jdk16 `aspose-jdk16` can be added to observed classes list in exception info || ";1;0;avoid circularity: if certain types a type for the first time during instrumentation while our mocking engine relies on the same types this can cause a circularity as checking if an instance is a mock requires instances of the latter types what again returns to the latter mock checking routine what causes an endless loop (described in comment) 1240;
1387;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1386: adding atmostonce()  rename threadverifiescontinuoslyinteractingmocktest and one todo;hi;;0;addition to files; add methods to files class to convert predicate&ltfile> from/to filefilter and filenamefilteradd file comparators by name full path size type last modified date etcadd filters for size and last modified date similar to isfile/isdirectory; ;;;;0;1;;
1387;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1386: adding atmostonce()  rename threadverifiescontinuoslyinteractingmocktest and one todo;hi;;0;add explicit guice binder for jax-rs services;;;;;;0;1;;
1387;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1386: adding atmostonce()  rename threadverifiescontinuoslyinteractingmocktest and one todo;hi;;0;upgrade to jmh 09;;;;;;1;1;upgrade to jmh 09;
1387;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1386: adding atmostonce()  rename threadverifiescontinuoslyinteractingmocktest and one todo;hi;;1386.0;1386: adding atmostonce() rename threadverifiescontinuoslyinteractingmocktest and one todo;hii would like to make a quick contribution on this projecti add atmostonce() it seems not to be a big feature i just want to highlight the fact you have the function atleastonce() but nothing for the atmostonce casei rename the testclass threadverifiescontinuoslyinteractingmocktest on threadverifiescontinuouslyinteractingmocktest and the todo on tostring() from hamcrestargumentmatcher; merging 1387  < ;add atmostonce()rename one testclass and one todo;hii would like to make a quick contribution on this projecti add atmostonce() it seems not to be a big feature i just want to highlight the fact you have the function atleastonce() but nothing for the atmostonce case i rename the testclass threadverifiescontinuoslyinteractingmocktest on threadverifiescontinuouslyinteractingmocktest and the todo on tostring() from hamcrestargumentmatcher<t>;;1;0;fix compilation of test;
1391;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make mockitoextension constructor public;it is possible to register an extension for automatic use using java s  serviceloader  mechanism.;;0;add futuresgetorcancel; consider adding something like:public static &ltt> t getorcancel(future&ltt> future) throws executionexception interruptedexception {&nbsp&nbsp&nbsp&nbsptry {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn futureget()&nbsp&nbsp&nbsp&nbsp} catch (interruptedexception e) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspfuturecancel(true)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspthrow e&nbsp&nbsp&nbsp&nbsp}}and a version with timeout too; i searched for it but didnt find anyway what i propose is different from the issue 1068 the idea is to cancel the future (with interruption) in case of interruption certainly the method name can be different ||;;;;0;1;;
1391;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make mockitoextension constructor public;it is possible to register an extension for automatic use using java s  serviceloader  mechanism.;;0;release notes for 070;;;;;;0;1;;
1391;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make mockitoextension constructor public;it is possible to register an extension for automatic use using java s  serviceloader  mechanism.;;0;rxscala: improve type inference;what do you think if we change the signatures below```def combinelatest[ur](that: observable[u] f: (t u) > r): observable[r]  ???def zipwith[u r](that: observable[u] selector: (tu) > r): observable[r]  ???``````def combinelatestwith[ur](that: observable[u])(selector: (t u) > r): observable[r]  ???def zipwith[u r](that: observable[u])(selector: (tu) > r): observable[r]  ???```to improve type inference (so we dont need to provide explicit parameter types for the lambdas)  and for more uniform naming it is kind of weird that we have `zipwith` but not `combinelatestwith`/cc @samuelgruetter @zsxwing;+1 || @zsxwing you wanna help go through the api and curry and possibly rename a few operators such that we can maximize type inference?(see  || sure i can take it this weekend || cool thanks lets make sure that no type is left uninferred || anything more to do on this issue or can it be closed? || we can close this @zsxwing did a great job ||;;;;0;1;;
1391;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;make mockitoextension constructor public;it is possible to register an extension for automatic use using java s  serviceloader  mechanism.;;1390.0;make mockitoextension constructor public;it is possible to register an extension for automatic use using javas `serviceloader` mechanism projects may want to provide their own `meta-inf` file to avoid tediously adding `mockitoextension` to tests since it is very common however `serviceloader` requires the class to have a no-args *public* constructor so the current extension cannot be used with the `serviceloader` mechanism1390check list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `fixes #<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_;would be great if you could add a test for this not sure if that is possible? it is not a blocking issue for me though ||   added a test (a bit heavyweight since it needs to be a separate project to avoid influencing others) ||;mockitoextension cannot be registered as a global junit5 extension;`mockitoextension` doesnt expose its constructor so it cant be loaded  serviceloader`when trying to register `mockitoextension` for automatic use using a file named `meta-inf\services\orgjunitjupiterapiextensionextension` and content `orgmockitojunitjupitermockitoextension`the below error is thrown using mockito-junit-jupiter 2183```orgjunitjupiterapiextensionextension: orgmockitojunitjupitermockitoextension unable to get public no-arg constructorjavautilserviceconfigurationerror: orgjunitjupiterapiextensionextension: orgmockitojunitjupitermockitoextension unable to get public no-arg constructor	at javabase/javautilserviceloaderfail(serviceloaderjava:581)	at javabase/javautilserviceloadergetconstructor(serviceloaderjava:672)	at javabase/javautilserviceloaderaccess$1000(serviceloaderjava:390)	at javabase/javautilserviceloader$lazyclasspathlookupiteratorhasnextservice(serviceloaderjava:1232)	at javabase/javautilserviceloader$lazyclasspathlookupiteratorhasnext(serviceloaderjava:1264)	at javabase/javautilserviceloader$2hasnext(serviceloaderjava:1299)	at javabase/javautilserviceloader$3hasnext(serviceloaderjava:1384)	at javabase/javalangiterableforeach(iterablejava:74)	at orgjunitjupiterengineextensionextensionregistryregisterautodetectedextensions(extensionregistryjava:102)	at orgjunitjupiterengineextensionextensionregistrycreateregistrywithdefaultextensions(extensionregistryjava:86)	at orgjunitjupiterenginedescriptorjupiterenginedescriptorprepare(jupiterenginedescriptorjava:37)	at orgjunitjupiterenginedescriptorjupiterenginedescriptorprepare(jupiterenginedescriptorjava:28)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutor$nodeexecutorprepare(hierarchicaltestexecutorjava:89)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutor$nodeexecutorexecute(hierarchicaltestexecutorjava:74)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorexecute(hierarchicaltestexecutorjava:55)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestengineexecute(hierarchicaltestenginejava:43)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:170)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:154)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:90)	at orggradleapiinternaltaskstestingjunitplatformjunitplatformtestclassprocessor$collectalltestclassesexecutorprocessalltestclasses(junitplatformtestclassprocessorjava:92)	at orggradleapiinternaltaskstestingjunitplatformjunitplatformtestclassprocessor$collectalltestclassesexecutoraccess$100(junitplatformtestclassprocessorjava:77)	at orggradleapiinternaltaskstestingjunitplatformjunitplatformtestclassprocessorstop(junitplatformtestclassprocessorjava:73)	at orggradleapiinternaltaskstestingsuitetestclassprocessorstop(suitetestclassprocessorjava:61)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javabase/javalangreflectmethodinvoke(methodjava:564)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)	at orggradleinternaldispatchcontextclassloaderdispatchdispatch(contextclassloaderdispatchjava:32)	at orggradleinternaldispatchproxydispatchadapter$dispatchinginvocationhandlerinvoke(proxydispatchadapterjava:93)	at comsunproxy$proxy1stop(unknown source)	at orggradleapiinternaltaskstestingworkertestworkerstop(testworkerjava:123)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javabase/javalangreflectmethodinvoke(methodjava:564)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)	at orggradleinternalremoteinternalhubmessagehubbackedobjectconnection$dispatchwrapperdispatch(messagehubbackedobjectconnectionjava:155)	at orggradleinternalremoteinternalhubmessagehubbackedobjectconnection$dispatchwrapperdispatch(messagehubbackedobjectconnectionjava:137)	at orggradleinternalremoteinternalhubmessagehub$handlerrun(messagehubjava:404)	at orggradleinternalconcurrentexecutorpolicy$catchandrecordfailuresonexecute(executorpolicyjava:63)	at orggradleinternalconcurrentmanagedexecutorimpl$1run(managedexecutorimpljava:46)	at javabase/javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1135)	at javabase/javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:635)	at orggradleinternalconcurrentthreadfactoryimpl$managedthreadrunnablerun(threadfactoryimpljava:55)	at javabase/javalangthreadrun(threadjava:844)caused by: javalangnosuchmethodexception: orgmockitojunitjupitermockitoextension<init>()	at javabase/javalangclassgetconstructor0(classjava:3302)	at javabase/javalangclassgetconstructor(classjava:2110)	at javabase/javautilserviceloader$1run(serviceloaderjava:659)	at javabase/javautilserviceloader$1run(serviceloaderjava:656)	at javabase/javasecurityaccesscontrollerdoprivileged(native method)	at javabase/javautilserviceloadergetconstructor(serviceloaderjava:667)	 46 more``` -  the mockito message in the stacktrace have useful information but it didnt help -  the problematic code (if thats possible) is copied here       note that some configuration are impossible to mock via mockito -  provide versions (mockito / jdk / os / any other relevant information) -  provide a [short self contained correct (compilable) example]( of the issue       (same as any question on stackoverflowcom) -  read the [contributing guide](https://githubcom/mockito/mockito/blob/master/github/contributingmd);;1;0;add test;
1402;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1401 : correctly handle varargsmatcher check for hamcrestmatchers;;;0;completiontracker: completionservice meets listenablefuture; we have this internally its a useful building block in implementing things like firstcompleted(iterable&ltlistenablefuture>) eventually we should get around to reviewing users deciding whether to make any api changes and possibly releasing it;im curious if there are plans to push this out as weve written our own || we ended up deleting the specific `completiontracker` class i teased here in favor of [`futuresincompletionorder`]( (and for some users other methods like [`futuressuccessfulaslist`]( would those work for your use case? || declaring this as  with the release of futuresincompletionorder in 170 ||;;;;0;1;;
1402;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1401 : correctly handle varargsmatcher check for hamcrestmatchers;;;0;statementclient does not handle  status code for initial request;;@nezihyigitbasi this is  with your 3-year old commit right?please close if you confirm || oh never mind i see it was not merged-in ;;;;0;1;;
1402;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1401 : correctly handle varargsmatcher check for hamcrestmatchers;;;0;remove pivot operator in 020?;the pivot operator continues to have concurrency issues im considering removing it in 020 (it probably should never have been added)does anyone use it? does anyone have issues with me removing it?i think it is better suited to being a custom operator rather than part of rxjava-core;id be totally fine with that it is a monster that is hard to tame || great  ill remove it in 020 id rather wait until it matures and possibly bring it back in the 1x series than leave it in its current state || +1 || it has been removed ||;;;;0;1;;
1402;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1401 : correctly handle varargsmatcher check for hamcrestmatchers;;;1401.0;1401 : correctly handle varargsmatcher check for hamcrestmatchers;; merging 1402  < ;varargsmatcher doesnt work correctly when using hamcrestmatchers in mockito 2;class a {    private b b    public a(b b) {        thisb  b    }    public integer perform() {        return brun(""abcd"" 1l 2l)    }}class b {    public integer run(string str long price) {        return 10    }}class hamcrestvarargsmatcher extends typesafematcher<long> implements varargmatcher {    protected boolean matchessafely(long item) {        return item < 3    }    public void describeto(description description) {    }}class test {   @test   public void varargsmatcherusinghamcrestmatcherworks() {        b b  mockitomock(bclass)        a a  new a(b)        when(brun(eq(""abcd"") mockitohamcrestargthat(new hamcrestvarargsmatcher())))thenreturn(15)        assertthat(aperform() is(15)) // actually returns 0    }}```";;1;0;1401 : correctly handle varargsmatcher check for hamcrestmatchers;
1404;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix wrong artifact name in javadoc  and link to proper javadoc page;## motivation;;0;fix wrong artifact name in javadoc and link to proper javadoc page;## motivation1 current javadoc in `mockitojava` uses wrong artifact name orgmockitojunit-jupiter but it should be [orgmockito:mockito-junit-jupiter]( to avoid users confusion fix it with correct name2 the `mockitoextension` isnt contained in `mockito-core` so we cannot use hyper link generated  {@link }` instead we can use `<a>` tag to guide users to proper javadoc page## check list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_thanks for your great product that really helps our daily hacking :); ;;;;1;1;fix wrong artifact name in javadoc and link to proper javadoc page;
1404;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix wrong artifact name in javadoc  and link to proper javadoc page;## motivation;;0;create table in presto;support create table in presto:create table [if not exists] table_name (col_name data_type ) [partitioned by (col_name data_type ) serde serde_name inputformat input_format_classname outputformat output_format_classname location location];wow this is such a big pr can you please explain this to me a little? ||;;;;0;1;;
1404;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix wrong artifact name in javadoc  and link to proper javadoc page;## motivation;;0;bug on observablepublish() and connectableobservableconnect?;"hi i am running into a problem with connectableobservables using underlying hot observables where the observable::publish() and connectableobservable::connect() contracts dont seem to be respected some context: i have a publishsubject where i onnext asynchronously when i receive some notifications from a remote service (zookeeper) im exposing this subject to some subscribers via asobservable() because i cant control the initialisation of subscribers nor afford missing any element from the stream im trying to buffer all the elements into the source and start emitting only after all subscribers are subscribed for example imagine the following sequence of events1 connect to the remote service and create the source observable2 sourceonnext(a)3 subscriber 1 subscribes to the source4 sourceonnext(b)5 subscriber 2 subscribes to the source6 initialisation complete tell source to stop buffering7 sourceonnext(c)8 subscriber 3 subscribesi want both subscribers 1 and 2 to see [a b c](because both subscribed before we told the source to stop buffering) subscriber 3 would get only [c](it subscribed late for [a b]) note that this is why i dont want a replaysubject i dont want 3 to receive [a b]reading through the documentation i find that observable::publish() ""returns a connectableobservable which waits until its connect method is called before it begins emitting items to those observers that have subscribed to it"" i understand this meaning that i can just call connectableobservable::connect() when all my subscribers are ready specifically at point 6 above something like this:connectableobservable<?> c  sourcepublish() csubscribe(a)csubscribe(b)cconnect()note that this behaviour matches with the marble diagram  and the docs at  it doesnt work both subscribers dont get any elements emitted from the source between subscribe() and connect() is invoked however if i move the connect before the 2 subscribes then it behaves as expected looking into the code it does look like connect() actually involves a subscribe to the underlying source this can be seen in operatormulticast::connect() only when the first subscriber invokes connect does the connectobservable actually subscribe to the underlying source observablethe contract specifies that connectableobservable will wait ""until its connect method is called before it begins emitting items to those observers that have subscribed to it"" but this will only be true for cold observables if we have a hot observable (my case) we will lose events emitted by the source between the subscribe and the connectis expected behaviour (that should be better documented) or a bug?";"since `xspublish` makes the underlying observable`xs` hot publishing a hot observable is a noop ``` scalaobject mainscala {  def main(args: array[string]): unit  {    val xs: observable[long]  {      val xs  observabletimer(0 seconds 1 second)take(5)publish      xssubscribe(x > println(s"">>>> hot observable produces ${x}"") e >{} ()> println(""hot observable done""))      xsconnect      xs    }    threadsleep(1000)    println(""publish hot observable"")    val ys  xspublish    threadsleep(1000)    println(""subscribe first subscriber to published hot observable"")    yssubscribe(x > println(s""first subscriber ${x}""))    threadsleep(1000)    println(""subscribe second subscriber to published hot observable"")    yssubscribe(x > println(s""second subscriber ${x}""))    threadsleep(1000)    println(""connect published hot observable"")    ysconnect    readline()  }}```if you really have a hot observable to start with you probably want to use replay subjects but if possible i would see if you can make things cold so that only when you connect you actually connect to zookeeper to start receiving notification the problem is that you dont know how long you need to buffer values when you wait for the subscribers to all come in || > if we have a hot observable (my case) we will lose events emitted by the source between the subscribe and the connectthats correct and how its expected to behave `connect` is subscribing the source if your source is ""hot"" and firing events before you connect/subscribe then you will never receive them that is the nature of hot sources you receive their events only after you subscribe to them thus the only value of `publish` and `connect` on an already hot stream is to ensure that a set of subscribers all start receiving data at the same time otherwise they can each just subscribe to the hot stream directly || reopen if you have further followup to this || ";;;;0;1;;
1407;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removing redundent sentence;there was a redundant sentence in the documentation (it was repeated 2 lines below it).;;0;npe in classpathscandirectory() for directory without file system read permission; here is the code in question in classpath (trunk but the same bug exists in the 1401 release and probably prior) private void scandirectory(&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspfile directory classloader classloader string packageprefix) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbspfor (file f : directorylistfiles()) {directorylistfiles() can return null which causes an npe for example if the dir does not have unix fs read permissions we ran into this bug here today i believe the correct fix is to ignore the directory if directorylistfiles() returns null i left a comment to this effect as a code review here: https://githubcom/google/guava/blob/c6c66536dc903ef9e870d3c8562d25808bbe66b2/guava/src/com/google/common/reflect/classpathjava#l298thoughts?; ;;;;0;1;;
1407;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removing redundent sentence;there was a redundant sentence in the documentation (it was repeated 2 lines below it).;;0;removing redundent sentence;there was a redundant sentence in the documentation (it was repeated 2 lines below it); ;;;;1;1;removing redundent sentence the sentence was repeated 2 lines below it;
1407;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removing redundent sentence;there was a redundant sentence in the documentation (it was repeated 2 lines below it).;;0;logproperties appears to have no effect;"gentsim benchmarking preso  ive installed 069 creating a cluster with eight worker nodes a stand-alone discovery node a stand-alone co-ordinator node and a stand-alone hive metastore server  the data files are in s3i am unable to influence logging  ""logproperties"" appears to have no effect  ive tried thiscomerrorioerrormakes no differencethis is a critical problem as currently i see in the log files one info-level debug line (eg about six lines of output which is i believe output captured from the stdout of  orgapache per line of data processed  consequently performance is terrible and as such i cannot benchmark  i need to be able to reduce logging below info";"the solution turns out to be this in logpropertiesstdouterrori was mistaken to assert logproperties was being ignored  the problem is finding the magic pseudo-classname (""stdout"") which turns off the problematic logging || ";;;;0;1;;
1407;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removing redundent sentence;there was a redundant sentence in the documentation (it was repeated 2 lines below it).;;0;[android] problems with handlerthreadscheduler since 0191;weve put our app in beta recently running rxjava 0191 were suddenly seeing problems with scheduling on the main thread where notifications arrive even after unsubscribing from the observable i suspect rxjava itself might be the cause here since the scheduler implementation changed in 019 i wanted to double check if anyone else is seeing this happen?more specifically what happens is that in a subscriber from which we unsubscribe in fragment#ondestroyview getview() returns null crashing the app this should never happen when unsubscribing before the views get destroyed unless messages for some reason keep propagating to the subscriber there had even been a fix committed recently that eagerly removes all pending runnables from the handlers message looper upon unsubscription so i wonder how this can even happenunfortunately these things are incredibly difficult to debug as they are usually timing issues some code extracts:```public class playlisttagsfragment extends fragment  {    @override    public void onviewcreated(view view bundle savedinstancestate) {        superonviewcreated(view savedinstancestate)                viewsubscriptions  new compositesubscription()        viewsubscriptionsadd(alltagsobservablesubscribe(new tagssubscriber()))        viewsubscriptionsadd(recenttagsobservablesubscribe(new recentssubscriber()))    }    @override    public void ondestroyview() {        viewsubscriptionsunsubscribe()        superondestroyview()    }    private final class recentssubscriber extends defaultsubscriber<playlisttagscollection> {        @override        public void onnext(playlisttagscollection tags) {            if (!tagsgetcollection()isempty()) {                // crashes here                getview()findviewbyid(ridrecent_tags_container)setvisibility(visible)                displayrecenttags(tags)            }        }    }}```;"so one thing i discovered is that in this particular case the action we execute is actually quite fast for small amounts of data and we forgot to actually schedule it on a background thread (so we didnt notice it was running on the main ui thread) ie we didnt `subscribeon` anything when firing the observable but we _did_ `observeon` the main threadi wonder if theres a timing issue or other glitch when observing something on the same thread youre already on? i cant reproduce it locally unfortunately || @mttkay i saw your description above which made me curious after looking into operatorobserveon and its interaction with handlerthreadscheduler here is what i found:1 both observeonsubscriberonnext() and scheduledunsubscribeunsubscribe() end up _posting_ a runnable in the handlerthreadschedulers handlerso with the code below:final subscription subscription  observablefrom(new object())                subscribeon(schedulersnewthread())                observeon(androidschedulersmainthread())                subscribe(new action1<object>() {                    @override                    public void call(final object o) {                        logd(""here"" "":("")                    }                })        subscriptionunsubscribe()if observeonsubscriberonnext() is called and an innerhandlerthreadschedulerschedule() call puts a scheduledaction in the loopers queue when you call subscriptionunsubscribe() it will also queue another runnable _behind_ the one which will call onnext() on your subscriberso you end up with something like this in the loopers messagequeuehead < observeonsubscriberpollqueue() < innerhandlerthreadschedulerunsubscribe() < tailnote that that happens since even though you are calling unsubscribe from the main thread scheduledunsubscribeunsubscribe() queues the subscribe() for the worker see below:@override        public void unsubscribe() {            if (once_updatergetandset(this 1)  0) {                workerschedule(new action0() {                    @override                    public void call() {                        workerunsubscribe()                    }                })            }        } so when your call to unsubscribe() returns within ondestroyview() all pending runnable instances in the queue will still be executed it seems to me that within operatorobserveonpollqueue() there should be a check for scheduledunsubscribeisunsubscribed()?i am going to send a pull request with the fix for it today let me know your thoughts!? || @mttkay there is a fix at  || the problem is that an unsubscribe() call from downstream is not distinguished from upstream the former should unsubscribe the worker and drop every queued event whereas an upstream unsubscribe - usually called due to an onerror case - should let queued events including the final onerror to be delivered before the worker is shut down the problem is in l75: dont share the child subscribers internal composite but rather use childadd(new observeonsubscriber()) near l56 || @dpsm good find! i wasnt aware of `operatorobserveon` scheduling `unsubscribe` this is highly problematic actually since code like this will not work as expected:```void ondestroyview() {  subscriptionunsubscribe() // is supposed to detach listeners from views  superondestroyview()}```since the call to `super` detaching all the views will now overtake the scheduled unsubscription this is counter intuitive as you would think that unsubscribing is synchronous and immediately makes an attempt at stopping the observable and detaching subscribersthis also means that removing posted runnables in the subscription block is less effective than it could be@akarnokd what do you mean with up- and downstream? || @mttkay we have a fix to be merged soon that should implement the correct behaviour see my comment above referring to the fix || @benjchristensen the fix for it is merged @mttkay please verify with version 0194 || thanks so much guys i will see to release a new beta running on 0194asap it usually takes a few days for crash reports to come in but illreport back in case the problem should persist || closing out please reopen or start a new issue if the fix did not work || ";;;;0;1;;
1425;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;updated documentation of timeout() and after();while working on @christianschwarz s pr  i found the current documentation confusing.;;0;should objectsequal handle arrays with arraysequals?; i was recently bitten by a bug concerning calling objectsequal passing arrays (the primitive type eg int) as parametersthe documented behavior of objectsequal states that it would be the same behavior as calling array1equals(array2) those in turn are equivalent of calling array1  array2i wonder if objectsequal could step in and provide a uniform semantic in this case if not im curious to learn the rationale behind it; the behavior you seek is provided by javautilarraysdeepequals() which is more self-documenting when you use itwe didnt to confuse the issue of exactly what objectsequal() is for  the broader lesson here is to avoid arrays as much as possible especially object arrays which have virtually no discernible advantages over lists anymore--- ;;;;0;1;;
1425;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;updated documentation of timeout() and after();while working on @christianschwarz s pr  i found the current documentation confusing.;;0;updated documentation of timeout() and after();while working on @christianschwarzs pr i found the current documentation confusing- made the documentation clear especially about the differences between timeout() and after()- removed mentions of internal api (new timeout() constructor)91;  @christianschwarz any feedback? || since this is a documentation only change ill go ahead and merge ||;;;;1;1;updated documentation of timeout() and after()- made the documentation clear especially about the differences between timeout() and after()- removed mentions of internal api (new timeout() constructor);
1425;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;updated documentation of timeout() and after();while working on @christianschwarz s pr  i found the current documentation confusing.;;0;add support for timestamp and other new types in hive ctas;```javalangillegalargumentexception: unsupported type: timestamp    at comfacebookprestohivehivetypetohivetype(hivetypejava:179) ~[na:na]    at comfacebookprestohivehivetype$1apply(hivetypejava:189) ~[na:na]    at comfacebookprestohivehivetype$1apply(hivetypejava:185) ~[na:na]    at comgooglecommoncollectiterators$8transform(iteratorsjava:794) ~[guava-1601jar:na]    at comgooglecommoncollecttransformediteratornext(transformediteratorjava:48) ~[guava-1601jar:na]    at comgooglecommoncollecttransformediteratornext(transformediteratorjava:48) ~[guava-1601jar:na]    at comgooglecommonbasejoinerappendto(joinerjava:111) ~[guava-1601jar:na]    at comgooglecommonbasejoinerappendto(joinerjava:152) ~[guava-1601jar:na]    at comgooglecommonbasejoinerjoin(joinerjava:193) ~[guava-1601jar:na]    at comgooglecommonbasejoinerjoin(joinerjava:183) ~[guava-1601jar:na]    at comfacebookprestohivehiverecordsink<init>(hiverecordsinkjava:93) ~[na:na]```;;;;;0;1;;
1425;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;updated documentation of timeout() and after();while working on @christianschwarz s pr  i found the current documentation confusing.;;0;kotlin warnings;seems like a good idea to try to have everything compile without warnings```:language-adaptors:rxjava-kotlin annotations path entry points to a non-existent location: trash/rxjava 104028 am/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/kotlintestskt warning:t has a nullable upper bound this means that a value of this type may be null using t? is likely to mislead the reader                         ^trash/rxjava 104028 am/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/kotlintestskt warning:t has a nullable upper bound this means that a value of this type may be null using t? is likely to mislead the reader```;@marioariasc can you take care of this? || sorry for the late answeryeah sure || thanks @marioariasc  || rxkotlin is now a separate project so can handle this in  ||;;;;0;1;;
1426;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;mockito on java 11-ea+21;1419;;0;multipart upload support for presto s3 file system implementation;prestos3filesystem implementation currently uses the putobject call to upload objects to s3 which is inefficient in terms of resource utilization as its a single threaded upload implementation this pull request adds support for s3 clients multipart upload capability (see  which is a multithreaded upload implementation that will especially be useful for large objects;updated the aws sdk version to 172 with 172 transfermanagershutdownnow(boolean) method is introduced so we can shutdown the transfer manager without closing the underlying s3 client || hey @cberner i see that commit 1b65968 is merged into master which is **not** multipart upload support can you please confirm? || im not sure why it auto closed your pr but i also dont see any commits in this pull request can you check that your branch contains the right commits? || i am now rebasing it and then will let you know once done || @cberner opened #1532 for this change ||;;;;0;1;;
1426;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;mockito on java 11-ea+21;1419;;0;ruby bindings;these warnings have been there for a long time```:language-adaptors:rxjava-jruby:javadoctrash/rxjava 104028 am/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/jrubyactionwrapperjava  warning: no description for @param * @param <t1>   ^trash/rxjava 104028 am/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/jrubyactionwrapperjava  warning: no description for @param * @param <t2>   ^trash/rxjava 104028 am/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/jrubyactionwrapperjava  warning: no description for @param * @param <t3>   ^trash/rxjava 104028 am/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/jrubyactionwrapperjava  warning: no description for @param * @param <t4>   ^trash/rxjava 104028 am/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/jrubyfunctionwrapperjava  warning: no description for @param * @param <t1>   ^trash/rxjava 104028 am/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/jrubyfunctionwrapperjava  warning: no description for @param * @param <t2>   ^trash/rxjava 104028 am/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/jrubyfunctionwrapperjava  warning: no description for @param * @param <t3>   ^trash/rxjava 104028 am/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/jrubyfunctionwrapperjava  warning: no description for @param * @param <t4>   ^trash/rxjava 104028 am/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/jrubyfunctionwrapperjava  warning: no description for @param * @param <t5>   ^trash/rxjava 104028 am/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/jrubyfunctionwrapperjava  warning: no description for @param * @param <t6>   ^trash/rxjava 104028 am/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/jrubyfunctionwrapperjava  warning: no description for @param * @param <t7>   ^trash/rxjava 104028 am/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/jrubyfunctionwrapperjava  warning: no description for @param * @param <t8>   ^trash/rxjava 104028 am/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/jrubyfunctionwrapperjava  warning: no description for @param * @param <t9>   ^trash/rxjava 104028 am/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/jrubyfunctionwrapperjava  warning: no description for @param * @param <r>   ^14 warnings```;;;;;0;1;;
1426;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;mockito on java 11-ea+21;1419;;1419.0;mockito on java 11-ea+21;1419 requires `-dnetbytebuddyexperimentaltrue` system property to be set to let bytebuddy use asm api version `asm7_expermiental` and use the same one in `inlinebytecodegenerator`;" merging 1426 `  ";provide java 11 compatibility;"i ran tests with java 11 and getting the follwing exception may be asm 62 fixes this?orgmockitoexceptionsbasemockitoexception: mockito cannot mock this class: interface deespiritfirstspiritaccesslanguageif youre not sure why youre getting this error please report to the mailing listjava               : 11jvm vendor name    : ""oracle corporation""jvm vendor version : 11-ea+18jvm name           : java hotspot(tm) 64-bit server vmjvm version        : 11-ea+18jvm info           : mixed modeos name            : linuxos version         : 490-6-amd64you are seeing this disclaimer because mockito is configured to create inlined mocksyou can learn about inline mocks and their limitations under item #39 of the mockito class javadocunderlying exception : orgmockitoexceptionsbasemockitoexception: could not modify all classes [interface javalangcomparable interface deespiritfirstspiritaccesslanguage]	at deespiritfirstspiritgeneratetestpluggableurlcreatorsetup(testpluggableurlcreatorjava:51)	at jdkinternalreflectgeneratedmethodaccessor15invoke(unknown source)	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)caused by: orgmockitoexceptionsbasemockitoexception: could not modify all classes [interface javalangcomparable interface deespiritfirstspiritaccesslanguage]	at netbytebuddytypecachefindorinsert(typecachejava:137)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:344)	at netbytebuddytypecachefindorinsert(typecachejava:159)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:353)caused by: javalangillegalstateexception: byte buddy could not instrument all classes within the mocks type hierarchythis problem should never occur for javac-compiled classes this problem has been observed for classes that are: - compiled by older versions of scalac - classes that are part of the android distribution	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortriggerretransformation(inlinebytecodegeneratorjava:120)	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratormockclass(inlinebytecodegeneratorjava:97)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:37)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:34)	at netbytebuddytypecachefindorinsert(typecachejava:137)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:344)	at netbytebuddytypecachefindorinsert(typecachejava:159)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:353)	at orgmockitointernalcreationbytebuddytypecachingbytecodegeneratormockclass(typecachingbytecodegeneratorjava:32)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakercreatemocktype(inlinebytebuddymockmakerjava:200)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakercreatemock(inlinebytebuddymockmakerjava:181)	at orgmockitointernalutilmockutilcreatemock(mockutiljava:35)	at orgmockitointernalmockitocoremock(mockitocorejava:65)	at orgmockitomockitomock(mockitojava:1855)	at orgmockitomockitomock(mockitojava:1787)caused by: javalangillegalargumentexception: unsupported class file major version 55	at netbytebuddyjarasmclassreader<init>(classreaderjava:166)	at netbytebuddyjarasmclassreader<init>(classreaderjava:148)	at netbytebuddyjarasmclassreader<init>(classreaderjava:136)	at netbytebuddyutilityopenedclassreaderof(openedclassreaderjava:54)	at netbytebuddydynamicscaffoldtypewriter$default$forinliningcreate(typewriterjava:2912)	at netbytebuddydynamicscaffoldtypewriter$defaultmake(typewriterjava:1634)	at netbytebuddydynamicscaffoldinlineredefinitiondynamictypebuildermake(redefinitiondynamictypebuilderjava:171)	at netbytebuddydynamicscaffoldinlineabstractinliningdynamictypebuildermake(abstractinliningdynamictypebuilderjava:92)	at netbytebuddydynamicdynamictype$builder$abstractbasemake(dynamictypejava:2669)	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortransform(inlinebytecodegeneratorjava:181)	at javainstrument/javalanginstrumentclassfiletransformertransform(classfiletransformerjava:246)	at javainstrument/suninstrumenttransformermanagertransform(transformermanagerjava:188)	at javainstrument/suninstrumentinstrumentationimpltransform(instrumentationimpljava:563)	at javainstrument/suninstrumentinstrumentationimplretransformclasses0(native method)	at javainstrument/suninstrumentinstrumentationimplretransformclasses(instrumentationimpljava:167)	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortriggerretransformation(inlinebytecodegeneratorjava:117)";"asm 62 alone does not fix this neither does upgrading to latest bytebuddy help herethe combination of asm 62 latest bytebuddy a minor code change in mockito and setting `-dnetbytebuddyexperimentaltrue` helps here || mockito-core-2210jar 	byte-buddy-1815jarwith orgmockitopluginsmockmaker ""mock-maker-inline"" the fix is not working with java 18_172 and java  11-ea+24without ""mock-maker-inline"" it worksorgmockitoexceptionsbasemockitoexception: mockito cannot mock this class: interface deespiritorschemaentitytypeif youre not sure why youre getting this error please report to the mailing listjava               : 18jvm vendor name    : oracle corporationjvm vendor version : 25172-b11jvm name           : java hotspot(tm) 64-bit server vmjvm version        : 180_172-b11jvm info           : mixed modeos name            : mac os xos version         : 10136you are seeing this disclaimer because mockito is configured to create inlined mocksyou can learn about inline mocks and their limitations under item #39 of the mockito class javadocunderlying exception : orgmockitoexceptionsbasemockitoexception: could not modify all classes [interface deespiritorschemaentitytype interface javaioserializable]	at deespiritfirstspiritaccesseditortestentityassociatebeforeeach(testentityassociatejava:27)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)	at orgjunitinternalrunnersstatementsrunbeforesevaluate(runbeforesjava:24)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orgjunitrunnerjunitcorerun(junitcorejava:137)	at comintellijjunit4junit4ideatestrunnerstartrunnerwithargs(junit4ideatestrunnerjava:68)	at comintellijrtexecutionjunitideatestrunner$repeaterstartrunnerwithargs(ideatestrunnerjava:47)	at comintellijrtexecutionjunitjunitstarterpreparestreamsandstart(junitstarterjava:242)	at comintellijrtexecutionjunitjunitstartermain(junitstarterjava:70)caused by: orgmockitoexceptionsbasemockitoexception: could not modify all classes [interface deespiritorschemaentitytype interface javaioserializable]	at netbytebuddytypecachefindorinsert(typecachejava:137)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:344)	at netbytebuddytypecachefindorinsert(typecachejava:159)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:353)	 23 morecaused by: javalangillegalstateexception: byte buddy could not instrument all classes within the mocks type hierarchythis problem should never occur for javac-compiled classes this problem has been observed for classes that are: - compiled by older versions of scalac - classes that are part of the android distribution	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortriggerretransformation(inlinebytecodegeneratorjava:164)	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratormockclass(inlinebytecodegeneratorjava:141)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:37)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:34)	at netbytebuddytypecachefindorinsert(typecachejava:137)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:344)	at netbytebuddytypecachefindorinsert(typecachejava:159)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:353)	at orgmockitointernalcreationbytebuddytypecachingbytecodegeneratormockclass(typecachingbytecodegeneratorjava:32)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakercreatemocktype(inlinebytebuddymockmakerjava:200)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakercreatemock(inlinebytebuddymockmakerjava:181)	at orgmockitointernalutilmockutilcreatemock(mockutiljava:35)	at orgmockitointernalmockitocoremock(mockitocorejava:69)	at orgmockitomockitomock(mockitojava:1895)	at orgmockitomockitomock(mockitojava:1804)	 23 morecaused by: javalangnosuchfielderror: asm_api	at orgmockitointernalcreationbytebuddyinlinebytecodegenerator$parameterwritingvisitorwrapper$parameteraddingclassvisitor<init>(inlinebytecodegeneratorjava:251)	at orgmockitointernalcreationbytebuddyinlinebytecodegenerator$parameterwritingvisitorwrapper$parameteraddingclassvisitor<init>(inlinebytecodegeneratorjava:246)	at orgmockitointernalcreationbytebuddyinlinebytecodegenerator$parameterwritingvisitorwrapperwrap(inlinebytecodegeneratorjava:242)	at netbytebuddyasmasmvisitorwrapper$compoundwrap(asmvisitorwrapperjava:645)	at netbytebuddydynamicscaffoldtypewriter$default$forinlining$redefinitionclassvisitorvisit(typewriterjava:3672)	at netbytebuddyjarasmclassreaderaccept(classreaderjava:492)	at netbytebuddyjarasmclassreaderaccept(classreaderjava:355)	at netbytebuddydynamicscaffoldtypewriter$default$forinliningcreate(typewriterjava:2915)	at netbytebuddydynamicscaffoldtypewriter$defaultmake(typewriterjava:1634)	at netbytebuddydynamicscaffoldinlineredefinitiondynamictypebuildermake(redefinitiondynamictypebuilderjava:171)	at netbytebuddydynamicscaffoldinlineabstractinliningdynamictypebuildermake(abstractinliningdynamictypebuilderjava:92)	at netbytebuddydynamicdynamictype$builder$abstractbasemake(dynamictypejava:2669)	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortransform(inlinebytecodegeneratorjava:215)	at suninstrumenttransformermanagertransform(transformermanagerjava:188)	at suninstrumentinstrumentationimpltransform(instrumentationimpljava:428)	at suninstrumentinstrumentationimplretransformclasses0(native method)	at suninstrumentinstrumentationimplretransformclasses(instrumentationimpljava:144)	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortriggerretransformation(inlinebytecodegeneratorjava:161)	 37 more || we are experiencing the same error with java 11 and inline mocks || having similar issue with mockito and java 11 unable to mock any class/interface do we need implement any method for class loadingsince defineclass method removed  in java11 ? i even edited my javapolicy for assertion exception -2210bytebuddy-1815below is the exception  mockito cannot mock this class: class comxxxxxxtoolkitconfigconfigurationmockito can only mock non-private & non-final classesif youre not sure why youre getting this error please report to the mailing listjava               : 11jvm vendor name    : oracle corporationjvm vendor version : 11-ea+26jvm name           : java hotspot(tm) 64-bit server vmjvm version        : 11-ea+26jvm info           : mixed modeos name            : mac os xos version         : 10134underlying exception : javalangillegalstateexception: error invoking javalanginvokemethodhandles$lookup#defineclasscaused by: javalangillegalstateexception: error invoking javalanginvokemethodhandles$lookup#defineclasscaused by: javasecurityaccesscontrolexception: access denied (""javalangruntimepermission"" ""defineclass"") || same problem here || seeing a related error:```orgmockitoexceptionsbasemockitoexception: mockito cannot mock this class: interface cloudcosminchecklisterrepolistrepomockito can only mock non-private & non-final classesif youre not sure why youre getting this error please report to the mailing listjava               : 11jvm vendor name    : adoptopenjdkjvm vendor version : 1101+13jvm name           : openjdk 64-bit server vmjvm version        : 1101+13jvm info           : mixed modeos name            : linuxos version         : 4150-39-genericunderlying exception : javalangunsupportedoperationexception: cannot define class using reflection	at cloudcosminchecklisterrestlistcontrollertestsetup(listcontrollertestjava:37)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javabase/javalangreflectmethodinvoke(methodjava:566)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)	at orgjunitinternalrunnersstatementsrunbeforesevaluate(runbeforesjava:24)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orggradleapiinternaltaskstestingjunitjunittestclassexecutorruntestclass(junittestclassexecutorjava:106)	at orggradleapiinternaltaskstestingjunitjunittestclassexecutorexecute(junittestclassexecutorjava:58)	at orggradleapiinternaltaskstestingjunitjunittestclassexecutorexecute(junittestclassexecutorjava:38)	at orggradleapiinternaltaskstestingjunitabstractjunittestclassprocessorprocesstestclass(abstractjunittestclassprocessorjava:66)	at orggradleapiinternaltaskstestingsuitetestclassprocessorprocesstestclass(suitetestclassprocessorjava:51)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javabase/javalangreflectmethodinvoke(methodjava:566)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)	at orggradleinternaldispatchcontextclassloaderdispatchdispatch(contextclassloaderdispatchjava:32)	at orggradleinternaldispatchproxydispatchadapter$dispatchinginvocationhandlerinvoke(proxydispatchadapterjava:93)	at comsunproxy$proxy2processtestclass(unknown source)	at orggradleapiinternaltaskstestingworkertestworkerprocesstestclass(testworkerjava:117)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javabase/javalangreflectmethodinvoke(methodjava:566)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)	at orggradleinternalremoteinternalhubmessagehubbackedobjectconnection$dispatchwrapperdispatch(messagehubbackedobjectconnectionjava:155)	at orggradleinternalremoteinternalhubmessagehubbackedobjectconnection$dispatchwrapperdispatch(messagehubbackedobjectconnectionjava:137)	at orggradleinternalremoteinternalhubmessagehub$handlerrun(messagehubjava:404)	at orggradleinternalconcurrentexecutorpolicy$catchandrecordfailuresonexecute(executorpolicyjava:63)	at orggradleinternalconcurrentmanagedexecutorimpl$1run(managedexecutorimpljava:46)	at javabase/javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1128)	at javabase/javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:628)	at orggradleinternalconcurrentthreadfactoryimpl$managedthreadrunnablerun(threadfactoryimpljava:55)	at javabase/javalangthreadrun(threadjava:834)caused by: javalangunsupportedoperationexception: cannot define class using reflection	at netbytebuddydynamicloadingclassinjector$usingreflection$dispatcher$unavailabledefineclass(classinjectorjava:821)	at netbytebuddydynamicloadingclassinjector$usingreflectioninject(classinjectorjava:185)	at netbytebuddydynamicloadingclassloadingstrategy$default$injectiondispatcherload(classloadingstrategyjava:187)	at netbytebuddydynamictyperesolutionstrategy$passiveinitialize(typeresolutionstrategyjava:79)	at netbytebuddydynamicdynamictype$default$unloadedload(dynamictypejava:4457)	at orgmockitointernalcreationbytebuddysubclassbytecodegeneratormockclass(subclassbytecodegeneratorjava:121)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:37)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:34)	at netbytebuddytypecachefindorinsert(typecachejava:138)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:346)	at netbytebuddytypecachefindorinsert(typecachejava:161)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:355)	at orgmockitointernalcreationbytebuddytypecachingbytecodegeneratormockclass(typecachingbytecodegeneratorjava:32)	at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemocktype(subclassbytebuddymockmakerjava:71)	at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemock(subclassbytebuddymockmakerjava:42)	at orgmockitointernalcreationbytebuddybytebuddymockmakercreatemock(bytebuddymockmakerjava:25)	at orgmockitointernalutilmockutilcreatemock(mockutiljava:35)	at orgmockitointernalmockitocoremock(mockitocorejava:65)	at orgmockitomockitomock(mockitojava:1855)	at orgmockitointernalconfigurationmockannotationprocessorprocess(mockannotationprocessorjava:36)	at orgmockitointernalconfigurationmockannotationprocessorprocess(mockannotationprocessorjava:16)	at orgmockitointernalconfigurationindependentannotationenginecreatemockfor(independentannotationenginejava:38)	at orgmockitointernalconfigurationindependentannotationengineprocess(independentannotationenginejava:62)	at orgmockitointernalconfigurationinjectingannotationengineprocessindependentannotations(injectingannotationenginejava:57)	at orgmockitointernalconfigurationinjectingannotationengineprocess(injectingannotationenginejava:41)	at orgmockitomockitoannotationsinitmocks(mockitoannotationsjava:69)	 48 morecaused by: javalangillegalstateexception: could not find sunmiscunsafe	at netbytebuddydynamicloadingclassinjector$usingunsafe$dispatcher$disabledinitialize(classinjectorjava:1366)	at netbytebuddydynamicloadingclassinjector$usingunsafeinject(classinjectorjava:1202)	at netbytebuddydynamicloadingclassloadingstrategy$forunsafeinjectionload(classloadingstrategyjava:458)	at netbytebuddydynamictyperesolutionstrategy$passiveinitialize(typeresolutionstrategyjava:79)	at netbytebuddydynamicdynamictype$default$unloadedload(dynamictypejava:4457)	at netbytebuddydynamicloadingclassinjector$usingreflection$dispatcher$indirectmake(classinjectorjava:684)	at netbytebuddydynamicloadingclassinjector$usingreflection$dispatcher$creationactionrun(classinjectorjava:302)	at netbytebuddydynamicloadingclassinjector$usingreflection$dispatcher$creationactionrun(classinjectorjava:290)	at javabase/javasecurityaccesscontrollerdoprivileged(native method)	at netbytebuddydynamicloadingclassinjector$usingreflection<clinit>(classinjectorjava:70)	at netbytebuddydynamicloadingclassloadingstrategy$default$injectiondispatcherload(classloadingstrategyjava:184)	 71 morecaused by: javalangnosuchmethodexception: sunmiscunsafedefineclass(javalangstring [b int int javalangclassloader javasecurityprotectiondomain)	at javabase/javalangclassgetmethod(classjava:2109)	at netbytebuddydynamicloadingclassinjector$usingunsafe$dispatcher$creationactionrun(classinjectorjava:1269)	at netbytebuddydynamicloadingclassinjector$usingunsafe$dispatcher$creationactionrun(classinjectorjava:1257)	at javabase/javasecurityaccesscontrollerdoprivileged(native method)	at netbytebuddydynamicloadingclassinjector$usingunsafe<clinit>(classinjectorjava:1136)	 80 more``` || @cstroe are you sure that you dont have some older byte-buddy version on the classpath?(of course i assume that use you the latest version of mockito and byte buddy provided by it) || @szpak your intuition is correct  i am using spring boot version `205release` and it is using an older version of the mockito library  in order to use the newest mockito i had to change my gradle config:```    testcompile(orgspringframeworkboot:spring-boot-starter-test) {        exclude group: ""orgmockito"" module: ""mockito-core""    }    testcompile(""orgmockito:mockito-core:2234"")```that  my errors  thank you for the help || great to hearbtw spring boot provides also an easier way to override dependency [versions]( here overriding mockito would be enoughbtw afair only spring boot 21 declared java 11 compatibility therefore you may want to upgrade to prevent further surprises :) || > testcompile(orgspringframeworkboot:spring-boot-starter-test) {>         exclude group: ""orgmockito"" module: ""mockito-core"">     }>     testcompile(""orgmockito:mockito-core:2234"")this works like a charm thank you! || > > > > testcompile(orgspringframeworkboot:spring-boot-starter-test) {> > exclude group: ""orgmockito"" module: ""mockito-core""> > }> > testcompile(""orgmockito:mockito-core:2234"")> > this works like a charm thank you!anyone has an idea how to do this in pomxml? || @jidarwish its basic maven dependency management )```xml<dependency>  <groupid>orgspringframeworkboot</groupid>  <artifactid>spring-boot-starter-test</artifactid>  <scope>test</test>  <exclusions>    <exclusion>      <groupid>orgmockito</groupid>      <artifactid>mockito-core</artifactid>    </exclusion>  </exclustions></dependency><dependency>  <groupid>orgmockito</groupid>  <artifactid>mockito-core</artifactid>  <version>2234</version>  <scope>test</scope></dependency>``` || @bric3 i did exactly the same still didnt help :-(> java               : 11> jvm vendor name    : oracle corporation> jvm vendor version : 1102+9> jvm name           : openjdk 64-bit server vm> jvm version        : 1102+9> jvm info           : mixed mode> os name            : mac os x> os version         : 10144 || ok adding bytebuddy dep on top of that helped! || > @jidarwish its basic maven dependency management )> > ```> <dependency>>   <groupid>orgspringframeworkboot</groupid>>   <artifactid>spring-boot-starter-test</artifactid>>   <scope>test</test>>   <exclusions>>     <exclusion>>       <groupid>orgmockito</groupid>>       <artifactid>mockito-core</artifactid>>     </exclusion>>   </exclustions>> </dependency>> <dependency>>   <groupid>orgmockito</groupid>>   <artifactid>mockito-core</artifactid>>   <version>2234</version>>   <scope>test</scope>> </dependency>> ```if your project extend `spring-boot-starter-parent` you might just add : ```	<properties>		<mockitoversion>2234</mockitoversion>	</properties>```in your maven file  || ";1;0;1419 - mockito on java 11-ea+21requires -dnetbytebuddyexperimentaltrue system property to be set!;
1429;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;updated test coverage for async verification;updated tests with after() verification mode;;0;multimapsputallimpl; maybe and even then probably only as a package-private helperpossible users:abstractmultimapputallmapconstraintsconstrainedmultimapputallstandardbimultimapputall (google-internal and not in commoncollect)related: is there anything else from abstractmultimap that wed want to use elsewhere? containsvalue? size newly implemented atop asmap?; i think id meant the multimap variant but both are possibilitiesanyway i dont intend to look into this in any detail anytime soon || this could be a todo or someone could eventually just do it but we dont think its useful to have an issue on record about it ||;;;;0;1;;
1429;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;updated test coverage for async verification;updated tests with after() verification mode;;0;updated test coverage for async verification;updated tests with after() verification mode- some existing tests for the feature did not work due to flaws in replyrule those tests (now ignored) consistently failed but succeeded only when used with reply rule- some existing tests had weak assertions that did not fully cover the feature- suggested simpler and cleaner way of implementing delayed execution via new asynctesting class instead of delayedexecution dropping the reply rule may introduce instabilities to the ci builds lets observe and measure before making an actionalthough we are considering deprecating after() we need good coverage for an existing feature even if it will be removed in the long run; merging 1429 ;;;;1;1;updated tests with after() verification mode- some existing tests for the feature did not work due to flaws in replyrule some of the tests (now ignored) consistently failed but succeeded only when used with reply rule- some existing tests had weak assertions that did not fully cover the feature- suggested simpler and cleaner way of implementing delayed execution via new asynctesting class instead of delayedexecutionalthough we are considering deprecating after() we need good coverage for an existing feature even if it will be removed in the long run;
1429;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;updated test coverage for async verification;updated tests with after() verification mode;;0;fix npe in verifier;;;;;;0;1;;
1429;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;updated test coverage for async verification;updated tests with after() verification mode;;0;rxringbuffer test fails;just reporting head fc86f8c3 class `rxinternalutilrxringbufferwithoutunsafetest``testconcurrency````javalangassertionerror: expected:<94390> but was:<94389>    at orgjunitassertfail(assertjava:93)    at orgjunitassertfailnotequals(assertjava:647)    at orgjunitassertassertequals(assertjava:128)    at orgjunitassertassertequals(assertjava:472)    at orgjunitassertassertequals(assertjava:456)    at rxinternalutilrxringbufferwithoutunsafetesttestconcurrency(rxringbufferwithoutunsafetestjava:166)    at sunreflectnativemethodaccessorimplinvoke0(native method)    at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javalangreflectmethodinvoke(methodjava:483)    at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:45)    at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:15)    at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:42)    at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:20)    at orgjunitinternalrunnersstatementsfailontimeout$statementthreadrun(failontimeoutjava:62)``` class `rxinternalutilrxringbufferspmctest``testconcurrency````javalangassertionerror: expected:<0> but was:<530>    at orgjunitassertfail(assertjava:93)    at orgjunitassertfailnotequals(assertjava:647)    at orgjunitassertassertequals(assertjava:128)    at orgjunitassertassertequals(assertjava:472)    at orgjunitassertassertequals(assertjava:456)    at rxinternalutilrxringbufferspmctesttestconcurrency(rxringbufferspmctestjava:164)    at sunreflectnativemethodaccessorimplinvoke0(native method)    at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javalangreflectmethodinvoke(methodjava:483)    at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:45)    at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:15)    at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:42)    at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:20)    at orgjunitinternalrunnersstatementsfailontimeout$statementthreadrun(failontimeoutjava:62)```;thanks for the report  and ;;;;0;1;;
1430;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;allow mockito-logger to be configurable as mockito extension;hi;;0;allow mockito-logger to be configurable as mockito extension;"hiwe have many of legacy tests that do over-mocking code base - lots of unused mocking there (we are cleaning it slowly) we have user `@mockitosettings(strictness  strictnesswarn)` switch to log and not fail in this situactions by default all logs are printed out to console using `systemoutprintln` and this make us trouble because we have ""silent"" profile at ci server which is configured to silent loggers / as you expect sith `println` we are not trully silent in this case :]thats why i have created this pr proposal and want to know what do you thinkthxivos"; merging 1430  < ;;;;1;1;allow mockito-logger configurable as mockito extension;
1430;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;allow mockito-logger to be configurable as mockito extension;hi;;0;support to set per session settings;"it would be useful to have a per session settings mechanism that can be used to control optimizations and other functionality these settings can be query specific configurations metadata properties or flags to enable/disable any functionality/optimizationin the discussion for pr   we talked about how we can use set command for session settings these settings are stored in connectorsessionin this pr following syntax are supported```set var  literalunset var set varset```presto-cli has a session-id which is used while making rest call to the server when the cli exit it makes a call to the server to remove the session configurations at presto-cli we can choose not to have a presto session by using ""no-session"" option  set command would error out when no-session is used```/presto-cli --catalogtest--schematest --useruserid  --no-session```";this is superseded by #1999the new approach stores the session variables in the client  the variables are set to the server via headers and the server can update the session on the client via response headers  this is analogous to  cookies and leaves the coordinator stateless ||;;;;0;1;;
1430;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;allow mockito-logger to be configurable as mockito extension;hi;;0;unneeded variance cleanup;removed unneeded variance and replaced a few type variables in result types that dont matter with anyused `@uncheckedvariance` in one place that i think is safe and correspond better with java signature which also just takes a `t````def publish[r](selector: observable[t] > observable[r] initialvalue: t @uncheckedvariance): observable[r]ublic final <r> observable<r> publish(func1<? super observable<t> ? extends observable<r>> selector final t initialvalue) {```[aside: is the `class completenesstest extends junitsuite` useful not for me at least it requires too much manual messing around and i am never sure what to change (and why)];#1384  you commented out almost all of the projects in settingsgradle  can you remove that from this commit? || i thought i did not commit that file  (my build suddenly breaks when i try to compile any of the contrib modules) ||;;;;0;1;;
1433;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixed travis build;we don t need private constructor on an  internal  class. internal classes can be changed at any time based on our compatibility policy.;;0;guava 1401 cannot be deployed in a jee7 container; in jee7 cdi (cdi 20) is enabled by default (without a beansxml needing to be present) with no standardized way of disable itcomgooglecommonutilconcurrentservicemanager is annotated with @﻿singleton and has a constructor&nbsp&nbsp@﻿inject servicemanager(set&ltservice> services) {&nbsp&nbsp&nbsp&nbspthis((iterable&ltservice>) services)&nbsp&nbsp}so any war or ear that contains a guava 1401 jar suffers from cdi seeing this and trying to create the bean but failing and thus failing the entire war from loadingthis error is from glassfish 40[2013-05-23t15 35664-0700] [glassfish 40] [severe]  [javaxenterprisesystemcore] [tid: _threadid34 _threadnameadmin-listener(2)] [timemillis: 1369346915664] [levelvalue: 1000] [[&nbsp&nbspexception while loading the app : cdi deployment failure:weld-001408 unsatisfied dependencies for type [set&ltservice>] with qualifiers [@﻿default] at injection point [[backedannotatedparameter] parameter 1 of [backedannotatedconstructor] @﻿inject comgooglecommonutilconcurrentservicemanager(set&ltservice>)]orgjbossweldexceptionsdeploymentexception: weld-001408 unsatisfied dependencies for type [set&ltservice>] with qualifiers [@﻿default] at injection point [[backedannotatedparameter] parameter 1 of [backedannotatedconstructor] @﻿inject comgooglecommonutilconcurrentservicemanager(set&ltservice>)]the same war also fails to deploy on firefly 80 with a similar errorcan guava be modified to not use the @﻿singleton and @﻿inject annotations?; done:  || why not remove just the @singleton annotation which causes the problem and leaves the @inject? at least guice users will have to only set the scope to this class if they need that || @brunojcm  that would probably have been more dangerous since then contains like guice would create a new servicemanager for each injection point and then some of them will fail because you cant construct a servicemanager with started servicesin any case the annotations were removed and adding custom bindings for servicemanager etal in your container should be straightforward || ";;;;0;1;;
1433;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixed travis build;we don t need private constructor on an  internal  class. internal classes can be changed at any time based on our compatibility policy.;;0; travis build;we dont need private constructor on an internal class internal classes can be changed at any time based on our compatibility policy; merging 1433  < ;;;;1;1; travis buildwe dont need private constructor on an internal class internal classes can be changed at any time based on our compatibility policy;
1433;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixed travis build;we don t need private constructor on an  internal  class. internal classes can be changed at any time based on our compatibility policy.;;0;insert into functionality;;"first off thanks for doing this and apologies for taking so long to review this- rather than relying on walking the file system to find out what partitions were written use the built-in data channel: the `recordsinkcommit()` method returns a ""fragment"" which is collected and passed to `commitcreatetable()` the value is an arbitrary string so for hive it could be a json structure containing the partition and the file location we might need to change the interface from `collection<string>`  to something like `iterable<string>` if it gets too big one advantage of this approach is that it allows sharding partitions across different file systems- we need to be very careful when appending data to existing partitions if anything fails while renaming the files into place we should try to rollback by deleting any that were already moved- to allow administrators to cleanup manually when rollback fails all the appended files should have a transaction identifier as part of the their name to make it easy to distinguish for example using `systemcurrenttimemillis()` should suffice- for s3 it should be possible to efficiently copy all of the temporary files into the existing partition by performing a multipart upload with copying:  this functionality will not work correctly with bucketing so we should fail if the target table or partition is bucketed- i think it would be better to have a new commit api and handle type rather than reusing `connectormetadatacommitcreatetable()` and `connectoroutputtablehandle` for inserts in the hive implementation they are actually completely separate so mixing them together makes the code more complicated connector implementors could still share if that makes sense for their connector one big difference between `tablehandle` and `outputtablehandle` is that the table exists for the former but not for the latter existing tables might use just an identifier but new tables need the name || i think with this pr my previous pr on s3 multipart upload support (#1426) becomes more relevant || i am mostly done with refactoring the apis for insert support once that is done we will merge that and this patch can be rebased to use the updated apis || @stagraqubole sorry for the delay on this i refactored your insert api changes to presto and merged them (currently supported only by the raptor connector) having a separate handle type and apis for insert turned out to be a lot more work than i expected and had some ugly bits inside of the main engine but the api for connectors is cleaner we would rather have the complexity in one place inside presto (where it can be improved later) rather than in every connectordo you want to try to update this to use the new apis taking into account the review comments? feel free to close this pr and open a new one if that is easierthanks for your contributions here! || @electrum thanks will rebase my changes to use new api and handles || @electrum our master has changes from dains pr( which are not there in upstream master ill have to wait to start working on this till this pr makes into master because till then we cannot fast forward our master  || @stagraqubole did you finish the insert into functionality based on new api? looking forward to it! || @yuananf not yet but i am working on this should be able to get the pr shortly || opened new pr for this  insert over new api with suggestions from review comments hereclosing this pr || ";;;;0;1;;
1433;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixed travis build;we don t need private constructor on an  internal  class. internal classes can be changed at any time based on our compatibility policy.;;0;take 3;removed unneeded variance and replaced a few type variables in result types that dont matter with anyused `@uncheckedvariance` in one place that i think is safe and correspond better with java signature which also just takes a `t````def publish[r](selector: observable[t] > observable[r] initialvalue: t @uncheckedvariance): observable[r]ublic final <r> observable<r> publish(func1<? super observable<t> ? extends observable<r>> selector final t initialvalue) {```;#1387 ;;;;1;1;copied from master;
1434;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;javadoc: update broken code example;it updates a broken code example in javadoc.;;0;joinerskipnulls() does not skip nulls if they were returned by objecttostring(); in  public joinerskipnulls() this code:```    while (partshasnext()) {      object part  partsnext()      if (part ! null) {        appendableappend(joinerthistostring(part))        break      }    }    while (partshasnext()) {      object part  partsnext()      if (part ! null) {        appendableappend(separator)        appendableappend(joinerthistostring(part))      }    }```is wrong because it assumes that joinerthistostring(part) does not return nullin both loops there needs to be additional checks for joinerthistostring() returning a null; > i also have legitimate cases of objects that are not null and implement charsequence returning null for those objects is also legitimatei really dont understand how returning null from the tostring() implementation of a class implementing charsequence is ""legitimate"" charsequences tostring() method is documented as follows:""returns a string containing the characters in this sequence in the same order as this sequence the length of the string will be the length of this sequence""it returns ""a string"" (null is not a string and doesnt have a length) if your charsequence has no characters in it tostring() should return the empty string  || ";;;;0;1;;
1434;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;javadoc: update broken code example;it updates a broken code example in javadoc.;;0;javadoc: update broken code example;it updates a broken code example in javadoci just copied the example from [answerjava]( to [mockitojava](https://githubcom/mockito/mockito/blob/release/2x/src/main/java/org/mockito/mockitojava#l525); merging 1434 ;;;;1;1;javadoc: update broken code example;
1434;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;javadoc: update broken code example;it updates a broken code example in javadoc.;;0;support for multiple metastore uris for high availability;in hive-sitexml hivemetastoreuris property can have a comma separated list when your cluster has multiple hive metastore serversit would be great if presto support that as well;im going to take this up || we actually support this today with `discoverylocatedhivecluster` it has code for connecting to multiple metastore services the discovery version has the advantage of being dynamic since you can add/remove services at runtime via the discovery api though ive considered removing it since no one uses it || @electrum this would be a useful feature if presto was able to connect to multiple metastore services and fallback to the other one when one fails is it currently possible to create such a configuration with presto? || from what i can see presto shuffles all of the metastores it has descriptors for and goes through sequentially trying them  so there is fallback  this does not quite match the behavior that hive uses though which is to default to using the first metastore uri specified in the list and then to fail over to a random uri in the list if it cant connect to the first metastore continuing to try the fallback uris until it is able to connect (see   i guess the servicedescriptor for the hive-metastore that is the default one could have a default property or something like that? || @cawallin what i mean by fallback is a fallback mechanism among multiple hive metastores for the same catalog is it really possible? i though it isnt now if it is how can i specify it in the catalog properties file? || @nezihyigitbasi i dont think you can specify it in the catalog properties file -- you have to set your hivemetastoreuri to something with the scheme discovery and then set up your metastores via the discovery server im still looking into how that works though || made a pr for adding multiple metastore support to the catalog properties file i tried for a while to get the discovery-based hive to work but couldnt get the static announcements to work to tell the discovery server about your metastores i might look into it more later though ||;;;;0;1;;
1434;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;javadoc: update broken code example;it updates a broken code example in javadoc.;;0;onerrorflatmap not called when error happened in subscribers onnext;"i want to make some of my observable uninterruptiblei currently trying to use onerrorflatmap to spawn another observable sequence but if error happens in subscriber onnext it stops receiving updates and onerrorflatmap is never calledim sure im just using this method incorrectly how can i fix it?``` java        observable<long> observable  observableinterval(1 timeunitseconds)                onerrorflatmap(new func1<onerrorthrowable observable<? extends long>>() {                    @override                    public observable<? extends long> call(onerrorthrowable onerrorthrowable) {                        return observableinterval(1 timeunitseconds)                    }                })        observablesubscribe(new subscriber<long>() {            @override            public void oncompleted() {            }            @override            public void onerror(throwable e) {            }            @override            public void onnext(long along) {                logd(tag ""val test:"" + along)                throw new runtimeexception(""oops"")            }        })```";"why not catch the exception in `onnext`? || @zsxwing yeah i that is my current option i thought there is better way to do it || take a look at this:  || we are killing `onerrorflatmap` as it breaks the rx contract see #1465 for the reasonshere is a simple event bus example that allows error handling + retry when errors happen:``` javaimport rxobservableimport rxsubjectspublishsubjectpublic class eventbus {    public static void main(string args) {        myeventbus bus  new myeventbus()        bustoobservable()filter(eventbus::is_number)foreach(n -> systemoutprintln(""got number: "" + n))        bustoobservable()filter(eventbus::is_string)foreach(systemout::println)        // something that can fail (it assumes integer)        bustoobservable()map(o -> {            if (((integer) o) > 10) {                return ""greater than 10""            } else {                return ""less than or equal to 10""            }        })doonerror(e -> systemerrprintln(egetmessage()))retry()foreach(systemout::println)        bussend(1)        systemoutprintln(""-----------------------"")        bussend(11)        systemoutprintln(""-----------------------"")        bussend(28)        systemoutprintln(""-----------------------"")        bussend(""hello"")        systemoutprintln(""-----------------------"")        bussend(5)        systemoutprintln(""-----------------------"")        bussend(""world"")        systemoutprintln(""-----------------------"")    }    public static boolean is_number(object o) {        if (o instanceof number) {            return true        } else {            return false        }    }    public static boolean is_string(object o) {        if (o instanceof string) {            return true        } else {            return false        }    }    public static class myeventbus {        private final publishsubject<object> bus  publishsubjectcreate()        public void send(object o) {            busonnext(o)        }        public observable<object> toobservable() {            return bus        }    }}```what use cases does this example not cover? id like to put together an ""event bus"" example in the docs || see  for where we are removing `onerrorflatmap` because it breaks the rx contract || ";;;;0;1;;
1436;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;javadoc: update code example (ignorestubs);it updates the code example of  ignorestubs  in javadoc.;;0;javadoc: update code example (ignorestubs);it updates the code example of `ignorestubs` in javadoc- correct wrong variable: from `mock` to `list`- change call sequence: the existing one doesnt clearly describe the use of `ignorestubs` with `inorder`;  thank you! || hey @marchpig do you want to help with #1438 cheers! || hi @mockitoguysure i will do that! ||;;;;1;1;javadoc: update code example (ignorestubs);
1436;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;javadoc: update code example (ignorestubs);it updates the code example of  ignorestubs  in javadoc.;;0;optimize json_size function;avoid extra round trip by performing size directly in extract codeuse function binder to cache patterns in call site;;;;;0;1;;
1436;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;javadoc: update code example (ignorestubs);it updates the code example of  ignorestubs  in javadoc.;;0;correct warnings;;#1390 ;;;;1;1;correct static access warnings;
1439;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;javadoc: #1438 update ignorestubs to include strictness;it updates  ignorestubs()  docs to include  strictness  information. (#1438);;0;document use of stringsemptytonull() in joiner javadoc;cow@ the issue of trimming or skipping empty strings comes up a lot for example see issue #﻿450 and #﻿708 this rfe was rejected twice but i believe addressing it in the javadoc would helphere is my own use-case and a workaround: i need join three arguments and skip any empty strings (notably classifier in this case):joineron()skipnulls()join(artifactgetgroupid() artifactgetartifactid() artifactgetclassifier())in any case it turns out there is a simple workaround passing in stringsemptytonull(artifactgetclassifier()) instead of artifactgetclassifier()so to recap please add joinerskipemptystrings() or document workarounds for this and other common use-cases; ;;;;0;1;;
1439;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;javadoc: #1438 update ignorestubs to include strictness;it updates  ignorestubs()  docs to include  strictness  information. (#1438);;0;mentioning the mysql-teradata integration posted by dheeban govindarajan;on the google group in june;;;;;0;1;;
1439;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;javadoc: #1438 update ignorestubs to include strictness;it updates  ignorestubs()  docs to include  strictness  information. (#1438);;0;019 javadocs arent published;  404;posted ||;;;;0;1;;
1439;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;javadoc: #1438 update ignorestubs to include strictness;it updates  ignorestubs()  docs to include  strictness  information. (#1438);;1438.0;javadoc: #1438 update ignorestubs to include strictness;it updates `ignorestubs()` docs to include `strictness` information (#1438);  this is ready to merge ill wait until current build is complete and merge it || thank you! ||;ignorestubs documentation should be updated for strictness;driven by #1436 we need to update ignorestubs docs to include information about mockito strictness (effectively replaces the need for ignorestubs);thank you for contribution! ||;1;0;updated documentation;
1440;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1420 auto downloader should respect file pattern and propose correct filename;(https://cloud.ent.com/assets/2141507/15472274/898030a4-20fa-11e6-9a77-8cfac10688d5.png);;0;consider adding whirlpool hash function (message digest);  you guys considered adding the whirpool digest algorithm to your toolkit?  the last time i checked it is cryptographically secure and is in the same class as sha-512﻿""(via comment by john sims on https://plusgooglecom/118010414872916542489/posts/1edwar1yre2)"; closing for the moment since we need to find a way to choose among the many available hash functions that we could implement--- ;;;;0;1;;
1440;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1420 auto downloader should respect file pattern and propose correct filename;(https://cloud.ent.com/assets/2141507/15472274/898030a4-20fa-11e6-9a77-8cfac10688d5.png);;0;javadoc: correct wrong links and code examples;some wrong links and code examples are corrected;  thank you @marchpig! ||;;;;1;1;javadoc: correct wrong links and code examples;
1440;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1420 auto downloader should respect file pattern and propose correct filename;(https://cloud.ent.com/assets/2141507/15472274/898030a4-20fa-11e6-9a77-8cfac10688d5.png);;0;verify at least one worker is selected in schedulenodecount;;;;;;0;1;;
1440;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1420 auto downloader should respect file pattern and propose correct filename;(https://cloud.ent.com/assets/2141507/15472274/898030a4-20fa-11e6-9a77-8cfac10688d5.png);;0;micro-optimization by nulling out list;a micro-optimization done as per discussion in  it is questionable whether this will help but if it can help android memory pressure then its worth it as it is a trivial change;;;;;1;1;micro-optimization by nulling out list;
1452;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;comprehensive test coverage for timeout() and after();new coverage enables us to test @christianschwarz s  within . i want to see all those tests working when we replace the internal implementation with  within .;;0;wiki documentation on primitives missing class name; in the primitive array utilities paragraph of the primitives category of the documentation wiki the class (objectarrays) containing the various methods explained here is never mentioned; thats correct objectarrays doesnt live in primitives  (it also doesnt share most of the methods mentioned on that page)--- ;;;;0;1;;
1452;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;comprehensive test coverage for timeout() and after();new coverage enables us to test @christianschwarz s  within . i want to see all those tests working when we replace the internal implementation with  within .;;0;comprehensive test coverage for timeout() and after();new coverage enables us to test @christianschwarzs within i want to see all those tests working when we replace the internal implementation with within; merging 1452 ! ||;;;;1;1;made timeouts more generous;
1452;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;comprehensive test coverage for timeout() and after();new coverage enables us to test @christianschwarz s  within . i want to see all those tests working when we replace the internal implementation with  within .;;0;upgrade to jax-rs 20 and jersey 291;;;;;;0;1;;
1452;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;comprehensive test coverage for timeout() and after();new coverage enables us to test @christianschwarz s  within . i want to see all those tests working when we replace the internal implementation with  within .;;0;removing onstart and onsetproducer from rxsubscriber;because they are unnecessary and it cant be undone once it is released  the `rxsubscriber` is part of the public api and these methods arent really needed for the rx to work;#1401  we have reviewed this in person and will modify this somewhat:- keep `onstart`- make `subscriberrequest` protected- remove `onsetproducer`thanks @abersnaze for this ||;;;;0;1;;
1458;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add stubbinglookupevent and notifier (a part of #793);this pr adds  stubbinglookupevent  and  stubbinglookupnotifier  as a part of the issue #793.;;0;make multimap putall/replaceall more clear about empty collection behavior; eg:&nbsp&nbsp&nbsp&nbsphashmultimap&ltinteger long> idblacklistmap  hashmultimapcreate()if i post the param like this  the key losted :&nbsp&nbsp&nbsp&nbspidblacklistmapputall(1 immutablesortedsetof())the putall implementation  is : &nbsp&nbsp&nbsp&nbspreturn valuesiterator()hasnext() && iterablesaddall(get(key) values)this is a little strange 。 u can reject the emptylist  but never ignore the key; ;;;;0;1;;
1458;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add stubbinglookupevent and notifier (a part of #793);this pr adds  stubbinglookupevent  and  stubbinglookupnotifier  as a part of the issue #793.;;0;minor metastore updates;;;;;;0;1;;
1458;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add stubbinglookupevent and notifier (a part of #793);this pr adds  stubbinglookupevent  and  stubbinglookupnotifier  as a part of the issue #793.;;0;remove pivot operator;as per https://githubcom/netflix/rxjava/issues/1402;#1410 too many modules || but pivot _must_ die! || its death is imminent :-) || #1411 ;;;;1;1;remove pivot operatoras per https://githubcom/netflix/rxjava/issues/1402;
1458;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add stubbinglookupevent and notifier (a part of #793);this pr adds  stubbinglookupevent  and  stubbinglookupnotifier  as a part of the issue #793.;;793.0;add stubbinglookupevent and notifier (a part of #793);this pr adds `stubbinglookupevent` and `stubbinglookupnotifier` as a part of the issue #793; merging 1458  < ;expose stubbinglookuplistener publicly and create listener distinction;"make stubbinglookuplistener public originating ticket: #770as a rule of a thumb we try to expose the internal apis that the top level features are built upon since stubbinglookuplistener is useful for us to implement strictness lets get the former exposed as public api this way we build stronger framework with the concept of ""onion skin api""";if exposed publicly the api should use an event object (see  ||;1;0;remove wrong comment on stubbinglookupnotifier;
1463;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;prevent stubonly() from being verified (#1460);this pr adds assertion to verification methods to prevent stub-only mock from being verified (#1460);;0;add synchronzed wrapper for deque; there is a method comgooglecommoncollectqueuessynchronizedqueue(queue&lte>) but there is no correspondent method for deque as deque is part of the standard java collection framework i request to introduce a method comgooglecommoncollectqueuessynchronizeddeque(deque&lte>) although there is no class like comgooglecommoncollectdeques the comgooglecommoncollectqueues class already contains deque-related methods like newarraydeque() so it would also be the logical place to put a method like synchronizeddeque()being kind of analogous to the synchronizedqueue() case i already did an implementation for my own amusement that id like to contribute; will be part of 150!--- ;;;;0;1;;
1463;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;prevent stubonly() from being verified (#1460);this pr adds assertion to verification methods to prevent stub-only mock from being verified (#1460);;0;added number of runs and  time zone header to perftest;;;;;;0;1;;
1463;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;prevent stubonly() from being verified (#1460);this pr adds assertion to verification methods to prevent stub-only mock from being verified (#1460);;0;merge bug: missing emissions;"notes and temporary fix using `synchronized` to achieve correctness until a proper solution can be foundthis code does not exhibit the issue when i do production testing without the two `synchronized` methods i get errors in prod that ive temporarily added to `blockingoperatortoiterator` until this is  so its visible```/apps/tomcat/logs$ tail -f catalinaout |grep ""timed out waiting for value""timed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjavatimed out waiting for value file a bug at githubcom/netflix/rxjava```";#1414 ;;;;1;1;merge bug: missing emissionsnotes and temporary fix;
1463;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;prevent stubonly() from being verified (#1460);this pr adds assertion to verification methods to prevent stub-only mock from being verified (#1460);;1460.0;prevent stubonly() from being verified (#1460);this pr adds assertion to verification methods to prevent stub-only mock from being verified (#1460)- `verify()`- `verifynomoreinteractions()`- `inorder()`; merging 1463  < ;verifyzerointeractions(stub-only-mock) does not throw exception;hi`verifyzerointeractions(stub-only-mock)` doesnt throw exceptioni think it should throw `cannotverifystubonlymock` exception as `verify()` does for consistency```java@testpublic void test_stub_only_not_verifiable_verify_zero_interactions() {    // given    imethods localmock  mock(imethodsclass withsettings()stubonly())    localmockobjectreturningmethod(200)    try {        // when        verifyzerointeractions(localmock)        fail()    } catch (cannotverifystubonlymock e) {        // then exception should be thrown    }}```thankssangwoo;;1;0;tweaked the tests- to improve coverage (safety) we want at least one test to verify the whole exception message- to keep tests clean we avoid copying implementation in tests (eg explicitly calling mockutilgetmockname);
1474;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1434: static groups are now longer displayed as dynamic ones;reason for this bug: explictegroup now derives from keywordgroup and thus was sometimes displayed as a keyword group. -   -   -   ();;0;filestostring(file charset) puts an extra newline char to the result; if you read a text file with filestostring(file charset) into a string and your input file did not contain a newline at the end (blah-blaheof) the resulting string will carry an extra (and i think redundant) newline charif its a conscious behavior i would suggest some warning into the javadocssystem: linux amd64guava: 1401java version ""170_25"""; i cant reproduce this i just created a file with no newline read it with filestostring and got a string with no newline also take a look at the tests in filestest specifically testtostring ( among other things it reads the file asciitxt ( which has no newline and asserts that its equal to the constant string ascii which also has no newlineare you sure the file youre reading doesnt have a newline on the end? if it doesnt could you give me a simple test case to reproduce this?--- ;;;;0;1;;
1474;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1434: static groups are now longer displayed as dynamic ones;reason for this bug: explictegroup now derives from keywordgroup and thus was sometimes displayed as a keyword group. -   -   -   ();;0;comprehensive coverage for timeout + inorder;preparing for merging major overhaul in the implementation of timeout and after apis (#936)we need coverage before we completely replace the existing implementation; merging 1474  if thats ok happy to address review feedback after this is ;;;;1;1;comprehensive coverate for timeout + inorderpreparing for merging major overhaul in the implementation of timeout and after apis (#936);
1474;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1434: static groups are now longer displayed as dynamic ones;reason for this bug: explictegroup now derives from keywordgroup and thus was sometimes displayed as a keyword group. -   -   -   ();;0;timestamp partitions not supported for hive;```unsupported partition type [timestamp] for partition: date_time_trunc_hour2013-12-01 00%253a00%253a00```;;;;;0;1;;
1474;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1434: static groups are now longer displayed as dynamic ones;reason for this bug: explictegroup now derives from keywordgroup and thus was sometimes displayed as a keyword group. -   -   -   ();;0;ignore backpressure for operatortoobservablesortedlist;;#1422 ;;;;1;1;ignore backpressure for operatortoobservablesortedlist;
1475;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;mockitosession api does not clean up listener when initmocks fails;when initmocks() fails we did not clean up the session listener. this led to a confusing error message on the next attempt to create a session (next test method run). i stumbled upon this problem when attempting to configure testng to use strict stubbing (https://github.com/mockito/mockito-testng/issues/1).;;0;fix multimapstransformvalues javadoc sample;  comgooglecommonbasefunction)the version 1401 javadoc sample for multimapstransformvalues(multimap function) currently states:{a[4 16] b[9 9] c[6]}but instead should state:{a[4 16] b[9 9] c[36]}; ;;;;0;1;;
1475;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;mockitosession api does not clean up listener when initmocks fails;when initmocks() fails we did not clean up the session listener. this led to a confusing error message on the next attempt to create a session (next test method run). i stumbled upon this problem when attempting to configure testng to use strict stubbing (https://github.com/mockito/mockito-testng/issues/1).;;0;mockitosession api does not clean up listener when initmocks fails;when initmocks() fails we did not clean up the session listener this led to a confusing error message on the next attempt to create a session (next test method run) i stumbled upon this problem when attempting to configure testng to use strict stubbing ( order to fix this cleanly i need to keep the existing functionality that protects the user from forgetting to use finishmocking() hence i still need to throw an exception if the user adds the same listener multiple times however in the event that the listener is dirty i clean it up automatically instead of failing; merging 1475  this because it blocks  happy to address code review feedback after this is merged the change does not involved public api changes it fixes a bug all existing tests pass and the new tests pass too lets ship it! ||;;;;1;1;added code comments to improve understanding of this change;
1475;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;mockitosession api does not clean up listener when initmocks fails;when initmocks() fails we did not clean up the session listener. this led to a confusing error message on the next attempt to create a session (next test method run). i stumbled upon this problem when attempting to configure testng to use strict stubbing (https://github.com/mockito/mockito-testng/issues/1).;;0;verifier improvements;;;;;;0;1;;
1475;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;mockitosession api does not clean up listener when initmocks fails;when initmocks() fails we did not clean up the session listener. this led to a confusing error message on the next attempt to create a session (next test method run). i stumbled upon this problem when attempting to configure testng to use strict stubbing (https://github.com/mockito/mockito-testng/issues/1).;;0;backpressure: amb;the amb operator needs to be updated with backpressure support;finished in #1516 ||;;;;0;1;;
1484;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix some typos;don t -> doesn t;;0;provide api access to details used for timed evictions in caches; from  :when using expireafteraccess or expireafterwrite the related timestamps are already held within the cache  i know that we can enumerate all objects in a cache  i know that we can also use removal listeners to receive notifications when entries are removed from the cache  there is also the cachestats  however the api currently doesnt provide for any method to determine when a given entry in the cache is due to expire (assuming nothing else happens to cause it to be renewed etc)what id like to do is provide a diagnostic / admin ui that shows all of the entries currently held in the cache - along with when they were created and when they are due to expire  i could probably store and maintain my own metadata for each entry to be able to determine these details myself - but it seems silly to need to duplicate data that is already being maintained internally by the cacheadditional helpful notes from ben manes:expiration is implemented as time ordered queues where the head is the entry most likely to expire the entries contain a timestamp which is used to evaluate for expiration the traversal of the queues must be done under a lock and the cache lacks true global ordering due to using queues per hash table segments for those reasons exposing an ordered iteration is expensive and not currently providedthats the background for why this may not be added but you can open an issue and maybe it will be addressed it could be done by sorting without leveraging the queues which is less elegant but perfectly fine for administration purposes; ;;;;0;1;;
1484;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix some typos;don t -> doesn t;;0;fix some typos;dont -> doesnt;  ;;;;1;1;fix typosdont -> doesnt;
1484;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix some typos;don t -> doesn t;;0;add try_cast;;;;;;0;1;;
1484;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix some typos;don t -> doesn t;;0;backpressure: flatmapiterable;need to add support for backpressure;now renamed to flatmapiterable || closing: `flatmapiterable` supports backpressure for some time now ||;;;;0;1;;
1521;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;minor improvements in the javadoc of mockito.java;this pr fixes a type and adds a reference to the junit5 extension.;;0;minor improvements in the javadoc of mockitojava;this pr fixes a type and adds a reference to the junit5 extensioncheck list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_;alright you win this time grammar nazi travis )i  the problem ||;;;;1;1;minor improvements in the javadoc of mockitojava;
1521;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;minor improvements in the javadoc of mockito.java;this pr fixes a type and adds a reference to the junit5 extension.;;0;add table rename support;syntax: `alter table old rename to new`this feature is disabled by default for the hive connectorenable by setting `hiveallow-rename-table` to `true`;;;;;0;1;;
1521;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;minor improvements in the javadoc of mockito.java;this pr fixes a type and adds a reference to the junit5 extension.;;0;fix toiterator exception handling;fixes https://githubcom/netflix/rxjava/issues/1450;#1440 ;;;;1;1;fix toiterator exception handling;
1523;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;added  lenient  annotation toggle;this way we can conveniently configure an existing  lenient  setting via an annotation. see the unit test that describes the feature.;;0;added lenient annotation toggle;this way we can conveniently configure an existing lenient setting via an annotation see the unit test that describes the feature```java@mock(lenient  true) someclass mock```; merging 1523  < ;;;;1;1;added documentation;
1523;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;added  lenient  annotation toggle;this way we can conveniently configure an existing  lenient  setting via an annotation. see the unit test that describes the feature.;;0;apache kafka support for presto;query apache kafka topics as presto tables;"not a single comment yet? :-(  || four weeks in pinging again :-)  || add release notes || @dain re release notes: sure how? there is no file in docs//release/release-076rst i would assume that this might move if another release comes along before this gets merged and generally i assumed that the presto team will write release notes once this has been merged in i am happy to contribute here please advise how || @hgschmie yep just add a 076 file  if the release moves well deal with the conflicts  this is a new thing as we move towards continuous release we need the release notes to always be up to date  the notes only need to be a brief description with a link to the docs || travis ci fails in postgresql with  [error] caused by: javalangillegalstateexception: process [/tmp/embedded-pg/pg-18ebb30f889739162843e4b7b8377d38/bin/initdb -a trust -u postgres -d /tmp/embedded-pg/bb2f3634-3fbc-48ad-bc6e-b15db5667b10 -e utf-8] failed[error] /tmp/embedded-pg/pg-18ebb30f889739162843e4b7b8377d38/bin/postgres: error while loading shared libraries: libsslso10: cannot open shared object file: no such file or directory[error] no data was returned by command """"/tmp/embedded-pg/pg-18ebb30f889739162843e4b7b8377d38/bin/postgres"" -v""[error] the program ""postgres"" is needed by initdb but was not found in the[error] same directory as ""/tmp/embedded-pg/pg-18ebb30f889739162843e4b7b8377d38/bin/initdb""[error] check your installationiaw travis does not run on rhel :-)  || ugh maybe we should use static linking? || overall looks good assigning to david to look at the documentation  || i have a new pull request with some changes for @nileema to review: #1651 || ";;;;0;1;;
1523;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;added  lenient  annotation toggle;this way we can conveniently configure an existing  lenient  setting via an annotation. see the unit test that describes the feature.;;152.0; #1522;`takelast` should ignore other `request`s if its requested with `longmax_value` #1522;#1441  #1442 #1443 looks good || [rxjava-pull-requests #1445]( successthis pull request looks good || [rxjava-pull-requests #1450 [rxjava-pull-requests #1453]( successthis pull request looks good || i think this looks good though im still curious if the complexity here is worth us having a fast-path would be interesting to do jmh testing in `onsubscribefromrange` it does make a difference but here i question it because every `onnext` is passing through a `queue` ||;implemented next operation;fixes issue #66;implemented #58 using next operation || @mairbek thank you for submitting these they look great based on a quick glance ive been crushed on some production work so have been delayed in reviewing these i will get to this and your other pull request definitely this week || i merged  which provides the toiterable functionalityclosing this one due to the issues discussed above ||;1;0;"make ""single"" support backpressuresigned-off-by: zsxwing <zsxwing@gmailcom>";
1526;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;typo fix in unfinishedstubbingexception;a very simple typo fix.;;0;objects - minor doc improvement;  t)note: if first is represented as an optional&ltt> this can be accomplished with firstor(second) that approach also allows for lazy evaluation of the fallback instance using firstor(supplier)@@please @﻿link to optional or optional#or; should be mirrored out shortly--- ;;;;0;1;;
1526;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;typo fix in unfinishedstubbingexception;a very simple typo fix.;;0;typo fix in unfinishedstubbingexception;a very simple typo fix check list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_; ;;;;1;1;typo fix in unfinishedstubbingexception;
1526;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;typo fix in unfinishedstubbingexception;a very simple typo fix.;;0;added section on joins with first section on cross join;;@electrum did you already review this? i thought you wanted to do all of these || ;;;;0;1;;
1526;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;typo fix in unfinishedstubbingexception;a very simple typo fix.;;0;restore use of spmcarrayqueue in rxringbuffer;- modification of spmcarrayqueue with fix from   - i expect updates to this code over time but wanted to move forward with a working solution for now- restore rxringbuffer to use spmcarrayqueue  - this reduces object allocation significantly and increases performance in some use cases### performance diff#### 0200-rc3```/gradlew benchmarks -pjmh-f 1 -wi 5 -i 5 -r 2 *rxinternalrxringbufferperf*benchmark                                            mode   samples        score  score error    unitsrirxringbufferperfspmccreateuseanddestroy1       thrpt         5 33224158580   399867898    ops/srirxringbufferperfspmccreateuseanddestroy1000    thrpt         5    73346934      853989    ops/srirxringbufferperfspmcringbufferaddremove1       thrpt         5 22034846226   579563777    ops/srirxringbufferperfspmcringbufferaddremove1000    thrpt         5    21612517      567086    ops/srirxringbufferperfspsccreateuseanddestroy1       thrpt         5 32277699473  2481022929    ops/srirxringbufferperfspsccreateuseanddestroy1000    thrpt         5    72782657     3836229    ops/srirxringbufferperfspscringbufferaddremove1       thrpt         5 21625427399   555584413    ops/srirxringbufferperfspscringbufferaddremove1000    thrpt         5    21588532      875871    ops/s``````/gradlew benchmarks -pjmh-f 1 -wi 5 -i 5 -r 2 *rxoperatorsoperatormergeperf*benchmark                                          (size)   mode   samples        score  score error    unitsrooperatormergeperfmerge1syncstreamofn               1  thrpt         5  5066495356    73296083    ops/srooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    55094237     1067519    ops/srooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       57981        1324    ops/srooperatormergeperfmergenasyncstreamsofn             1  thrpt         5    97273839     9582028    ops/srooperatormergeperfmergenasyncstreamsofn          1000  thrpt         5        4754        0115    ops/srooperatormergeperfmergensyncstreamsof1              1  thrpt         5  4384357616   302930385    ops/srooperatormergeperfmergensyncstreamsof1            100  thrpt         5   278124421    36626222    ops/srooperatormergeperfmergensyncstreamsof1           1000  thrpt         5    35179120     1059293    ops/srooperatormergeperfmergensyncstreamsofn              1  thrpt         5  5383548483   125915654    ops/srooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       54551        3245    ops/srooperatormergeperfmergetwoasyncstreamsofn           1  thrpt         5    66546808    30474772    ops/srooperatormergeperfmergetwoasyncstreamsofn        1000  thrpt         5     2828244      103470    ops/srooperatormergeperfonestreamofnthatmergesin1         1  thrpt         5  5030721519   181734814    ops/srooperatormergeperfonestreamofnthatmergesin1      1000  thrpt         5    24489183      759520    ops/srooperatormergeperfonestreamofnthatmergesin1   1000000  thrpt         5       30101        0802    ops/s```memory allocation capture with java flight recorder while executing:```/gradlew benchmarks -pjmh-f 1 -wi 5 -i 5 -r 20 *rxoperatorsoperatormergeperfmergenasyncstreamsofn*```![object-allocation-with-linkedlist]( with jctools impl```/gradlew benchmarks -pjmh-f 1 -wi 5 -i 5 -r 2 *rxinternalrxringbufferperf*benchmark                                            mode   samples        score  score error    unitsrirxringbufferperfspmccreateuseanddestroy1       thrpt         5 27028267871  2547216752    ops/srirxringbufferperfspmccreateuseanddestroy1000    thrpt         5    78238446     2539165    ops/srirxringbufferperfspmcringbufferaddremove1       thrpt         5 43396574546   918454062    ops/srirxringbufferperfspmcringbufferaddremove1000    thrpt         5    64074506      531873    ops/srirxringbufferperfspsccreateuseanddestroy1       thrpt         5 27163028506   506868149    ops/srirxringbufferperfspsccreateuseanddestroy1000    thrpt         5    77472474     2875597    ops/srirxringbufferperfspscringbufferaddremove1       thrpt         5 43309504983   337590502    ops/srirxringbufferperfspscringbufferaddremove1000    thrpt         5    64140916     1292265    ops/s``````/gradlew benchmarks -pjmh-f 1 -wi 5 -i 5 -r 2 *rxoperatorsoperatormergeperf*benchmark                                          (size)   mode   samples        score  score error    unitsrooperatormergeperfmerge1syncstreamofn               1  thrpt         5  5146417279   168011480    ops/srooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    56640224      789709    ops/srooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       60610        1022    ops/srooperatormergeperfmergenasyncstreamsofn             1  thrpt         5    97759963     1897592    ops/srooperatormergeperfmergenasyncstreamsofn          1000  thrpt         5        5937        0404    ops/srooperatormergeperfmergensyncstreamsof1              1  thrpt         5  4511685053   136414240    ops/srooperatormergeperfmergensyncstreamsof1            100  thrpt         5   285644030     9325626    ops/srooperatormergeperfmergensyncstreamsof1           1000  thrpt         5    32789901     1143208    ops/srooperatormergeperfmergensyncstreamsofn              1  thrpt         5  5415231898   107538428    ops/srooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       55918        0660    ops/srooperatormergeperfmergetwoasyncstreamsofn           1  thrpt         5    74341892     3274847    ops/srooperatormergeperfmergetwoasyncstreamsofn        1000  thrpt         5     4138087      329935    ops/srooperatormergeperfonestreamofnthatmergesin1         1  thrpt         5  5026384994   242183595    ops/srooperatormergeperfonestreamofnthatmergesin1      1000  thrpt         5    24700473      334516    ops/srooperatormergeperfonestreamofnthatmergesin1   1000000  thrpt         5       30458        0603    ops/s```memory allocation capture with java flight recorder while executing:```/gradlew benchmarks -pjmh-f 1 -wi 5 -i 5 -r 20 *rxoperatorsoperatormergeperfmergenasyncstreamsofn*```![object-allocation-with-arrayqueue](https://cloudentcom/assets/813492/3727746/38de2d8c-16a1-11e4-93cd-32dba4497a5fpng);note that in this comparison (1 minute test of mergenasyncstreamsofn) over 6gb of object allocation is eliminated by changing the data structure || #1446 ;;;;1;1;restore use of spmcarrayqueue in rxringbuffer- modification of spmcarrayqueue with fix from  restore rxringbuffer to use spmcarrayqueue- this reduces object allocation significantly (see pull request for screenshots);
1536;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;allow delegating to non-public methods for additionalanswers#delegatesto;fixes an issue where doing  delegatesto(new anonymousclass() {})  would cause an illegalaccessexception  and other access-related issues.;;0;eventbus: handling events on different pools based on method tags;l@ this is originally coming from this issue: it would be great to be able to tag a @﻿subscriber together with custom tags and to open eventbus to custom implementations of ""handlerfindingstrategy"" so we can also extend eventhandler and override ""handleevent(object)"" there so we can handle it on the edt for instance"; ;;;;0;1;;
1536;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;allow delegating to non-public methods for additionalanswers#delegatesto;fixes an issue where doing  delegatesto(new anonymousclass() {})  would cause an illegalaccessexception  and other access-related issues.;;0;allow delegating to non-public methods for additionalanswers#delegatesto;"fixes an issue where doing ""delegatesto(new anonymousclass() {})"" would cause an illegalaccessexception and other access-related issues(see  - sorry wasnt aware that you cant change the pr source branch)";" merging 1536  ";;;;1;1;reworked coveragewe prefer user e2e tests for such features;
1536;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;allow delegating to non-public methods for additionalanswers#delegatesto;fixes an issue where doing  delegatesto(new anonymousclass() {})  would cause an illegalaccessexception  and other access-related issues.;;0;flush join indexes when memory is constrained;add a separate limit for index memory usage that is independent of the taskmemory limit this removes the risk of the flushable memory usage causinganother operator to run out of memoryloader will attempt to load new data and add to existing cache  if thatfails it flushes the cache and tries again  if that fails it loads onlythe single required request for the loader thread;ok im done with this pass let me know what you think about these comments || @erichwang take another look ||;;;;0;1;;
1536;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;allow delegating to non-public methods for additionalanswers#delegatesto;fixes an issue where doing  delegatesto(new anonymousclass() {})  would cause an illegalaccessexception  and other access-related issues.;;0;non-deterministic hang - exceptionstest?;three builds have hung around the same place near here:- rxexceptionsexceptionstest > teststackoverflowisthrown standard_out- rxexceptionsexceptionstest standard_outthe logs can be seen at:-    have tried to replicate in the `exceptionstest` code but have not succeeded;anyone able to reproduce this? i havent been able to  || i let `teststackoverflowisthrown` run in a loop for 20+ minutes without issue || another cloudbees hang:  || happened again here:  this looks like it has more logs:```rxexceptionsexceptionstest standard_out    2571rxexceptionsonnextvaluetest > addonnextvalueexceptionnotaddedwithbadstring standard_out    on error: javalangillegalargumentexception: failure while handling        at rxexceptionsonnextvaluetest$2call(onnextvaluetestjava:101)        at rxexceptionsonnextvaluetest$2call(onnextvaluetestjava:98)        at rxinternaloperatorsoperatormap$1onnext(operatormapjava:54)        at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:41)        at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:30)        at rxobservable$2call(observablejava:173)        at rxobservable$2call(observablejava:166)        at rxobservablesubscribe(observablejava:8287)        at rxobservablesubscribe(observablejava:8156)        at rxexceptionsonnextvaluetestaddonnextvalueexceptionnotaddedwithbadstring(onnextvaluetestjava:97)        at sunreflectnativemethodaccessorimplinvoke0(native method)        at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:57)        at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)        at javalangreflectmethodinvoke(methodjava:606)        at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:45)        at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:15)        at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:42)        at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:20)        at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:263)        at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:68)        at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:47)        at orgjunitrunnersparentrunner$3run(parentrunnerjava:231)        at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:60)        at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:229)        at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:50)        at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:222)        at orgjunitrunnersparentrunnerrun(parentrunnerjava:300)        at orggradleapiinternaltaskstestingjunitjunittestclassexecuterruntestclass(junittestclassexecuterjava:80)        at orggradleapiinternaltaskstestingjunitjunittestclassexecuterexecute(junittestclassexecuterjava:47)        at orggradleapiinternaltaskstestingjunitjunittestclassprocessorprocesstestclass(junittestclassprocessorjava:69)        at orggradleapiinternaltaskstestingsuitetestclassprocessorprocesstestclass(suitetestclassprocessorjava:49)        at sunreflectgeneratedmethodaccessor7invoke(unknown source)        at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)        at javalangreflectmethodinvoke(methodjava:606)        at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:35)        at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:24)        at orggradlemessagingdispatchcontextclassloaderdispatchdispatch(contextclassloaderdispatchjava:32)        at orggradlemessagingdispatchproxydispatchadapter$dispatchinginvocationhandlerinvoke(proxydispatchadapterjava:93)        at comsunproxy$proxy2processtestclass(unknown source)        at orggradleapiinternaltaskstestingworkertestworkerprocesstestclass(testworkerjava:103)        at sunreflectgeneratedmethodaccessor6invoke(unknown source)        at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)        at javalangreflectmethodinvoke(methodjava:606)        at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:35)        at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:24)        at orggradlemessagingremoteinternalhubmessagehub$handlerrun(messagehubjava:355)        at orggradleinternalconcurrentdefaultexecutorfactory$stoppableexecutorimpl$1run(defaultexecutorfactoryjava:66)        at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1145)        at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:615)        at javalangthreadrun(threadjava:744)    caused by: rxexceptionsonerrorthrowable$onnextvalue: onerror while emitting onnext value: badtostringclass        at rxexceptionsonerrorthrowableaddvalueaslastcause(onerrorthrowablejava:98)        at rxinternaloperatorsoperatormap$1onnext(operatormapjava:56)         47 morerxexceptionsonnextvaluetest > addonnextvalueexceptionadded standard_out    on error: javalangillegalargumentexception: failure while handling        at rxexceptionsonnextvaluetest$1call(onnextvaluetestjava:87)        at rxexceptionsonnextvaluetest$1call(onnextvaluetestjava:84)        at rxinternaloperatorsoperatormap$1onnext(operatormapjava:54)        at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:41)        at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:30)        at rxobservable$2call(observablejava:173)        at rxobservable$2call(observablejava:166)        at rxobservablesubscribe(observablejava:8287)        at rxobservablesubscribe(observablejava:8156)        at rxexceptionsonnextvaluetestaddonnextvalueexceptionadded(onnextvaluetestjava:83)        at sunreflectnativemethodaccessorimplinvoke0(native method)        at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:57)        at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)        at javalangreflectmethodinvoke(methodjava:606)        at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:45)        at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:15)        at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:42)        at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:20)        at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:263)        at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:68)        at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:47)        at orgjunitrunnersparentrunner$3run(parentrunnerjava:231)        at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:60)        at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:229)        at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:50)        at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:222)        at orgjunitrunnersparentrunnerrun(parentrunnerjava:300)        at orggradleapiinternaltaskstestingjunitjunittestclassexecuterruntestclass(junittestclassexecuterjava:80)        at orggradleapiinternaltaskstestingjunitjunittestclassexecuterexecute(junittestclassexecuterjava:47)        at orggradleapiinternaltaskstestingjunitjunittestclassprocessorprocesstestclass(junittestclassprocessorjava:69)        at orggradleapiinternaltaskstestingsuitetestclassprocessorprocesstestclass(suitetestclassprocessorjava:49)        at sunreflectgeneratedmethodaccessor7invoke(unknown source)        at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)        at javalangreflectmethodinvoke(methodjava:606)        at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:35)        at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:24)        at orggradlemessagingdispatchcontextclassloaderdispatchdispatch(contextclassloaderdispatchjava:32)        at orggradlemessagingdispatchproxydispatchadapter$dispatchinginvocationhandlerinvoke(proxydispatchadapterjava:93)        at comsunproxy$proxy2processtestclass(unknown source)        at orggradleapiinternaltaskstestingworkertestworkerprocesstestclass(testworkerjava:103)        at sunreflectgeneratedmethodaccessor6invoke(unknown source)        at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)        at javalangreflectmethodinvoke(methodjava:606)        at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:35)        at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:24)        at orggradlemessagingremoteinternalhubmessagehub$handlerrun(messagehubjava:355)        at orggradleinternalconcurrentdefaultexecutorfactory$stoppableexecutorimpl$1run(defaultexecutorfactoryjava:66)        at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1145)        at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:615)        at javalangthreadrun(threadjava:744)    caused by: rxexceptionsonerrorthrowable$onnextvalue: onerror while emitting onnext value: badtostringclass        at rxexceptionsonerrorthrowableaddvalueaslastcause(onerrorthrowablejava:98)        at rxinternaloperatorsoperatormap$1onnext(operatormapjava:56)         47 morebuild timed out (after 40 minutes) marking the build as aborted``` || i cant replicate this and no one has reported this in prod/dev usage only cloudbees so im moving this to 10 and not blocking 020 on this || what happens is that a stackoverflowerror is thrown but the check for it close (the stack is still next to full) so the attempt to report it may again cause another stackoverflowerror so instead of causing an actual stackoverflow we could just throw one similar to how threaddeath is tested btw `assertfalse(iscomputeron())`? || i havent seen this failure a long time so closing ||;;;;0;1;;
1539;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;improved sensitivity of potential stubbing problem;this change improves the developer experience with strict stubbing. it is now possible to stub the same method with different argument multiple times in the test. previously  we threw potentialstubbingproblem exception in this scenario:;;0;guava 15 doesnt work on oracle java 7u40; javalangverifyerror: class comgooglecommoncollectemptyimmutablelist overrides final method toarray([ljava/lang/object)[ljava/lang/objectthe 1401 version works perfectly; hmm yes there are definitely two versions of guava on the classpath you can tell because emptyimmutablelist doesnt exist in guava 15--- ;;;;0;1;;
1539;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;improved sensitivity of potential stubbing problem;this change improves the developer experience with strict stubbing. it is now possible to stub the same method with different argument multiple times in the test. previously  we threw potentialstubbingproblem exception in this scenario:;;0;allow verifier to specify the jdbc driver for control and test;ran this on the impala cluster that i set up verifier completed successfully however i need to look into the results;looks good besides comments || thinking about this some more why do you need your own classloader instead of just using java -classpath?  || hah great point chris || in fact reading a little more about jdbc im not sure we need this at all i think if you add the impala jar to the classpath everything will just work ( @nileema can you try that? || the idea was to load it at runtime and doing so requires some trickery due to class loader security i didnt realize the obvious that this is simply an executable jar so just add the driver to the class path when running itthough it will make running a bit more involved since i think you have to specify the main class but that seems reasonable to avoid this complexity || that was the first thing i tried however the impala jdbc jar does not have all the dependencies there are 13 jar that are needed for the driver to run correctly  || with java 7 you can use wild cards in the class path argument does that help? || @nileema how does this help with the missing dependencies compared to using `java -cp`? || ;;;;0;1;;
1539;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;improved sensitivity of potential stubbing problem;this change improves the developer experience with strict stubbing. it is now possible to stub the same method with different argument multiple times in the test. previously  we threw potentialstubbingproblem exception in this scenario:;;0;need help with composition of several observables;``` javaobservable<string> observable1observable<boolean> observable2observable<void> observable3```i need to to create observable3 that will produce values on every change of observable1 when observable2 last value is truewill appreciate any help(by the way im using java 6);"do you mean latest value of obs2 is true or last value? || here are some options that might get you moving in the direction you want:``` javaimport javautilconcurrenttimeunitimport rxobservablepublic class combinelatestandfilter {    public static void main(string args) {        observable<string> observable1  observableinterval(1 timeunitmilliseconds)map(i -> ""value_"" + i)        observable<boolean> observable2  observableinterval(7 timeunitmilliseconds)map(i -> i % 2  0 ? true : false)startwith(false)        /*         * solution a         *          * this works as long as youre okay if the last observable1 value is emitted when observable2 changes from false to true         */        observable<string> observable3a  observablecombinelatest(observable1 observable2 (o1 o2) -> {            systemoutprintln(""        o1: "" + o1 + "" o2: "" + o2)            return new object { o1 o2 } // poor excuse for a tuple            })filter(oo -> (boolean) oo[1])map(oo -> (string) oo[0])        /*         * solution b         *          * this adds distinctuntilchanged so that it wont emit during the change from false -> true         * however this means it could also skip values from observable1 if duplicates are expected so it can only be used if         * the values are expected to be unique         */        observable<string> observable3b  observablecombinelatest(observable1 observable2 (o1 o2) -> {            systemoutprintln(""        o1: "" + o1 + "" o2: "" + o2)            return new object { o1 o2 } // poor excuse for a tuple            })distinctuntilchanged(oo -> (string) oo[0])filter(oo -> (boolean) oo[1])map(oo -> (string) oo[0])        /*         * solution c         *          * this gets more complicated by zipping observable1 with a range to index it so we can de-dupe on the index number         * instead of the value in case we need to handle possible duplicate values and solution a above is not okay         */        observable<object> observable1withindex  observable1zipwith(observablerange(0 integermax_value) (v i) -> new object { v i })        observable<string> observable3c  observablecombinelatest(observable1withindex observable2 (o1 o2) -> {            systemoutprintln(""        o1: "" + o1[0] + "" index: "" + o1[1] + "" o2: "" + o2)            return new object { o1[1] ""repetitive-value"" o2 } // poor excuse for a tuple            })distinctuntilchanged(oo -> oo[0])filter(oo -> (boolean) oo[2])map(oo -> (string) oo[1])        observable3atake(20)toblocking()foreach(systemout::println)        //        observable3btake(20)toblocking()foreach(systemout::println)        //        observable3ctake(20)toblocking()foreach(systemout::println)    }}``` || @benjchristensen thank you for your quick response this was very helpful!i believe the solution a youve suggested will suffice with solving my problem || great good luck! || ";;;;0;1;;
1539;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;improved sensitivity of potential stubbing problem;this change improves the developer experience with strict stubbing. it is now possible to stub the same method with different argument multiple times in the test. previously  we threw potentialstubbingproblem exception in this scenario:;;1522.0;improved sensitivity of potential stubbing problem;this change improves the developer experience with strict stubbing it is now possible to stub the same method with different argument multiple times in the test previously we threw potentialstubbingproblem exception in this scenario:```javawhen(mockfoo(1))thenreturn(1)when(mockfoo(2))thenreturn(2) // <- no longer throws potentialstubbingproblem (false negative)```this reduces the number of false negatives reported by strict stubbing1522 #1496 partially #769 #720; merging 1539 ;correct usage of strict stubbings -> potentialstubbingproblem: strict stubbing argument mismatch;"hi guysthis is following is almost a copy paste from the mockito google group/forum which i was recommended to do: versions:**```os : fedora linux 41814-200fc28x86_64mockito : 2230junit : 531jdk : oracle 1002 (happens under 8 and openjdk 1101 too)intellij : 20183 eap    testcompile group: orgjunitjupiter name: junit-jupiter-api version: 531    testruntime group: orgjunitjupiter name: junit-jupiter-engine version: 531    testcompile group: orgmockito name: mockito-junit-jupiter version: 2230```**actual question:**i had some questions regarding use cases of new ""strict"" stubbingwith junit5 & `@extendwith(mockitoextensionclass)` ive noticed that it errors out when i think it shouldnt (when compared with junit4 & `@runwith(mockitojunitrunnerclass)` )i have a very simple test case which i consider to be both good code and good mocking which gets highlighted as incorrect stubbing usage under strict (default) checking```package comexampleimport orgjunitjupiterapitestimport orgjunitjupiterapiextensionextendwithimport orgmockitomockimport orgmockitojunitjupitermockitoextensionimport javautilmapimport static orgjunitjupiterapiassertionsassertequalsimport static orgmockitomockitowhen@extendwith(mockitoextensionclass)class mockitotest {    @mock    private map<string object> mockmap    @mock    private object mockobject    @test    void shouldbeabletomock() {        // when        when(mockmapget(""a""))thenreturn(""apple"")        when(mockmapget(""b""))thenreturn(mockobject)        // then        assertequals(""apple"" mockmapget(""a""))        assertequals(mockobject mockmapget(""b""))    }}```the above gives the following stacktrace when run:```orgmockitoexceptionsmisusingpotentialstubbingproblem: strict stubbing argument mismatch please check: - this invocation of get method:    mockmapget(""b"")    -> at comexamplemockitotestshouldbeabletomock(mockitotestjava:25) - has following stubbing(s) with different arguments:    1 mockmapget(""a"")      -> at comexamplemockitotestshouldbeabletomock(mockitotestjava:24)typically stubbing argument mismatch indicates user mistake when writing testsmockito fails early so that you can debug potential problem easilyhowever there are legit scenarios when this exception generates false negative signal:  - stubbing the same method multiple times using given()will() or when()then() api    please use will()given() or doreturn()when() api for stubbing  - stubbed method is intentionally invoked with different arguments by code under test    please use default or silent junit rule (equivalent of strictnesslenient)for more information see javadoc for potentialstubbingproblem class    at comexamplemockitotestshouldbeabletomock(mockitotestjava:25)    at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)    at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)    at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javabase/javalangreflectmethodinvoke(methodjava:564)    at orgjunitplatformcommonsutilreflectionutilsinvokemethod(reflectionutilsjava:515)    at orgjunitjupiterengineexecutionexecutableinvokerinvoke(executableinvokerjava:115)    at orgjunitjupiterenginedescriptortestmethodtestdescriptorlambda$invoketestmethod$6(testmethodtestdescriptorjava:171)    at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)    at orgjunitjupiterenginedescriptortestmethodtestdescriptorinvoketestmethod(testmethodtestdescriptorjava:167)    at orgjunitjupiterenginedescriptortestmethodtestdescriptorexecute(testmethodtestdescriptorjava:114)    at orgjunitjupiterenginedescriptortestmethodtestdescriptorexecute(testmethodtestdescriptorjava:59)    at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:105)    at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)    at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:95)    at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:71)    at javabase/javautilarraylistforeach(arraylistjava:1378)    at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorserviceinvokeall(samethreadhierarchicaltestexecutorservicejava:38)    at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:110)    at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)    at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:95)    at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:71)    at javabase/javautilarraylistforeach(arraylistjava:1378)    at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorserviceinvokeall(samethreadhierarchicaltestexecutorservicejava:38)    at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:110)    at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)    at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:95)    at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:71)    at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorservicesubmit(samethreadhierarchicaltestexecutorservicejava:32)    at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorexecute(hierarchicaltestexecutorjava:57)    at orgjunitplatformenginesupporthierarchicalhierarchicaltestengineexecute(hierarchicaltestenginejava:51)    at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:220)    at orgjunitplatformlaunchercoredefaultlauncherlambda$execute$6(defaultlauncherjava:188)    at orgjunitplatformlaunchercoredefaultlauncherwithinterceptedstreams(defaultlauncherjava:202)    at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:181)    at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:128)    at comintellijjunit5junit5ideatestrunnerstartrunnerwithargs(junit5ideatestrunnerjava:74)    at comintellijrtexecutionjunitideatestrunner$repeaterstartrunnerwithargs(ideatestrunnerjava:47)    at comintellijrtexecutionjunitjunitstarterpreparestreamsandstart(junitstarterjava:242)    at comintellijrtexecutionjunitjunitstartermain(junitstarterjava:70)```ive found 1 other reference to this issue online which was here: above stated you could work around the issue by changing the code as follows:```// from thiswhen(mockmapget(""a""))thenreturn(""apple"")when(mockmapget(""b""))thenreturn(mockobject)// to thiswhen(mockmapget(anystring()))thenanswer(invocation -> {    object arg  invocationgetargument(0)    if (""a""equals(arg)) return ""apple""    if (""b""equals(arg)) return system})```is this a bug or is this intentional going forwards?thanks for your time!check that - [✓] the mockito message in the stacktrace have useful information but it didnt help - [✓] the problematic code (if thats possible) is copied here       note that some configuration are impossible to mock via mockito - [✓] provide versions (mockito / jdk / os / any other relevant information) - [✓] provide a [short self contained correct (compilable) example]( of the issue       (same as any question on stackoverflowcom) - [✓] read the [contributing guide](https://githubcom/mockito/mockito/blob/master/github/contributingmd)";im not sure if im on the right track with this or is this helps anyone else but i had the same problem and solved it by using the `doreturn()when()` version of mockito instead of `when()thenreturn()` || @bwhiting2356  this works to resolve the issue but it causes a new issue  when i use `doreturn()when()` it turns off the `unnecessarystubbingexception` that we rely on  any idea how to overload method stubbing while still being strict? || i think the `strict` and `lenient` thing has not been thought trough  its quite common to stub a method twice with different parameter values  for example when code needs to fetch two (or more) values from a dependency you would stub for those two values  now this generates an `unnecessarystubbingexception` while it clearly **is** necessary for proper working of the testthe solution using an `answer` class is not a good one in fact im of the opinion you want to avoiding using `answer` objects as much as possible || finding exactly the same issue as described above using `@runwith(mockitoextensionclass)````<dependency>      <groupid>orgjunitjupiter</groupid>      <artifactid>junit-jupiter-api</artifactid>      <scope>test</scope>    </dependency>    <dependency>      <groupid>orgjunitjupiter</groupid>      <artifactid>junit-jupiter-engine</artifactid>      <scope>test</scope>    </dependency>    <dependency>      <groupid>orgjunitvintage</groupid>      <artifactid>junit-vintage-engine</artifactid>      <scope>test</scope>    </dependency>```version 532 of the above dependencies and ```<dependency>      <groupid>orgmockito</groupid>      <artifactid>mockito-junit-jupiter</artifactid>      <version>2230</version>      <scope>test</scope>    </dependency>```@hjohn @bwhiting2356  @jmart1 be interested to hear how you resolved this || bump! || @jaygehlot im afraid ive just turned it off as i do with all warnings that create too many false positives  keeping an eye on this issue still in case it gets  ||;1;0;updated @since version in a new public method;
1543;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;exposed new api - stubbinglookuplistener;exposed new public api based on an internal api - stubbinglookuplistener - #793.;;0;event bus documentation;a common question i see is how to do simple event bus use cases lets add docs and exames to the wiki;related to  add code examples possibly we should link to other projects like reactor disruptor and vertx when more advanced event buses are wanted ideally we would have rxjava modules for those  || this is a very old issue i personally dont want to put too much emphasis on thinking in an shared event bus instead of dedicated sequences in addition people have blogged about it extensively since the opening of this issue thoughts? || the problem with eventbus with rxjava that it funnels all sorts of source emissions into a single serialized pipeline instead of having as many flows (individually multicasted if necessary) as there are types ||;;;;0;1;;
1543;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;exposed new api - stubbinglookuplistener;exposed new public api based on an internal api - stubbinglookuplistener - #793.;;793.0;exposed new api - stubbinglookuplistener;"exposed new public api based on an internal api - stubbinglookuplistener - #793as a rule of a thumb we try to expose the internal apis that the top level features are built upon since stubbinglookuplistener is useful for us to implement strictness lets get the former exposed as public api this way we build stronger framework with the concept of ""onion skin api""this pr replaces #1466 - very nice pr from @marchpig due to number of changes i needed to do i decided to reimplement the feature rather than use the original pr @marchpig thank you for understanding!"; merging 1543 ;expose stubbinglookuplistener publicly and create listener distinction;"make stubbinglookuplistener public originating ticket: #770as a rule of a thumb we try to expose the internal apis that the top level features are built upon since stubbinglookuplistener is useful for us to implement strictness lets get the former exposed as public api this way we build stronger framework with the concept of ""onion skin api""";if exposed publicly the api should use an event object (see  ||;1;0;updated since tags;
1543;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;exposed new api - stubbinglookuplistener;exposed new public api based on an internal api - stubbinglookuplistener - #793.;;1466.0;exposed new api - stubbinglookuplistener;"exposed new public api based on an internal api - stubbinglookuplistener - #793as a rule of a thumb we try to expose the internal apis that the top level features are built upon since stubbinglookuplistener is useful for us to implement strictness lets get the former exposed as public api this way we build stronger framework with the concept of ""onion skin api""this pr replaces #1466 - very nice pr from @marchpig due to number of changes i needed to do i decided to reimplement the feature rather than use the original pr @marchpig thank you for understanding!"; merging 1543 ;expose stubbinglookuplistener publicly (#793);this pr makes `stubbinglookuplistener` public and adds `mockobjectlistener` as parent of `invocationlistener` and `stubbinglookuplistener` (#793); merging 1466 ;1;0;updated since tags;
1543;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;exposed new api - stubbinglookuplistener;exposed new public api based on an internal api - stubbinglookuplistener - #793.;;0;fix like for values with multiple lines;;;;;;0;1;;
1543;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;exposed new api - stubbinglookuplistener;exposed new public api based on an internal api - stubbinglookuplistener - #793.;;0;iterablesremoveif wrong items removed when arraylist is used; hii have found strange behaviour of iterablesremoveif method when i remove items from iterable by frequency and having them nearby every found duplicate item is removed even the last one at a bottom you can find test snippets there is difference between use of arraylist and linkedlistnote: i know that i should use set for this kind of situations but imagine that you do not have string list but list full of legacy uneditable s*it classes problem is inside iterablesremoveiffromrandomaccesslist method<code language""java"">&nbsp&nbsp&nbsp&nbsp@﻿test&nbsp&nbsp&nbsp&nbsppublic void testok() throws exception {```    final list<string> list  listsnewarraylist(""a"" ""b"" ""a"")    systemoutprintln(list) // [a b a]    iterablesremoveif(list new predicate<string>() {        @override        public boolean apply(string input) {            return iterablesfrequency(list input) > 2        }    })    systemoutprintln(list) // [b a]}@testpublic void testwrong() throws exception {    final list<string> list  listsnewarraylist(""a"" ""a"" ""a"")    systemoutprintln(list) // [a a a]    iterablesremoveif(list new predicate<string>() {        @override        public boolean apply(string input) {            return iterablesfrequency(list input) > 2        }    })    systemoutprintln(list) //  should be [a]}@testpublic void testokwithlinkedlist() throws exception {    final list<string> list  listsnewlinkedlist()    listadd(""a"")    listadd(""a"")    listadd(""a"")    systemoutprintln(list) // [a a a]    iterablesremoveif(list new predicate<string>() {        @override        public boolean apply(string input) {            return iterablesfrequency(list input) > 2        }    })    systemoutprintln(list) // [a]}```</code>"; as a workaround you could wrap your input in a forwardinglist that doesnt implement randomaccess || we will document on removeif that the ordering of predicate testing versus removals is not specified || doc fix submitted internally will be mirrored out shortly || ";;;;0;1;;
1544;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1541: prevent premature garbage collection of mock objects;1541.;;0;add `only()` and `onlymatch(predicate<? super e> predicate)` to `fluentiterable`;j@ there are `itera*sgetonlyelement(*)` but no equivalent methods on the fluent wrapperid like to see both `only()`&nbspto retrieve the single element in the wrapped iterable and `onlymatch(predicate)`&nbspto retrieve the single element in the wrapped iterable that matches the predicate`only()`&nbspshould return `optional` just like `first()`&nbspand `last()`&nbspdoim not sure on the return type of `onlymatch(predicate)` though: both `optional`&nbsp(like `firstmatch(predicate)`) and throwing exceptions (like `iterablesgetonlyelement(iterable)`) have their use cases the latter provides some kind of built-in constraint enforcing but i wouldnt sacrifice the first for it maybe two cleverly-named methods are doable; ah wasnt completely sure about the laziness || ";;;;0;1;;
1544;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1541: prevent premature garbage collection of mock objects;1541.;;0;add partition support;syntax: alter table table_name add partition (partcol  partvalue)this feature is disabled by default for the hive connectorenable by setting hiveallow-add-partition to true;we first need to determine how partitioning is going to work in presto if youre interested in doing a survey of how this is supported in other databases that would be helpful ive filed an issue to track the design work:  that is complete we can re-open this or open a new issue ;;;;0;1;;
1544;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1541: prevent premature garbage collection of mock objects;1541.;;0;error handling documentation;common questions are related to error handling such as retry exponential back off checked exceptions user functions throwing and handling different errors differently lets add a section to the docs with code examples for these things and explaining the rx contract with idiomatic solutions it should show how to convert from imperative try/catch thinking;ive started work on this here:  || thank you || i would be happy to contribute to the documentation whats currently missing or whats partially complete that would need better support ? || here is what we have currently: could use some fleshing-out with concrete examples || there are also the operator pages for the onerror() operators retry() and such which are now at the reactivexio site: || those 2 wiki pages have both `error handling` label on a sidebar it seems that the latter should be `error handling operators` || thanks @koral-- updated the wiki || closing as it will be handled via #6001 ||;;;;0;1;;
1544;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1541: prevent premature garbage collection of mock objects;1541.;;1541.0;1541: prevent premature garbage collection of mock objects;"1541if using one-liner stubs ( the mock object may be premature cleaned up and returning the mock fails with an exception this occurs because there is no strong reference to the mock itselftherefore we need to maintain a strong reference to the mock until weve returned it while making sure that the gc can still cleanup the mock correctly when neededcause implementations of `basestubbing` are intended to be cleaned up after usage we can store a strong ref to the mock there `getmock` then uses the strong ref (instead of the weak ref provided by the invocation) after cleaning up the implementations of  `basestubbing` there is no strong ref to the mock itself anymore (except the one in the test class)i tried some alternative solutions but i believe this is the only way it works----bind last mock creation to mockingprogress does not work because of this:```when(mock(testclass2class)gettestclass())thenreturn(mock(testclassclass))getmock()```bind mock of last invocation for stubbing to mockingprogress does not work because of this:```when(mock(testclassclass)getstuff())thenreturn(""x"")thenreturn(    when(mock(testclassclass)getstuff())thenreturn(""xxx"")<testclass>getmock()getstuff())getmock()```";" merging 1544  < ! || lgtm thanks for your improvementsonly passing the mock was my first take but i thought passing the `invocationcontainerimpl` is more type safe than just having `object` as parameter also the ""mock retrieval logic"" would be located in one central place but im very fine with the refactoring || thank you! || ";mock object premature garbage collected when using one-liner stubs;":one-liner stubs may throw an exception because the actual mock object is already garbage collected when trying to return the mock### reproduce:1 mockito 2235 using mockito-inline2 -xmx256m```public class onelinerstubstresstest {    public class testclass {        public string getstuff() {            return ""a""        }    }    private static string generatestring() {        final int length  10000        final stringbuilder stringbuilder  new stringbuilder(length)        for (int i  0 i < length i++) {            stringbuilderappend(""b"")        }        return stringbuildertostring()    }    @test    public void call_a_lot_of_mocks() {        final string returnvalue  generatestring()        for (int i  0 i < 40000 i++) {            final testclass mock  when(mock(testclassclass)getstuff())                                   thenreturn(returnvalue)getmock()            assertequals(returnvalue mockgetstuff())        }    }}```#### expected:test finishes successfully#### actual:```javalangillegalstateexception: the mock object was garbage collected this should not happen in normal circumstances when using public api typically the test class keeps strong reference to the mock object and it prevents getting the mock collected mockito internally needs to keep weak references to mock objects to avoid memory leaks for certain types of mockmaker implementations if you see this exception using mockito public api please file a bug for more information see issue #1313        at orgmockitointernalinvocationmockrefmockweakreferenceget(mockweakreferencejava:32)        at orgmockitointernalinvocationinterceptedinvocationgetmock(interceptedinvocationjava:103)        at orgmockitointernalstubbinginvocationcontainerimplinvokedmock(invocationcontainerimpljava:157)        at orgmockitointernalstubbingconsecutivestubbinggetmock(consecutivestubbingjava:28)```### analysis:as part of #1313 `defaultinvocationfactory` and `interceptedinvocation` were refactored to keep week reference to the mock this was necessary in order to get rid of strong references by the handlers which caused memory leaks on the other hand this requires to have a strong reference to the mock in the test class in order to prevent premature garbage collection unfortunately if using one-liner stubs ( the mock object may be premature cleaned up this occurs because we gain access to the `interceptedinvocation` when calling `getmock()` (which tries to get the mock from the invocation) without having any strong reference to the mock itself at this point the mock may already be cleaned up";great investigation! do you have a suggestion on how to resolve this? || tried different approaches i believe i found one solution that works well created a pr ||;1;0;simplified code passing only mock as parameteralso made the constructors package-protected followed by idea hint its always a good idea to reduce the scope;
1549;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;searchbar across all bib files instead each having its own;implemented #825. the searchbar is now in the top toolbar instead of each tab having its own (always at the right). on tab change the tab gets updated. the autocomplete is bound to the current tab (maybe extend this one in another pr?). the old global search (opening all findings in a new window) is gone  do we really need it?  ![jabref_globalsearch]( -   -   -   ();;0;duplicated eventhandler registration on the generic method; abstract class baseclass&ltt>{&nbsp&nbsp&nbsp&nbsppublic abstract void onchange1(configclass p)```public abstract void onchange2(t p)```}class childclassforeventbus extends baseclass&ltconfigclass> {&nbsp&nbsp&nbsp&nbsp@﻿override&nbsp&nbsp&nbsp&nbsppublic void onchange1(configclass p)&nbsp&nbsp&nbsp&nbsp{&nbsp&nbsp&nbsp&nbsp}```@override  @subscribepublic void onchange2(configclass p){}```}if register a generice event handler it will automatically register 2 handlers the actual handler and raw type handler ""onchange2(configclass)"" & ""onchange2(object)"" should enhance the ""findallhandlers"" to bypass the raw type handler otherwise the generic handler will be called twice!";  internally should be mirrored out soon--- ;;;;0;1;;
1549;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;searchbar across all bib files instead each having its own;implemented #825. the searchbar is now in the top toolbar instead of each tab having its own (always at the right). on tab change the tab gets updated. the autocomplete is bound to the current tab (maybe extend this one in another pr?). the old global search (opening all findings in a new window) is gone  do we really need it?  ![jabref_globalsearch]( -   -   -   ();;0;merge operator infomation;as the todo described we might need to merge operator stats at a connectorsplit or a custom internal operatorthe interface name reducer might not be the best name but i think it would be a good start of discussion;i renamed the interface to `mergeable` and made it generic  i also remove the initial call to `merge(null)`other than that  it is pushed  let me know if this doesnt work for you ||;;;;0;1;;
1549;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;searchbar across all bib files instead each having its own;implemented #825. the searchbar is now in the top toolbar instead of each tab having its own (always at the right). on tab change the tab gets updated. the autocomplete is bound to the current tab (maybe extend this one in another pr?). the old global search (opening all findings in a new window) is gone  do we really need it?  ![jabref_globalsearch]( -   -   -   ();;0;feature request: observable methods to supress oncomplete onerror and onnext;observable<foo> observableobservablesuppressoncomplete()observablesuppressonerror()observablesuppressonnext()the resulting observable would be guaranteed to never emit the respective notificationthis can be implemented as a custom operator with lift but if it is commonly needed maybe it should be added to the api in particular these are useful for the event bus use cases ( eg  observablesuppressoncomplete()subscribe(mypublishsubject) );"are you trying to subscribe a single publishsubject to multiple finite observables?what is the use case that results in terminal events being propagated that you want to ignore?here is a simple example that will never terminate:  || > what is the use case that results in terminal events being propagated that you want to ignore?interested in the why as well also because typically when you subscribe you just pass in onnext moreover you can always concatenate `observablenever` at the end to ignore `oncompleted` and `onerror` however i dont think it is smart or useful to do that || @benjchristensen yes one subject subscribing to multiple finite observables for example observables returned by retrofit services (  ) the observables returned by retrofit emit one item and then complete or just error but you might want to ""pipe"" the results into one subject || aha i now see what you do `subscribe(mypublishsubject)` which is not the way to merge streams and yes in that case the subject will be closed instead you simply  the streamsin general you should try to avoid subjects and definitively avoid using them inside subscribe || @yogurtearl as per @headinthebox you should use `merge` `zip` or other combinatorial operators to achieve what youre doing it is almost always wrong to need the use of a `subject`here is example code using `flatmap` and `zip` to combine multiple network calls:  || a lot of our use cases are event bus (-ish) is there a recommended way to implement event buses without subjects?  || you need subject when (a) you want to share side-effects of a computation in many case you can do that locally by using `xspublish(xs -> {})` or (b) you want to turn a cold observable into a hot observable (which technically is sharing side effects as well) in many case when you think you need a subject as a source/producer of events you can do without one for example use `observablecreate` instead the other thing to note is that once you do a `subscribe` you should assume you are leaving the rx world ie you update the ui or perform some side-effects to write data to a file or something as a rule of thumb you never use subjects inside a subscribe because that is an indication that there should be an operator you use to transform the stream _before_ you subscribe || ";;;;0;1;;
1549;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;searchbar across all bib files instead each having its own;implemented #825. the searchbar is now in the top toolbar instead of each tab having its own (always at the right). on tab change the tab gets updated. the autocomplete is bound to the current tab (maybe extend this one in another pr?). the old global search (opening all findings in a new window) is gone  do we really need it?  ![jabref_globalsearch]( -   -   -   ();;151.0; issue with leftover state when stubbing with bad throwables; issue with leftover state when stubbing with bad throwables 1514;good catch ||  merging 1549 ;investigate why #125 did not trigger release;investigate why #125 did not trigger release;gc old issues ||;1;0; issue with stubbing statewhen stubbing with bad throwables we were leaving state behind 1514;
1552;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;performance improvements for groups;the bibentry now stores a list of words which are contained in the field. in this way the keywordgroup.ismatch method just has to compare two arrays instead of analyzing strings over and over again. for a big file (> 7000 entries  > 100 groups) the load time decreased by 1 sec from 4.8 seconds to 3.7. half of the time needed for showing the groups tree is spent in calculating the number of hits. moreover  subsequent rerendings of the groups tree (for example after changing an entry) are also quicker.  note that the match algorithm changed slightly. for example  previously looking for  test  in  some$test  resulted in a match  this is no longer the case. however  normal word separators (like whitespace  comma and semicolon are recognized properly)  i.e. searching for  test  in  some test  returns true.  also fixed a npe. -   -   -   ();;0;add orderingstrictmin; sometimes multiple minimum values mean an error in this case orderingstrictmin should throw an exception; given that this isnt hard to do without a new method added we would need to be convinced that this need comes up _very_ commonly in order to add it to such a core type as ordering you should make your own helper method that does something like this&nbsp&nbspset&ltfoo> mins  immutablesetcopyof(orderingleastvalues(source 2))&nbsp&nbspif (minssize()  2) {&nbsp&nbsp&nbsp&nbspreturn minsiterator()next()&nbsp&nbsp} else {&nbsp&nbsp&nbsp&nbsp// handle edge cases&nbsp&nbsp}--- ;;;;0;1;;
1552;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;performance improvements for groups;the bibentry now stores a list of words which are contained in the field. in this way the keywordgroup.ismatch method just has to compare two arrays instead of analyzing strings over and over again. for a big file (> 7000 entries  > 100 groups) the load time decreased by 1 sec from 4.8 seconds to 3.7. half of the time needed for showing the groups tree is spent in calculating the number of hits. moreover  subsequent rerendings of the groups tree (for example after changing an entry) are also quicker.  note that the match algorithm changed slightly. for example  previously looking for  test  in  some$test  resulted in a match  this is no longer the case. however  normal word separators (like whitespace  comma and semicolon are recognized properly)  i.e. searching for  test  in  some test  returns true.  also fixed a npe. -   -   -   ();;0;add support for distributed index joins;this is enabled via a config option and is default off;;;;;0;1;;
1552;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;performance improvements for groups;the bibentry now stores a list of words which are contained in the field. in this way the keywordgroup.ismatch method just has to compare two arrays instead of analyzing strings over and over again. for a big file (> 7000 entries  > 100 groups) the load time decreased by 1 sec from 4.8 seconds to 3.7. half of the time needed for showing the groups tree is spent in calculating the number of hits. moreover  subsequent rerendings of the groups tree (for example after changing an entry) are also quicker.  note that the match algorithm changed slightly. for example  previously looking for  test  in  some$test  resulted in a match  this is no longer the case. however  normal word separators (like whitespace  comma and semicolon are recognized properly)  i.e. searching for  test  in  some test  returns true.  also fixed a npe. -   -   -   ();;1542.0;fixing a bug and a potential for other concurrency issues;fix for #1542the root cause of the issue was this line of code where it was casting the notification list object to t```        private t getrecentvalue() {            return (t)value        }```while i was in there i noticed that is was a race condition between calling `hasnext()` and `next()` on the `iterator`;#1467  thanks @abersnaze  ||;mostrecent returning notificationlite#on_next_null_sentinel;this can return  notificationlite#on_next_null_sentinel or notificationlite#on_completed_sentinel``` javaobservable<foo> observable   foo foo  observabletoblocking()mostrecent(null)iterator()next()```which will cause a classcastexception this seems inconsistent with the docs and it didnt used to do this ( in 0175 ) like the fix will probably relate to blockingoperatormostrecentmostrecentobserver;thanks for reporting this i think i know what caused this || @abersnaze do you have time to take a look at this? || sure ill take look ||  in #1552  ||;1;0;fixing a bug and a potential for other concurrency issues;
1552;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;performance improvements for groups;the bibentry now stores a list of words which are contained in the field. in this way the keywordgroup.ismatch method just has to compare two arrays instead of analyzing strings over and over again. for a big file (> 7000 entries  > 100 groups) the load time decreased by 1 sec from 4.8 seconds to 3.7. half of the time needed for showing the groups tree is spent in calculating the number of hits. moreover  subsequent rerendings of the groups tree (for example after changing an entry) are also quicker.  note that the match algorithm changed slightly. for example  previously looking for  test  in  some$test  resulted in a match  this is no longer the case. however  normal word separators (like whitespace  comma and semicolon are recognized properly)  i.e. searching for  test  in  some test  returns true.  also fixed a npe. -   -   -   ();;155.0;minimal test to repro generic issue with smart nulls;created a minimal test that reproduces bug with smart nulls and generics see issue #1551;  since this is a new test ill just merge it without review happy to fix / change things later if someone reviews it ||;internal comparator violates its general contract;log from my test run  comparison method violates its general contract!    at javautiltimsortmergehi(timsortjava:868)    at javautiltimsortmergeat(timsortjava:485)    at javautiltimsortmergeforcecollapse(timsortjava:426)    at javautiltimsortsort(timsortjava:223)    at javautiltimsortsort(timsortjava:173)    at javautilarrayssort(arraysjava:659)    at javautilcollectionssort(collectionsjava:217)    at orgmockitointernalconfigurationinjectionpropertyandsetterinjectionorderedinstancefieldsfrom(propertyandsetterinjectionjava:125)    at orgmockitointernalconfigurationinjectionpropertyandsetterinjectioninjectmockcandidates(propertyandsetterinjectionjava:100)    at orgmockitointernalconfigurationinjectionpropertyandsetterinjectionprocessinjection(propertyandsetterinjectionjava:77)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyprocess(mockinjectionstrategyjava:68)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyrelayprocesstonextstrategy(mockinjectionstrategyjava:89)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyprocess(mockinjectionstrategyjava:71)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyrelayprocesstonextstrategy(mockinjectionstrategyjava:89)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyprocess(mockinjectionstrategyjava:71)    at orgmockitointernalconfigurationinjectionmockinjection$ongoingmockinjectionapply(mockinjectionjava:92)    at orgmockitointernalconfigurationdefaultinjectionengineinjectmocksonfields(defaultinjectionenginejava:20)    at orgmockitointernalconfigurationinjectingannotationengineinjectmocks(injectingannotationenginejava:100)    at orgmockitointernalconfigurationinjectingannotationengineprocessinjectmocks(injectingannotationenginejava:62)    at orgmockitointernalconfigurationinjectingannotationengineprocess(injectingannotationenginejava:56)    at orgmockitomockitoannotationsinitmocks(mockitoannotationsjava:108);it occures when bean under test has many fields (declaredfieldssize  44) ||;1;0;minimal test to repro generic issue with smart nullscreated a minimal test that reproduces bug with smart nulls and generics see issue #1551;
1554;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed verifyerror when junit 3 is in the classpath;mockito will throw verifyerror during its junit detection when junit 3;;0;serialization for immutablemap (and probably others) class fails with circular graphs; a classcastexception is thrown when there is a circularity in the object graph involving an immutablemapfrom experimentation it looks like the order in which objects are serialized matters  the classcastexception may not occur if a different object in the object graph cycle is (de)serialized ""first""also from the looks of it other collection classes suffer the same fault where the static inner serializedform does not extend the appropriate interface/classes  the attached file shows the problem in immutablebimap:exception in thread ""main"" javalangclasscastexception: cannot assign instance of comgooglecommoncollectimmutablebimap$serializedform to field immutablemapserializationmap of type comgooglecommoncollectimmutablemap in instance of immutablemapserialization&nbsp&nbsp&nbsp&nbspat javaioobjectstreamclass$fieldreflectorsetobjfieldvalues(objectstreamclassjava:2063)&nbsp&nbsp&nbsp&nbspat javaioobjectstreamclasssetobjfieldvalues(objectstreamclassjava:1241)&nbsp&nbsp&nbsp&nbspat javaioobjectinputstreamdefaultreadfields(objectinputstreamjava:1970)&nbsp&nbsp&nbsp&nbspat javaioobjectinputstreamreadserialdata(objectinputstreamjava:1888)&nbsp&nbsp&nbsp&nbspat javaioobjectinputstreamreadordinaryobject(objectinputstreamjava:1771)&nbsp&nbsp&nbsp&nbspat javaioobjectinputstreamreadobject0(objectinputstreamjava:1347)&nbsp&nbsp&nbsp&nbspat javaioobjectinputstreamreadarray(objectinputstreamjava:1685)&nbsp&nbsp&nbsp&nbspat javaioobjectinputstreamreadobject0(objectinputstreamjava:1341)&nbsp&nbsp&nbsp&nbspat javaioobjectinputstreamdefaultreadfields(objectinputstreamjava:1964)&nbsp&nbsp&nbsp&nbspat javaioobjectinputstreamreadserialdata(objectinputstreamjava:1888)&nbsp&nbsp&nbsp&nbspat javaioobjectinputstreamreadordinaryobject(objectinputstreamjava:1771)&nbsp&nbsp&nbsp&nbspat javaioobjectinputstreamreadobject0(objectinputstreamjava:1347)&nbsp&nbsp&nbsp&nbspat javaioobjectinputstreamreadobject(objectinputstreamjava:369)&nbsp&nbsp&nbsp&nbspat immutablemapserializationmain(immutablemapserializationjava:31)"; a possible workaround is to turn serializedform into a forwarding wrapper the downside is that there would be another kind of immutablemap floating around this could hurt performance a little (in part because of the indirection but also because the calls are more likely to be megamorphic) worse the new type would have to be made gwt-serializable to avoid breaking serialization for users who use both gwt serialization and plain serialization that would mean that wed have to support serializedform under gwt we could do it but this is starting to sound like a big project(suggested by bob lees &lt || cpovirk explains above why we are not making any change here || ";;;;0;1;;
1554;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed verifyerror when junit 3 is in the classpath;mockito will throw verifyerror during its junit detection when junit 3;;0;implement list and map types;# roadmap1 add map and list type including new syntax and use json as the representation during execution this allows us to implement the syntax separately from execution optimizations for structural types and would not regress performance since we already are converting all structures into json2 add a json type with implicit coercions from map and list and create versions of the json_\* functions that take json in addition to the ones that take varchar this way all the json_\* functions will continue to work as they do today after step 33 change the hive connector to use map and list types but display a prominent warning with the sql  operator because its 1-indexed and jsonpath is 0-indexed4 add udfs that need map/list5 deprecate map/list to json coercion6 remove coercion and also remove warning from  operator7 performance optimization## proposed presto syntax#### listfollow sql standard for array#### maptbd## sql standard syntax#### list- arrays are 1-indexed see p161 of sql:1999- uses  for element access- || can be used to concatenate arrays- array values can be constructed with array [1 2 3 4]## postgres syntax#### list[postgres arrays]( arrays indexes are 1-based- uses my_list[1] and my_list[1:10]- literals may be either {1 2 3} or array[1 2 3]- 10  any(my_list) evaluates to true if any element of my_list is 10- 10  all(my_list) evaluates to true if all elements of my_list are 10#### map[postgres json]( and [json functions]( did not find a map type but theres a json type- uses -> and ->> for element access- <@ @> and ? for testing existence## hive syntax[hive operators]( uses  for both map and list- array indexes are 0-based- uses array(1 2 3) and map(1 cat 2 dog) for construction;superseded by  ||;;;;0;1;;
1554;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed verifyerror when junit 3 is in the classpath;mockito will throw verifyerror during its junit detection when junit 3;;0;groupby with element selector;we are missing the groupby overload with element selector  see here for a use case  we pass in an element selector we can make this much more efficient https://githubcom/netflix/rxjava/blob/master/rxjava-core/src/main/java/rx/internal/operators/operatorgroupbyjava;;;;;0;1;;
1554;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed verifyerror when junit 3 is in the classpath;mockito will throw verifyerror during its junit detection when junit 3;;155.0; verifyerror when junit 3 is in the classpath;mockito will throw verifyerror during its junit detection when junit 3is in the classpath because the code only supports junit 4 and laterthis change will catch this error and pretend that junit is not thereissue: #1553;i would like some opinions on testing because i was not able to figure out a good way to test this i tried changing the class hierarchy of comparisonfailure using byte buddy and a custom classloader but was not able to get that to work i also thought it would be possible (though heavy) to use a gradle property to change the version of the junit dependency to run a test and add that to the test matrix but i dont expect that to work without other changes because mockito itself uses junit 4 to compile and run its own tests ||  merging 1554 ` ;internal comparator violates its general contract;log from my test run  comparison method violates its general contract!    at javautiltimsortmergehi(timsortjava:868)    at javautiltimsortmergeat(timsortjava:485)    at javautiltimsortmergeforcecollapse(timsortjava:426)    at javautiltimsortsort(timsortjava:223)    at javautiltimsortsort(timsortjava:173)    at javautilarrayssort(arraysjava:659)    at javautilcollectionssort(collectionsjava:217)    at orgmockitointernalconfigurationinjectionpropertyandsetterinjectionorderedinstancefieldsfrom(propertyandsetterinjectionjava:125)    at orgmockitointernalconfigurationinjectionpropertyandsetterinjectioninjectmockcandidates(propertyandsetterinjectionjava:100)    at orgmockitointernalconfigurationinjectionpropertyandsetterinjectionprocessinjection(propertyandsetterinjectionjava:77)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyprocess(mockinjectionstrategyjava:68)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyrelayprocesstonextstrategy(mockinjectionstrategyjava:89)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyprocess(mockinjectionstrategyjava:71)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyrelayprocesstonextstrategy(mockinjectionstrategyjava:89)    at orgmockitointernalconfigurationinjectionmockinjectionstrategyprocess(mockinjectionstrategyjava:71)    at orgmockitointernalconfigurationinjectionmockinjection$ongoingmockinjectionapply(mockinjectionjava:92)    at orgmockitointernalconfigurationdefaultinjectionengineinjectmocksonfields(defaultinjectionenginejava:20)    at orgmockitointernalconfigurationinjectingannotationengineinjectmocks(injectingannotationenginejava:100)    at orgmockitointernalconfigurationinjectingannotationengineprocessinjectmocks(injectingannotationenginejava:62)    at orgmockitointernalconfigurationinjectingannotationengineprocess(injectingannotationenginejava:56)    at orgmockitomockitoannotationsinitmocks(mockitoannotationsjava:108);it occures when bean under test has many fields (declaredfieldssize  44) ||;1;0;simplified the code covering more caseswe have plenty of coverage that asserts that we are creating the right exception;
1565;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;added information in the tool tip for undo and redo and disabled when…;a tool tip text is shown describing the undo/redo action. also  the undo/redo buttons are enabled/disabled when there are things to undo/redo.  <img width= 167  alt= capture3 2  src=  >  current problem is that it doesn t work on startup (both undo and redo is enabled as before)  but as soon as one edit is done it works just fine. -   -   ()  … no undo/redo is available;;0;prevent stackoverflowerror when processing reversed generics;when processing the reverse method the type parameters are actuallyreversed compared to the type parameters in the class this subsequentlyconfuses genericmetadatasupport as it creates a cycle in`contextualactualtypeparameters` in that case a resolves to b while bresolves to athe root cause is that we are processing type parameters of methodswhile we already processed them in the class declaration thereforeignore any type parameters if we already derived the appropriatecontextual type parameter;;;;;1;1;prevent stackoverflowerror when processing reversed genericswhen processing the reverse method the type parameters are actuallyreversed compared to the type parameters in the class this subsequentlyconfuses genericmetadatasupport as it creates a cycle in`contextualactualtypeparameters` in that case a resolves to b while bresolves to athe root cause is that we are processing type parameters of methodswhile we already processed them in the class declaration thereforeignore any type parameters if we already derived the appropriatecontextual type parameter;
1565;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;added information in the tool tip for undo and redo and disabled when…;a tool tip text is shown describing the undo/redo action. also  the undo/redo buttons are enabled/disabled when there are things to undo/redo.  <img width= 167  alt= capture3 2  src=  >  current problem is that it doesn t work on startup (both undo and redo is enabled as before)  but as soon as one edit is done it works just fine. -   -   ()  … no undo/redo is available;;0;improve support for numeric fields in json extract;allow numeric fields without quoting in path expressionsnumeric fields match both array elements and object fields;can you please fix the typo `jasonparser` || ;;;;0;1;;
1565;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;added information in the tool tip for undo and redo and disabled when…;a tool tip text is shown describing the undo/redo action. also  the undo/redo buttons are enabled/disabled when there are things to undo/redo.  <img width= 167  alt= capture3 2  src=  >  current problem is that it doesn t work on startup (both undo and redo is enabled as before)  but as soon as one edit is done it works just fine. -   -   ()  … no undo/redo is available;;0;fixing kotlin defer;broke this with https://githubcom/netflix/rxjava/pull/1561;#1478 ;;;;1;1;fixing kotlin deferbroke this with https://githubcom/netflix/rxjava/pull/1561;
1567;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix 1530: integrity checker should ignore unescaped hashes in url field;addresses #1530  -   -  ;;0;running tests in a non-us locale might fail; failed tests: &nbsp&nbsptesttostring(comgooglecommonbasestopwatchtest): null expected:&lt0000 ns> but was:&lt0000 ns>&nbsp&nbsptestsimple(comgooglecommonutilconcurrentratelimitertest): null expected:<[r0[00 r020 r0]20]> but was:<[r0[00 r020 r0]20]>&nbsp&nbsptestsimplewithwait(comgooglecommonutilconcurrentratelimitertest): null expected:<[r0[00 u020 r000 r0]20]> but was:<[r0[00 u020 r000 r0]20]>&nbsp&nbsptestonesecondburst(comgooglecommonutilconcurrentratelimitertest): null expected:<[u1[00 u100 r000 r000 r000 r000 r0]20]> but was:<[u1[00 u100 r000 r000 r000 r000 r0]20]>&nbsp&nbsptestwarmup(comgooglecommonutilconcurrentratelimitertest): null expected:<[r0[00 r138 r113 r088 r063 r050 r050 r050 u050 u400 r000 r138 r113 r088 r063 r050 r050 r050 u050 u200 r000 r050 r050 r050 r050 r050 r050 r0]50]> but was:<[r0[00 r138 r113 r088 r063 r050 r050 r050 u050 u400 r000 r138 r113 r088 r063 r050 r050 r050 u050 u200 r000 r050 r050 r050 r050 r050 r050 r0]50]>&nbsp&nbsptestwarmupandupdate(comgooglecommonutilconcurrentratelimitertest): null expected:<[r0[00 r138 r113 r088 r063 r050 r050 r050 u450 r000 r138 r113 r088 r034 r028 r025 r025 u425 r000 r072 r066 r059 r053 r047 r041 r034 r028 r025 r0]25]> but was:<[r0[00 r138 r113 r088 r063 r050 r050 r050 u450 r000 r138 r113 r088 r034 r028 r025 r025 u425 r000 r072 r066 r059 r053 r047 r041 r034 r028 r025 r0]25]>&nbsp&nbsptestbursty(comgooglecommonutilconcurrentratelimitertest): null expected:<[u10[00 r000 r100 r100 u300 r000 r3]00]> but was:<[u10[00 r000 r100 r100 u300 r000 r3]00]>&nbsp&nbsptestburstyandupdate(comgooglecommonutilconcurrentratelimitertest): null expected:<[r0[00 r100 r100 r050 r100 r2]00]> but was:<[r0[00 r100 r100 r050 r100 r2]00]>&nbsp&nbsptesttimewrapping(comgooglecommonutilconcurrentratelimitertest): null expected:<[r0[00 r100 r100 r1]00]> but was:<[r0[00 r100 r100 r1]00]>&nbsp&nbsptestsimpleweights(comgooglecommonutilconcurrentratelimitertest): null expected:<[r0[00 r100 r100 r200 r400 r8]00]> but was:<[r0[00 r100 r100 r200 r400 r8]00]>&nbsp&nbsptestinfinity_bursty(comgooglecommonutilconcurrentratelimitertest): null expected:<[r0[00 r000 r0]00]> but was:<[r0[00 r000 r0]00]>&nbsp&nbsptestinfinity_warmup(comgooglecommonutilconcurrentratelimitertest): null expected:<[r0[00 r000 r0]00]> but was:<[r0[00 r000 r0]00]>@@instead of:stringformat(""%4g %s"" value abbreviate(unit))you might want to use:stringformat(localeroot ""%4g %s"" value abbreviate(unit))@@you might want to check the entire codebase for usages of stringformat without an explicit locale"; ;;;;0;1;;
1567;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix 1530: integrity checker should ignore unescaped hashes in url field;addresses #1530  -   -  ;;0;add warning to inline mock maker when running on a jre;i made a topic about this in the [mailing list]( story short: the inline mock maker doesnt work when running on just a jre so i added a warning in the error message if thats that case this wouldve saved me a lot of headache so i figured id maybe help a poor soul that encounters this in the future; merging 1567 ;;;;1;1;add warning to inline mock maker when running on a jrethis wouldve saved me a lot of headache;
1567;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix 1530: integrity checker should ignore unescaped hashes in url field;addresses #1530  -   -  ;;0;add 075 release notes;;;;;;0;1;;
1567;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix 1530: integrity checker should ignore unescaped hashes in url field;addresses #1530  -   -  ;;0;groupby with element selector;fixes https://githubcom/netflix/rxjava/issues/1554;#1479 ;;;;1;1;groupby with element selectorfixes https://githubcom/netflix/rxjava/issues/1554;
1576;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixed undo when update time stamp on edit is enabled;fixed a bug where the field change compound was not ended  leading to that field changes could not be undone when  automatically update time stamp on edit  was enabled. -  ;;0;documentation updates;;;;;;0;1;;
1576;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixed undo when update time stamp on edit is enabled;fixed a bug where the field change compound was not ended  leading to that field changes could not be undone when  automatically update time stamp on edit  was enabled. -  ;;0;from(t) -> just(t);deprecate the from(t) methods in favor of items(t)as per discussion in https://githubcom/netflix/rxjava/issues/1563;#1492  as per voting in #1563 this changes the signatures to:``` javafrom(future<? extends t>)from(future<? extends t> long timeunit)from(future<? extends t> scheduler)from(iterable<? extends t>)from(t)just(t)just(t t)just(t t t)just(t t t t)just(t t t t t)just(t t t t t t)just(t t t t t t t)just(t t t t t t t t)just(t t t t t t t t t)just(t t t t t t t t t t)``` ||;;;;1;1;from(t) -> just(t)see  for discussion;
1576;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fixed undo when update time stamp on edit is enabled;fixed a bug where the field change compound was not ended  leading to that field changes could not be undone when  automatically update time stamp on edit  was enabled. -  ;;1551.0;fix/bug 1551 cce on smart not null answers;this pr intends to 1551 for fix it the `returnssmartnulls` answer use now some reflection to find the correct return type instead of the `javautilobject`when the return type can be found it will start to retrieve empty values using the answer `returnsmoreemptyvalues` & `returnsemptyvalues` before creating a new mock instanceas you may notice in tests there is still one case where the return type cannot be found in this case the `answer` will return a `null` instead of `object` mocki think it may be possible to improve this code any suggestion will be welcome !; merging 1576 ;classcastexception with generics and smart nulls;"hello i am trying to migrate my junit4 tests (java version is 180_74) from mockito v11019 to v2010 and i have the following exception: ```javajavalangclasscastexception: codegenjavalangobject$mockitomock$220764719 cannot be cast to comsolanteqsolarfpdaoschememockitotest$entity```when i mock my objects using `answersreturns_smart_nulls`however when i change the answer to default or change the stubbing to dowhen approach the exception disappears before version upgrade everything worked finetest case to reproduce the issue:  ```javaimport orgjunitbeforeimport orgjunittestimport orgjunitrunnerrunwithimport orgmockitoanswersimport orgmockitomockimport orgmockitomockitoimport orgmockitojunitmockitojunitrunnerimport static orgjunitassertassertequals@runwith(mockitojunitrunnerclass)public class mockitotest {    @mock(answer  answersreturns_smart_nulls)    private concretedao concretedao    @before    public void setup() {        mockitowhen(concretedaofindbyid(1l))                thenreturn(new entity(1l))    }    @test    public void testmockito() {        assertequals(1l concretedaofindbyid(1l)id)    }    public static class abstractdao<t> {        t findbyid(final long id) {            throw new unsupportedoperationexception(""not implemented"")        }    }    public static class entity {        private final long id        public entity(long id) {            thisid  id        }    }    public static class concretedao extends abstractdao<entity> {    }}```thanks in advance";"thank you for reporting! based on your test i created a minimal test that reproduces the issue: #1552 i marked this ticket with ""please contribute"" hoping you or someone from the community can help the issue is tricky and it is caused by java generics combined with smart nulls || hello !if youre agree with that i can work on this ive start watching how it works and how it can be solve i  also think that it can be pretty tricky but i can even try ) ! || feel free to! || ";1;0;#1551 : fix typo and some missing documentation;
1582;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;extend the openconsolefeature;extend the openconsolefeature by offering a selection between default terminal emulator and configurable command execution.  @koppor  s wish (see  was to have a selection between own terminal emulators. this feature extension provides that. - add:   - radio selection to the externaltab   - program execution to jabrefdesktop   - new jabrefpreference entries   - ui outputs   - localization keys  screenshots: ![oc_sc3]( -   -   ();;0;make immutablecollectionbuilder java8-collector-friendly; the upcoming jdk-8 contains the new stream-api which is somewhat comparable to fluentiterable - expect that its core abstraction is the iterator and not the iterable but its pattern to create new collections after a stream chain is different than guavas:liststream()collect(collectorstolist())the collect-method takes a collector a somewhat clunky yet powerful interface to build result collections both sequential (by adding single elements) and in parallel (by combining multiple elements via addall)this method can also be used with guava-collections by defining its own collector based on immutablecollectionbuilder but there is one catch:the collector-interface requires at least the following:- a supplier: builder::new- an accumulator: builder::add- a combiner builder::addall- a finisher: builder::buildthe problem is the addall-method: in order to be compatible with the combiner it needs to take a builder as its ínput however the builderaddall methods currently only allows it to add iterables not another builder so the accumulator-function would be something like builderaddall(otherbuilderbuild()) which is not very efficient especially for set-builders---there are at least three different ways to solve this problem:- make the builder itself iterable so that it can be added to its own addall-method- add another addall-method overload to immutablecollectionbuilder which accepts any immutablecollectionbuilder- accept the overhead until guava is jdk8-ready then roll your own collector which can access the package-private internal structure of the builder; the former would probably work better if your stream is parallel and i dont think its any less efficient in general || the first two suggestions repeated below could be done to help support java 8 users without needing ""a java 8 version of guava"" (or at least what i choose to interpret from that statement anyway) - is there a philosophical (or otherwise) objection to folding that in?- make the builder itself iterable so that it can be added to its own addall-method- add another addall-method overload to immutablecollectionbuilder which accepts any immutablecollectionbuilder || i was wondering why is `streamcollect(collectorscollectingandthen(collectorstolist() immutablelist::copyof))` the same efficiency as `immutablelistcopyof(streamiterator())`?it sounds like the first approach requires building an array then copying the array into an `immutablelist` whereas the second approach only builds the array once || both approaches are going to put the stream into a arraylist-like structure and then copy it into the immutablelist  immutablelistcopyof(iterator) delegates to immutablelistbuilder which is built as approximately a specialized arraylist || i see thanks for the help ) || i dont think thats 100% true immutablelistcopyof(streamiterator()) is [more efficient]( for the special case of an iterator yielding only 0 or 1 elements where it avoids allocating the intermediary arraylist || we have a plan were working on to use collectors w/ immutable collections and itll be addresses in an upcoming version of guava that supports java8 || +1 || would love to see this added into the core guava codebase  any traction on this yet? || the immutable collections now have built-in collectors that will be included in the guava 21 release  i think we can actually call this closed?(we havent exposed collector-ness in the builders themselves just collectors but i think thats what wed prefer unless we hear compelling reasons to add them into the builders) || ";;;;0;1;;
1582;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;extend the openconsolefeature;extend the openconsolefeature by offering a selection between default terminal emulator and configurable command execution.  @koppor  s wish (see  was to have a selection between own terminal emulators. this feature extension provides that. - add:   - radio selection to the externaltab   - program execution to jabrefdesktop   - new jabrefpreference entries   - ui outputs   - localization keys  screenshots: ![oc_sc3]( -   -   ();;0;make chr() work with unicode;- update docs to reference chr() instead of char()- make chr() work with unicode code points instead of ascii code points to match the documentation;looks good but add a test for a code point that doesnt fit in utf-16 ||;;;;0;1;;
1582;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;extend the openconsolefeature;extend the openconsolefeature by offering a selection between default terminal emulator and configurable command execution.  @koppor  s wish (see  was to have a selection between own terminal emulators. this feature extension provides that. - add:   - radio selection to the externaltab   - program execution to jabrefdesktop   - new jabrefpreference entries   - ui outputs   - localization keys  screenshots: ![oc_sc3]( -   -   ();;0;deprecate groupedobservablefrom;it was a bad solution use observablegroupby with element selector insteadsee https://githubcom/netflix/rxjava/issues/1579;;;;;1;1;deprecate groupedobservablefromit was a bad solution use observablegroupby with element selector insteadsee https://githubcom/netflix/rxjava/issues/1579;
1582;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;extend the openconsolefeature;extend the openconsolefeature by offering a selection between default terminal emulator and configurable command execution.  @koppor  s wish (see  was to have a selection between own terminal emulators. this feature extension provides that. - add:   - radio selection to the externaltab   - program execution to jabrefdesktop   - new jabrefpreference entries   - ui outputs   - localization keys  screenshots: ![oc_sc3]( -   -   ();;1577.0;1577: refactoring naming rule for sealed packages to better work with the java module system;the java module system consideres packages of all named modules to be sealed this results in the naming strategy to rename classes such that they cannot subclass package-private types;" merging 1582  ";illegalaccesserror on java 11 when using module path;mockito cannot mock package private class when tests running with module path it trying to use reflection and defineclass method by default and this does not work on java 11 ive found pr #1355 and tried to use orgmockitointernalsimulatejava11 system property but it doesnt works eitherim using:java 11 (release) maven 360 surefire-maven-plugin 300-m3 junit 532 mockito 2234 (22311 have same issue)with this configuration mockito and byte buddy are included in classpath my modular jar is included in module path and module system is configured correctly (i suppose :))you can check this on minimal sample project: [mockito-java11-jpms-examplezip]( - just run `mvn clean test`stacktrace```underlying exception : javalangillegalstateexception: error invoking javalanginvokemethodhandles$lookup#defineclass                                                                                      at testmarxmockito/testmarxmockitoservicetesttestmockito(servicetestjava:17)                                                                                                                   at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)                                                                                                                     at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)                                                                                                   at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)                                                                                           at javabase/javalangreflectmethodinvoke(methodjava:566)                                                                                                                                         at orgjunitplatformcommonsutilreflectionutilsinvokemethod(reflectionutilsjava:532)                                                                                                             at orgjunitjupiterengineexecutionexecutableinvokerinvoke(executableinvokerjava:115)                                                                                                            at orgjunitjupiterenginedescriptortestmethodtestdescriptorlambda$invoketestmethod$6(testmethodtestdescriptorjava:171)                                                                          at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)                                                                                              at orgjunitjupiterenginedescriptortestmethodtestdescriptorinvoketestmethod(testmethodtestdescriptorjava:167)                                                                                   at orgjunitjupiterenginedescriptortestmethodtestdescriptorexecute(testmethodtestdescriptorjava:114)                                                                                            at orgjunitjupiterenginedescriptortestmethodtestdescriptorexecute(testmethodtestdescriptorjava:59)                                                                                             at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$4(nodetesttaskjava:108)                                                                                     at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)                                                                                              at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:98)                                                                                               at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:74)                                                                                                          at javabase/javautilarraylistforeach(arraylistjava:1540)                                                                                                                                         at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorserviceinvokeall(samethreadhierarchicaltestexecutorservicejava:38)                                              at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$4(nodetesttaskjava:112)                                                                                     at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)                                                                                              at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:98)                                                                                               at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:74)                                                                                                          at javabase/javautilarraylistforeach(arraylistjava:1540)                                                                                                                                         at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorserviceinvokeall(samethreadhierarchicaltestexecutorservicejava:38)                                              at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$4(nodetesttaskjava:112)                                                                                     at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)                                                                                              at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:98)                                                                                               at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:74)                                                                                                          at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorservicesubmit(samethreadhierarchicaltestexecutorservicejava:32)                                                 at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorexecute(hierarchicaltestexecutorjava:57)                                                                                  at orgjunitplatformenginesupporthierarchicalhierarchicaltestengineexecute(hierarchicaltestenginejava:51)                                                                                      at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:220)                                                                                                                 at orgjunitplatformlaunchercoredefaultlauncherlambda$execute$6(defaultlauncherjava:188)                                                                                                        at orgjunitplatformlaunchercoredefaultlauncherwithinterceptedstreams(defaultlauncherjava:202)                                                                                                  at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:181)                                                                                                                 at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:128)                                                                                                                 at orgapachemavensurefirejunitplatformjunitplatformproviderinvokealltests(junitplatformproviderjava:150)                                                                                       at orgapachemavensurefirejunitplatformjunitplatformproviderinvoke(junitplatformproviderjava:124)                                                                                               at orgapachemavensurefirebooterforkedbooterinvokeproviderinsameclassloader(forkedbooterjava:384)                                                                                               at orgapachemavensurefirebooterforkedbooterrunsuitesinprocess(forkedbooterjava:345)                                                                                                            at orgapachemavensurefirebooterforkedbooterexecute(forkedbooterjava:126)                                                                                                                       at orgapachemavensurefirebooterforkedbootermain(forkedbooterjava:418)                                                                                                                  caused by: javalangillegalstateexception: error invoking javalanginvokemethodhandles$lookup#defineclass                                                                                                  at netbytebuddydynamicloadingclassinjector$usinglookup$dispatcher$forjava9capablevmdefineclass(classinjectorjava:1686)                                                                          at netbytebuddydynamicloadingclassinjector$usinglookupinjectraw(classinjectorjava:1415)                                                                                                         at netbytebuddydynamicloadingclassinjector$abstractbaseinject(classinjectorjava:111)                                                                                                            at netbytebuddydynamicloadingclassloadingstrategy$usinglookupload(classloadingstrategyjava:466)                                                                                                 at netbytebuddydynamictyperesolutionstrategy$passiveinitialize(typeresolutionstrategyjava:100)                                                                                                   at netbytebuddydynamicdynamictype$default$unloadedload(dynamictypejava:5623)                                                                                                                     at orgmockitointernalcreationbytebuddysubclassbytecodegeneratormockclass(subclassbytecodegeneratorjava:129)                                                                                    at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:37)                                                                                  at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:34)                                                                                  at netbytebuddytypecachefindorinsert(typecachejava:152)                                                                                                                                           at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:365)                                                                                                                      at netbytebuddytypecachefindorinsert(typecachejava:174)                                                                                                                                           at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:376)                                                                                                                      at orgmockitointernalcreationbytebuddytypecachingbytecodegeneratormockclass(typecachingbytecodegeneratorjava:32)                                                                               at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemocktype(subclassbytebuddymockmakerjava:71)                                                                              at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemock(subclassbytebuddymockmakerjava:42)                                                                                  at orgmockitointernalcreationbytebuddybytebuddymockmakercreatemock(bytebuddymockmakerjava:25)                                                                                                  at orgmockitointernalutilmockutilcreatemock(mockutiljava:35)                                                                                                                                    at orgmockitointernalmockitocoremock(mockitocorejava:69)                                                                                                                                         at orgmockitomockitomock(mockitojava:1896)                                                                                                                                                        at orgmockitomockitomock(mockitojava:1805)                                                                                                                                                         42 more                                                                                                                                                                                   caused by: javalangillegalaccesserror: class orgmockitocodegenidependency$mockitomock$1828864830 cannot access its superinterface testmarxmockitoservice$idependency (orgmockitocodegenidependency$mockitomock$1828864830 is in unnamed module of loader app testmarxmockitoservice$idependency is in module testmarxmockito of loader app)                                                    at javabase/javalangclassloaderdefineclass1(native method)                                                                                                                                        at javabase/javalangsystem$2defineclass(systemjava:2123)                                                                                                                                         at javabase/javalanginvokemethodhandles$lookupdefineclass(methodhandlesjava:962)                                                                                                                at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)                                                                                                                     at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)                                                                                                   at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)                                                                                           at javabase/javalangreflectmethodinvoke(methodjava:566)                                                                                                                                         at netbytebuddydynamicloadingclassinjector$usinglookup$dispatcher$forjava9capablevmdefineclass(classinjectorjava:1682)                                                                           62 more                                                                                                                                                                                   ```;you have to open your module to the unnamed module where mockito is set to make this work  || @raphw im using this configuration:```            <plugin>                <artifactid>maven-surefire-plugin</artifactid>                <configuration>                    <!-- test code needs access to package private level so we use add-opens -->                    <argline>                        --add-opens testmarxmockito/testmarxmockitoall-unnamed                    </argline>                    <systempropertyvariables>                        <!-- this hidden property force mockito to use method lookup -->                        <orgmockitointernalsimulatejava11>true</orgmockitointernalsimulatejava11>                    </systempropertyvariables>                </configuration>            </plugin>```maybe im missing something btw adding `--add-opens javabase/javalangall-unnamed` does not helps too  || i see what the problem is now java considers all packages that belong to a named module to be sealed therefore our mock creation strategy is oversensitive and defines the mock in another package such that the super type is no longer visiblelet me look into this for a bit we will fix this in an upcoming release || @marx-freedom could you check out this branch build mockito and see if it works? || @raphw ive tried it today but it doesnt works as expectedwith -dorgmockitointernalsimulatejava11true test throws exception:```orgmockitoexceptionsbasemockitoexception: mockito cannot mock this class: interface testmarxmockitoservice$idependencymockito can only mock non-private & non-final classesif youre not sure why youre getting this error please report to the mailing listjava               : 11jvm vendor name    : oracle corporationjvm vendor version : 11+28jvm name           : openjdk 64-bit server vmjvm version        : 11+28jvm info           : mixed modeos name            : windows 10os version         : 100underlying exception : javalangillegalstateexception: error invoking javalanginvokemethodhandles$lookup#defineclass	at testmarxmockito/testmarxmockitoservicetesttestmockito(servicetestjava:17)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javabase/javalangreflectmethodinvoke(methodjava:566)	at orgjunitplatformcommonsutilreflectionutilsinvokemethod(reflectionutilsjava:532)	at orgjunitjupiterengineexecutionexecutableinvokerinvoke(executableinvokerjava:115)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorlambda$invoketestmethod$6(testmethodtestdescriptorjava:171)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorinvoketestmethod(testmethodtestdescriptorjava:167)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorexecute(testmethodtestdescriptorjava:114)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorexecute(testmethodtestdescriptorjava:59)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$4(nodetesttaskjava:108)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:98)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:74)	at javabase/javautilarraylistforeach(arraylistjava:1540)	at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorserviceinvokeall(samethreadhierarchicaltestexecutorservicejava:38)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$4(nodetesttaskjava:112)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:98)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:74)	at javabase/javautilarraylistforeach(arraylistjava:1540)	at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorserviceinvokeall(samethreadhierarchicaltestexecutorservicejava:38)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$4(nodetesttaskjava:112)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:98)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:74)	at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorservicesubmit(samethreadhierarchicaltestexecutorservicejava:32)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorexecute(hierarchicaltestexecutorjava:57)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestengineexecute(hierarchicaltestenginejava:51)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:220)	at orgjunitplatformlaunchercoredefaultlauncherlambda$execute$6(defaultlauncherjava:188)	at orgjunitplatformlaunchercoredefaultlauncherwithinterceptedstreams(defaultlauncherjava:202)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:181)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:128)	at orgapachemavensurefirejunitplatformjunitplatformproviderinvokealltests(junitplatformproviderjava:150)	at orgapachemavensurefirejunitplatformjunitplatformproviderinvoke(junitplatformproviderjava:124)	at orgapachemavensurefirebooterforkedbooterinvokeproviderinsameclassloader(forkedbooterjava:384)	at orgapachemavensurefirebooterforkedbooterrunsuitesinprocess(forkedbooterjava:345)	at orgapachemavensurefirebooterforkedbooterexecute(forkedbooterjava:126)	at orgapachemavensurefirebooterforkedbootermain(forkedbooterjava:418)caused by: javalangillegalstateexception: error invoking javalanginvokemethodhandles$lookup#defineclass	at netbytebuddydynamicloadingclassinjector$usinglookup$dispatcher$forjava9capablevmdefineclass(classinjectorjava:1686)	at netbytebuddydynamicloadingclassinjector$usinglookupinjectraw(classinjectorjava:1415)	at netbytebuddydynamicloadingclassinjector$abstractbaseinject(classinjectorjava:111)	at netbytebuddydynamicloadingclassloadingstrategy$usinglookupload(classloadingstrategyjava:466)	at netbytebuddydynamictyperesolutionstrategy$passiveinitialize(typeresolutionstrategyjava:100)	at netbytebuddydynamicdynamictype$default$unloadedload(dynamictypejava:5623)	at orgmockitointernalcreationbytebuddysubclassbytecodegeneratormockclass(subclassbytecodegeneratorjava:129)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:37)	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:34)	at netbytebuddytypecachefindorinsert(typecachejava:152)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:365)	at netbytebuddytypecachefindorinsert(typecachejava:174)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:376)	at orgmockitointernalcreationbytebuddytypecachingbytecodegeneratormockclass(typecachingbytecodegeneratorjava:32)	at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemocktype(subclassbytebuddymockmakerjava:71)	at orgmockitointernalcreationbytebuddysubclassbytebuddymockmakercreatemock(subclassbytebuddymockmakerjava:42)	at orgmockitointernalcreationbytebuddybytebuddymockmakercreatemock(bytebuddymockmakerjava:25)	at orgmockitointernalutilmockutilcreatemock(mockutiljava:35)	at orgmockitointernalmockitocoremock(mockitocorejava:62)	at orgmockitomockitomock(mockitojava:1896)	at orgmockitomockitomock(mockitojava:1805)	 42 morecaused by: javalangillegalaccesserror: class orgmockitocodegenidependency$mockitomock$2018315156 cannot access its superinterface testmarxmockitoservice$idependency (orgmockitocodegenidependency$mockitomock$2018315156 is in unnamed module of loader app testmarxmockitoservice$idependency is in module testmarxmockito of loader app)	at javabase/javalangclassloaderdefineclass1(native method)	at javabase/javalangsystem$2defineclass(systemjava:2123)	at javabase/javalanginvokemethodhandles$lookupdefineclass(methodhandlesjava:962)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javabase/javalangreflectmethodinvoke(methodjava:566)	at netbytebuddydynamicloadingclassinjector$usinglookup$dispatcher$forjava9capablevmdefineclass(classinjectorjava:1682)	 62 more```should i use system property orgmockitointernalsimulatejava11 or there is any other setup tasks im missing?one little idea ive wrote something like this recently it works with module path and custom module layers but ive tested it only for custom classes not in standard packages like `java*`  ```class somefactory {    public <c> c createdynamicsubclass(class<c> clazz) {        getclass()getmodule()addreads(clazzgetmodule())        var dynamicclass  new bytebuddy()                subclass(clazz constructorstrategydefaultimitate_super_class)                definefield()                                make()                load(clazzgetclassloader() classloadingstrategyusinglookupof(                        methodhandlesprivatelookupin(clazz methodhandleslookup()))                )                getloaded()        return dynamicclassgetconstructor(new class<?> {})newinstance()    }``` || i have worked quite a bit on this over the last days i just checked in several changes in the last hour i also managed to write a bunch of unit tests now and hope that it works as i expect it || @raphw thank you very much! mockito 22316 works perfectly problem solved ||;1;0;remove serializability of listener again;
1583;0;0;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed #1527 and some refactoring/cleanups;fixed #1527 and did some refactoring and cleanups. -  ;;0;iterablespartition() produces notserializable items; when the input iterable to partition does not contain enough elements to satisfy the partition size it produces a list that is not serializableexample:&nbsp&nbsp&nbsplist&ltinteger> elements  listsnewarraylist(012)&nbsp&nbsp&nbspiterable&ltlist&ltinteger>> part  iterablespartition(elements 2)in this example the second list of the ""part"" iterable will not be serializable looking at the code this seems to be caused by the use of a ""sublist"" (javautilrandomaccesssublist)"; ;;;;0;1;;
1583;0;0;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed #1527 and some refactoring/cleanups;fixed #1527 and did some refactoring and cleanups. -  ;;0;add support for android tests using androidxtest;see  for more details onandroidx;;;;;1;1;refactor instrumentationregistry handling into common method;
1583;0;0;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed #1527 and some refactoring/cleanups;fixed #1527 and did some refactoring and cleanups. -  ;;0;first_value issues in 075 worked fine in 074;"helloafter upgrading from 074 to 075 the first_value function does not work inside from() if where filter gives no rows eg where 1>1 the errors is ""expected 1 arguments for function first_value but got 0""this gives an error:`select * from (select first_value(ename) over( partition by user_uuidorder by ecreated_at asc) from events e ) where 1>1`without from() no error:`select first_value(ename) over( partition by user_uuid order byecreated_at asc) from events e  where 1>1`also no error if where returns rows( where 11):`select * from (select first_value(ename) over( partition by user_uuidorder by ecreated_at asc) from events e ) where 11`";thanks for the detailed bug report!@nileema can you see if this is related to the row number optimization that was added in the most recent release? || yes ill take a look || this is  with #1587  ||;;;;0;1;;
1583;0;0;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed #1527 and some refactoring/cleanups;fixed #1527 and did some refactoring and cleanups. -  ;;0;redo/repeat backpressure;fix backpressure and memory leaksthis now works:``` java    public static void main(string args) {        observable<integer> o1  observablefrom(1 1)concatwith(observablejust(-1)repeat())        observable<integer> o2  observablefrom(2 2 2 2)        observablezip(o1 o2 (a b) -> a + b)foreach(systemout::println)    }```;#1494 ;;;;1;1;redo/repeat backpressurefix backpressure and memory leaksthis now works:    public static void main(string args) {        observable<integer> o1  observablefrom(1 1)concatwith(observablejust(-1)repeat())        observable<integer> o2  observablefrom(2 2 2 2)        observablezip(o1 o2 (a b) -> a + b)foreach(systemout::println)    };
1585;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1584 where multipleparentclassloader lacks of classloaders of superclasses;the multipleparentclassloader is now composed also with classloaders of supertypes of the mockedtype so in osgi is able to load all declared types in the hierarchy.;;0;hive catalog doc;adding a section for hive  this pr adds the basics how to configure the hive connector and how to access a table in a hive schema this section should ultimately expand to include troubleshooting and tips for hive-specific issuesthis pr builds on the content in https://githubcom/facebook/presto/pull/1517;;;;;0;1;;
1585;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1584 where multipleparentclassloader lacks of classloaders of superclasses;the multipleparentclassloader is now composed also with classloaders of supertypes of the mockedtype so in osgi is able to load all declared types in the hierarchy.;;0;exception not thrown from interval with blank onerror;"hi allthis one (and probably some other similar bugs) has been biting me badly last couple of weeksrxscala 0200-rc5 lets have``` scalaimport rxlangscalaobservableimport scalaconcurrentduration_def fail(o: observable[long])  omap(x ⇒ if (x > 1) throw new runtimeexception(""bang!""))```then``` scalafail(observableitems(1 2 3))subscribe(println(_))```throws a runtimeexception as expected but``` scalafail(observableinterval(100milli))subscribe(println(_))threadsleep(1000)```does not id expect it to throw an exception as well albeit probably in a different threadthank you best regards     tomáš dvořák";"the exception is getting thrown but `futuretask` is swallowing it its not obvious to me as to what needs to change to make the executorscheduler throw outside the callable/futuretask will need to spend more time || ok thank you any progress on this issue will be greatly appreciated || related to  || @dvtomas i have finished #1682 there isnt much that can be done other than output logs to systemerr if exceptions are allowed to propagate without anything catching them (as your examples do) but at least now they wont fail silently can you please review #1682 and let me know if you have any better suggestions?here is an example:``` java        observableinterval(100 timeunitmilliseconds)map(i -> {            throw new runtimeexception(""fail!"")        })subscribe()        threadsleep(1000)```now outputs```javalangillegalstateexception: exception thrown on schedulerworker thread add `onerror` handling    at rxinternalschedulersscheduledactionrun(scheduledactionjava:50)    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:511)    at javautilconcurrentfuturetaskrun(futuretaskjava:266)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:180)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:293)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)    at javalangthreadrun(threadjava:745)caused by: rxexceptionsonerrornotimplementedexception: fail!    at rxobservable$36onerror(observablejava:7387)    at rxobserverssafesubscriber_onerror(safesubscriberjava:128)    at rxobserverssafesubscriberonerror(safesubscriberjava:97)    at rxinternaloperatorsoperatormap$1onerror(operatormapjava:48)    at rxinternaloperatorsoperatormap$1onnext(operatormapjava:56)    at rxinternaloperatorsonsubscribetimerperiodically$1call(onsubscribetimerperiodicallyjava:51)    at rxscheduler$worker$1call(schedulerjava:118)    at rxinternalschedulersscheduledactionrun(scheduledactionjava:45)     7 morecaused by: javalangruntimeexception: fail!    at errorstestlambda$0(errorstestjava:10)    at errorstest$$lambda$1/1406718218call(unknown source)    at rxinternaloperatorsoperatormap$1onnext(operatormapjava:54)     10 morecaused by: rxexceptionsonerrorthrowable$onnextvalue: onerror while emitting onnext value: longclass    at rxexceptionsonerrorthrowableaddvalueaslastcause(onerrorthrowablejava:98)    at rxinternaloperatorsoperatormap$1onnext(operatormapjava:56)     10 more``` || i have had a look at #1682 i havent tested it because it seems that rxjava-scala rcs havent been released to maven yetmy original use case was that i have some observables i know should never fail if they do it means that some unhandled exception has been thrown in my code and it is definitely a bug that should be resolved in the same spirit as a bug in ordinary code results in an exception being thrown and thus immediate feedback to the developer i have expected an exception in reactive code to do the same now that i see all the troubles with this issue i think ill change my approach to subscribing to observables ill just implement a special error handler for handling these ""never-failing"" observables and pass it to them during subscribing this handler could log the error or try to somehow pass it to the main thread where it could be raised or anything else so for me your improvement with stack trace print will be a huge help especially during the transition to the handle-everything approach but other than that ill just work around this issue with this special handlerso as far as i am concerned im happy with your fix and current state of affairsthank you regards @dvtomas || thanks for the feedback  || @benjchristensen i have numerous occurrences of this crash throughout my application however i am finding it extremely difficult to hunt down the source of these crashes since the stack trace does not lead back to my client code do you have any tips for tracking the source down given that i have a pretty large codebase that is using schedulers intervals observeons etc all over the place?  || i responded to your question in the issue you opened:  || ";;;;0;1;;
1585;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1584 where multipleparentclassloader lacks of classloaders of superclasses;the multipleparentclassloader is now composed also with classloaders of supertypes of the mockedtype so in osgi is able to load all declared types in the hierarchy.;;1584.0;1584 where multipleparentclassloader lacks of classloaders of superclasses;the multipleparentclassloader is now composed also with classloaders of supertypes of the mockedtype so in osgi is able to load all declared types in the hierarchy;the problem of test case is that is not possible reflect a real osgi environment without use some test framework like pax exam (the most complicate thing is do not pollute test dependency with 10 and more dependencies) if is not a problem i can try to create test case that verify if the multiparentclassloader contains more classloaders || a job fails to install jdk11 other jobs are ok || i think that this can cause issues with class loader hierarchies where we would now generate a new class loader even if all classes were visible from the top-most type this would effectively prevent mocking package-private classes and methods for such types which worked until nowi just extended the multiple parent class loader in byte buddy to allow for collecting the most specific class loaders only after this i think we can add this change probably we would also need to include all class loaders of interface types for this to work universallyi am a bit afraid of the performance impact of this though as this can cost some runtime for types with a large type tree || > i think that this can cause issues with class loader hierarchies where we would now generate a new class loader even if all classes were visible from the top-most typei had a look to the implementation of `multipleparentclassloader` and it delegate to parents in the exact order they was added this means that if the classloader of the actual type (the first added) is able to load all classes other classloaders are not visited> probably we would also need to include all class loaders of interface types for this to work universallyits already like that the actual classloader is built with a composition of classloader of actual type and the classloader of all interfaces the class implements my pr simply add classloaders from superclasses> i am a bit afraid of the performance impact of this though as this can cost some runtime for types with a large type treei do not expect a hierarchy bigger than 10 classloader are filtered at most we should ensure there are no duplicated in the list (if not already) || this needs a rebase now ||  merging 1585 ;classloader built by mockito is not able to load declared types in the hierarchy in osgi;we develop in osgi environment and we are using latest version of mockito available on maven central 2234we got an issue when we mock classes given to guice (sisu) for injection sisu/guice analyse all declared fields and methods for the input type and its super classes to built a sort of index of known types in osgi it fails with classnotfoundexception on mocked classes the reason is that the mocked class built with `subclassbytecodegenerator` has a classloader not able to load types reachable only by supertypes in osgi this does not happen because each class has associated the classloader from which is loaded this guarantee that the class is able to reach/load each type it declares (by its methods fields or annotations)example:- bundle a`fooclass1` has a protected method that returns fooimplotherclass`fooimplotherclass`- bundle b (imports only `foo` package from bundle a)`acmeclass2 extends class1``mockitomock(fooclass1)getdeclaredmethods()` will fails to fix this issue `subclassbytecodegenerator` should compose a classloader (`multipleparentclassloader`) with also the classloader of superclass the mocked type (`featuresmockedtype`);@raphw fyi ||;1;0;1584 create a multipleparentclassloader with also classloaders of supertypes of the mockedtype so in osgi is able to load all declared types in the hierarchy;
1586;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added isbn integrity checker;isbn integrity checker -   -  ;;0;should hashingoutputstreamwrite make a copy of the byte before passing it to the hasher?; (were pretty sure the answer is ""no thats too paranoid"" im filing this issue so that we have a record of the discussion)""i would say that its probably paranoid additionally the way i see it part of the reason that hashingoutputstream exists is so that the user doesnt have to make such a copy (that is he could just write everything to a bytearrayoutputstream hash the whole thing and then write the whole thing) i guess that making a paranoid copy isnt quite that bad since were only ever copying a chunk of the data at once rather than the whole thing still i do think its paranoia the caller who chooses to use hashingoutputstream is almost certainly the caller who chooses the hashfunction so any damage he does it to himself we do like to protect against that sort of thing of course but i doubt there are even many custom hashfunction implementations in existence so a bug seems unlikely""";;;;;0;1;;
1586;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added isbn integrity checker;isbn integrity checker -   -  ;;0;add some missing `@deprecated` annotations;errorprone caught this we correctly had them on most of the deprecatedmethods but not on all of them;;;;;1;1;add some missing `@deprecated` annotationserrorprone caught this we correctly had them on most of the deprecatedmethods but not on all of them;
1586;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added isbn integrity checker;isbn integrity checker -   -  ;;0;cassandra catalog doc;this pr contains basic instructions for the cassandra connectorwhy did i create these sections?  the documentation for connectors seems too distributed for presto users  as an end-user id like to be able to see integrated documentation in a single place  i would also like a quick introduction to how data types tables and (in this case) a keyspace map to presto schemaseventually a section like this will contain tips for cassandra queries troubleshooting etcthis pr builds upon - https://githubcom/facebook/presto/pull/1517;;;;;0;1;;
1586;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added isbn integrity checker;isbn integrity checker -   -  ;;0;rxscala: observableitems(t*) -> observablejust(t*);;#1496   +1 ||;;;;1;1;rxscala: observableitems(t*) -> observablejust(t*);
1588;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added filter to not show selected integrity checks;added the possibility to dynamically filter out some classes of integrity check messages. <img width= 356  alt= capture5  src=  > -   -   ();;0;setview size is 1 when the contents are the null set;ben@ if i use setsdifference to subtract two sets such that the difference is empty the resulting setview seems wrong to me it returns 1 for size()tostring  renders ""[null]""iterator()hasnext() returns trueiterator()next() return null";ben@ no worries thanks for looking into it--- ;;;;0;1;;
1588;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added filter to not show selected integrity checks;added the possibility to dynamically filter out some classes of integrity check messages. <img width= 356  alt= capture5  src=  > -   -   ();;0;allow binding multiple event clients;allow extensions of the verifier to add their own event clientimplementations by not failing to start if an un-recognized eventclient is found;looks good! ||;;;;0;1;;
1588;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added filter to not show selected integrity checks;added the possibility to dynamically filter out some classes of integrity check messages. <img width= 356  alt= capture5  src=  > -   -   ();;0;added doonunsubscribed() to observable;we often need to be notified when an observable is unsubscribed for cleaning up internal states logging metrics gathering and etc with this added method users can save the effort of writing the similar boilerplate to register a listener for un-subscription events;#1498 i accidentally set a different branch as upstream master which causes merge conflict ill close this one and submit a new one instead || can you also make it be doonunsubscribe instead of doonunsubscribed? || will do thanks!on thu aug 14 2014 at 6:32 pm ben christensen notifications@githubcomwrote:> can you also make it be doonunsubscribe instead of doonunsubscribed?> > —> reply to this email directly or view it on github>  || i like this addition would be convenient for unit testing unsubscription for custom operators ||;;;;0;1;;
1588;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added filter to not show selected integrity checks;added the possibility to dynamically filter out some classes of integrity check messages. <img width= 356  alt= capture5  src=  > -   -   ();;1587.0;1587 : remove unnecessary loop from injectingannotationengine;removes injectingannotationengine::processinjectmocks method that does an unnecessary loopfixes https://githubcom/mockito/mockito/issues/1587; merging 1588  < ;injectingannotationengine does an unnecessary loop;processinjectmocks method of injectingannotationengine does unnecessary work it might call injectmocks several times while it is sufficient to call injectmocks once    private void processinjectmocks(final class<?> clazz final object testinstance) {        class<?> classcontext  clazz        while (classcontext ! objectclass) {            injectmocks(testinstance)            classcontext  classcontextgetsuperclass()        }    }inside injectmocks loops classes by himself    public void injectmocks(final object testclassinstance) {        class<?> clazz  testclassinstancegetclass()        set<field> mockdependentfields  new hashset<field>()        set<object> mocks  newmocksafehashset()        while (clazz ! objectclass) {            new injectmocksscanner(clazz)addto(mockdependentfields)            new mockscanner(testclassinstance clazz)addpreparedmocks(mocks)            oninjection(testclassinstance clazz mockdependentfields mocks)            clazz  clazzgetsuperclass()        }        new defaultinjectionengine()injectmocksonfields(mockdependentfields mocks testclassinstance)    }why not delete the unnecessary loop?;;1;0;1587 : remove unnecessary loop from injectingannotationengine;
1596;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cleanup findfile and asssociated tests;cleaned up the findfiles method reworked tests  added some new tests tests should now work in linux  too  -  ;;0;iterablesremoveiffromrandomaccesslist() not working with lists prohibiting duplicates;jensvon@ the list interface does not state that it must allow duplicate elements it is only stated as the typical case:""unlike sets lists typically allow duplicate elements more formally lists typically allow pairs of elements e1 and e2 such that e1equals(e2) and they typically allow multiple null elements if they allow null elements at all it is not inconceivable that someone might wish to implement a list that prohibits duplicates by throwing runtime exceptions when the user attempts to insert them but we expect this usage to be rare"" (javautillist javadoc)when a list prohibits duplicates comgooglecommoncollectiterablesremoveiffromrandomaccesslist(list&ltt> predicate<? super t>) leads to exceptions because an element temporarily may be contained muiltple times in the list this is true in particular for emfs orgeclipseemfcommonutilabstractelist&lte> which does not allow duplicatessince allowing of duplicates is not a hard constraint of the list interface i would consider this a bug in particular since this specialized method is called from comgooglecommoncollectiterablesremoveif(iterable&ltt> predicate<? super t>) so the client has little control over whats going to happen"; it looks like that would work for orgeclipseemfcommonutilabstractelistas an aside looking through that class its violating the spec of list in its add(e) method at least it returns false from add if the object is a duplicate and uniqueness is required when it should throw iae listadd is specced to return true always unless an exception is thrown ||;;;;0;1;;
1596;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cleanup findfile and asssociated tests;cleaned up the findfiles method reworked tests  added some new tests tests should now work in linux  too  -  ;;0;add mbean support to spi;we need a better way to for plugins to export mbeans and to deal with namespacing by connector instance etc;@martint any plans to fix this? this blocks #1571 (and a bunch of other monitoring stuff i plan to create a new pr for) ;;;;0;1;;
1596;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cleanup findfile and asssociated tests;cleaned up the findfiles method reworked tests  added some new tests tests should now work in linux  too  -  ;;0;java8 stream support;support java 8 streams;"need help there? how complex do you think that would be? || it shouldnt be hard and a java 8 `stream` is effectively just a different api on an `iterable` so it will be very similar to `from(iterable)` it just cant be done in 1x since rxjava 1x is java 6 compliant thats the reason this is scheduled for the future in 20we could also create a bridge module for java8 support added on top of rxjava 1x but it would be a separate module not part of rxobservable || ok so this is kind of a backlog for the futurei will look for another issue to helpcheers || yes it is the 020 and then 10 milestones are good places to look || what about a ""low hanging"" label for newbies like me that want to help but know next to nothing about rxjava? || done- [fromstream]( [toblocking()stream()]( || ";;;;0;1;;
1596;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cleanup findfile and asssociated tests;cleaned up the findfiles method reworked tests  added some new tests tests should now work in linux  too  -  ;;1578.0;1578: outer class mocks unavailable from inner class;i opened issue #1578 a few weeks ago that went without an correspondence so i apologize if submitting a pr isnt the ideal method of moving this issue forward  however i am hoping i can get this fix incorporated into an official version without implementing temporary workaroundsthe pr should clearly show the issue i am trying to fix but i had to introduce a testcompile snapshot dependency  the dependent project has a fix required to demonstrate the issue within mockito but it unfortunately has not been incorporated into an official release and i cant think of another way to reproduce the issue  i have contacted the owner of the dependent project but i havent received a response from them eitheri am looking for guidance on next steps for what i believe to be regression (reported to be working in #353)  the only other solution i can think of is to merge this without a unit test but i highly doubt that is desirable_git commit message_- problem - junitrule detects an unfinished mocking session when an inner class is detected- fix - if a mockitosession has been established for junitrule then use that and init mocks of the inner class- tests - within an inner class  ensure mocks are accessible override outer class values when desired retain original values if not overwritten- demonstrated with debechtejunit:junit-hierarchicalcontextrunner:4122-snapshot; merging 1596  < ;unfinishedmockingsessionexception with inner test classes;this appears to be a regression from 11019 and 2x-beta since it was reported as  in #353 but i was unable to get the sample test class to work in the release/2x branch (also reported to fail in 2130 210-beta125 and master too) the root cause is junitrule attempting to add a universaltestlistener a second time to a threadsafemockingprocesssample test class```@runwith(hierarchicalcontextrunnerclass)public class hierarchicalmockitotest {    @rule    public mockitorule mockitorule  mockitojunitrule()    @mock    private runnable runnable    public class context {        @test        public void test() throws exception {            runnablerun()        }    }}```exception thrown```orgmockitoexceptionsmisusingunfinishedmockingsessionexception: unfinished mocking session detectedprevious mockitosession was not concluded with finishmocking()for examples of correct usage see javadoc for mockitosession class	at orgmockitointernaljunitjunitrule$1evaluate(junitrulejava:42)	at orgmockitointernaljunitjunitrule$1evaluatesafely(junitrulejava:52)	at orgmockitointernaljunitjunitrule$1evaluate(junitrulejava:43)	at debechtejunitrunnerscontextstatementsstatementexecutorexecute(statementexecutorjava:28)	at debechtejunitrunnerscontextprocessingmethodexecutorrun(methodexecutorjava:83)	at debechtejunitrunnerscontextprocessingmethodexecutorrun(methodexecutorjava:57)	at debechtejunitrunnerscontextstatementsrunchildrenevaluate(runchildrenjava:38)	at debechtejunitrunnerscontextstatementsrunallevaluate(runalljava:27)	at debechtejunitrunnerscontextstatementsstatementexecutorexecute(statementexecutorjava:28)	at debechtejunitrunnerscontexthierarchicalcontextrunnerrun(hierarchicalcontextrunnerjava:134)	at debechtejunitrunnerscontextprocessingcontextexecutorrun(contextexecutorjava:26)	at debechtejunitrunnerscontextprocessingcontextexecutorrun(contextexecutorjava:15)	at debechtejunitrunnerscontextstatementsrunchildrenevaluate(runchildrenjava:38)	at debechtejunitrunnerscontextstatementsrunallevaluate(runalljava:27)	at debechtejunitrunnerscontextstatementsstatementexecutorexecute(statementexecutorjava:28)	at debechtejunitrunnerscontexthierarchicalcontextrunnerrun(hierarchicalcontextrunnerjava:134)	at orgeclipsejdtinternaljunit4runnerjunit4testreferencerun(junit4testreferencejava:86)	at orgeclipsejdtinternaljunitrunnertestexecutionrun(testexecutionjava:38)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:459)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:678)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerrun(remotetestrunnerjava:382)	at orgeclipsejdtinternaljunitrunnerremotetestrunnermain(remotetestrunnerjava:192)```i have a fix in progress which involves lazy initialization (  i haven’t submitted a pr yet because i’m waiting for the library i used to reproduce the issue to make a new release with a required fix bechte/junit-hierarchicalcontextrunner#32 also i need to clean up the commit to use reference this issue instead of 353 i suppose i can move forward with a pr if there was a way to reproduce the issue without using that library but i haven’t thought of a way to do thatthanks to @ursmetz for verifying the regression and providing a sample test class;;1;0;1578: append mocks to existing mockitosession- problem - junitrule detects an unfinished mocking session when the apply method is invoked more than once  this commonly happens with runners that enable developers to write nested test classes- fix - if a mockitosession has been established for junitrule then use that and initialize any new mocks (typically from a nested test class)- test - instantiate one @rule and assign it to a second one  this will simulate the apply method being invoked more than once without introducing a new test dependency;
1596;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;cleanup findfile and asssociated tests;cleaned up the findfiles method reworked tests  added some new tests tests should now work in linux  too  -  ;;353.0;1578: outer class mocks unavailable from inner class;i opened issue #1578 a few weeks ago that went without an correspondence so i apologize if submitting a pr isnt the ideal method of moving this issue forward  however i am hoping i can get this fix incorporated into an official version without implementing temporary workaroundsthe pr should clearly show the issue i am trying to fix but i had to introduce a testcompile snapshot dependency  the dependent project has a fix required to demonstrate the issue within mockito but it unfortunately has not been incorporated into an official release and i cant think of another way to reproduce the issue  i have contacted the owner of the dependent project but i havent received a response from them eitheri am looking for guidance on next steps for what i believe to be regression (reported to be working in #353)  the only other solution i can think of is to merge this without a unit test but i highly doubt that is desirable_git commit message_- problem - junitrule detects an unfinished mocking session when an inner class is detected- fix - if a mockitosession has been established for junitrule then use that and init mocks of the inner class- tests - within an inner class  ensure mocks are accessible override outer class values when desired retain original values if not overwritten- demonstrated with debechtejunit:junit-hierarchicalcontextrunner:4122-snapshot; merging 1596  < ;@mock-annotated fields are null for inner test classes (eg when using junit-hierarchicalcontextrunner);using the two current versions of mockito (11019 and 2x-beta) and the junit-mockito-rule together with junit extensions like [junit-hierarchicalcontextrunner]( that use inner classes causes fails with `nullpointerexception`s:``` java@runwith(hierarchicalcontextrunnerclass)public class hierarchicalmockitotest {    @rule    public mockitorule mockitorule  mockitojunitrule()    @mock    private runnable runnable    public class context {        @test        public void test() throws exception {            runnablerun()        }    }}```with older 1x versions that didnt not contain the new junit rule api (eg where `mockitojunitrule` was not deprecated yet) the above test pass i guess the reason is that the old rules constructor had the current test instance passed in in newer versions the rule uses the `target` from `orgjunitrulesmethodrule#apply()` which in this example is an instance of `hierarchicalmockitotestcontext` so the `@mock`-annotated fields of the outer classes are not seen and the mocks wont get instantiated;@ursmetz this is not yet supported feel free to craft a pull request for that ) || @bric3 i will look into that and eventually craft a pull requestmaybe it was not clear from my original post: this is a regression because when updating to the latest 1x release tests like the one above will fail: when though the constructor of `mockitojunitrule` gets the target (eh `this`) passed it doesnt use it in the newest version and as a consequence the test fails with a `nullpointerexeception` earlier version used the parameter so that the mocks got initiated and the test was green so even when the old now deprecated api is used tests start to fail after updating mockito so maybe a back port to the 1x branch should be considered too? || oh i didnt get that indeed actually the this was removed because junit passes the target when the rule is applied see [mockitojunitrule]( with these _exotic_ junit runners im not sure how to solve this in a proper way maybe adding a hierarchical mockito rule || or maybe with such exotic runner the pr could be on their project ?  || i was also thinking whether it is not a issue with the junit-hierarchicalcontextrunner i will investigate this and either raise an issue over there (and reference this issue) or take a stab at a fix and pull request for mockito im not one hundred percent sure whether it worked in all corner case with the old version where the parameter of `mockitojunitrule` was used instead of the parameter `target` of the `apply` method of the rule i will also look into that || @bric3 after playing a bit around with the example above and different versions of mockito (pre 11017 where the internal implementation of the junit rule changed and > 11017) i figured out that only some corner cases worked in the old version (exactly those we are using right now in my team at work) now different case work and the old cases stopped working as you said it seems to be an issue with junit-hierarchicalcontextrunner i raised the issue bechte/junit-hierarchicalcontextrunner#26 over there || @ursmetz cool if youre ok with that lets close the issue there ? || sure im closing it || cool thanks :) || i think there is still a bug with junitrule  i built the master branch of the project which includes @ursmetzs pull request in that project and ran the sample test class at the top but i received the following exception prior to reaching the code that causes the nullpointerexception  the root cause is junitrule attempting to add a universaltestlistener a second time to a threadsafemockingprocess (mockito currently does not readily provide the full stack trace at this time)```orgmockitoexceptionsmisusingunfinishedmockingsessionexception: unfinished mocking session detectedprevious mockitosession was not concluded with finishmocking()for examples of correct usage see javadoc for mockitosession class	at orgmockitointernaljunitjunitrule$1evaluate(junitrulejava:42)	at orgmockitointernaljunitjunitrule$1evaluatesafely(junitrulejava:52)	at orgmockitointernaljunitjunitrule$1evaluate(junitrulejava:43)	at debechtejunitrunnerscontextstatementsstatementexecutorexecute(statementexecutorjava:28)	at debechtejunitrunnerscontextprocessingmethodexecutorrun(methodexecutorjava:83)	at debechtejunitrunnerscontextprocessingmethodexecutorrun(methodexecutorjava:57)	at debechtejunitrunnerscontextstatementsrunchildrenevaluate(runchildrenjava:38)	at debechtejunitrunnerscontextstatementsrunallevaluate(runalljava:27)	at debechtejunitrunnerscontextstatementsstatementexecutorexecute(statementexecutorjava:28)	at debechtejunitrunnerscontexthierarchicalcontextrunnerrun(hierarchicalcontextrunnerjava:134)	at debechtejunitrunnerscontextprocessingcontextexecutorrun(contextexecutorjava:26)	at debechtejunitrunnerscontextprocessingcontextexecutorrun(contextexecutorjava:15)	at debechtejunitrunnerscontextstatementsrunchildrenevaluate(runchildrenjava:38)	at debechtejunitrunnerscontextstatementsrunallevaluate(runalljava:27)	at debechtejunitrunnerscontextstatementsstatementexecutorexecute(statementexecutorjava:28)	at debechtejunitrunnerscontexthierarchicalcontextrunnerrun(hierarchicalcontextrunnerjava:134)	at orgeclipsejdtinternaljunit4runnerjunit4testreferencerun(junit4testreferencejava:86)	at orgeclipsejdtinternaljunitrunnertestexecutionrun(testexecutionjava:38)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:459)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:678)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerrun(remotetestrunnerjava:382)	at orgeclipsejdtinternaljunitrunnerremotetestrunnermain(remotetestrunnerjava:192)``` || the hierarchicalmockitotest fails even with @ursmetzs fix for [bechte/junit-hierarchicalcontextrunner#26](  since a new version of the dependency has not been released the test failure can be demonstrated by following the steps below (after a new version of the dependency has been released building my feature branch will be sufficient):1 build and install (requires maven)   this pulls in @ursmetzs fix with a version 4122-snapshot1 clone   in buildgradle change [this line]( to `testcompile debechtejunit:junit-hierarchicalcontextrunner:4122-snapshot` to match the artifact produced previously1 `/gradlew build` as-is results in a pass1 `/gradlew build` with my change to junitrule reverted results in hierarchicaljunitruletestjava failing due to the unfinishedmockingsessionexception i cited previouslythis issue would have happened with any runner that enabled hierarchical test classes ([such as the nitorcreations nestedrunner](  junitrule overwrites the mockitosession instantiated in the outer call in the nested case this seems wrong and it seems reasonable to augment the existing session with the mocks from the inner classi havent submitted a pr at this time eventhough the test suite passed because i have no idea if my changes are oblivious to other exception cases  but i would like to re-open a discussion on this ticket since i still believe this is a legitimate issue   @mouyang i had a quick look at it (i dont know why but i had to tweak `gradlebuild` in your repo a bit further so that the `junit-hierarchicalcontextrunner` snapshot version in my local maven repository was found as a `testcompile` dependency: i had to add a top level `repositories` section with `mavenlocal()` in it)i can reproduce your error when using some 2x versions of mockito (i tried 2130 210-beta125 and the master)with a mockito version 1x and 200-beta118 i cannot reproduce the failureso at the time when i was working on this it worked(tm) -) but with the current 2x version it is broken so i think youre right that there is an issue (please note that im not a maintainer of mockito i just saw that there was some activity on an old issue i once created) || from your clarifications it makes more sense to keep this ticket closed and for me to create a new ticket for my issue as it is clearly different thanks @ursmetz! ||;1;0;1578: append mocks to existing mockitosession- problem - junitrule detects an unfinished mocking session when the apply method is invoked more than once  this commonly happens with runners that enable developers to write nested test classes- fix - if a mockitosession has been established for junitrule then use that and initialize any new mocks (typically from a nested test class)- test - instantiate one @rule and assign it to a second one  this will simulate the apply method being invoked more than once without introducing a new test dependency;
1608;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added layoutformatterpreferences (and related files);;;0;typo?  thenreturn instruction if completed ->  thenreturn instruction is completed;`if` -> `is`?; ;;;;1;1;typo?`if` -> `is`?;
1608;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added layoutformatterpreferences (and related files);;;0;rewrite jdbc connector querybuilder to use preparedstatement;; by #4651 ||;;;;0;1;;
1608;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;added layoutformatterpreferences (and related files);;;0;add missing window with time overload;`observablewindow` is missing an overload the one overload to rule them all (couldnt resist) the missing overload is below and corresponds to the ability to customize every parameter associated with the window with time functionality`public final observable<observable<t>> window(long timespan long timeshift timeunit unit int count scheduler scheduler)`;#1514  :-) ||;;;;1;1;add missing window with time overload the one that has control over every parameter;
1612;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;return null instead of causing a cce;this solves a large number of edge-cases where  null  will actually;;0;investigate optimizing partition name fetching for hive;`get_partition_names_ps` seems to allow passing an empty string for missing parts (so it doesnt have to be a pure prefix filter) this might improve performance for certain queries or metadata queries over tables with a huge number of partitions (and allow some that do not work at all today);;;;;0;1;;
1612;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;return null instead of causing a cce;this solves a large number of edge-cases where  null  will actually;;0;update readme to reflect repository move;i figured updating the readme makes sense now;#1519  #1520 note that in the code i found much more references but thats a start ||;;;;0;1;;
1612;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;return null instead of causing a cce;this solves a large number of edge-cases where  null  will actually;;357.0;return null instead of causing a cce;this solves a large number of edge-cases where `null` will actuallyremove the runtime classcastexception this essentially negates thewhole mockitocast errorprone check we can still not support every usecase but causing a npe instead of a cce does not seem to make thisworsei am still running internal tests within google to see if there are anyregressions but i already saw that some of the test failures we hadwith bytebuddy were resolved with this particular patchnote that this now fully closes #357 a previous pr resolved the sameissue with returnssmartnulls: #1576357; merging 1612  < ;classcastexceptions with jdk9 javac;jdk 9 fixes a javac bug ([jdk-8058199]( that was causing checkcast intructions to be skipped previously javac used the parameter types of a method symbols erased type as targets when translating the arguments in jdk 9 javac has been  to use the inferred types as targets the fix causes additional checkcasts to be generated if the inferred types do not have the same erasurethe fix breaks mockito answer strategies that pick types based on the erased method signatures return type and causes tests to fail with classcastexceptions when compiled with the jdk 9 javac---example 1``` javaclass super<t> {  t g() {    return null  }}class sub extends super<boolean> {}`````` java@mock sub swhen(sg())thenreturn(false)```compiled with javac 8```invokevirtual subg ()ljava/lang/objectinvokestatic org/mockito/mockitowhen (ljava/lang/object)lorg/mockito/stubbing/ongoingstubbing```compiled with javac 9```invokevirtual subg ()ljava/lang/objectcheckcast java/lang/booleaninvokestatic org/mockito/mockitowhen (ljava/lang/object)lorg/mockito/stubbing/ongoingstubbing```the erased return type of `superg` is `object` but the expected return type of `subg` is `boolean` if the answer strategy returns `object` the checkcast fails---example 2``` javaclass foo {  <t> t getfirst(iterable<t> xs) { return xsiterator()next() }}`````` java@mock foo fiterable<boolean> it  arraysaslist(false)when(fgetfirst(it))thenreturn(false)```compiled with javac 8```invokevirtual foogetfirst (ljava/lang/iterable)ljava/lang/objectinvokestatic org/mockito/mockitowhen (ljava/lang/object)lorg/mockito/stubbing/ongoingstubbing```compiled with javac 9```invokevirtual foogetfirst (ljava/lang/iterable)ljava/lang/objectcheckcast java/lang/booleaninvokestatic org/mockito/mockitowhen (ljava/lang/object)lorg/mockito/stubbing/ongoingstubbing```the erased return type of `foogetfirst` is `object` but the inferred return type of `getfirst(iterable<boolean>)` is `boolean` if the answer strategy returns `object` the checkcast fails---the first example could be fixed by using [`genericmetadatasupport`]( in all of the answer implementations instead of `invocationgetmethod()getreturntype()`it gets more difficult if the mocks type is an instantiation of a generic type (eg `@mock foo<bar> x`) since the fields type arguments get dropped i think fixing that would require adding support for mocking types not just classesfor the second example returning the right answer requires considering the generic signature of the invoked method and performing type inference using the argument types unfortunately the runtime type of the argument is going to be a raw `iterable` and the inference depends on knowing its `iterable<boolean>` so im not sure what to do there;this problem is also the cause for  || the test from #304 passes on current master  so maybe this issue is also solved? || closing this issue as it seems to be resolved || i dont think this is  both of the examples in the original report still fail with `v2078-beta` and jdk `9-ea+116`full repro:  codegenjavalangobject$mockitomock$1914109206 (in module: unnamed module) cannot be cast to javalangboolean (in module: javabase)``````javalangclasscastexception: codegenjavalangobject$mockitomock$1914109206 (in module: unnamed module) cannot be cast to javalangboolean (in module: javabase)``` || thanks i check this out prior to release || sorry - do you mean that you verified its fixed at head or that you will take another look before the next release? if its the second one do you mind re-opening the issue to make sure it doesnt get lost? im seeing the same behaviour at head  || @cushon i think its more that well look at it )typically using `genericmetadatasupport` for `@mock` fields has been on my mind for some time already however note that using `mock()`style would not work unless we use some `typereference` trick> it gets more difficult if the mocks type is an instantiation of a generic type (eg @mock foo<bar> x) since the fields type arguments get dropped i think fixing that would require adding support for mocking types not just classes@raphw i think we should not delay 20 for that one jdk9 is not yet out we can still release fixes later || @cushon i have just completed testing mockito against java 9 and everything works as expected the examples that you provide work without any problemsthinking about how this would work also makes sense if not configured to return a different value mockito returns `null` during the configuration what passes the _checkcast_ only if a user specifies an illegal value to the generic signature (heap pollution) a problem occurs but this is not really mockitos responsibilitydid you test a recent version? || > if not configured to return a different value mockito returns null during the configuration what passes the checkcastwhat about `returns_smart_nulls` and `returns_deep_stubs`? || ah of course sorry for that i did another mistake in my test this problem is actually already reproduceable on recent versions of java 8 || ok i have now finally looked into this in detail there are three scenarios:1 for generic return types it suffices to resolve those return types properly by using `genericmetadatasupport` this can simply be added i already tried this2 for locally inferred generic return types there is not much we can do for example if we mocked some method `public <t> t foo() {  }` there is no information preserved within the method that would allow us to know the expected type for `t` we could only parse any method from where `foo` was called to contextually determine the return type this would add a whole new layer of complexity to mockito and i do not think we should support this case we should probably add a warning to the docs3 for generic fields we could find ways to preserve this information we should probably refactor the `return_smart_nulls` option to allow its binding to a generic base type rather than using the mock instances (raw) type || #639 builds on java 9 which still has 3 test failures (but they seem to be related to `assertj` rather than our code) @cushon could you check out that branch and test if your usecases have been fixed with jdk9? || > could you check out that branch and test if your usecases have been fixed with jdk9?@timvdlippe it has not been fixed i turned the repro into a unit test in #664those tests fail in the jdk9 branch:```orgmockitointernalstubbingdefaultanswersreturnssmartnullstest > inferred_generic_type failed    javalangclasscastexception: codegenjavalangobject$mockitomock$1081761404 (in module: unnamed module) cannot be cast to javalangboolean (in module: javabase)        at orgmockitointernalstubbingdefaultanswersreturnssmartnullstestinferred_generic_type(returnssmartnullstestjava:122)orgmockitointernalstubbingdefaultanswersreturnssmartnullstest > generic_return_type_erasure failed    javalangclasscastexception: codegenjavalangobject$mockitomock$1081761404 (in module: unnamed module) cannot be cast to javalangboolean (in module: javabase)        at orgmockitointernalstubbingdefaultanswersreturnssmartnullstestgeneric_return_type_erasure(returnssmartnullstestjava:105)``` || > for generic return types it suffices to resolve those return types properly by using `genericmetadatasupport` this can simply be added i already tried thisthat sounds good to me i skipped the original `class sub extends super<boolean> {}` example in #664 because its no longer broken by the jdk9 javac change it hasnt worked since 7fabd84fdfb2f80f8c135fe3865263c684c0d4e7 is it worth splitting this into a separate bug?``` java    @test    public void generic_return_type_checkcast() throws throwable {        class super<t> {            t get() {                return null            }        }        class sub extends super<boolean> {}        sub sub  mockitomock(subclass answersreturns_smart_nulls)        mockitowhen(subget())thenreturn(true)        asserttrue(subget())    }``````generic_return_type_checkcast failed    javalangclasscastexception: codegenjavalangobject$mockitomock$1200321394 cannot be cast to javalangboolean        at orgmockitointernalstubbingdefaultanswersreturnssmartnullstest$1sub$mockitomock$412017289get(unknown source)        at orgmockitointernalstubbingdefaultanswersreturnssmartnullstest$1sub$mockitomock$412017289get(unknown source)        at orgmockitointernalstubbingdefaultanswersreturnssmartnullstestgeneric_return_type_checkcast(returnssmartnullstestjava:94)``` || careful as `genericmetadatasupport` requires more cpu and memory || we might be able to get around these issues with a solution like #643  || note that this also fails with eclipses java compiler (running under a java 8 jre) in eclipse neon (45) with the same classcastexception || @cushon @raphw @epaul what is the status of this issue?**java 9 has been released today!**i am getting the following error in all my tests that use mockito:```javajavalangclasscastexception: codegenjavalangobject$mockitomock$1574589819 cannot be cast to orghibernatesession``` || as said there is not much we can do the information of the required type lies outside of the class we instrument we simply do not have this information available i am afraid that this chained mocking is something we cannot fully support and you will have to mock your method chanes manually to supply this information  || @raphw thank you!well does it mean that mockito will never work with java 9? omg its an epic disaster :(  || only when returning automatic mocks from mocks with generic return types maybe we should add a warning for this to make the error more intuitive || @raphw yes the warning would be very helpful so do i correctly understand that people will need to rewrite their tests in order to upgrade to java 9? probably a lot of tests?   || theres an error prone check that detects this problem at compile-time:  it can also be run as a [refactoring]( to add work-arounds to affected code ||;1;0;return null instead of causing a ccethis solves a large number of edge-cases where `null` will actuallyremove the runtime classcastexception this essentially negates thewhole mockitocast errorprone check we can still not support every usecase but causing a npe instead of a cce does not seem to make thisworsei am still running internal tests within google to see if there are anyregressions but i already saw that some of the test failures we hadwith bytebuddy were resolved with this particular patchnote that this now fully closes #357 a previous pr resolved the sameissue with returnssmartnulls: #1576357;
1617;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;added more fields and fixed some issues;i guess   publishers   in  xmputil  was a typo?;;0;jdbc connector fixes;;;;;;0;1;;
1617;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;added more fields and fixed some issues;i guess   publishers   in  xmputil  was a typo?;;0;non blocking future;;#1523 i need to merge this first with 1x branch to avoid dragging the whole history with merge on top i will reply the modified files on 1x branch ||;;;;0;1;;
1617;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;added more fields and fixed some issues;i guess   publishers   in  xmputil  was a typo?;;1615.0; with mocking of javautil* classes;1615i hope the test is correct at least it failed before and succeeds now; merging 1617 ;"issue with mocking type in ""javautil*"" java 12";after upgrading mockito from `2234` to `2240` we cant run junit 5s tests anymore the error message reads:```    orgmockitoexceptionsbasemockitoexception:     mockito cannot mock this class: interface javautilconcurrentlockslock    mockito can only mock non-private & non-final classes    if youre not sure why youre getting this error please report to the mailing list```find the complete stacktrace here:  that using mockito `2240` using java 11 (and 13 locally) did work out! see this build matrix:  revert to mockito `2234` for the time being via https://githubcom/junit-team/junit5/commit/754f1eb0f106ab043d79de546d49769690a731b6;"suspiciously the type is again in the `javautil` package that leads me to believe any type definitive in there cant be mocked || > that leads me to believe any type definitive in there cant be mockedusing `2240` it works with the older version || the package should not be an issue but ill check  || there is a dot missing after the package name || haha well spotted! might be a simple string concatenation typo || this is probably the mistake:  be:```java typename  injectionbaseclassgetpackage()getname() +"""" + featuresmockedtypegetsimplename()``` || yes very muchcan it be that we dont have a test case for mocking a java type?are yoilu on your machine? ill fix it next week otherwise  || sadly not i can work on it tomorrow as well luckily we have a test suite now 🎉  || or if @sormuras is available to make that pr that would be amazing as well 😄 our tests are specified in  || great tim!any plans to sync current release to maven central soon? 2240 is the latest one that was uploaded:  || i wanted to do so but i first wanted to get some other issues resolved with @raphw hopefully we can get to that next week (but seems like we hit a jdk bug 🎉 ) || mockito 2245 should be available on maven central later today || looks good on 12:  || ";1;0;fix other broken test;
1619;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;added dateformatter to layoutentry so that it actually works;nowadays it is not just enough to add a class (maybe).;;0;javadoc link in wiki page is broken;javadoc [link]( in wiki page is broken any new link available?;oh yeah  that didnt migrate with everything else ill need to figure that out thanks for reminding me ||  the link which is now:  image links are all broken so need to regenerate them || javadocs are showing up including images ||;;;;0;1;;
1619;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;added dateformatter to layoutentry so that it actually works;nowadays it is not just enough to add a class (maybe).;;1614.0;new api to clean up all inline mocks after test;in certain specific rare scenarios (issue #1614) inline mocking causes memory leaks there is no clean way to mitigate this problem completely hence we introduced a new api to explicitly clear mock state (only make sense in inline mocking!):```javapublic class exampletest {     @after     public void clearmocks() {         mockitoframework()clearinlinemocks()     }     @test     public void sometest() {         //     } }```due to the introduction of map from weak reference from mock instance toits invocation handler mockito became vulnerable to memory leaks asthere are multiple situations where mockito could unintentionally holdstrong references to mock instances in the map record the strongreferences could be through spiedinstance for spies and arguments usedto facilitate method stubbingmockito could never know if the arguments passed in for method stubbingare also strongly referenced somewhere else or not so mockito needs tosave a strong reference to these arguments to avoid premature gctherefore to solve cyclic strong references through arguments mockitoneeds to explicitly know when mocks are out of their life and cleanup all internal strong references associated with them1532 and #1533;"i will review this tomorrow at a first glance we are going to need to make some changes most notably the way we handle interfaces (a new method on `mockmaker` is a breaking change) will give you a detailed review tomorrow || (that said the pr is much appreciated sorry if my initial reaction seemed not positive we really do appreciate community prs for these kind of issues!) || oh thanks for quick response i didnt expect any feedback todayi am not familiar with how to contribute to mockito (ie dont know what can be done and what cant) its expected to have some back and forth for a change at this scale just please be as detailed as possible so that i know how to make proper changesi just hope the overall approach wont be vetoed as i basically dont have any other ideas on how to solve it ||  merging 1619  || this is awesome thank you guys! i’ll try this api on our codebase and samples i’ve provided in original issues also — kudos for including tests reproducing the behavior i’ve described 😉  || hi just to let you know i am using the new api already with v2282 and for me it was breaking the strict test with following exception:``` orgmockitoexceptionsmisusingnotamockexception: argument passed to mockitomockingdetails() should be a mock but is an instance of class cache$mockitomock$149288076!       at orgmockitointernalrunnersdefaultinternalrunner$1$2testfinished(defaultinternalrunnerjava:63) ```i had to move it to `@afterclass` to mitigate the problem || @s2131 you are not allowed to interact with mocks anymore after calling that api because all internal states of mocks are cleaned up after the api call that includes all delayed actions or interactions from other threadsunfortunately its never as easy as just calling that api || ";memory leak in mockito-inline calling method on mock with at least a mock as parameter;# summarywe found a memory leak with mockito-inline a short example is shown as below a more detailed example can be found at the end```javaclass bigclass {  void accept(smallclass small) {}}class smallclass {  void accept(bigclass big) {}}void leak() {  bigclass a  mockitomock(bigclassclass)  smallclass b  mockitomock(smallclassclass)  // remove any one of the 2 lines below will stop leaking  aaccept(b)  baccept(a)}```# analysislooking at the [memory dump][memdump] mock of `bigclass` and `smallclass` are held as a weak ref in a map of type `weakconcurrentmap$withinlinedexpunction` used to map the mock and its invocation handler when the mock can be reclaimed by gc the map will remove the record from itin the case with memory leak the mock instance of `bigclass` was held as a strong reference  rawarguments` and `arguments` in [`invocationmatcher`][invocationmatcher]  as `invocation` in [`interceptedinvocation`][interceptedinvocation] as `invocationforstubbing` in [`invocationcontainerimpl`][invocationcontainerimpl] as `invocationcontainer` in [`mockhandlerimpl`][mockhandlerimpl] that eventually leads to a value in the `weakconcurrentmap` for `smallclass` similar thing happens to the mock instance of `smallclass` that creates a ring of reference and no mock can be reclaimed by gc because they are all referenced transitively by a value in the mapsimilar things can also happen for stubbed methods saved in `stubbed` in `invocationcontainerimpl`subclass mock makers dont suffer from it because there is no map from mock to handler -- its just a strong reference gc can handle non-accessible rings well but gc doesnt know the mock map purging semantic in inline mock makers# potential solutionunlike #1533 where converting `spiedinstance` to a weak reference may be an acceptable solution we cant convert arguments in stubbing method calls into weak references because there are stubbing calls with an object (or a mock) that doesnt have strong ref anywhere else than arguments in mockitotherefore i failed to see a solution thats transparent to callers the possible solution below is the one that i think has the least changethe possible solution is we can somehow reset the mock when their lives end which clears the stubbing records maybe we can tie their lives to a `mockitosession` we can track all mocks created after a session is created and reset them when the session is finished now we only have events for mock creation in the same thread we may need to expand that to include other threadswe may be able to set `spiedinstance` to `null` when their lives end which should also be able to 1532 and #1533 that would be a solution with least riskof course any solution thats transparent to callers is still more desirable# a detailed examplesee github project [mockitomethodcallmemleak][mockitomethodcallmemleak] one can open it in intellij and the run configuration is already configured (with mem dump at oom and 4m java heap size)[memdump]:      https://githubcom/ttanxu/mockitomethodcallmemleak;thanks for the detailed explanation!> we may be able to set `spiedinstance` to `null` when their lives end which should also be able to 1532 and #1533 that would be a solution with least risksounds like the best plan forward do you mind opening a pr with regression test to get that ? || it seems to be rather hard to convert all listeners to listen to events from all threads due to current test setuphowever its pretty important to capture mocks from other threads to make this solution work because junit has failontimeout impl which basically runs each individual test case in its own thread that means we need start a session in each test case rather than in setup and teardown which is rather inconvenientill add a global listener that captures all mock events from all threads but disable the feature unless caller explicitly enables in session buildersit would be a hard refactor to make `threadsrunalltestshalfmanualtest` pass with this || actually we probably shouldnt refactor those tests since they probably represent part of current api but it should be just ok to stick to the plan in my previous comment || thanks! i added documentation about this as it was having a big impact on a project and was hard to find  || we just updated our testing dependencies to latest version and ran into this oom how is adding an @after-annotated function to 3000+ tests practical of which some already have their own implementation @after implementation? or maybe im missing something? || there was a lot of discussion about this feature in the corresponding pr: #1619 that should hopefully clear up why we were forced to implement it this way 😢  || got it so is there a way that you know of to invoke that for all tests without me going into every test and adding that code? maybe via some test listener or reflection? || you can write your own test runner that extends from the default mockito runner and implements the logicwe might actually consider that as part of the default mockito runner implementation do you mind opening a pr to start that discussion? it will mostly revolve around potential issues with multithreaded code || > we just updated our testing dependencies to latest version and ran into this oom> how is adding an @after-annotated function to 3000+ tests practical of which some already have their own implementation @after implementation? or maybe im missing something?classes can have as many `@after` functions as they want in my case we had a base class that all classes inherited from ||;1;0;merge branch release/2x into release/2x;
1619;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;added dateformatter to layoutentry so that it actually works;nowadays it is not just enough to add a class (maybe).;;1532.0;new api to clean up all inline mocks after test;in certain specific rare scenarios (issue #1614) inline mocking causes memory leaks there is no clean way to mitigate this problem completely hence we introduced a new api to explicitly clear mock state (only make sense in inline mocking!):```javapublic class exampletest {     @after     public void clearmocks() {         mockitoframework()clearinlinemocks()     }     @test     public void sometest() {         //     } }```due to the introduction of map from weak reference from mock instance toits invocation handler mockito became vulnerable to memory leaks asthere are multiple situations where mockito could unintentionally holdstrong references to mock instances in the map record the strongreferences could be through spiedinstance for spies and arguments usedto facilitate method stubbingmockito could never know if the arguments passed in for method stubbingare also strongly referenced somewhere else or not so mockito needs tosave a strong reference to these arguments to avoid premature gctherefore to solve cyclic strong references through arguments mockitoneeds to explicitly know when mocks are out of their life and cleanup all internal strong references associated with them1532 and #1533;"i will review this tomorrow at a first glance we are going to need to make some changes most notably the way we handle interfaces (a new method on `mockmaker` is a breaking change) will give you a detailed review tomorrow || (that said the pr is much appreciated sorry if my initial reaction seemed not positive we really do appreciate community prs for these kind of issues!) || oh thanks for quick response i didnt expect any feedback todayi am not familiar with how to contribute to mockito (ie dont know what can be done and what cant) its expected to have some back and forth for a change at this scale just please be as detailed as possible so that i know how to make proper changesi just hope the overall approach wont be vetoed as i basically dont have any other ideas on how to solve it ||  merging 1619  || this is awesome thank you guys! i’ll try this api on our codebase and samples i’ve provided in original issues also — kudos for including tests reproducing the behavior i’ve described 😉  || hi just to let you know i am using the new api already with v2282 and for me it was breaking the strict test with following exception:``` orgmockitoexceptionsmisusingnotamockexception: argument passed to mockitomockingdetails() should be a mock but is an instance of class cache$mockitomock$149288076!       at orgmockitointernalrunnersdefaultinternalrunner$1$2testfinished(defaultinternalrunnerjava:63) ```i had to move it to `@afterclass` to mitigate the problem || @s2131 you are not allowed to interact with mocks anymore after calling that api because all internal states of mocks are cleaned up after the api call that includes all delayed actions or interactions from other threadsunfortunately its never as easy as just calling that api || ";nested spies cause memory leaks;"seems like nested spies can cause memory leaks since such objects are kept in memory without purging not sure if it can be resolved at all should it be avoided? is there a mention about this in docs? anyway the code speaks better and fortunately i’ve been able to create a self-contained samplebtw i can provide a `hprof` file if you are interested#### versions```orgmockito:mockito-core mockito-inline:2220``````java version ""180_181""java(tm) se runtime environment (build 180_181-b13)java hotspot(tm) 64-bit server vm (build 25181-b13 mixed mode)```#### gradleheap is set to 64 mb```groovytaskswithtype<test> {    maxheapsize  ""64m""    jvmargs(""-xx:+heapdumponoutofmemoryerror"")    failfast  true}``````$ /gradlew  cleantestdebugunittest  testdebugunittest --tests ""comgithubsamplenestedspiesmemoryleakspec"#### code```kotlinpackage comgithubsampleimport comjakewhartonrxrelay2behaviorrelayimport ioreactivexfunctionsconsumerimport orgjetbrainsspekapispekimport orgjetbrainsspekapidslitimport orgjunitplatformrunnerjunitplatformimport orgjunitrunnerrunwithimport orgmockitomockito@runwith(junitplatform::class)class nestedspiesmemoryleakspec : spek({    repeat(10_000) { iteration ->        it(""iteration [$iteration]"") {            mockitospy(service())        }    }}) {    class service {        // remove mockitospy and oom disappears        val value  mockitospy(consumer<int> {            // this closure keeps a reference to service            streamssize        })        // see at as a mass to fill the ram        val streams  (01_000)map { behaviorrelaycreate<int>() }    }}``````> task  testdebugunittestjavalangoutofmemoryerror: gc overhead limit exceededdumping heap to java_pid23350hprof heap dump file created [99857779 bytes in 0356 secs]comgithubsamplenestedspiesmemoryleakspec > it iteration [187] standard_error    javalangoutofmemoryerror: gc overhead limit exceeded    	at comjakewhartonrxrelay2behaviorrelay<init>(behaviorrelayjava:99)    	at comjakewhartonrxrelay2behaviorrelaycreate(behaviorrelayjava:77)    	at comgithubsamplenestedspiesmemoryleakspec$service<init>(nestedspiesmemoryleakspeckt:32)    	at comgithubsamplenestedspiesmemoryleakspec$1$1$1invoke(nestedspiesmemoryleakspeckt:17)    	at comgithubsamplenestedspiesmemoryleakspec$1$1$1invoke(nestedspiesmemoryleakspeckt:12)    	at orgjetbrainsspekenginescope$testexecute(scopekt:102)    	at orgjetbrainsspekenginescope$testexecute(scopekt:80)    	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:105)    	at orgjunitplatformenginesupporthierarchicalnodetesttask$$lambda$82/547193480execute(unknown source)    	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)    	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:95)    	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:71)comgithubsamplenestedspiesmemoryleakspec > it iteration [187] failed    javalangoutofmemoryerror> task  testdebugunittest failed```#### eclipse memory analyzer<img width""1238"" alt""screen shot 2018-11-14 at 19 09 53"" src"" width""1238"" alt""screen shot 2018-11-14 at 19 08 59"" src"" width""1238"" alt""screen shot 2018-11-14 at 19 09 09"" src"" like this happens:* `service` is a spy* `service` contains a `consumer` it is a `spy` as well* `consumer` is a closure and has an implicit reference to `service`* mockito keeps both spies and cannot remove them from memory since there is a cross-reference (i guess)";@mockitoguy sorry for the ping but the situation gets worse on our side is the issue with mockito or we are just using it the wrong way? || cc @raphw  || you are right due to the reference of one mock to another the weak map is loosing its effecttechnically we would need to make the spy reference weak to break the cross reference but i sm not sure how this can be achieved without risking to have the references collected prematurely  || @raphw thanks for the explanation! if it is more or less intended — maybe let’s document it somewhere? another option is throwing an exception or printing a warning in such cases since we weren’t aware of this and use mockito quite a lot we got ourselves in a pretty bad oom situation finding nested spies by hand is a tedeous task not even sure i can automate it without library support i’m afraid people will continue to do this not understanding the consequencescan i ask you to take a look at #1533 as well? i think it is pretty similar or even exactly the same in terms of the root issue || it is surely not expected behavior and i consider it a bug however i do not know how to solve this and i even doubt that it is solvable without a data structure that is called an  and which java does not (currently) supportbut we should definitely document this || just checked mockito 2270 using the new `mockitoframework()clearinlinemocks()` call does the trick and helps to avoid oom ;1;0;merge branch release/2x into release/2x;
1619;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;added dateformatter to layoutentry so that it actually works;nowadays it is not just enough to add a class (maybe).;;1533.0;new api to clean up all inline mocks after test;in certain specific rare scenarios (issue #1614) inline mocking causes memory leaks there is no clean way to mitigate this problem completely hence we introduced a new api to explicitly clear mock state (only make sense in inline mocking!):```javapublic class exampletest {     @after     public void clearmocks() {         mockitoframework()clearinlinemocks()     }     @test     public void sometest() {         //     } }```due to the introduction of map from weak reference from mock instance toits invocation handler mockito became vulnerable to memory leaks asthere are multiple situations where mockito could unintentionally holdstrong references to mock instances in the map record the strongreferences could be through spiedinstance for spies and arguments usedto facilitate method stubbingmockito could never know if the arguments passed in for method stubbingare also strongly referenced somewhere else or not so mockito needs tosave a strong reference to these arguments to avoid premature gctherefore to solve cyclic strong references through arguments mockitoneeds to explicitly know when mocks are out of their life and cleanup all internal strong references associated with them1532 and #1533;"i will review this tomorrow at a first glance we are going to need to make some changes most notably the way we handle interfaces (a new method on `mockmaker` is a breaking change) will give you a detailed review tomorrow || (that said the pr is much appreciated sorry if my initial reaction seemed not positive we really do appreciate community prs for these kind of issues!) || oh thanks for quick response i didnt expect any feedback todayi am not familiar with how to contribute to mockito (ie dont know what can be done and what cant) its expected to have some back and forth for a change at this scale just please be as detailed as possible so that i know how to make proper changesi just hope the overall approach wont be vetoed as i basically dont have any other ideas on how to solve it ||  merging 1619  || this is awesome thank you guys! i’ll try this api on our codebase and samples i’ve provided in original issues also — kudos for including tests reproducing the behavior i’ve described 😉  || hi just to let you know i am using the new api already with v2282 and for me it was breaking the strict test with following exception:``` orgmockitoexceptionsmisusingnotamockexception: argument passed to mockitomockingdetails() should be a mock but is an instance of class cache$mockitomock$149288076!       at orgmockitointernalrunnersdefaultinternalrunner$1$2testfinished(defaultinternalrunnerjava:63) ```i had to move it to `@afterclass` to mitigate the problem || @s2131 you are not allowed to interact with mocks anymore after calling that api because all internal states of mocks are cleaned up after the api call that includes all delayed actions or interactions from other threadsunfortunately its never as easy as just calling that api || ";cross-references and a single spy cause memory leak;"not entirely sure but i think that mockito does not handle cross-references well i have a semi-complex sample that proves this but at the same time i’m not sure it is a mockito failure and especially a fixable one suggestions how to avoid this behavior in general will be very helpful!btw i can provide a `hprof` file if you are interested#### versions```orgmockito:mockito-core mockito-inline:2220``````java version ""180_181""java(tm) se runtime environment (build 180_181-b13)java hotspot(tm) 64-bit server vm (build 25181-b13 mixed mode)```#### gradleheap is set to 64 mb```groovytaskswithtype<test> {    maxheapsize  ""64m""    jvmargs(""-xx:+heapdumponoutofmemoryerror"")    failfast  true}``````$ /gradlew  cleantestdebugunittest  testdebugunittest --tests ""comgithubsamplesubscriptionmemoryleakspec"#### code```kotlinpackage comgithubsampleimport comjakewhartonrxrelay2behaviorrelayimport comjakewhartonrxrelay2publishrelayimport ioreactivexdisposablescompositedisposableimport orgjetbrainsspekapispekimport orgjetbrainsspekapidslitimport orgjunitplatformrunnerjunitplatformimport orgjunitrunnerrunwithimport orgmockitomockito@runwith(junitplatform::class)class subscriptionmemoryleakspec : spek({    repeat(1_000) { iteration ->        it(""iteration $iteration"") {            // remove mockitospy and oom disappears (even without componentunbind)            val service  mockitospy(service())            val memoryconsumingservice  memoryconsumingservice()            val component  component(service memoryconsumingservice)            componentbind()            // uncomment the following line and oom disappears            // componentunbind()        }    }}) {    class service {        val stream  publishrelaycreate<unit>()toserialized()    }    class memoryconsumingservice {        // see at as a mass to fill the ram        val streams  (01_000)map { behaviorrelaycreate<int>() }    }    class component(            private val service: service            private val memoryconsumingservice: memoryconsumingservice    ) {        private val disposable  compositedisposable()        fun bind() {            disposable + servicestreamsubscribe {                // this closure keeps a reference to component                memoryconsumingservicestreamssize            }        }        fun unbind()  disposableclear()    }}``````> task  testdebugunittestjavalangoutofmemoryerror: gc overhead limit exceededdumping heap to java_pid31753hprof heap dump file created [96660586 bytes in 0332 secs]comgithubsamplesubscriptionmemoryleakspec > it iteration 260 standard_error    javalangoutofmemoryerror: gc overhead limit exceeded    	at javautilconcurrentlocksreentrantreadwritelock$sync<init>(reentrantreadwritelockjava:338)    	at javautilconcurrentlocksreentrantreadwritelock$nonfairsync<init>(reentrantreadwritelockjava:669)    	at javautilconcurrentlocksreentrantreadwritelock<init>(reentrantreadwritelockjava:240)    	at javautilconcurrentlocksreentrantreadwritelock<init>(reentrantreadwritelockjava:230)    	at comjakewhartonrxrelay2behaviorrelay<init>(behaviorrelayjava:99)    	at comjakewhartonrxrelay2behaviorrelaycreate(behaviorrelayjava:77)    	at comgithubsamplesubscriptionmemoryleakspec$memoryconsumingservice<init>(subscriptionmemoryleakspeckt:41)*** javalanginstrument assertion failed ***: ""!erroroutstanding"" with message cant create byte arrau at jplisagentc line: 813    	at comgithubsamplesubscriptionmemoryleakspec$1$1$1invoke(subscriptionmemoryleakspeckt:21)    	at comgithubsamplesubscriptionmemoryleakspec$1$1$1invoke(subscriptionmemoryleakspeckt:14)    	at orgjetbrainsspekenginescope$testexecute(scopekt:102)    	at orgjetbrainsspekenginescope$testexecute(scopekt:80)    	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:105)    	at orgjunitplatformenginesupporthierarchicalnodetesttask$$lambda$82/1204954813execute(unknown source)    	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)    	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:95)    	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:71)    	at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorservice$$lambda$89/1263089654accept(unknown source)    	at javautilarraylistforeach(arraylistjava:1257)    	at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorserviceinvokeall(samethreadhierarchicaltestexecutorservicejava:38)    	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:110)    	at orgjunitplatformenginesupporthierarchicalnodetesttask$$lambda$82/1204954813execute(unknown source)    	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)    	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:95)    	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:71)    	at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorservice$$lambda$89/1263089654accept(unknown source)    	at javautilarraylistforeach(arraylistjava:1257)    	at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorserviceinvokeall(samethreadhierarchicaltestexecutorservicejava:38)    	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:110)    	at orgjunitplatformenginesupporthierarchicalnodetesttask$$lambda$82/1204954813execute(unknown source)    	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:72)    	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:95)    	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:71)comgithubsamplesubscriptionmemoryleakspec > it iteration 260 failed    javalangoutofmemoryerror261 tests completed 1 failed> task  testdebugunittest failed82 actionable tasks: 5 executed 77 up-to-date```#### eclipse memory analyzer<img width""1513"" alt""screen shot 2018-11-15 at 11 57 52"" src"" width""1513"" alt""screen shot 2018-11-15 at 11 58 42"" src"" width""1513"" alt""screen shot 2018-11-15 at 11 59 17"" src"" width""1513"" alt""screen shot 2018-11-15 at 11 59 58"" src"" width""1513"" alt""screen shot 2018-11-15 at 12 01 25"" src"" like this happens:* `service` is a spy and is being passed to `component` along with `memoryconsumingservice`* since `service` is a spy it is being held by mockito* `component` subscribes to `servicestream` the `subscribe` closure captures `component` `service` and `memoryconsumingservice` due to rxjava specifics `servicestream` holds all of these thanks to the closure* since `service` is being held by mockito (since it is a spy) and by itself (due to the `subscribe` closure) mockito does not release ithowever:* releasing the subscription via `componentunbind()` removes a reference so mockito releases it and there is no oom* avoiding making `service` a spy eliminates oom as well i e cross-references are not an issue for the jvm itself";the issue is most likely caused by 2 factors:1 `creationsettingsspiedinstance` holds a hard reference to spied instance `inlinebytebuddymockmaker` puts instance of the settings into a hard-referenced value of `mocks` field solution could be to make `creationsettingsspiedinstance` a weak reference field || @timvdlippe @bric3 🏓  || @ming13 @beworker does anyone of you wants to take a stab at it? can you write up a short design note how you would like to solve it and pros/cons of adding another weak reference field? thanks so much! || @mockitoguy hey thanks for the reply! i think i don’t have enough expertise to do this without breaking something along the way but just to confirm — is the issue really with mockito or it is just a bad practices leading to this behavior? || wow eclipse || just checked mockito 2270 using the new `mockitoframework()clearinlinemocks()` call does the trick and helps to avoid oom ;1;0;merge branch release/2x into release/2x;
1619;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;added dateformatter to layoutentry so that it actually works;nowadays it is not just enough to add a class (maybe).;;0;improve presto documentation navigation;"replace navbar with basic breadcrumb navigation on the left and simple""previous / next"" links on the right sidethis allows navigating back to the toc at any time and navigating upin the document tree";thanks for sending this we tried it out and played around with some variations but given that we only have two levels we prefer the current design this new design could be better if we add more levels in the future ||;;;;0;1;;
1619;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;added dateformatter to layoutentry so that it actually works;nowadays it is not just enough to add a class (maybe).;;0;defaulthashmap replicates pythons defaultdict behaviour; a map that replicates pythons defaultdict behaviour meaning calling get(mykey) if mykey does not exists will create that key and assign a default value; since this is commonly asked ive added it to our wiki:  || ";;;;0;1;;
1620;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;protected terms management dialog;the idea is that the lists with protected terms should be user configurable. this pr adds the mechanism for this as well as a dialog to manage the lists.  eventually the internal lists should be managed as resources to simplify adding more. -   -   -   ();;0;logged error during presto-main tests;2014-09-02t09 23446+0545    error   task-querystagetask1-813  comfacebookprestoeventqueryquerymonitor    error posting split completion event for task querystagetask1comfasterxmljacksondatabindjsonmappingexception: no serializer found for class comfacebookprestoexecutiontestingsplit and no properties discovered to create beanserializer (to avoid exception disable serializationfeaturefail_on_empty_beans) ) (through reference chain: comfacebookprestooperatordriverstats[""operatorstats""]->comgooglecommoncollectregularimmutablelist[0]->comfacebookprestooperatoroperatorstats[""info""])    at comfasterxmljacksondatabindserimplunknownserializerfailforempty(unknownserializerjava:59) ~[jackson-databind-242jar:242]    at comfasterxmljacksondatabindserimplunknownserializerserialize(unknownserializerjava:26) ~[jackson-databind-242jar:242]    at comfasterxmljacksondatabindserbeanpropertywriterserializeasfield(beanpropertywriterjava:505) ~[jackson-databind-242jar:242]    at comfasterxmljacksondatabindserstdbeanserializerbaseserializefields(beanserializerbasejava:639) ~[jackson-databind-242jar:242]    at comfasterxmljacksondatabindserbeanserializerserialize(beanserializerjava:152) ~[jackson-databind-242jar:242]    at comfasterxmljacksondatabindserimplindexedlistserializerserializecontents(indexedlistserializerjava:100) ~[jackson-databind-242jar:242]    at comfasterxmljacksondatabindserimplindexedlistserializerserializecontents(indexedlistserializerjava:21) ~[jackson-databind-242jar:242]    at comfasterxmljacksondatabindserstdasarrayserializerbaseserialize(asarrayserializerbasejava:183) ~[jackson-databind-242jar:242]    at comfasterxmljacksondatabindserbeanpropertywriterserializeasfield(beanpropertywriterjava:505) ~[jackson-databind-242jar:242]    at comfasterxmljacksondatabindserstdbeanserializerbaseserializefields(beanserializerbasejava:639) ~[jackson-databind-242jar:242]    at comfasterxmljacksondatabindserbeanserializerserialize(beanserializerjava:152) ~[jackson-databind-242jar:242]    at comfasterxmljacksondatabindserdefaultserializerproviderserializevalue(defaultserializerproviderjava:114) ~[jackson-databind-242jar:242]    at comfasterxmljacksondatabindobjectmapper_configandwritevalue(objectmapperjava:2866) ~[jackson-databind-242jar:242]    at comfasterxmljacksondatabindobjectmapperwritevalueasstring(objectmapperjava:2323) ~[jackson-databind-242jar:242]    at comfacebookprestoeventqueryquerymonitorsplitcompletionevent(querymonitorjava:221) [classes/:na]    at comfacebookprestoeventqueryquerymonitorsplitcompletionevent(querymonitorjava:201) [classes/:na]    at comfacebookprestoexecutionsqltaskexecution$1onsuccess(sqltaskexecutionjava:313) [classes/:na]    at comgooglecommonutilconcurrentfutures$4run(futuresjava:1181) [guava-1601jar:na]    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:471) [na:170_67]    at javautilconcurrentfuturetaskrun(futuretaskjava:262) [na:170_67]    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:178) [na:170_67]    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:292) [na:170_67]    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1145) [na:170_67]    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:615) [na:170_67]    at javalangthreadrun(threadjava:745) [na:170_67]```";;;;;0;1;;
1620;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;protected terms management dialog;the idea is that the lists with protected terms should be user configurable. this pr adds the mechanism for this as well as a dialog to manage the lists.  eventually the internal lists should be managed as resources to simplify adding more. -   -   -   ();;0;scala observableusing should take a by-name param?;this is a pretty trivial proposal but i have just spent 10 minutes trying to figure out the error in the types current definition of `observableusing` (as of rxjava 0200) is ```  def using[t resource <: subscription](resourcefactory: () > resource observablefactory: resource > observable[t]): observable[t]  {```wouldnt it be more idiomatic scala to just use a by-name param for creating the resource?```  def using[t resource <: subscription](resourcefactory: > resource observablefactory: resource > observable[t]): observable[t]  {```regards  tomáš dvořák;yes no (generally speaking) scala signature should have `()>` || in addition i like the new `using` method in rxjava: #1592i will add it once the build scripts are set up maybe need to wait for one week || done in #1623 ||;;;;0;1;;
1620;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;protected terms management dialog;the idea is that the lists with protected terms should be user configurable. this pr adds the mechanism for this as well as a dialog to manage the lists.  eventually the internal lists should be managed as resources to simplify adding more. -   -   -   ();;1618.0;1618 : fix strict stubbing profile serialization support;when strict stubs profile is enabled mock serialization doesnt workthis pr fixes this problem; ;serializable flag doesnt make mock serializable;i have a simple example test like this (im using junit5 with mockito-junit-jupiter extension)```@extendwith(mockitoextensionclass)class exampletest {  @mock(serializable  true) private iterable<?> it  @test  void shouldserializeanddeserializeit() throws ioexception classnotfoundexception {    // when    bytearrayoutputstream out  new bytearrayoutputstream()    new objectoutputstream(out)writeobject(it)    bytearrayinputstream in  new bytearrayinputstream(outtobytearray())    iterable<?> deserializedit  (iterable<?>) new objectinputstream(in)readobject()    // then    assertthat(deserializedit)isequaltocomparingfieldbyfieldrecursively(it)  }}```and im getting this error on during instance serialization:```javaionotserializableexception: orgmockitointernaljunitdefaultstubbinglookuplistener	at javabase/javaioobjectoutputstreamwriteobject0(objectoutputstreamjava:1185)	at javabase/javaioobjectoutputstreamwriteobject(objectoutputstreamjava:349)	at javabase/javautilarraylistwriteobject(arraylistjava:896)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javabase/javalangreflectmethodinvoke(methodjava:566)	at javabase/javaioobjectstreamclassinvokewriteobject(objectstreamclassjava:1130)	at javabase/javaioobjectoutputstreamwriteserialdata(objectoutputstreamjava:1497)	at javabase/javaioobjectoutputstreamwriteordinaryobject(objectoutputstreamjava:1433)	at javabase/javaioobjectoutputstreamwriteobject0(objectoutputstreamjava:1179)	at javabase/javaioobjectoutputstreamdefaultwritefields(objectoutputstreamjava:1553)	at javabase/javaioobjectoutputstreamwriteserialdata(objectoutputstreamjava:1510)	at javabase/javaioobjectoutputstreamwriteordinaryobject(objectoutputstreamjava:1433)	at javabase/javaioobjectoutputstreamwriteobject0(objectoutputstreamjava:1179)	at javabase/javaioobjectoutputstreamdefaultwritefields(objectoutputstreamjava:1553)	at javabase/javaioobjectoutputstreamwriteserialdata(objectoutputstreamjava:1510)	at javabase/javaioobjectoutputstreamwriteordinaryobject(objectoutputstreamjava:1433)	at javabase/javaioobjectoutputstreamwriteobject0(objectoutputstreamjava:1179)	at javabase/javaioobjectoutputstreamdefaultwritefields(objectoutputstreamjava:1553)	at javabase/javaioobjectoutputstreamwriteserialdata(objectoutputstreamjava:1510)	at javabase/javaioobjectoutputstreamwriteordinaryobject(objectoutputstreamjava:1433)	at javabase/javaioobjectoutputstreamwriteobject0(objectoutputstreamjava:1179)	at javabase/javaioobjectoutputstreamdefaultwritefields(objectoutputstreamjava:1553)	at javabase/javaioobjectoutputstreamwriteserialdata(objectoutputstreamjava:1510)	at javabase/javaioobjectoutputstreamwriteordinaryobject(objectoutputstreamjava:1433)	at javabase/javaioobjectoutputstreamwriteobject0(objectoutputstreamjava:1179)	at javabase/javaioobjectoutputstreamdefaultwritefields(objectoutputstreamjava:1553)	at javabase/javaioobjectoutputstreamwriteserialdata(objectoutputstreamjava:1510)	at javabase/javaioobjectoutputstreamwriteordinaryobject(objectoutputstreamjava:1433)	at javabase/javaioobjectoutputstreamwriteobject0(objectoutputstreamjava:1179)	at javabase/javaioobjectoutputstreamdefaultwritefields(objectoutputstreamjava:1553)	at javabase/javaioobjectoutputstreamwriteserialdata(objectoutputstreamjava:1510)	at javabase/javaioobjectoutputstreamwriteordinaryobject(objectoutputstreamjava:1433)	at javabase/javaioobjectoutputstreamwriteobject0(objectoutputstreamjava:1179)	at javabase/javaioobjectoutputstreamwriteobject(objectoutputstreamjava:349)```;we have observed similar things before it seems like a mock is something keeping a hard reference to a listener @timvdlippe do you remember me mentioning to having observed this some times? were you working with the listener parts originally? || yes i recall that discussion the listener parts were introduced by @mockitoguy i have run into this problem myself from time to time and have not figured out where it goes wrong these listeners should not even be considered when serializing mocks ||;1;0;1618 : fix strict stubbing profile serialization support;
1624;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;handle terminal type var with bounds;this pr aim to fix the issue described in #1621  the issue being that terminal type variable arguments were not looked up for their bounds.;;0;longmathcheckedpow() mishandles negative numbers with large magnitude; in v15 longmathcheckpow(longmin_value2)0  instead it should throw an arithmeticexception per specification  the problem occurs more generally when the base is negative and the result overflowslongmaths checkpow() implementation should have the similar check as intmath:// from longmathcheckedpow()checknooverflow(b < floor_sqrt_max_long) // from intmathcheckedpow()checknooverflow(-floor_sqrt_max_int < b & b < floor_sqrt_max_int); ;;;;0;1;;
1624;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;handle terminal type var with bounds;this pr aim to fix the issue described in #1621  the issue being that terminal type variable arguments were not looked up for their bounds.;;0;dont generate so many invokedynamic callsite names;"java 7 doesnt seem to like too many unique callsite names in a single class (java 8 works ok though)it causes execution for queries with many projections to fail with:```exception in thread ""main"" javalangbootstrapmethoderror: call site initialization exception    at javalanginvokecallsitemakesite(callsitejava:298)    at javalanginvokemethodhandlenativeslinkcallsite(methodhandlenativesjava:295)    at runnable_1run404(unknown source)    at runnable_1run(unknown source)    at comfacebookindytestmainmain(mainjava:8)    at sunreflectnativemethodaccessorimplinvoke0(native method)    at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:57)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javalangreflectmethodinvoke(methodjava:606)    at comintellijrtexecutionapplicationappmainmain(appmainjava:134)caused by: javalangnullpointerexception    at suninvokeutilvalueconversionsunboxinteger(valueconversionsjava:77)    at javalanginvokecallsitemakesite(callsitejava:282)     9 more```for future reference heres a stand-alone test case that reproduces the issue: https://githubcom/martint/indytest";;;;;0;1;;
1624;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;handle terminal type var with bounds;this pr aim to fix the issue described in #1621  the issue being that terminal type variable arguments were not looked up for their bounds.;;0;test isolation problem;`newthreadschedulertest` fails 9 out of 10 runs on my laptop when i run the unit test suite but passes every time if run individuallystack trace of failing test:``` javajavalangassertionerror: expected:<2> but was:<4>at rxschedulersabstractschedulerconcurrencyteststestunsubscribeforscheduler(abstractschedulerconcurrencytestsjava:107)```ive dumped the thread stack traces at the start of the test in question and it appears that `operatorparalleltest` is still busy being mentioned in 4 threads see one example at the bottom of this postso the issue i want to raise is that tests of asynchronous code are not releasing resources effectively so that a following unit test that relies on timing can proceed deterministicallyin particular i think that - `operatorparalleltest` should release its resources after completion so that the behaviour im seeing is  would someone like to have a go at it?-  strategies for test isolation could be discussed further for example enabling such isolation in the scheduler apiwhat do you think?```rxcomputationthreadpool-3javalangthreadsleep(native method)rxinternaloperatorsoperatorparalleltest$10$1call(operatorparalleltestjava:210)rxinternaloperatorsoperatorparalleltest$10$1call(operatorparalleltestjava:1)rxinternaloperatorsoperatormap$1onnext(operatormapjava:54)rxinternaloperatorsnotificationliteaccept(notificationlitejava:147)rxinternaloperatorsoperatorobserveon$observeonsubscriberpollqueue(operatorobserveonjava:169)rxinternaloperatorsoperatorobserveon$observeonsubscriberaccess$0(operatorobserveonjava:158)rxinternaloperatorsoperatorobserveon$observeonsubscriber$2call(operatorobserveonjava:151)rxinternalschedulersscheduledactionrun(scheduledactionjava:43)javautilconcurrentexecutors$runnableadaptercall(executorsjava:511)javautilconcurrentfuturetaskrun(futuretaskjava:266)javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:180)javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:293)javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)javalangthreadrun(threadjava:745)```;do you still experience this failure? || not this one no operatorparalleltest is gone now but the issue of tests being able to affect other tests (especially those relying on timeouts) due to async work continuing on schedulers after a test has finished is probably still around and i imagine may rear its head again @akarnokd the schedulerreset() work would be useful in this regard if it does happen again assuming that the schedulerreset() work has gotten into the codebase (?) by the way i did get a test failure on my 5 year old 2 core laptop when i checked running all tests in eclipse but ill raise it as a separate issue  || ah hold your horses the latest failure (`operatormergetesttestbackpressureupstream2`) is another example of a test isolation issue the test passes every time if run alone but fails if run in the suite (ill check with what frequency)```javalangassertionerror: expected:<257> but was:<256>    at orgjunitassertfail(assertjava:93)    at orgjunitassertfailnotequals(assertjava:647)    at orgjunitassertassertequals(assertjava:128)    at orgjunitassertassertequals(assertjava:472)    at orgjunitassertassertequals(assertjava:456)    at rxinternaloperatorsoperatormergetesttestbackpressureupstream2(operatormergetestjava:651)    at sunreflectnativemethodaccessorimplinvoke0(native method)    at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javalangreflectmethodinvoke(methodjava:483)    at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:45)    at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:15)    at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:42)    at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:20)    at orgjunitinternalrunnersstatementsrunbeforesevaluate(runbeforesjava:28)    at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:263)    at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:68)    at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:47)    at orgjunitrunnersparentrunner$3run(parentrunnerjava:231)    at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:60)    at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:229)    at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:50)    at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:222)    at orgjunitrunnersparentrunnerrun(parentrunnerjava:300)    at orgeclipsejdtinternaljunit4runnerjunit4testreferencerun(junit4testreferencejava:50)    at orgeclipsejdtinternaljunitrunnertestexecutionrun(testexecutionjava:38)    at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:459)    at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:675)    at orgeclipsejdtinternaljunitrunnerremotetestrunnerrun(remotetestrunnerjava:382)    at orgeclipsejdtinternaljunitrunnerremotetestrunnermain(remotetestrunnerjava:192)``` || `operatormergetesttestbackpressureupstream2` fails 2 out of 3 times when running the whole suite in eclipse || the test `operatormergetesttestbackpressureupstream2` makes use of `schedulerscomputation` and only fails when other tests have run before it (presumably async work is taking place still once this test starts) to clarify what i mean with `schedulerreset()` what id hope is that when a test like the one in question makes use of an async `scheduler` we should be able to ensure test isolation by starting the test with a call to `schedulerscomputation()reset()` this would ensure that any outstanding work on the computation scheduler completed before the test gets going do you think this is a valid approach @akarnokd @zsxwing @benjchristensen? || reset() may be sufficient or we should ensure that were not letting things run async in the background and that tests must wait for all work to finish the fact this is happening suggests we are allowing tests to finish prematurely the reset() thing seems to bandage over the real issue || yep i agree it would be nice to ensure tests clean up after themselves butthat seems like a big ask to review all existing tests for possible asyncleftovers (or just uniformly put a reset() at the end of each test!) itmight be easier to apply the reset() bandaid reactively at the start ofnon-deterministic tests as they turn up dunnoon 22 january 2015 at 10:03 ben christensen notifications@githubcomwrote:> reset() may be sufficient or we should ensure that were not letting> things run async in the background and that tests must wait for all work to> finish the fact this is happening suggests we are allowing tests to finish> prematurely the reset() thing seems to bandage over the real issue> > —> reply to this email directly or view it on github>  || on one time ive created a small utility method that takes the computation scheduler asks for `availableprocessor()` number of workers issues a task to each and waits 1s to get a response this should detect obstruction another option is to get all threads and see if we detect unrecognized threads or leftover newthreads by their name || the master now has the [testobstructiondetection] class ( which you can insert at various places to see if something hung in a computation scheduler ||;;;;0;1;;
1624;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;handle terminal type var with bounds;this pr aim to fix the issue described in #1621  the issue being that terminal type variable arguments were not looked up for their bounds.;;1621.0;handle terminal type var with bounds;this pr aim to fix the issue described in #1621 the issue being that terminal type variable arguments were not looked up for their bounds1621; merging 1624 ;"returns_deep_stubs causes ""raw extraction not supported for : null"" in some cases";when trying to mock the [hadoop mappercontext]( class with mockito 2240 exception `orgmockitoexceptionsbasemockitoexception: raw extraction not supported for : null` is thrown when calling one of the methods that returns a generic type  actual mocking is taking place inside the [mrunit library]( as seen in [mockmapcontextwrapper](     final mapper<keyin valuein keyout valueout>context context  mock(orgapachehadoopmapreducemappercontextclass mockitoreturns_deep_stubs)context is an abstract inner class of mapper and implements the [mapcontext]( interface which extends the [taskinputoutputcontext]( interface which extends several other non-generic interfaces exception is thrown later when calling the [`contextgetcurrentkey()`]( method on the mock which returns generic type `keyin`this works fine with mockito 1mrunit project is abandoned so it is not possible to change the mock  it by default uses old mockito 195 and works with 11019  i am attempting to exclude its dependencies on old mockito and powermock and instead provide latest mockito 2240 and powermock 200 so that my project using mrunit and mockito will not be permanently stuck on mockito 1 the only time these problem methods appear to be [called within mrunit is to set up stubbing]( so it doesnt really matter what the return value is in this case  should this even work with mockito or was this just a bug in mockito 1 that mrunit exploited? ----here is a minimal example that reproduces the issue:```javapackage exampleimport orgjunitbeforeimport orgjunittestimport static orgmockitomockitoreturns_deep_stubsimport static orgmockitomockitomockpublic class example {    public interface firstinterface<t> {        boolean normal()        t generic()    }    public interface secondinterface<t> extends firstinterface<t> { }    public class testclass<t> {        public abstract class abstractinner implements secondinterface<t> { }    }    private testclassabstractinner testmock    @before    public void setup() {        testmock  mock(testclassabstractinnerclass returns_deep_stubs)    }    @test    public void works() {        testmocknormal()    }    @test    public void fails() {        testmockgeneric()    }}``` has this code with a gradle buildboth tests pass with mockito 11019 but one fails with 2240  changing testclassabstractinner to implement firstinterface instead of secondinterface causes the same failure with both mockito 1 and 2;@zman0900 hi nice bug report and reproducible example it really helped indeed thats a bug or a current limitation in mockitos way to handle generics im currently devising a way to improve such scenario ||;1;0;reintroduces the guard that returns null instead of a mock of objectwhile the generics metadata extractor has been improved not everypossible scenarios are covered even javac in version 8 do not followthrough in order to avoid a stealth return of the bugs spot in #357this change improves the guard by making sure extracted generic datadoes not have extra-interfaces as well;
1635;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;more tests;a few more tests of cookie  stringutil.intvalueofwithnull  and reenabling some tests for layout.;;0;jdk and guava typevariable implementations are no longer compatible under 170_51-b13; comgooglecommonreflecttyperesolvertestcomgooglecommonreflecttypetokenresolutiontestcomgooglecommonreflecttypetokentestcomgooglecommonreflecttypestestjava -versionjava version ""170_51""java(tm) se runtime environment (build 170_51-b13)java hotspot(tm) 64-bit server vm (build 2451-b03 mixed mode)please fix it ：）"; any plans for 1501 with the same fix?  jclouds upgraded to 1601 in its 18x development branch but prefers not to upgrade guava a major version in its 17x stable branch due to various guava deprecations and api changes || ";;;;0;1;;
1635;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;more tests;a few more tests of cookie  stringutil.intvalueofwithnull  and reenabling some tests for layout.;;0;fix handling of generics in returnsmocks;returnsmocks was exhibiting the same problems as we previously had withreturnssmartnulls extract that common behavior into a separate classand thus fix the issues with returnsmocks;we found a regression in our test suites should be easy to fix but i will do that tomorrow then i will merge thanks @raphw for the review 😄  ||  merging 1635 ;;;;1;1;fix handling of generics in returnsmocksreturnsmocks was exhibiting the same problems as we previously had withreturnssmartnulls extract that common behavior into a separate classand thus fix the issues with returnsmocks;
1635;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;more tests;a few more tests of cookie  stringutil.intvalueofwithnull  and reenabling some tests for layout.;;0;bound the number of queued queries in presto;;looks good but make sure the error is properly classified ||;;;;0;1;;
1635;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;more tests;a few more tests of cookie  stringutil.intvalueofwithnull  and reenabling some tests for layout.;;0;optimize single blockingobservable operations;this changeset optimizes all blocking operations that just return a singlevalue the previous code used an iterator all the time adding significantgc pressure with iterators and a backing lbqthe following numbers are from the added jmh tests just as a generalmeasurement the most boost is gained from small results and lessgc pressurebefore this change:```roblockingobservableperfbenchfirst          1  thrpt         5  2839391882    17771079    ops/sroblockingobservableperfbenchfirst       1000  thrpt         5  2046716781    22884125    ops/sroblockingobservableperfbenchfirst    1000000  thrpt         5  2067456792    15499650    ops/sroblockingobservableperfbenchlast           1  thrpt         5  2160081041    21230437    ops/sroblockingobservableperfbenchlast        1000  thrpt         5    83270845      871836    ops/sroblockingobservableperfbenchlast     1000000  thrpt         5      100190        1001    ops/sroblockingobservableperfbenchsingle         1  thrpt         5  3702921521   154008164    ops/s```after this change:```roblockingobservableperfbenchfirst          1  thrpt         5  6466732996   191239670    ops/sroblockingobservableperfbenchfirst       1000  thrpt         5  3752276751   135138711    ops/sroblockingobservableperfbenchfirst    1000000  thrpt         5  3840942600    59305202    ops/sroblockingobservableperfbenchlast           1  thrpt         5  4110186134    98795733    ops/sroblockingobservableperfbenchlast        1000  thrpt         5    84528104     1710853    ops/sroblockingobservableperfbenchlast     1000000  thrpt         5       99460        2091    ops/sroblockingobservableperfbenchsingle         1  thrpt         5 11897793778   321260803    ops/s```;there you go please review @benjchristensen  || #1536  those test failures reported but i dont know about the assertobservabletest so if you could jump in if its okay or we should change something let me know the other tests have not been modified || #1537 ;;;;1;1;optimize single blockingobservable operationsthis changeset optimizes all blocking operations that just return a singlevalue the previous code used an iterator all the time adding significantgc pressure with iterators and a backing lbqthe following numbers are from the added jmh tests just as a generalmeasurement the most boost is gained from small results and lessgc pressurebefore this change:roblockingobservableperfbenchfirst          1  thrpt         5  2839391882    17771079    ops/sroblockingobservableperfbenchfirst       1000  thrpt         5  2046716781    22884125    ops/sroblockingobservableperfbenchfirst    1000000  thrpt         5  2067456792    15499650    ops/sroblockingobservableperfbenchlast           1  thrpt         5  2160081041    21230437    ops/sroblockingobservableperfbenchlast        1000  thrpt         5    83270845      871836    ops/sroblockingobservableperfbenchlast     1000000  thrpt         5      100190        1001    ops/sroblockingobservableperfbenchsingle         1  thrpt         5  3702921521   154008164    ops/safter this change:roblockingobservableperfbenchfirst          1  thrpt         5  6466732996   191239670    ops/sroblockingobservableperfbenchfirst       1000  thrpt         5  3752276751   135138711    ops/sroblockingobservableperfbenchfirst    1000000  thrpt         5  3840942600    59305202    ops/sroblockingobservableperfbenchlast           1  thrpt         5  4110186134    98795733    ops/sroblockingobservableperfbenchlast        1000  thrpt         5    84528104     1710853    ops/sroblockingobservableperfbenchlast     1000000  thrpt         5       99460        2091    ops/sroblockingobservableperfbenchsingle         1  thrpt         5 11897793778   321260803    ops/s;
1639;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removes inaccessible links from javadocs in mockito.java;the monkeyisland.pl domain is no longer available.;;0;gwt+guava compilation error:[error] line 761: max_size cannot be resolved or is not a field; when compiling guava 160+gwt 26 rc4i got this error:compiling module comdscathenaathena&nbsp&nbsp&nbsp[error] errors in jar /home/alex/workspace/dsc-lib/lib/guava-gwt-160jar!/com/google/common/base/super/com/google/common/base/charmatcherjava&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp[error] line 761: max_size cannot be resolved or is not a field; this is  in 1601--- ;;;;0;1;;
1639;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removes inaccessible links from javadocs in mockito.java;the monkeyisland.pl domain is no longer available.;;0;removes inaccessible links from javadocs in mockitojava;the monkeyislandpl domain is no longer availablelist of inaccessible articles //monkeyislandpl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoringhttp://monkeyislandpl/2008/07/12/should-i-worry-about-the-unexpectedhttp://monkeyislandpl/2008/04/26/asking-and-tellinghttp://monkeyislandpl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring; ;;;;1;1;1638: removes inaccessible links from javadocs in mockitojavathe monkeyislandpl domain is no longer availablelist of inaccessible articles //monkeyislandpl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoringhttp://monkeyislandpl/2008/07/12/should-i-worry-about-the-unexpectedhttp://monkeyislandpl/2008/04/26/asking-and-tellinghttp://monkeyislandpl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring;
1639;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removes inaccessible links from javadocs in mockito.java;the monkeyisland.pl domain is no longer available.;;0;preparatory changes to support parametric types;;;;;;0;1;;
1639;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removes inaccessible links from javadocs in mockito.java;the monkeyisland.pl domain is no longer available.;;0;dooneach - handle fatal exceptions;merging change from 020 into 1x > https://githubcom/reactivex/rxjava/pull/1631/files;#1540];;;;1;1;dooneach - handle fatal exceptionsmerging change from 020 into 1x > https://githubcom/reactivex/rxjava/pull/1631/files;
1641;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fix returns mocks for final classes;the guard for final mocking was incorrect. it should have passed it on;;0;fix returns mocks for final classes;the guard for final mocking was incorrect it should have passed it onto mockitocore since we have the inlinemockmaker we can actually mockso this check was incorrect; merging 1641 ;;;;1;1;fix returns mocks for final classesthe guard for final mocking was incorrect it should have passed it onto mockitocore since we have the inlinemockmaker we can actually mockso this check was incorrect;
1641;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fix returns mocks for final classes;the guard for final mocking was incorrect. it should have passed it on;;0;add hive tests for newly added columns;verify that all of the file formats work correctly if a column isadded to the table after the file is already created;;;;;0;1;;
1641;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;fix returns mocks for final classes;the guard for final mocking was incorrect. it should have passed it on;;0;rxscala: fix infinite recursive onstart call in subscriber;without this fix when subscribing using a `new subscriber` onstart would be called in an infinite loop giving a strack trace similar to this:```javalangstackoverflowerror    at rxlangscalasubscribertests$$anon$1onstart(subscribertestsscala:65)    at rxlangscalasubscriber$$anon$1onstart(subscriberscala:8)    at rxlangscalasubscriber$classonstart(subscriberscala:43)    at rxlangscalasubscribertests$$anon$1onstart(subscribertestsscala:65)    at rxlangscalasubscriber$$anon$1onstart(subscriberscala:8)    at rxlangscalasubscriber$classonstart(subscriberscala:43)```;[reactivex » rxjava » rxjava-pull-requests #1 #1542  good catch  please also fix this in the new rxscala project ||;;;;1;1;rxscala: fix recursive onstart call in subscriber;
1644;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;resolve crossrefs and strings in main table;based on a discussion in the forum  this is a quick hack to show the possibilities. can be downloaded and tested from    it would be especially interesting for people with large databases with many strings to test it for performance. a better implementation can be done if this will make it to the released version. at least removing the commented out lines. -   -  manually tested changed features in running jabref;;0;remove all references to unsupported java api classes;nickwil@ this enhancement to proposed to remove all references to unsupported java api classes (ie sun*)issue #﻿1635 has raised a number of concerns within the community and these need to be addressed so that guava is not exposed to issues caused by unsupported specification changessee: http://wwwredditcom/r/java/comments/1vxvr8/java_security_patch_breaks_guava_library/; we believe that our usages of sun\* all have fallbacks let us know if you find otherwise (for clarity: issue 1635 is about undocumented equals() methods rather than about sun\* classes)--- ;;;;0;1;;
1644;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;resolve crossrefs and strings in main table;based on a discussion in the forum  this is a quick hack to show the possibilities. can be downloaded and tested from    it would be especially interesting for people with large databases with many strings to test it for performance. a better implementation can be done if this will make it to the released version. at least removing the commented out lines. -   -  manually tested changed features in running jabref;;0;select count(*) with aggregation subquery throws arrayindexoutofboundsexception;```presto> select count(*) from (select count(1))query 20140910_204334_54189_w8f29 failed 1 node 1 total 0 done (000%)cpu time: 00s total     0 rows/s     0b/s 0% activeper node: 00 parallelism     0 rows/s     0b/sparallelism: 000:01 [1 rows 0b] [0 rows/s 0b/s]query 20140910_204334_54189_w8f29 failed: 0javalangarrayindexoutofboundsexception: 0    at comfacebookprestooperatorpage<init>(pagejava:34)    at comfacebookprestooperatoraggregationoperatorgetoutput(aggregationoperatorjava:168)    at comfacebookprestooperatordriverprocess(driverjava:329)    at comfacebookprestooperatordriverprocessfor(driverjava:271)    at comfacebookprestoexecutionsqltaskexecution$driversplitrunnerprocessfor(sqltaskexecutionjava:679)    at comfacebookprestoexecutiontaskexecutor$prioritizedsplitrunnerprocess(taskexecutorjava:444)    at comfacebookprestoexecutiontaskexecutor$runnerrun(taskexecutorjava:578)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1145)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:615)    at javalangthreadrun(threadjava:744)```;presto:di> explain select count(*) from (select count(1))             query plan              ------------------------------------- - output[_col0]                              _col0 : count_3                 - aggregate > [count_3:bigint]              count_3 : ""count""(*)            - aggregate >                         - values >           ``` || if that is a valid plan it is trivial to fix the operator to support this || technically its valid (the way values is printing is misleading -- its really a single row with no columns) the single-row values node followed by the empty aggregate should collapse into a single-row values node || ";;;;0;1;;
1644;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;resolve crossrefs and strings in main table;based on a discussion in the forum  this is a quick hack to show the possibilities. can be downloaded and tested from    it would be especially interesting for people with large databases with many strings to test it for performance. a better implementation can be done if this will make it to the released version. at least removing the commented out lines. -   -  manually tested changed features in running jabref;;0;nebula build - single module;;#1543  [reactivex » rxjava » rxjava-pull-requests #2];;;;1;1;nebula build - single module;
1644;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;resolve crossrefs and strings in main table;based on a discussion in the forum  this is a quick hack to show the possibilities. can be downloaded and tested from    it would be especially interesting for people with large databases with many strings to test it for performance. a better implementation can be done if this will make it to the released version. at least removing the commented out lines. -   -  manually tested changed features in running jabref;;1642.0;verificationcollector to handle non-matching args and other assertions;this fix for #1642 widens the catch in `verificationcollectorimpl` so that it will catch any `assertionerror` rather than just `mockitoassertionerror` in this way any comparison failures (such as the built-in argument comparison when running under junit) will also be collected rather than propagating through to the test frameworkthere are also two commits which are more cosmetic improvements to `verificationcollectorimpltest`:* rename `assertatleastonefailure()` to `assertexactlyonefailure()` (more accurate description of what it does)* change `assertfail()` to assertjs `assertbecauseexceptionwasnotthrown()` (produces better diagnostics in the case of a failure); merging 1644 ` ;verificationcollector doesnt work for invocations with non-matching args;i found the incubating `verificationcollector` (#287) which is similar to assertj `softassertion`s in that it collects multiple verifications and then asserts on the whole rather than throwing an exception on the first one and skipping the rest of the verifications very useful for complicated testinghowever i found that the verification collector doesnt work for verifications on method invocations with parameters i had a quick check of the source code of the test and i noticed that all of the tests in `verificationcollectorimpltest` use no-arg invocationshopefully this would be an easy fix because this looks like an extremely useful feature for my application but i need to verify invocations with arguments at the moment my workaround is to wrap each verification call in an assertj soft assertion but this makes writing the tests a bit more tedious and less readable;update: i found that the lazy verification works properly when you use `verificationcollector` directly however if you try and use it as a junit rule thats when this bug manifestsi have updated `verificationcollectorimpltest` to properly test for this situation and fail as appropriate i will have a quick look and see if it is an easy fix otherwise i may submit a pr with the test only and leave a more experienced hand to fix it || another update: i have gotten to the root of this problem>i found that the lazy verification works properly when you use verificationcollector directly however if you try and use it as a junit rule thats when this bug manifeststhis wasnt quite correct the distinguishing feature wasnt the junit rule but if you do a verification for an invocation that tries to match on an argument while running under junitthere is code in `orgmockitointernaljunitexceptionfactory` that checks to see if junit is on the classpath - if so then it will throw `orgmockitoexceptionsverificationjunitargumentsaredifferent` rather than `orgmockitoexceptionsverificationargumentsaredifferent` the junit version inherits from `junitframeworkcomparisonfailure` whereas the basic version inherits from `orgmockitoexceptionsbasemockitoassertionerror`it seems that the purpose of this is to help junit-aware guis to produce more helpful diagnostic output this makes sense (although it would make more sense to derive from a more-up-to-date version of `comparisonfailure` if it is available like `orgjunitcomparisonfailure` - perhaps this could be the subject of a different issue/pr) however because it is not a subclass of `mockitoassertionerror` it skips out of the try/catch in `verificationcollectorimpl` (see  are two possible solutions:1 add another `catch()` to catch `comparisonfailure` as well2 broaden the catch for `mockitoassertionerror` to a common superclass (like `assertionerror`)the second probably has more generic appeal and would future-proof the solution if other types of argument comparison were used (eg a custom argument matcher) i will submit a pr for this shortly ||;1;0;enhance verificationcollectorimpl to collect argument-matching failures1642;
1646;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;add back getargument(int  class) to circumvent compilation issues;also add  @notextensible  to several of our interfaces to document they;;0;release fluentiterablejoin(joiner); i see 174 internal callers ~15th of the methods on fluentiterable as far as i can tell our reason for adding it internally only was purely precautionary i havent seen discussion of any particular issues; ;;;;0;1;;
1646;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;add back getargument(int  class) to circumvent compilation issues;also add  @notextensible  to several of our interfaces to document they;;0;add back getargument(int class) to circumvent compilation issues;also add `@notextensible` to several of our interfaces to document theyare not intended to be subclassed1609; merging 1646  this pr || good work thank you! sorry i was late to review ||;;;;1;1;merge branch release/2x into get-argument-class;
1646;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;add back getargument(int  class) to circumvent compilation issues;also add  @notextensible  to several of our interfaces to document they;;0;update tests;;;;;;0;1;;
1646;0;1;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;add back getargument(int  class) to circumvent compilation issues;also add  @notextensible  to several of our interfaces to document they;;0;deprecate parallelmerge;removing in 10 as it is confusing and rarely useful;[reactivex » rxjava » rxjava-pull-requests #4;;;;1;1;deprecate parallelmergeremoving in 10 as it is confusing and rarely useful;
1648;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;refactoring of importer;moved classes to gui and logic and created a bit more structure.  (eclipse just hang and i have other things to do at the moment  but there are mainly some code cleanups: - getting rid of a gui-dependency in arxiv by moving correctlinebreaks - import grouping in a few files   );;0;add preconditioncheckargumentnotnull() throws iae; to check precondions for methods or constructors it would be handy to have a equivalent to checknotnull() that throws an illegalargumentexceptiona good explanation why to throw an iae in this case rather than a npe can be found here //stackoverflowcom/questions/3881/illegalargumentexception-or-nullpointerexception-for-a-null-parameter; added to  || ";;;;0;1;;
1648;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;refactoring of importer;moved classes to gui and logic and created a bit more structure.  (eclipse just hang and i have other things to do at the moment  but there are mainly some code cleanups: - getting rid of a gui-dependency in arxiv by moving correctlinebreaks - import grouping in a few files   );;0;prevent npe in findtypefromgenericinarguments;there was only a single test failing on this i think the issue was returns_smart_nulls in combination with an argumentcaptor butcouldnt figure that part out at least this fixes prevented the npe; merging 1648  < ;;;;1;1;fix checkstyle warnings;
1648;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;refactoring of importer;moved classes to gui and logic and created a bit more structure.  (eclipse just hang and i have other things to do at the moment  but there are mainly some code cleanups: - getting rid of a gui-dependency in arxiv by moving correctlinebreaks - import grouping in a few files   );;0;log exception for skipped queries;;;;;;0;1;;
1648;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;refactoring of importer;moved classes to gui and logic and created a bit more structure.  (eclipse just hang and i have other things to do at the moment  but there are mainly some code cleanups: - getting rid of a gui-dependency in arxiv by moving correctlinebreaks - import grouping in a few files   );;0;operator scan backpressure fix;problem 1) the initial value was being emitted before subscription which caused issues with request/producer state particularly if filter() was used to skip that initial value and then called request(1) before the real request had been sentproblem 2) the initial value was not accounted for by the request so it was sending 1 more value than requested it now modifies the request to account for itproblem 3) redo relied upon these nuances to work ive  this by using a simpler implementation that just maintains state within a map function;[reactivex » rxjava » rxjava-pull-requests #6 [reactivex » rxjava » rxjava-pull-requests #9  [reactivex » rxjava » rxjava-pull-requests #10;;;;1;1;skip the empty set being emittedthis is unnecessary and unexpected so skipping it;
1665;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;new public api: invocation.getargumentsasmatchers();- new public api: invocation.getargumentsasmatchers()  useful for advanced integrations  such as mockito-scala;;0;abstractpackagesanitytests equals test fails for autovalue classes with set members; for an @﻿autovalue that has a field that is a parameterised set is tested by abstractpackagesanitytests for some types the tests seem to generate incorrect equality groups  for example this class:@﻿autovaluepublic abstract class equalsbreaker {&nbsp&nbspequalsbreaker() {}&nbsp&nbsppublic static equalsbreaker create(set&lthostandport> hosts) {&nbsp&nbsp&nbsp&nbspreturn new autovalue_equalsbreaker(immutablesetcopyof(hosts))&nbsp&nbsp}&nbsp&nbsppublic abstract set&lthostandport> hosts()}leads to a failure like this: caused by: junitframeworkassertionfailederror: comspotifyhermescacheautovalue_cachedresponse([2]) must not be object#equals to comspotifyhermescacheautovalue_cachedresponse(set@1)the following changes make this work as expected:- changing to set&ltstring>- changing to list&lthostandport>i originally had another @﻿autovalue class as set type parameter but changed to hostandport to pick something that was not almost primitive and that i was very sure wouldnt have any issues with its equals methodexplicitly testing the class using equalstester and hand-coded equality groups works as expected so im pretty sure the issue is in how abstractpackagesanitytests generates equality groups for sets; i can easily include this in 17 since i need to pull in a bloomfilter related change to the branch anyway--- ;;;;0;1;;
1665;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;new public api: invocation.getargumentsasmatchers();- new public api: invocation.getargumentsasmatchers()  useful for advanced integrations  such as mockito-scala;;0;add release notes;;use a function reference ;;;;0;1;;
1665;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;new public api: invocation.getargumentsasmatchers();- new public api: invocation.getargumentsasmatchers()  useful for advanced integrations  such as mockito-scala;;0;fix javadoc readme link; gives 404 i presume this should point to http://reactivexio/rxjava/javadoc/;[reactivex » rxjava » rxjava-pull-requests #18  thanks  ||;;;;1;1;fix javadoc readme link;
1665;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;new public api: invocation.getargumentsasmatchers();- new public api: invocation.getargumentsasmatchers()  useful for advanced integrations  such as mockito-scala;;166.0;new public api: invocationgetargumentsasmatchers();- new public api: invocationgetargumentsasmatchers() useful for advanced integrations such as mockito-scala- some internal refactorings that provide temporary help with mockito-scala integration1664; merging 1665 ;unfinishedstubbingexception when thenreturn contains mock which is used in when;hi ive found something strange and would like to ask you to explain what is the reason unfinishedstubbingexception is thrown here? my understanding is that using mock in thenreturn is forbidden when it is a part of when as well but frankly i dont get why :-)```@testpublic void shouldmockmethodbutdoesnot() {    testinterface mock  mockitomock(testinterfaceclass)    when(mockgetobject())thenreturn(mockitomock(objectclass))    when(mockreturnsomething())thenreturn(new testinterfaceuser(mock))}static interface testinterface {    public testinterfaceuser returnsomething()    public object getobject()}static class testinterfaceuser {    object obj    public testinterfaceuser( testinterface t) {        thisobj  tgetobject()    }}```;"if you slightly change your code to the next form:``` java@testpublic void shouldmockmethodbutdoesnot() {    testinterface mock  mockitomock(testinterfaceclass)    when(mockgetobject())thenreturn(mockitomock(objectclass))    testinterfaceuser t  new testinterfaceuser(mock)    when(mockreturnsomething())thenreturn(t)}```it is working correctlyalternatively if you do next thing:``` java@testpublic void shouldmockmethodbutdoesnot() {    testinterface mock  mockitomock(testinterfaceclass)    when(mockgetobject())thenreturn(mockitomock(objectclass))    when(mockreturnsomething())thenreturn(new testinterfaceuser(mock))}static interface testinterface {    public testinterfaceuser returnsomething()    public object getobject()}static class testinterfaceuser {    testinterface obj    public testinterfaceuser( testinterface t) {        thisobj  t    }}```it also behave in expected wayyour problem is connected to the fact that in one place you are trying to register mock behaviour for selected method `when(mockreturnsomething())` - as a result mock is in state for registering answer  and then you are interacting with the same mock by invoking method `getobj()` as a result mock is moved from waiting for answer state to some other one without receiving answeri am not sure whether i explain it to you in enough clear way but i think that you should more or less catch it i think that provided workaround should be sufficient for youas far as i know there is no easy way to handle exactly the same cases described by you (but maybe i am wrong) || thanks alberskib for your reply i know how to build such a workaround :) what is more i was almost sure that ""incorrect state"" is the reason why exception is thrown nothing new for me but the question is if it is a desired behavior or just a bug? in my opinion it is at least weird || > the question is if it is a desired behavior or just a bug?it is really good question but unfortunately i am not able to answer to iti think that @szczepiq or @bric3 will be able to answer it || hi @mplewkafor this kind of code it is expected ie a mock is being used while the other mock is not yet stubbedmock stubbing wasnt really designed to be _intertwined_ things are already complicated but when mocks call another while being stubbed it becomes very difficult to actually detect the correct arguments for the correct call in intertwined mocks i dont remember the details but if we relax this part it may blow in the wrong way for some other casesalso if you want i can give more precise detail on whats really going on in the snippet you provided || ";1;0;improve javadoc with links;
1667;0;0;0;0;0;0;1;1;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;improved ide experience for junit5 - visual comparison failure;when junit5+mockito is used in modern ide (idea  eclipse) we now show  visual  comparison failure pop-up for certain mockito exceptions (such as argumentsaredifferent).;;0;improve the error message thrown from mediatypeparse; when you pass an invalid string to the parse method of mediatype an iae is thrown this exception has no message it would be nice if it at least contained the string you gave it that was invalid better yet would be some indication of why it is incorrectas background we are using mediatype to do content negotiation based on an accept header unfortunately one of our clients was sending an invalid string of the form \* (yes just a *) anyway it was harder than it should have been to track down the issue as there was no indication of what the error was having a more detailed error would certainly have helped; ;;;;0;1;;
1667;0;0;0;0;0;0;1;1;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;improved ide experience for junit5 - visual comparison failure;when junit5+mockito is used in modern ide (idea  eclipse) we now show  visual  comparison failure pop-up for certain mockito exceptions (such as argumentsaredifferent).;;0;add option for double scheduling;allows nodes to be selected multiple times during selection for aparticular stage;maybe `maxtaskspernodeperquery`? || other than the poor config name ;;;;0;1;;
1667;0;0;0;0;0;0;1;1;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;improved ide experience for junit5 - visual comparison failure;when junit5+mockito is used in modern ide (idea  eclipse) we now show  visual  comparison failure pop-up for certain mockito exceptions (such as argumentsaredifferent).;;0;fix the bug that switch doesnt propagate unsubscribe;found in #1666;thank you for jumping on this so quickly  ||;;;;1;1;fix the bug that switch doesnt propagate unsubscribe;
1667;0;0;0;0;0;0;1;1;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;improved ide experience for junit5 - visual comparison failure;when junit5+mockito is used in modern ide (idea  eclipse) we now show  visual  comparison failure pop-up for certain mockito exceptions (such as argumentsaredifferent).;;1663.0;improved ide experience for junit5 - visual comparison failure;"when junit5+mockito is used in modern ide (idea eclipse) we now show ""visual"" comparison failure pop-up for certain mockito exceptions (such as argumentsaredifferent)1663";" merging 1667  as-is || ";improve ide ux comparison failure for junit5;"when junit4 is used and the test is invoked from ide (idea or eclipse) and we are getting ""arguments are different"" mockitoverificationerror the ide gets nice ""click to see the difference"" link in the test failure providing neat comparison pop-upwe want to provide this feature for junit5 too we do not want to add a new dependency on mockito (eg opentest4j) rather we can use reflection just like we do it now for junit4 or how assertj integrates with junit5spin-off from #1656";changing the exception type is an incompatible change in a strict sense however we need to be able to improve the framework by tweaking the exceptions if needed we always strive to be compatible there are no known legit use cases why our users would want to catch & handle specific mockito exceptions its ok to change the type of argumentsaredifferent exception || im happy to take this on per your request the hardest part was the question of whether/how to handle backward compatibility should have a pr submitted by monday || > the hardest part was the question of whether/how to handle backward compatibilitywe are ok with this incompatible change (see my other comment) thanks for taking this on!!! ||;1;0;added support for opentest4js assertionfailederror1663;
1670;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add support for answer6 and voidanswer6;regretfully  i ran into a case where i needed to mock a six-argument method. one can of course claim that such methods _ought not to exist_  but sadly  this is not always the reality and i think that some pragmatism is useful in tools like mockito  so here is my attempt at adding support for it.;;0;add support for answer6 and voidanswer6;regretfully i ran into a case where i needed to mock a six-argument method one can of course claim that such methods _ought not to exist_ but sadly this is not always the reality and i think that some pragmatism is useful in tools like mockito so here is my attempt at adding support for itof course its possible to use the plain `answer` interface in this case but adding a dedicated `answer6` interface makes it more convenient on the user `answer` is a quite raw interface(im not sure if this should target the 2x release or `master` also but feel free to cherry-pick as needed after review/merge);"while we could simply ship this my concerns are mostly ""where do we stop?"" if we ship with 6 arguments we should also ship with 7 there does not seem to be a good reason not tohowever i would prefer to limit to 5 these should cover all common cases if we ship more we are generating more code than is actually useful (and maintainable) it should be quite straightforward to write your own 6-answer or use the lack thereof as an incentive to refactor you code to just use 5 arguments || > while we could simply ship this my concerns are mostly ""where do we stop?"" if we ship with 6 arguments we should also ship with 7 there does not seem to be a good reason not tosure thats a valid concern we have to draw the line somewhere im perfectly fine with that>  it should be quite straightforward to write your own 6-answerthats actually how it started but i thought id go the extra mile and suggest this for inclusion in mockito proper> or use the lack thereof as an incentive to refactor you code to just use 5 argumentsunfortunately not that easy in this case the method in question is an existing interface used for fetching tv recordings for a given customer filtered by a given set of channels a server id (which can be null) a start time and end time and an optional flag determining if the result should be sorted or notin languages like ruby i could easily just add a hash parameter and provide `n` number of (optional) parameters but in java id have to wrap up a ""parameter class"" just for this sake and it feels kind of an overkill design if you ask mesimply put real-world scenarios are not always so easy motivating change in systems simply because ""the tools we use dont support more than 5 arguments"" is perhaps also not so easy either----like you say though we _can_ keep this as a local class in our project but i do think it makes some sense here since other users could find it useful as well i think we could (in mockito) consider expanding the ""5-argument limit"" to 10 in the long run yes methods with 10 arguments are quite absurd but im not sure we will ""win the war"" against bad code simply by being too strict in this area || > thats actually how it started but i thought id go the extra mile and suggest this for inclusion in mockito properthat is much appreciated thanks for opening the discussion!> but in java id have to wrap up a ""parameter class"" just for this sake and it feels kind of an overkill design if you ask methat is inherently subjective i would disagree and regard that as an appropriate solution as a mockito owner we can be selective on the apis we ship while keeping maintainability in mind in this case i dont think adding more convenience answer classes is worth the extra maintenance cost || > while we could simply ship this my concerns are mostly ""where do we stop?"" if we ship with 6 arguments we should also ship with 7 there does not seem to be a good reason not to@timvdlippe youre exactly right that it is really hard to set a limit here! thing is that this code has minimum complexity and is extremely easy to maintain (compiler!) i suggest we keep shipping new ""increments"" so long there are motivated customers that can send us a beautiful well described well tested prs such as this one :) || @mockitoguy thanks much appreciated :) i  the trivial checkstyle problem and rebased on top of latest `release-2x` from the main repo----(btw running checkstyle locally for me fails w/ java 11 it works on java 8 the strange thing is that the travis ci jobs run correctly even on the newer jdk versions so i wonder if theres some special conf going on there to make it work)```$ /gradlew checkstarting a gradle daemon (subsequent builds will be faster)parallel execution is an incubating feature> configure project :  building version 2252 (value loaded from versionproperties file)> task :checkstylemain failedfailure: build failed with an exception* what went wrong:execution failed for task :checkstylemain> unable to create a checker: configlocation {/home/per/git/3rd-party/mockito/config/checkstyle/checkstylexml} classpath {/home/per/git/3rd-party/mockito/build/classes/java/main:/home/per/git/3rd-party/mockito/build/resources/main:/home/per/gradle/caches/modules-2/files-21/netbytebuddy/byte-buddy/197/8fea78fea6449e1738b675cb155ce8422661e237/byte-buddy-197jar:/home/per/gradle/caches/modules-2/files-21/netbytebuddy/byte-buddy-agent/197/8e7d1b599f4943851ffea125fd9780e572727fc0/byte-buddy-agent-197jar:/home/per/gradle/caches/modules-2/files-21/orgobjenesis/objenesis/26/639033469776fd37c08358c6b92a4761feb2af4b/objenesis-26jar:/home/per/gradle/caches/modules-2/files-21/junit/junit/412/2973d150c0dc1fefe998f834810d68f278ea58ec/junit-412jar:/home/per/gradle/caches/modules-2/files-21/orghamcrest/hamcrest-core/13/42a25dc3219429f0e5d060061f71acb49bf010a0/hamcrest-core-13jar}* try:run with --stacktrace option to get the stack trace run with --info or --debug option to get more log output run with --scan to get full insights* get more help at  failed in 5s21 actionable tasks: 1 executed 20 up-to-date``` || @timvdlippe  - thoughts?  ||  merging 1670  ";;;;1;1;add support for answer6 and voidanswer6;
1670;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add support for answer6 and voidanswer6;regretfully  i ran into a case where i needed to mock a six-argument method. one can of course claim that such methods _ought not to exist_  but sadly  this is not always the reality and i think that some pragmatism is useful in tools like mockito  so here is my attempt at adding support for it.;;0;upgrade provisio plugin to 019;;;;;;0;1;;
1670;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;add support for answer6 and voidanswer6;regretfully  i ran into a case where i needed to mock a six-argument method. one can of course claim that such methods _ought not to exist_  but sadly  this is not always the reality and i think that some pragmatism is useful in tools like mockito  so here is my attempt at adding support for it.;;0;feature request: cooldown operator like throttle except latest value is forwarded when delay period ends;"there are some use cases where its useful to know the latest value and okay to miss some intermediate values but you dont want to get swamped for those cases it would be useful to have a ""cooldown"" operator which discarded intermediate values that arrived too soon after a previous value but kept track of the latest value and forwarded it when the cooldown endsfor example suppose you have a ui widget that has a non-negligible redraw cost and you want it to show the latest value with a leeway of 100ms the value is usually stable but there are periods where it is changing tens of thousands of times a second you want to skip some of the intermediate redraws during bursts but need to ensure the latest value is drawn when a stable period sets inyou could use throttle but it can discard the last value before the stable period windowing works but if a single change comes along it adds an unnecessary 100ms delay to the redraw what we want is to have values forwarded immediately unless they come too fast in which case we switch to sampling[heres an example implementation (but against reactivecocoa)](http://stackoverflowcom/a/20669332/52239)";"you might want to check out `debounce(time timeunit)` or `throttlefirst(time timeunit)` || the described use case appears to be exactly what debounce is for  || @strilanc did `debounce` solve your needs?im closing this out because the conversation is stale but reopen if you dont have a solution || it was a suggestion based on a need i had at one point and implemented for myself not one i was waiting on so ""solved"" || ";;;;0;1;;
1672;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;got rid of unused preferences;and marked some which can not be changed from within jabref. -   -  manually tested changed features in running jabref;;0;joinerjoin with skipnulls() gives npe when 3th arg is null;joerile@ consider this scenario:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspsystemoutprintln(joineron(&)skipnulls()join(""one"" null)) // prints ""one""&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspsystemoutprintln(joineron(&)skipnulls()join(""one"" ""two"" ""three"" null)) // prints ""one&two&three""&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspsystemoutprintln(joineron(&)skipnulls()join(""one"" ""two"" null)) // nullpointerexceptionthe last line will result in a nullpointerexception because the 3th argument is interpreted as a varargs list which cannot be null"; ;;;;0;1;;
1672;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;got rid of unused preferences;and marked some which can not be changed from within jabref. -   -  manually tested changed features in running jabref;;0;update 076 release notes;;;;;;0;1;;
1672;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;got rid of unused preferences;and marked some which can not be changed from within jabref. -   -  manually tested changed features in running jabref;;0;merge 0204 fixes;merge fixes from 0204 into 1x;;;;;1;1;make takeuntil obey rx contract;
1672;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;got rid of unused preferences;and marked some which can not be changed from within jabref. -   -  manually tested changed features in running jabref;;1599.0;report initialization failures per test method;prior to this commit `defaultinternalrunner` threw an exception when`mockitoannotationsinitmocks()` failed from the overridden`withbefores` method instead it now returns a `statement` that isresponsible for initializing potential exceptions are then handled byjunit regardless whether version 412 or 413-beta-2 is used insteadof reporting a class-level error junit will now report a failure foreach test method in such test classesrelated issue: junit-team/junit4#1599 -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_; merging 1672 ;master;;this should not be ;1;0;report initialization failures per test methodprior to this commit `defaultinternalrunner` threw an exception when`mockitoannotationsinitmocks()` failed from the overridden`withbefores` method instead it now returns a `statement` that isresponsible for initializing potential exceptions are then handled byjunit regardless whether version 412 or 413-beta-2 is used insteadof reporting a class-level error junit will now report a failure foreach test method in such test classesrelated issue: junit-team/junit4#1599;
1680;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix handling of generic void type for donothing();when the return type bound to a generic type resolved to void;;0;cachebuilder#removallistener(removallistener) lacks information about deferred invoking removallistener; [ in this stackoverflow question] user pointed out that removallistener isnt called on removal entry that behavior is not explicitely documented as cachebuilder#removallistener(removallistener) documentation says:> specifies a listener instance that caches should notify each time an entry> is removed for any reason each cache created by _this builder will invoke> this listener as part of the routine maintenance described in the class> documentation above_the ""documentation above"" says:> caches built with cachebuilder do not perform cleanup and evict values> ""automatically"" or instantly after a value expires or anything of the sort> instead it performs small amounts of maintenance during write operations> _or during occasional read operations if writes are rare_i think user can expect removallistener to be called on actual removalinternally the cleanup is (not) made by postreadcleanup():```/** * performs routine cleanup following a read normally cleanup happens during writes if cleanup * is not observed after a sufficient number of reads try cleaning up from the read thread */void postreadcleanup() {  if ((readcountincrementandget() & drain_threshold)  0) {    cleanup()  }}```so ""occasionally"" means every 64 reads if no write or cleanup occured meanwhile this is some kind of optimization so id like to request either:&nbsp\- adding a clarification in cachebuilder#removallistener(removallistener)&nbsp\- changing postreadcleanup() to just do cleanup() (it should probably be benchmarked)&nbsp\- adding something like cachebuilder#donotdeferremovallistener() which would bypass drain_threshold check in postreadcleanup()ive checked loadingcache tests and it looks like the third option (which is a win-win imo) would not break any tests while second option breaks testdrainrecencyqueueon{readwrite}"; after checking the example and reading source and docs again it seems that its a documented behavior and changes in code i proposed wouldnt be suitable for guavas (loading)cache not-heavyweight designhowever phrase ""specifies a listener instance that caches should notify _each time an entry is removed_ for any reason"" isnt 100% accurate to me because notification doesnt occur _at once_ but as part of ""routine described in docs"" so whole sentence should be imo rephrased i dont know if you feel the same - if not dont hesitate to close this issue || i think this is wai i believe it is accurate that the removal listener is called _when the entry is removed_ its just that ""when the entry is removed"" is not necessarily ""as soon as the entry expires"" because thats not how `cache` works || ";;;;0;1;;
1680;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix handling of generic void type for donothing();when the return type bound to a generic type resolved to void;;0;fix handling of generic void type for donothing();when the return type bound to a generic type resolved to void`donothing()` would still throw an exception update the `isvoid`implementation to also handle generic return types; merging 1680  < ;;;;1;1;fix handling of generic void type for donothing()when the return type bound to a generic type resolved to void`donothing()` would still throw an exception update the `isvoid`implementation to also handle generic return types;
1680;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix handling of generic void type for donothing();when the return type bound to a generic type resolved to void;;0;remove unused methods on page;;superseded by #1685 ||;;;;0;1;;
1680;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix handling of generic void type for donothing();when the return type bound to a generic type resolved to void;;0;observeon schedules onerror  should it jump the line?;"onerror events are put on the queue so they get emitted on the scheduled thread  but they are at the end of the onnext events should they instead ""jump the line""?i think yes as an `onerror` is supposed to act like throwing an exception which unravels the stack immediately and discards all state including data in queuesthis is based on rx design guideline 66:> 66 onerror messages should have abort semantics> as normal control flow in net uses abort semantics for exceptions (the stack is unwound current code path is interrupted) rx mimics this behavior to ensure this behavior no messages should be sent out by an operator once one of it sources has an error message or an exception is thrown within the operator";"involving @headinthebox and @mattpodwysocki so we can verify what this behavior should bethe design guidelines are not clear enough to make a decision as to how this should behaveconsider this use case:``` javasourcemap(t -> r)observeon(s)map(t -> slowr)subscribe(o)```- source observable emits infinite stream of ints- after 1000 are emitted an error occurs in a mid-stream operator before observeon- the error is caught and propagated via `onerror`- the map after observeon is slow- currently all 1000 items are processed in queue and then onerror is propagatedshould the onerror ""cut the line"" as soon as it happens or should it wait?in this example it can take a long time to get through the queue due to the slow map function after the observeon || verified that in net `onerror` does not cut the line but  i do think it makes sense to ""follow the design guidelines"" and for the delayed error behavior add an overload `observeondelayerror` (since you may want to receive all values at the other end of the `observeon` || thanks for the confirmation ill proceed with this change || ";;;;0;1;;
1690;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;add errorprone mockitointernalusage checker;this checker will warn on any usage of a mockito internal symbol. since;;0;add errorprone mockitointernalusage checker;this checker will warn on any usage of a mockito internal symbol sincewe do not guarantee api stability on symbols in our internal packagesusers should not rely on them this checker can be used to enforce thatthey are unused;i will merge this after #1693 ||  merging 1690 ;;;;1;1;make mockitointernalusage service-loadable;
1690;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;add errorprone mockitointernalusage checker;this checker will warn on any usage of a mockito internal symbol. since;;0;fix hivestorage-format;@electrum this will fix the broken hivestorage-format;this looks good but we need a test that verifies we can read and write each format || @electrum thanks get it i will rebase and add a testcase || @electrum do you know how to run a single testcase in presto?i am trying to run testhiveclient#testtablecreation while kept getting:parameter hivehadoop1metastorehost is required by @configuration on method setup but has not been marked @optional or defined```at orgtestnginternalparameterscreateparameters(parametersjava:155)at orgtestnginternalparameterscreateparameters(parametersjava:358)at orgtestnginternalparameterscreateconfigurationparameters(parametersjava:86)at orgtestnginternalinvokerinvokeconfigurations(invokerjava:199)at orgtestnginternalinvokerinvokeconfigurations(invokerjava:138)at orgtestnginternaltestmethodworkerinvokebeforeclassmethods(testmethodworkerjava:175)at orgtestnginternaltestmethodworkerrun(testmethodworkerjava:107)at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1145)at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:615)at javalangthreadrun(threadjava:744)```results :failed tests:   » testngparameter hivehadoop1metastorehost is required by @configuratiotests run: 2 failures: 1 errors: 0 skipped: 1 || you can pass them as -d arguments to maven or add them in the parameters section in the testng run configuration in intellij || @electrum get it  @electrum updated add testcases in abstracttesthiveclient#testtablecreation || assigning to @dain hell take a look at the comments || @electrum @dain thanks for the review get the comments addressed except for the testcase || i think the only sane way to test this is to add support for connectorsession properties  im working on adding this feature and will fixup and merge this pr when the connectorsession properties feature lands || superseded by #1769  ||;;;;0;1;;
1690;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;add errorprone mockitointernalusage checker;this checker will warn on any usage of a mockito internal symbol. since;;0;cross build a scala 211 version;how bout publishing a 211 version of rxscala?  im looking ahead to updating one of my projects that uses rx to scala 211 one of these days;rxscala build discussions can now be had in the top-level rxscala project:  as duplicate of  ||;;;;0;1;;
1693;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;removed (false) npe issue reported by findbugs;findbugs reported a potential npe here  which never occurred since it would only happen if  model.getsearchstate() == maintabledatamodel.displayoption.disabled . as this is checked for in the first part of the if-clause  i removed the second check.  so this shouldn t affect any perfomance since  matches  will only be triggered under the same conditions as before.  nothing in changelog since the npe couldn t actually happen. -  manually tested changed features in running jabref;;0;baseencoding#decode illegalargumentexception leaks the use of guava; the illegalargumentexception thrown by baseencoding#decode is constructed with the decodeexceptions tostring so it contains the decodeexceptions fqcn as such when the input comes from the a third party illegalargumentexception#getmessage cannot be safely used to tell the sender whats wrong with its inputsee  example:&nbspbaseencodingbase64()decode(""€""getbytes(standardcharsetsutf_8))will throw an illegalargumentexception whose detail message is:&nbspcomgooglecommoniobaseencoding$decodingexception: unrecognized character: €instead of just:&nbspunrecognized character: €workaround: use iaegetcause()getmessage() instead of iaegetmessage() or just a static ""malformed input"" messagesuggested fix: use&nbspnew illegalargumentexception(egetmessage() e)instead of&nbspnew illegalargumentexception(e)"; in my specific case i was implementing  basic auth```string credentialstry {  charsetdecoder charsetdecoder  standardcharsetsutf_8newdecoder()  credentials  charsetdecoderdecode(bytebufferwrap(baseencodingbase64()decode(partsget(1))))tostring()} catch (charactercodingexception | illegalargumentexception e) {  malformedcredentials(requestcontext)  return}```long story short: i originally forgot to catch illegalargumentexception which resulted in a 500 internal server error when revisiting the code to add the iae i thought i could possibly send the egetmessage() to the user to he knows whats wrong rather than the static ""malformed credentials"" message i current send and stumbled on this strange behaviori can very well live with the current situation (and a static error message) but thought i should probably report it anyway it probably wasnt the expected behavior so feel free to close the issue if you think its not worth it || ";;;;0;1;;
1693;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;removed (false) npe issue reported by findbugs;findbugs reported a potential npe here  which never occurred since it would only happen if  model.getsearchstate() == maintabledatamodel.displayoption.disabled . as this is checked for in the first part of the if-clause  i removed the second check.  so this shouldn t affect any perfomance since  matches  will only be triggered under the same conditions as before.  nothing in changelog since the npe couldn t actually happen. -  manually tested changed features in running jabref;;0;remove duplicate dependency in presto-hive;;;;;;0;1;;
1693;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;removed (false) npe issue reported by findbugs;findbugs reported a potential npe here  which never occurred since it would only happen if  model.getsearchstate() == maintabledatamodel.displayoption.disabled . as this is checked for in the first part of the if-clause  i removed the second check.  so this shouldn t affect any perfomance since  matches  will only be triggered under the same conditions as before.  nothing in changelog since the npe couldn t actually happen. -  manually tested changed features in running jabref;;0;registering my own scheduler in 0204;in 0204 `rxjavadefaultschedulers` is deprecated  what am i supposed to use instead?  `parallel` uses `schedulerscomputation()`  which is set to `rxjavapluginsgetinstance()getdefaultschedulers()getcomputationscheduler()`i might be missing something but i dont see the alternative to setting an `rxjavadefaultschedulers`;instantiate a sub-class to `rxjavaschedulershook` where you override `getcomputationscheduler()` and use `rxjavapluginsgetinstance()registerschedulershook` to register your scheduler hook instance before using doing any observable calls || i tried this already but it did not work  when using `observable#parallel` it uses `schedulers#computation` which doesnt use `schedulers#getschedulershook` but `schedulers#getdefaultschedulers` || ah i was under the impression `rxjavaschedulershook` was hooked into the schedulers overrides when it was added in _020x_ but it seems it was not actually done until the _1x_ branch was created sorry about that so for _020x_ you need to use `rxjavadefaultschedulers` but 1x and forward will work with what i wrote || ok cool  im not going mad then :) ||;;;;0;1;;
1693;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;removed (false) npe issue reported by findbugs;findbugs reported a potential npe here  which never occurred since it would only happen if  model.getsearchstate() == maintabledatamodel.displayoption.disabled . as this is checked for in the first part of the if-clause  i removed the second check.  so this shouldn t affect any perfomance since  matches  will only be triggered under the same conditions as before.  nothing in changelog since the npe couldn t actually happen. -  manually tested changed features in running jabref;;1692.0;make `mockitonotextensible` service-loadable;this way error prone can find the plugin when `mockito-errorprone` is added to the annotation processor classpath1692;"nb: in this pr i chose to use [google autoservice]( as is customary for error prone plugins if preferred i can instead introduce an explicit ` meta-inf/services/comgoogleerrorpronebugpatternsbugchecker` file || @timvdlippe sure! will have a look at whats the simplest way to achieve this ||   @stephan202 were you able to take a look at this? i wanted to fix the same in #1690 || @timvdlippe i considered several approaches and concluded that the best way forward would be to see whether/how support for this kind of ""real""/""full"" test can be added to error prones `compilationtesthelper` and `bugcheckerrefactoringtesthelper` classes the idea would be that they get another static factory method which relies on service loading rather than an explicitly provided checker class this would also benefit other non-google ep users such as @ubers [nullaway]( then ""life happened"" so i didnt yet get to the point of actually trying that implementation note that even if it would work this pr would be blocked on those changes getting merged and released as part of error prone (but i assume you could help getting the changes reviewed by the ep team)so that leaves the question of timelines i can try (but wont commit) to spend some time on this later this week likely in the weekend alternatively if you agree with the suggested solution you could have a crack at an error prone pr and id be happy to be the first reviewerwrt whether this pr should be blocked on all that: i have manually tested the changes in this pr so functionally we could just merge this for now the approach taken here is [exactly]( what nullaway does (but ""just merging"" is not in the spirit of the mockito project so i totally undestand not wanting to go that route)  || lets merge it for now and hope we dont regress in the future || ";the new error prone plugin isnt service-loadable;the `mockitonotextensible` plugin added in #1669 is pretty cool however when `mockito-errorprone` is added to the annotation processor classpath error prone does not recognize/find the plugin this is because `mockitonotextensible` is not declared in a `meta-inf/services/comgoogleerrorpronebugpatternsbugchecker` file on the classpath;;1;0;make `mockitonotextensible` service-loadablethis way error prone can find the plugin when `mockito-errorprone` is added tothe annotation processor classpath1692;
1695;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;injected layoutformatterpreferences in exportformat;and removed the need for the static variable  customexportnameformatters  in  jabrefpreferences .  ~~still  savepreferences  to inject and remove the reference for resource loading to~~ completely get rid of  globals .;;0;create overloaded operations for sortedmultiset; in order to do the sum/union of two sortedmultiset (or any other set operation) i can write:sortedmultiset&ltinteger> set1  immutablesortedmultisetof(1 2 2 3 3 3)sortedmultiset&ltinteger> set2  immutablesortedmultisetof(1 1 2 4)sortedmultiset&ltinteger> sum  immutablesortedmultisetcopyof(multisetssum(set1 set2))and similarly for the other methods (union intersection difference etc)it shouldnt be too difficult to add convenience methods to perform these operations (possibly using views instead of copying the whole collection) they might probably have to live in their own convenience class say sortedmultisets; the user shouldnt need to force anything as long as the types of the two arguments to the method are both sortedmultiset (or a subtype of it) the overload that takes two sortedmultisets will be selected as the most specific overload by the compiler || internally there arent any usages of `multisetssum` with `sortedmultisets` so were inclined to close this however if you feel strongly please re-open ||;;;;0;1;;
1695;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;injected layoutformatterpreferences in exportformat;and removed the need for the static variable  customexportnameformatters  in  jabrefpreferences .  ~~still  savepreferences  to inject and remove the reference for resource loading to~~ completely get rid of  globals .;;0;fix javadoc typo and use html list;"the javadoc for `invocationonmockgetargument(int index class<t> clazz)` had two typos:- ""to directly **pas** the result""- ""**clazz** to cast the argument to""additionally i changed the list to be a proper html list the current version just collapsed it into one text block:  might also be worth it adding the actual html paragraphs into the javadoc (for the other methods as well)";travis is failing on unrelated issues will take a look next week ||  merging 1695 ;;;;1;1;fix javadoc typo and use html list;
1695;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;injected layoutformatterpreferences in exportformat;and removed the need for the static variable  customexportnameformatters  in  jabrefpreferences .  ~~still  savepreferences  to inject and remove the reference for resource loading to~~ completely get rid of  globals .;;0;change output buffers to use task ids;;;;;;0;1;;
1695;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;injected layoutformatterpreferences in exportformat;and removed the need for the static variable  customexportnameformatters  in  jabrefpreferences .  ~~still  savepreferences  to inject and remove the reference for resource loading to~~ completely get rid of  globals .;;1688.0;rewrite onsubscriberefcount to handle synchronous source;resubmitting this one having stuffed up the rebaserewrite of `onsubscriberefcount` because original didnt handle synchronous source (#1688) and as far as i could see the original was fundamentally broken by this use case please note also includes a fix in `operatormulticast` where a null check was required ive done the rewrite using locks rather than submit a lock-free version just to ensure that the approach is valid with the experts first;would appreciate review of latest commit which incorporates @zsxwing suggestions || righto over to you concurrency switched on people again im not convinced that given the holes that @akarnokd pointed out that a dual lock arrangement is going to work so ive wound back to using a single lock for all subscriptions and disconnect  || i dont quite understand these changes yet partly im confused because the newly added unit tests pass even if the code changes arent applied  || spent time reviewing this again and i think its good so mergingthanks @davidmoten for the fix and @zsxwing and @akarnokd for the reviewsi considered alternatives to the single-lock approach but am not confident enough in any of them to attempt right now correctness first we can attempt enhancements later  ||;refcount unsubscribe never happens for infinite synchronous source;given `opublish()refcount()` on an infinite synchronous source `o` [line 93]( in `onsubscriberefcount` never completes thus `emitting` is never false and disconnect cannot happenheres a unit test failing on 0204:``` javapackage augovamsaaisrximport static orgjunitassertasserttrueimport javautilconcurrentcountdownlatchimport javautilconcurrenttimeunitimport orgjunittestimport rxobservableimport rxobservableonsubscribeimport rxobservableoperatorimport rxsubscriberimport rxobserverssubscribersimport rxschedulersschedulerspublic class refcounttest {    @test(timeout3000)    public void testrefcountunsubscribeforsynchronoussource() throws interruptedexception {        final countdownlatch latch  new countdownlatch(1)        observable<long> o  synchronousinterval()lift(detectunsubscription(latch))        subscriber<long> sub  subscribersempty()        opublish()refcount()subscribeon(schedulerscomputation())subscribe(sub)        subunsubscribe()        asserttrue(latchawait(3 timeunitseconds))    }    private operator<long long> detectunsubscription(final countdownlatch latch) {        return new operator<longlong>(){            @override            public subscriber<? super long> call(subscriber<? super long> subscriber) {                latchcountdown()                return subscribersfrom(subscriber)            }}    }    private observable<long> synchronousinterval() {        return observablecreate(new onsubscribe<long>() {            @override            public void call(subscriber<? super long> subscriber) {                while (!subscriberisunsubscribed()) {                    try {                        threadsleep(100)                    } catch (interruptedexception e) {                    }                    subscriberonnext(1l)                }            }})    }}```;i think i see what to do to fix ill make a pr if someone is already working on it let me know and ill stop || pull request is ;1;0;synchronize access to subscription for null check in operatormulticast;
1698;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix clonesarguments for null and arrays;the clonesarguments class works for many cases  but fails when trying to clone an argument that is an array  or is null. this pr fixes those edge cases. this does not directly resolve any open issue  but it is related to #1153  #1469;;0;regularcontiguoussetcontains() may throw nullpointerexception; the method contains() in comgooglecommoncollectrange contains a call to preconditionschecknotnull() for the formal parameter:&nbsp&nbsppublic boolean contains(c value) { &nbsp&nbsp&nbsp&nbspchecknotnull(value)&nbsp&nbsp&nbsp&nbsp// let this throw cce if there is some trickery going on&nbsp&nbsp&nbsp&nbspreturn lowerboundislessthan(value) && !upperboundislessthan(value)&nbsp&nbsp}that is this method will throw a nullpointerexception if value is nullthe method contains() in comgooglecommoncollectregularcontiguousset is implemented using rangecontains():&nbsp&nbsp@﻿override public boolean contains(object object) {&nbsp&nbsp&nbsp&nbsptry {&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn rangecontains((c) object)&nbsp&nbsp&nbsp&nbsp} catch (classcastexception e) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn false&nbsp&nbsp&nbsp&nbsp}&nbsp&nbsp}there is no null check here so if regularcontiguoussetcontains() is called with a null value it will pass that value to rangecontains() and a nullpointerexception will result  this is erroneous because regularcontiguoussetcontains() overrides immutablecollectioncontains() whose ""object"" parameter is explicitly annotated as @﻿nullable  that is the method should be able to handle a test against null:&nbsp&nbsp@﻿override&nbsp&nbsppublic boolean contains(@﻿nullable object object) {&nbsp&nbsp&nbsp&nbspreturn object ! null && iteratorscontains(iterator() object)&nbsp&nbsp}regularcontiguoussetcontains() should be  to check for null:&nbsp@﻿override public boolean contains(object object) {&nbsp&nbsp&nbsp&nbsptry {&nbsp&nbsp&nbsp&nbsp&nbsp&nbspif (object  null) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn false&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp} else {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn rangecontains((c) object)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp}&nbsp&nbsp&nbsp&nbsp} catch (classcastexception e) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbspreturn false&nbsp&nbsp&nbsp&nbsp}&nbsp&nbsp}"; glad to know it was   i saw this error in the guava source currently embedded in the android project ||;;;;0;1;;
1698;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix clonesarguments for null and arrays;the clonesarguments class works for many cases  but fails when trying to clone an argument that is an array  or is null. this pr fixes those edge cases. this does not directly resolve any open issue  but it is related to #1153  #1469;;0;fix clonesarguments for null and arrays;the clonesarguments class works for many cases but fails when trying to clone an argument that is an array or is null this pr fixes those edge cases this does not directly resolve any open issue but it is related to #1153 #1469check list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_;@timvdlippe i believe i have the right branch this time please review ||  merging 1698 ;;;;1;1;added separate test;
1698;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix clonesarguments for null and arrays;the clonesarguments class works for many cases  but fails when trying to clone an argument that is an array  or is null. this pr fixes those edge cases. this does not directly resolve any open issue  but it is related to #1153  #1469;;0;fix race condition when updating sources;the current implementation has a potential race condition under the following scenario:```task updater              driver                          acquire lock                          process new sources                                                    process new sources in lock release codeadd new sourcefail to acquire lock (sources not processed)                          release lock```this results in new sources not being processed and the query getting stuckif the task updater never call update sources again and the driver becomesblocked because data from all current exchanges are consumed;;;;;0;1;;
1698;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix clonesarguments for null and arrays;the clonesarguments class works for many cases  but fails when trying to clone an argument that is an array  or is null. this pr fixes those edge cases. this does not directly resolve any open issue  but it is related to #1153  #1469;;0;validate join/groupjoin signatures;the join and groupjoin operators are not battle-tested and im not convinced they are correct we already have split out most of the join functionality into  plan to deprecate these in 020x and remove them in 10 this functionality can mature in rxjavajoins and can return to rxjava core libs if deemed worthy in the future;nevermind  i have no idea what im talking about discussing with @headinthebox he clarified these are _not_ related to rxjavajoins despite the namesi still am not convinced that they are 100% ready   || assigning to @headinthebox to ensure the type signatures are correct || signatures confirmed changes merged and released ||;;;;0;1;;
1701;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;show multiple invocations on argumentsaredifferent;this is the reconciliation of #1556 with the tests fixed and implementation rebased on  release/2.x .;;0;fix the compose generics;;thank you @zsxwing  i guess one of @headinthebox or i owes you a drink! now to figure out how to get to you in china || buy one when you get a chance to visit china or when i visit bay area :) || sounds good id love to get to china at some pointthanks again ||;;;;1;1;fix the compose generics in rxscala;
1701;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;show multiple invocations on argumentsaredifferent;this is the reconciliation of #1556 with the tests fixed and implementation rebased on  release/2.x .;;1556.0;show multiple invocations on argumentsaredifferent;this is the reconciliation of #1556 with the tests  and implementation rebased on `release/2x`1542;;fixes issue #1542: when verify fails show all method invocations;"this pr fixes issue #1542 (when mock is called multiple times and verify fails the error message reports only the first invocation) from the issue the idea is that showing all invocation would make it easier to see why something failedi have changed the behavior of the exception thrown and its message now contains all method invocations instead of only the first onenew format: ```argument(s) are different! wanted:examplebuilderwith(""key1"" ""wrongvalue"")-> at orgmockitousageverificationverifyprintsallinvocationsonerrortestshouldprintallinvocationsonerror(verifyprintsallinvocationsonerrortestjava:23)actual invocations have different arguments:examplebuilderwith(""key1"" ""val1"")-> at orgmockitousageverificationverifyprintsallinvocationsonerrortestshouldprintallinvocationsonerror(verifyprintsallinvocationsonerrortestjava:20)examplebuilderwith(""key2"" ""val2"")-> at orgmockitousageverificationverifyprintsallinvocationsonerrortestshouldprintallinvocationsonerror(verifyprintsallinvocationsonerrortestjava:21)```";working on fixing the failing tests ||  merging 1556 ;1;0;polish implementation and fix verifyprintsallinvocationsonerrortest;
1701;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;show multiple invocations on argumentsaredifferent;this is the reconciliation of #1556 with the tests fixed and implementation rebased on  release/2.x .;;1542.0;show multiple invocations on argumentsaredifferent;this is the reconciliation of #1556 with the tests  and implementation rebased on `release/2x`1542;;when mock is called multiple times and verify fails the error message reports only the first invocation;"as a diligent devi want to verify that a mock will eventually get called with the specified parametersso that i can properly test my builder classscenarioi have a builder class exposing a with(string key string value) methodi created a test for testing that at a certain point the method gets called with foo valuefooid like to follow a test pattern where 1 test case has only 1 assertion```buildermockwith(barvaluebar)buildermockwith(foonotvaluefoo)verify(buildermock)with(foovaluefoo)```whats wrongverify reports only the first invocation in the test failed logs```arguments are different! wanted: buildermockwith(foovaluefoo)at actual invocation has different arguments:buildermockwith(barvaluebar)at ``` imo should be a list of invocation for that methods something like:```// actual invocations have different arguments:// buildermockwith(barvaluebar)// at // buildermockwith(foonotvaluefoo)// at ```notefor anybody else having this problem im rethrowing the exception raised with something like this:```    public static argumentsaredifferent createexceptionwithenhancedverifylogsfor(            object mockedobject            string invokedmethod            argumentsaredifferent ex    ) {        string newline  systemgetproperty(""lineseparator"")        string wanted  exgetexpected()        string actualtitle  messageformatformat(                ""interactions of {0}{1}():""                mockedobjectgetclass()getcanonicalname() invokedmethod        )        string actual  mockingdetails(mockedobject)getinvocations()stream()                filter(invocation -> invocationgetmethod()getname()equals(invokedmethod))                map(object::tostring)                collect(collectorsjoining( newline ))        string message  stringjoin(newline                exgetclass()getcanonicalname()                ""wanted: "" + wanted                actualtitle actual        )        argumentsaredifferent enhancedex  new argumentsaredifferent(message wanted actual)        enhancedexsetstacktrace(exgetstacktrace())        return enhancedex    }```";nice report thank you! do you want to take a stub at fixing it? i suspect that we need to tweak the reporting so that we print other interactions too we do something like that for regular verification failures (as opposed to verification failures due to mismatched arguments) || i can try and take a look at this || hi @mockitoguysorry my email is bleeding with spam and ive been caught up with some deadlinesit would be an interesting piece of work that id like to take but i dont have the time right now forits going into my todo list though || just started working on this today doesnt seem like too bad of a change i should have something to show later today or tomorrow ||;1;0;polish implementation and fix verifyprintsallinvocationsonerrortest;
1701;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;show multiple invocations on argumentsaredifferent;this is the reconciliation of #1556 with the tests fixed and implementation rebased on  release/2.x .;;0;hive 13 changes;;back to you for comments id like to see the lazy block part again || @cberner can you take a look at the lazy code again? || @cberner can you take one last look at the lazy block change? || ;;;;0;1;;
1701;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;show multiple invocations on argumentsaredifferent;this is the reconciliation of #1556 with the tests fixed and implementation rebased on  release/2.x .;;0;preconditionsformat possible nullpointerexception;soe@ within preconditionsjava you defined ""args"" as nullable but in line 416 (new stringbuilder(templatelength() + 16 \* argslength)) a nullpointerexception can be thrown!i would expect at least the nullable-annotation should be removed (even for the calling methods like checknotnull) or it should be null-safe"; to be honest there is no real code error-szenario it was just popping up during some tests and i was wondering that creation of error-message causes an error that was more or less unexpected || i believe this is no longer the case as of the time of comment  already handles null can any maintainer close this issue? || yes thanks we decided to be permissive here ||;;;;0;1;;
1706;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;get rid of npe on travis;travis uses jdk 1.8.0_101  whereas circleci uses 1.8.0_40.  current state: there are no protected terms loaded any more. i don t know  why.;;0;setsnewlinkedhashset(e elements) helper method; it would be good to add a vararg helper method for creating linkedhashset&lte> similar to the one that already exists for hashset&lte>; i hadnt thought of immutableset thanks kevinb ||;;;;0;1;;
1706;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;get rid of npe on travis;travis uses jdk 1.8.0_101  whereas circleci uses 1.8.0_40.  current state: there are no protected terms loaded any more. i don t know  why.;;0;fix a typo;thanks for the contribution this is awesome> as you may have read project members have somehow an opinionated view on what and how should be> mockito eg we dont want mockito to be a feature bloat> there may be a thorough review with feedback -> code change loop> > which branch : > - on mockito 2x make your pull request target `release/2x`> - on next mockito version make your pull request target `master`check list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_; ;;;;1;1;fix a typo;
1706;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;get rid of npe on travis;travis uses jdk 1.8.0_101  whereas circleci uses 1.8.0_40.  current state: there are no protected terms loaded any more. i don t know  why.;;0;handle the response of the initial  request in the statementclient;an attempt to 1402;an issue here is what happens if the original query was actually successful but the client failed to receive the response this is fine for `select` queries that dont modify data (they just run for a while and consume resources) but a `create table` could result in the second failing because the table already exists (would be confusing) and for `insert` would result in duplicate datathis could be solvable with some protocol changes for a single coordinator but for multiple coordinators would require global locking / transactions || yes this is a problem and seems like the ultimate solution is a change in the protocoldoes this problem also exist in the current master as `advance()` already does retries ( || no the data retrieval protocol is designed to allow retries ||;;;;0;1;;
1706;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;get rid of npe on travis;travis uses jdk 1.8.0_101  whereas circleci uses 1.8.0_40.  current state: there are no protected terms loaded any more. i don t know  why.;;0;add deploy dates into changesmd; really like [this format]( the date a change was deployed will make it easier to tell what is brand new and what is olderit will also point out that the library is being updated often (or not);every release is also listed at  with dates tags commits etc the changesmd file is mostly just a backup in case github ever screws up the releases feature!if you want to go back through the 106 releases and add dates id be happy to merge the change :-) || i can start adding dates going forward   ||;;;;0;1;;
1708;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1623 : rename toolittleactualinvocations;rename the exception toolittleactualinvocations to;;0;more convenience methods for maps sortedmap please!; would it make sense to have static convenience methods such as:public static &ltkv> immutablemap&ltkv> sum(map&ltkv> x map&ltkv> y){  }public static &ltkv> immutablesortedmap&ltkv> sum(sortedmap&ltkv> x sortedmap&ltkv> y){  }public static &ltkv> immutablesortedmap&ltkv> sum(map&ltkv> x map&ltkv> y){  }in immutablemap and immutablesortedmap?right now i have to do the following:immutablemap&ltkv>builder()addall(x)addall(y)build()immutablesortedmap&ltkv>naturalorder()addall(x)addall(y)build()which is not too bad actually but i assume having a static method might allow for some optimization (views etc)thoughts?; the code that uses the builder throws eagerly if the keys overlap but view methods should return in constant time: it could only throw lazily when it discovers after the fact that the keys overlapor it could use some other kind of merging behavior || the workaround given in the op seems reasonable and theres really no good way to do a view ||;;;;0;1;;
1708;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1623 : rename toolittleactualinvocations;rename the exception toolittleactualinvocations to;;0;fix hidden flag for kafka getcolumnmetadata;;looks good even though i am not sure whether this is not just a change for changes sake ||;;;;0;1;;
1708;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1623 : rename toolittleactualinvocations;rename the exception toolittleactualinvocations to;;0;possibly incorrect semantics in abstractschedulerteststestmixofdelayedandnondelayedactions;when building rxquasar on travis the `testmixofdelayedandnondelayedactions` sometimes fails on [this line]( reason is that the `first` and `forth` action are tested in order while the `testsequenceofactions` test specifically says that order of execution should not be guaranteed by schedulers;pstravis is great for uncovering concurrency issues as their thread scheduling is so out of whack (i have no idea how they manage this) :) || does this test still fail for you? || closing due to inactivity if you encounter the issue again feel free to reopen this issue or submit a separate one || hi sorry for not responding sooner -- i thought this required checking the tests again and i didnt have the time but now i see that the test hasnt been changed right? if so then it is still wrong: the test doesnt test the spec as the test verifies in-order execution when the spec specifically says ordering is not required || it seems to me that `testsequenceofactions` was created before we moved to a more strict scheduling where the `schedulerworker` guarantees ordered execution and generally if you are using rxjavas built-in schedulers they are based upon the javas scheduledexecutorservice which also keeps things [fifo]( scheduled for the same time || thats impossible no multithreaded scheduler (even one starting tasks in fifo order) can guarantee the completion of `first` before that of `fourth` neither should it only a serial scheduler can guarantee that  || rxjavas workers are single-threaded || it may be that rxjavas built-in schedulers happen to be single threaded but this test _requires_ any rx scheduler to be single threaded is that a requirement you wish to make (because its not necessitated by any other test)?the requirement means that two tasks issued to a scheduler on _two different threads_ are guaranteed to _complete_ in the order theyve been submitted (which is completely arbitrary) im not familiar with any such guarantees in concurrent systems usually the strongest requirement (which isnt always necessary either) is that of linearalizability namely that any two events will always be observed to happen in the same order to all observersrequiring rx schedulers to be single threaded is both limiting and unnecessary (what does it buy?) yet you have this test that _will fail_ for multithreaded schedulers  || the [documentation]( on the `worker` specifies it must be sequential and the built-in schedulers have an extra guarantee of no thread hopping since observables are required to be sequential themselves observing them on a scheduler maintains this order without extra effort and no complex logic is necessary the requirement is to be sequential not that it must be single threaded for example the `executorsfrom` allows you to wrap an arbitrary `executor` and makes sure that tasks are kept in fifo order and are executed sequentially but it cant prevent thread hopping> the requirement means that two tasks issued to a scheduler on two different threads are guaranteed to complete in the order theyve been submittedwhy would you submit them to different threads?> requiring rx schedulers to be single threaded is both limitingin what way?> unnecessary (what does it buy?)sequential guarantees across rxjava make it simpler to implement and reason about since no one needs to defensively serialize its inputs or make its internal state thread-safe all the time saving enormous sequential performance> yet you have this test that will fail for multithreaded schedulersthose schedulers dont conform the required contract of rxjava if it happens under quasar then id say its a bug either in quasar itself or in rxquasars scheduler implementation ([looks like]( the implementation still uses some old and racy code) || oh! youve changed the semantics of a scheduler and introduced the `worker` abstraction! i see i had totally missed that and then went to see how come rxquasar even compiles and noticed that ben had made some changes but not quite the right ones :) instead of assigning a fiber per `worker` every action gets a new fiber (as it used to be before the introduction of workers) alright then ill make the fiber scheduler use sequential workers sorry for the mixupsee reactivex/rxquasar#4 || no problem the `eventloopsscheduler` [should give]( you a hint how to do it well || sorry for not fixing it correctly! ||;;;;0;1;;
1708;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1623 : rename toolittleactualinvocations;rename the exception toolittleactualinvocations to;;1623.0;1623 : rename toolittleactualinvocations;rename the exception toolittleactualinvocations totoofewactualinvocations as this is more correct english as thisexception is public api we rename by subclassing and deprecating theoriginal rename all tests and internal methods that were referencingthe old name by aligning with the new namecheck list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_; merging 1708  < ;consider renaming toolittleactualinvocations;"i agree with the commenter [here]( that the exception name `toolittleactualinvocations` is not idealthe correct english would be `toofewactualinvocations` (where ""few"" is the opposite of ""many"" - as used in `toomanyactualinvocations`)i appreciate this isnt the most critical issue ever raised but it would make this assertion failure more readable!as the existing class is non-final i imagine it could be changed without breaking existing client code via subclassing and deprecating the original please let me know if it would be helpful for me to pick this up (or instead if the change wouldnt be desirable or im otherwise missing something)thanks";i would welcome a pr for this    ||;1;0;1623 : rename toolittleactualinvocationsrename the exception toolittleactualinvocations totoofewactualinvocations as this is more correct english as thisexception is public api we rename by subclassing and deprecating theoriginal rename all tests and internal methods that were referencingthe old name by aligning with the new name;
1714;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1713: fix typo in mockito.java javadoc;i was confused and tried to look for  verifynomoreinvocations  when i came across this javadocs.;;0;cache hivetype category during construction;the category is checked for each slice read in the record cursors and this causes 2x regression in performance for varchar reads;;;;;0;1;;
1714;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1713: fix typo in mockito.java javadoc;i was confused and tried to look for  verifynomoreinvocations  when i came across this javadocs.;;0;merge 0205 into 1x;merge the following:-  fix rx serialization bug in takeuntil again and the concurrent issue in bufferuntilsubscriber-  fix the compose generics-  fixing regression in mergedelayerror;;;;;1;1;use emptyobserver instead of subscribersempty()onerror should be ignored after unsubscribe is called;
1714;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1713: fix typo in mockito.java javadoc;i was confused and tried to look for  verifynomoreinvocations  when i came across this javadocs.;;1713.0;1713: fix typo in mockitojava javadoc;i was confused and tried to look for `verifynomoreinvocations` when i came across this javadocshopefully this prevents further confusion; ;typo in mockitojava javadoc;"the following javadocs refer to `verifynomoreinvocations` but link to `verifynomoreinteractions````    /**     * creates {@link orgmockitoinorder} object that allows verifying mocks in order     *     * <pre class""code""><code class""java"">     *   inorder inorder  inorder(firstmock secondmock)     *     *   inorderverify(firstmock)add(""was called first"")     *   inorderverify(secondmock)add(""was called second"")     * </code></pre>     *     * verification in order is flexible - <b>you dont have to verify all interactions</b> one-by-one     * but only those that you are interested in testing in order     * <p>     * also you can create inorder object passing only mocks that are relevant for in-order verification     * <p>     * <code>inorder</code> verification is greedy but you will hardly ever notice it     * if you want to find out more read     * <a href"" wiki page</a>     * <p>     * as of mockito 184 you can verifynomoreinvocations() in order-sensitive way read more: {@link inorder#verifynomoreinteractions()}     * <p>     * see examples in javadoc for {@link mockito} class     *     * @param mocks to be verified in order     *     * @return inorder object to be used to verify in order     */    @checkreturnvalue    public static inorder inorder(object mocks) {        return mockito_coreinorder(mocks)    }``````    /**     * allows checking if given method was the only one invoked eg:     * <pre class""code""><code class""java"">     *   verify(mock only())somemethod()     *   //above is a shorthand for following 2 lines of code:     *   verify(mock)somemethod()     *   verifynomoreinvocations(mock)     * </code></pre>     *     * <p>     * see also {@link mockito#verifynomoreinteractions(object)}     * <p>     * see examples in javadoc for {@link mockito} class     *     * @return verification mode     */    @checkreturnvalue    public static verificationmode only() {        return verificationmodefactoryonly()    }```javadoc should be corrected to `verifynomoreinteractions`";;1;0;1713: fix typo in mockitojava javadoc;
1715;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;298: replaces objenesis references from stubbing classes with plugin equivalents.;this enables the ios mockito plugin;;0;possible hang in servicemanagertest; one time when running the tests of the jdk5 backport[*] -- no i dont know if the jdk5-ness (eg arraydeque -> linkedlist) is relevant -- servicemanagertest appeared to hang jstack output is attached i dont know if there were any exceptions or other hints of a cause (certainly our maven test output always has exceptions in it i didnt see if any looked related and ive since overwritten the output files :) the interesting part of the stacks is belowthe test worked fine the next time i ran it and it worked fine when i made the equivalent internal change and ran 10x against the normal internal jdk with the normal toolsi could believe that we hit a crazy vm bug or something but in case theres anything actually wrong in servicemanager or its test i figured id file this bug&nbsp&nbspat javautilconcurrentlockslocksupportpark(locksupportjava:186)&nbsp&nbspat javautilconcurrentlocksabstractqueuedsynchronizerparkandcheckinterrupt(abstractqueuedsynchronizerjava:834)&nbsp&nbspat javautilconcurrentlocksabstractqueuedsynchronizerdoacquiresharedinterruptibly(abstractqueuedsynchronizerjava:994)&nbsp&nbspat javautilconcurrentlocksabstractqueuedsynchronizeracquiresharedinterruptibly(abstractqueuedsynchronizerjava:1303)&nbsp&nbspat javautilconcurrentcountdownlatchawait(countdownlatchjava:236)&nbsp&nbspat comgooglecommonutilconcurrentuninterruptiblesawaituninterruptibly(uninterruptiblesjava:55)&nbsp&nbspat comgooglecommonutilconcurrentservicemanagertest$4failure(servicemanagertestjava:365)&nbsp&nbspat comgooglecommonutilconcurrentservicemanager$servicemanagerstate$5call(servicemanagerjava:689)&nbsp&nbspat comgooglecommonutilconcurrentservicemanager$servicemanagerstate$5call(servicemanagerjava:687)&nbsp&nbspat comgooglecommonutilconcurrentlistenercallqueuerun(listenercallqueuejava:118)&nbsp&nbspat comgooglecommonutilconcurrentmoreexecutors$samethreadexecutorserviceexecute(moreexecutorsjava:297)&nbsp&nbspat comgooglecommonutilconcurrentlistenercallqueueexecute(listenercallqueuejava:86)&nbsp&nbspat comgooglecommonutilconcurrentservicemanager$servicemanagerstateexecutelisteners(servicemanagerjava:700)&nbsp&nbspat comgooglecommonutilconcurrentservicemanager$servicemanagerstatetransitionservice(servicemanagerjava:671)&nbsp&nbspat comgooglecommonutilconcurrentservicemanager$servicelistenerfailed(servicemanagerjava:774)&nbsp&nbspat comgooglecommonutilconcurrentabstractservice$9call(abstractservicejava:484)&nbsp&nbspat comgooglecommonutilconcurrentabstractservice$9call(abstractservicejava:482)&nbsp&nbspat comgooglecommonutilconcurrentlistenercallqueuerun(listenercallqueuejava:118)&nbsp&nbspat comgooglecommonutilconcurrentmoreexecutors$samethreadexecutorserviceexecute(moreexecutorsjava:297)&nbsp&nbspat comgooglecommonutilconcurrentlistenercallqueueexecute(listenercallqueuejava:86)&nbsp&nbspat comgooglecommonutilconcurrentabstractserviceexecutelisteners(abstractservicejava:433)&nbsp&nbspat comgooglecommonutilconcurrentabstractservicestartasync(abstractservicejava:180)&nbsp&nbspat comgooglecommonutilconcurrentservicemanagerstartasync(servicemanagerjava:287)&nbsp&nbspat comgooglecommonutilconcurrentservicemanagertesttestlistenerdeadlock(servicemanagertestjava:371)[*] at https://githubcom/google/guava/commit/566894361b48cec7d391127fe4b0f9547b4549c6;lukes@ looks like a bug in the test  though a pretty crazy one  i doubt the backport change you made would make a difference  though possibly the recent listenercallqueue changes made this race more likely (since there is slightly less locking going on)the failure callback was supposed to run on another thread but it looks like thread scheduling allowed notifyfailed to run prior to when the original executelisteners call from servicestartasync call returned  so the failure listeners ended up running on the wrong thread (in particular it ran on the test thread)  the fix is to introduce another synchronization point between the background thread and the main test thread to make sure that all started callbacks have fired prior to calling notifyfailed phew! || this was  a while back in this commit  the bug was in the test ||;;;;0;1;;
1715;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;298: replaces objenesis references from stubbing classes with plugin equivalents.;this enables the ios mockito plugin;;0;fix typeregistry to return null for unknown types;;;;;;0;1;;
1715;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;298: replaces objenesis references from stubbing classes with plugin equivalents.;this enables the ios mockito plugin;;0;deprecate parallel;see https://githubcom/reactivex/rxjava/issues/1673;;;;;1;1;deprecate parallelsee https://githubcom/reactivex/rxjava/issues/1673;
1715;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;298: replaces objenesis references from stubbing classes with plugin equivalents.;this enables the ios mockito plugin;;298.0;298: replaces objenesis references from stubbing classes with plugin equivalents;this enables the ios mockito plugin( to upgrade to v2; merging 1715  < ;objenesishelper references in mockmaker-independent code;a couple of references to orgobjenesis classes in code that is otherwise independent of bytecode-based mocks:src/main/java/org/mockito/internal/stubbing/answers/clonesargumentsjavasrc/main/java/org/mockito/internal/stubbing/answers/throwsexceptionclassjavaboth of these classes use objenesishelpernewinstance(class) which differs from classnewinstance() in that no constructors are called is that necessary for these classes? if not then updating to classnewinstance() makes mockito fully platform-independent (at least for platforms that define a mockmaker) if it is necessary can this call be moved into mockmaker?im happy to make the changes once the team decides on the best approach;im with youthe interactions with objenesis should be better isolated mockmaker might be a reasonable idea technically creating instances of things is not mockmakers responsibility so perhaps there is a better way? a different extension point? check out orgmockitoplugins package || it looks like you already did most of the work! the orgmockitointernalcreationinstance package defines instantiator with the correct method so it looks like all thats to be done to make this cross-platform is to move instantiator to orgmockitoplugins and update instantiatorprovider to check for a plugin before assigning a objenesisinstantiator to instantiatorproviderinstanceif youre comfortable with that approach ill make the changes and submit a pull request || any updates on this? ||  in [current source]( mockitos travisci continuous build successfully built the change but for some reason since late last june ci builds cant be posted to [mockitos releases page]( i guess someone from the project will need to hand-roll the next release or fix the projects travis ci configuration || thanks @tomball ! || new objenesishelper references were added in release/2x branch to org/mockito/internal/stubbing/basestubbingjava and org/mockito/internal/stubbing/stubberimpljava ||;1;0;added unit test to verify core classes do not depend on bytecode libraries;
1718;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;1717 : configure the methodvisitor for java 11 compatibility;i m looking into adding a unit test  if i can find how to use byte buddy to generate a class with a conditional dynamic instruction when running with java 11.;;0;insert support in hive connector;replacing previous pr ( with this this has changes ported to new insert api;any comments on this pr? || in general you shouldnt references packages in the `shaded` namespace but thrift is an exception because we want to shade the version that hive uses but also need to reference the classes directly (this allows us to use a different version in the connector to talk to other systems) || we should probably shade it specially into a separate namespace to avoid this confusion || @stagraqubole  are you still working on this pr? i saw qubole supports insert in presto any possible to support insert with partition keyword? || @yuananf  i havent started work on the comments yet regarding partition keyword it was dropped because partition is a hive construct and presto is a generic query engine that said current implementation works well with partitions see the document attached in this thread for context and syntax for using partitions:  support all features mentioned in the document in this link while only insert into was accepted in open source || @stagraqubole @electrum any plans to finalize this pr? || @stagraqubole  @nezihyigitbasi @electrum i have made insert work in hive connector based on this prwill make another pull request recently || i am in middle of updating our presto code base and porting the insert work to latest apis i should be refreshing this pr around next week || to give some context this particular feature has made presto upgrades tricky for us at qubole because of the large number number of conflicts this has also prevented us from refreshing the pr recently hopefully we can get this pr sorted out soon - this will benefit presto/hive users and it will help us rev faster as well || thats great! hope for the new pull request! || opened the new pr(#2574) addressing the review comments and porting changes to new interfaces ||;;;;0;1;;
1718;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;1717 : configure the methodvisitor for java 11 compatibility;i m looking into adding a unit test  if i can find how to use byte buddy to generate a class with a conditional dynamic instruction when running with java 11.;;0;double onbackpressuredrop() hangs with observeon();"may be related to issues: #1677 #1717 weve noticed on 204 some hard-to-reproduce hangs when using observeon()  however weve discovered this nonsensical use case reproduces the hang every time  maybe the nonsensical example will help reveal the more general issue with observeon()the keys points to the examples are: (1) infinite hot stream (2) slow consumer (3) double backpressure before observeon()  we were able to reproduce the issue with a single onbackpressuredrop() but with less consistency``` javaimport javautilconcurrentcountdownlatchimport rxobservableimport rxsubscriberimport rxobservableonsubscribeimport rxschedulersschedulerspublic class doublebackpressuretest {    private static void run() throws interruptedexception {        countdownlatch latch  new countdownlatch(1)        observablecreate(new onsubscribe<integer>() {            @override            public void call(subscriber<? super integer> s) {                for (int i  0 i < integermax_value i++) { // <-- having an infinite stream seems to be key to reproducing the issue                    sonnext(i)                    try {                        threadsleep(5)                    } catch (interruptedexception e) {                        eprintstacktrace()                    }                }                soncompleted()            }        })        onbackpressuredrop()        onbackpressuredrop()        observeon(schedulersio())        subscribe(v -> {            systemoutprintln(v)        } e -> {        } () -> {            systemoutprintln(""completed iteration"")            latchcountdown()        })        latchawait()    }    public static void main(string args) throws interruptedexception {        for(int i1 i<10 i++){            systemoutprintln(""running iteration: ""+i)            run()        }        systemoutprintln(""done running all iterations"")    }}```";this is working for me i believe it was  by  ||;;;;0;1;;
1718;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;1717 : configure the methodvisitor for java 11 compatibility;i m looking into adding a unit test  if i can find how to use byte buddy to generate a class with a conditional dynamic instruction when running with java 11.;;1717.0;1717 : configure the methodvisitor for java 11 compatibility;im looking into adding a unit test if i can find how to use byte buddy to generate a class with a conditional dynamic instruction when running with java 11;this should 1717 ||  merging 1718 ;incompatibility between the inline mocks and jacoco 084;# versionsmockito 2270jacoco 084# problemjacoco 084 introduced the use of the conditional dynamic instruction when running with java 11+ which triggers an exception in the [`methodvisitor`]( used to strip the parameters because its not configured for the correct asm api version:    mockito cannot mock this class: class comekinomockitob        if youre not sure why youre getting this error please report to the mailing list            java               : 11    jvm vendor name    : adoptopenjdk    jvm vendor version : 1103+7    jvm name           : openjdk 64-bit server vm    jvm version        : 1103+7    jvm info           : mixed mode    os name            : mac os x    os version         : 10145            you are seeing this disclaimer because mockito is configured to create inlined mocks    you can learn about inline mocks and their limitations under item #39 of the mockito class javadoc        underlying exception : orgmockitoexceptionsbasemockitoexception: could not modify all classes [class javalangobject class comekinomockitob]    orgmockitoexceptionsbasemockitoexception:     mockito cannot mock this class: class comekinomockitob        if youre not sure why youre getting this error please report to the mailing list            java               : 11    jvm vendor name    : adoptopenjdk    jvm vendor version : 1103+7    jvm name           : openjdk 64-bit server vm    jvm version        : 1103+7    jvm info           : mixed mode    os name            : mac os x    os version         : 10145            you are seeing this disclaimer because mockito is configured to create inlined mocks    you can learn about inline mocks and their limitations under item #39 of the mockito class javadoc        underlying exception : orgmockitoexceptionsbasemockitoexception: could not modify all classes [class javalangobject class comekinomockitob]    	at comekinomockitoatestshould_call_b(atestjava:10)    	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)    	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)    	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    	at javabase/javalangreflectmethodinvoke(methodjava:566)    	at orgjunitplatformcommonsutilreflectionutilsinvokemethod(reflectionutilsjava:628)    	at orgjunitjupiterengineexecutionexecutableinvokerinvoke(executableinvokerjava:117)    	at orgjunitjupiterenginedescriptortestmethodtestdescriptorlambda$invoketestmethod$7(testmethodtestdescriptorjava:184)    	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)    	at orgjunitjupiterenginedescriptortestmethodtestdescriptorinvoketestmethod(testmethodtestdescriptorjava:180)    	at orgjunitjupiterenginedescriptortestmethodtestdescriptorexecute(testmethodtestdescriptorjava:127)    	at orgjunitjupiterenginedescriptortestmethodtestdescriptorexecute(testmethodtestdescriptorjava:68)    	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:135)    	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)    	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$7(nodetesttaskjava:125)    	at orgjunitplatformenginesupporthierarchicalnodearound(nodejava:135)    	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$8(nodetesttaskjava:123)    	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)    	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:122)    	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:80)    	at javabase/javautilarraylistforeach(arraylistjava:1540)    	at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorserviceinvokeall(samethreadhierarchicaltestexecutorservicejava:38)    	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:139)    	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)    	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$7(nodetesttaskjava:125)    	at orgjunitplatformenginesupporthierarchicalnodearound(nodejava:135)    	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$8(nodetesttaskjava:123)    	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)    	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:122)    	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:80)    	at javabase/javautilarraylistforeach(arraylistjava:1540)    	at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorserviceinvokeall(samethreadhierarchicaltestexecutorservicejava:38)    	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:139)    	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)    	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$7(nodetesttaskjava:125)    	at orgjunitplatformenginesupporthierarchicalnodearound(nodejava:135)    	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$8(nodetesttaskjava:123)    	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)    	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:122)    	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:80)    	at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorservicesubmit(samethreadhierarchicaltestexecutorservicejava:32)    	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorexecute(hierarchicaltestexecutorjava:57)    	at orgjunitplatformenginesupporthierarchicalhierarchicaltestengineexecute(hierarchicaltestenginejava:51)    	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:220)    	at orgjunitplatformlaunchercoredefaultlauncherlambda$execute$6(defaultlauncherjava:188)    	at orgjunitplatformlaunchercoredefaultlauncherwithinterceptedstreams(defaultlauncherjava:202)    	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:181)    	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:128)    	at orggradleapiinternaltaskstestingjunitplatformjunitplatformtestclassprocessor$collectalltestclassesexecutorprocessalltestclasses(junitplatformtestclassprocessorjava:102)    	at orggradleapiinternaltaskstestingjunitplatformjunitplatformtestclassprocessor$collectalltestclassesexecutoraccess$000(junitplatformtestclassprocessorjava:82)    	at orggradleapiinternaltaskstestingjunitplatformjunitplatformtestclassprocessorstop(junitplatformtestclassprocessorjava:78)    	at orggradleapiinternaltaskstestingsuitetestclassprocessorstop(suitetestclassprocessorjava:61)    	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)    	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)    	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    	at javabase/javalangreflectmethodinvoke(methodjava:566)    	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)    	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)    	at orggradleinternaldispatchcontextclassloaderdispatchdispatch(contextclassloaderdispatchjava:32)    	at orggradleinternaldispatchproxydispatchadapter$dispatchinginvocationhandlerinvoke(proxydispatchadapterjava:93)    	at comsunproxy$proxy5stop(unknown source)    	at orggradleapiinternaltaskstestingworkertestworkerstop(testworkerjava:132)    	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)    	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)    	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    	at javabase/javalangreflectmethodinvoke(methodjava:566)    	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)    	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)    	at orggradleinternalremoteinternalhubmessagehubbackedobjectconnection$dispatchwrapperdispatch(messagehubbackedobjectconnectionjava:175)    	at orggradleinternalremoteinternalhubmessagehubbackedobjectconnection$dispatchwrapperdispatch(messagehubbackedobjectconnectionjava:157)    	at orggradleinternalremoteinternalhubmessagehub$handlerrun(messagehubjava:404)    	at orggradleinternalconcurrentexecutorpolicy$catchandrecordfailuresonexecute(executorpolicyjava:63)    	at orggradleinternalconcurrentmanagedexecutorimpl$1run(managedexecutorimpljava:46)    	at javabase/javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1128)    	at javabase/javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:628)    	at orggradleinternalconcurrentthreadfactoryimpl$managedthreadrunnablerun(threadfactoryimpljava:55)    	at javabase/javalangthreadrun(threadjava:834)    caused by: orgmockitoexceptionsbasemockitoexception: could not modify all classes [class javalangobject class comekinomockitob]    	at netbytebuddytypecachefindorinsert(typecachejava:152)    	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:365)    	at netbytebuddytypecachefindorinsert(typecachejava:174)    	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:376)    	 77 more    caused by: javalangillegalstateexception:     byte buddy could not instrument all classes within the mocks type hierarchy        this problem should never occur for javac-compiled classes this problem has been observed for classes that are:     - compiled by older versions of scalac     - classes that are part of the android distribution    	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortriggerretransformation(inlinebytecodegeneratorjava:177)    	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratormockclass(inlinebytecodegeneratorjava:153)    	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:37)    	at orgmockitointernalcreationbytebuddytypecachingbytecodegenerator$1call(typecachingbytecodegeneratorjava:34)    	at netbytebuddytypecachefindorinsert(typecachejava:152)    	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:365)    	at netbytebuddytypecachefindorinsert(typecachejava:174)    	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:376)    	at orgmockitointernalcreationbytebuddytypecachingbytecodegeneratormockclass(typecachingbytecodegeneratorjava:32)    	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakercreatemocktype(inlinebytebuddymockmakerjava:197)    	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakercreatemock(inlinebytebuddymockmakerjava:178)    	at orgmockitointernalutilmockutilcreatemock(mockutiljava:35)    	at orgmockitointernalmockitocoremock(mockitocorejava:62)    	at orgmockitomockitomock(mockitojava:1907)    	at orgmockitomockitomock(mockitojava:1816)    	 77 more    caused by: javalangunsupportedoperationexception: this feature requires asm7    	at netbytebuddyjarasmmethodvisitorvisitldcinsn(methodvisitorjava:542)    	at netbytebuddyjarasmclassreaderreadcode(classreaderjava:2181)    	at netbytebuddyjarasmclassreaderreadmethod(classreaderjava:1275)    	at netbytebuddyjarasmclassreaderaccept(classreaderjava:679)    	at netbytebuddyjarasmclassreaderaccept(classreaderjava:391)    	at netbytebuddydynamicscaffoldtypewriter$default$forinliningcreate(typewriterjava:3393)    	at netbytebuddydynamicscaffoldtypewriter$defaultmake(typewriterjava:1930)    	at netbytebuddydynamicscaffoldinlineredefinitiondynamictypebuildermake(redefinitiondynamictypebuilderjava:217)    	at netbytebuddydynamicscaffoldinlineabstractinliningdynamictypebuildermake(abstractinliningdynamictypebuilderjava:120)    	at netbytebuddydynamicdynamictype$builder$abstractbasemake(dynamictypejava:3396)    	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortransform(inlinebytecodegeneratorjava:254)    	at javainstrument/javalanginstrumentclassfiletransformertransform(classfiletransformerjava:246)    	at javainstrument/suninstrumenttransformermanagertransform(transformermanagerjava:188)    	at javainstrument/suninstrumentinstrumentationimpltransform(instrumentationimpljava:563)    	at javainstrument/suninstrumentinstrumentationimplretransformclasses0(native method)    	at javainstrument/suninstrumentinstrumentationimplretransformclasses(instrumentationimpljava:167)    	at orgmockitointernalcreationbytebuddyinlinebytecodegeneratortriggerretransformation(inlinebytecodegeneratorjava:174)    	 91 more# exampleive pushed an [example]( demonstrating the problem# fixi believe the fix is simply to configure the visitor with the asm 7 api version since that _is_ the version used by mockito;for reference the change was introduced in jacoco with jacoco/jacoco#845 ||;1;0;1717: configure the methodvisitor for java 11+ compatibilityby using byte buddys supported asm api version the visitor will always becompatible with the currently supported bytecode including when using theexperimental feature;
1720;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;used field properties for some operations;used the  journal_name  field property instead of hard coding the field names. as a consequence  journaltitle  is included in the integrity check and if we want to add  journalsubtitle    issuetitle  etc later it is just to change in a single position for checks  abbreviation and so on.;;0;charmatcherasciimatchesallof sometimes is wrong; after alot of tries ive realized that if i check the same string in different runs sometimes the methodcharmatcherasciimatchesallof(string)will return the wrong answer about 97% of the time it returns false but every once in a while it returns as truei do not know how to reproduce it that seems to happen in random times;janecekp@ or an occasional empty string in the input || ";;;;0;1;;
1720;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;used field properties for some operations;used the  journal_name  field property instead of hard coding the field names. as a consequence  journaltitle  is included in the integrity check and if we want to add  journalsubtitle    issuetitle  etc later it is just to change in a single position for checks  abbreviation and so on.;;0;add missing be in javadoc;;;;;;1;1;add missing be in javadoc;
1720;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;used field properties for some operations;used the  journal_name  field property instead of hard coding the field names. as a consequence  journaltitle  is included in the integrity check and if we want to add  journalsubtitle    issuetitle  etc later it is just to change in a single position for checks  abbreviation and so on.;;0;replace all touppercase and tolowercase using default locale;replace with explicit localeenglish this fixes quirky bugs in languages (such as turkish) where lowercase mappings are not as intuitive as in say english;see  for a good reason to do this || is there a check style rule for this?  it is likely this will creep back in without a checker || not checkstyle but pmd:  || this is  in version 109 of the duplicate finder plugin || merged  ;;;;0;1;;
1720;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;used field properties for some operations;used the  journal_name  field property instead of hard coding the field names. as a consequence  journaltitle  is included in the integrity check and if we want to add  journalsubtitle    issuetitle  etc later it is just to change in a single position for checks  abbreviation and so on.;;0;change repeatwhen and retrywhen signatures;add a shim to make it so the public api for repeatwhen and retrywhen dont expose notification<?>https://githubcom/reactivex/rxscala/pull/24; these public apis seem better merging  ||;;;;1;1;forgot to commit the changes to the tests;
1723;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;change implementation of exceptionfactory to explicitly test for dependent classes;the original implementation of conditional opentest4j support (#1667) relied on some implicit behaviour of the java classloader to generate and catch the exception at the right time. it seems that this behaviour is not always exactly replicated in all environments - for example  in #1716  where mockito was being used in an instrumentation test that was being run on an android emulator.;;0;nullpointerexception in enummultisetcreate; the attached two tests on two variants of create cause a nullpointerexception i am not sure if this is a bug because some collections do not allow null values however i could not find anything in the documentation about these exact cases; ok then we count this test as a false warning ||;;;;0;1;;
1723;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;change implementation of exceptionfactory to explicitly test for dependent classes;the original implementation of conditional opentest4j support (#1667) relied on some implicit behaviour of the java classloader to generate and catch the exception at the right time. it seems that this behaviour is not always exactly replicated in all environments - for example  in #1716  where mockito was being used in an instrumentation test that was being run on an android emulator.;;0;two kafka fixes;see commit description- fixes default port handling- deal with null key or payload;;;;;0;1;;
1723;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;change implementation of exceptionfactory to explicitly test for dependent classes;the original implementation of conditional opentest4j support (#1667) relied on some implicit behaviour of the java classloader to generate and catch the exception at the right time. it seems that this behaviour is not always exactly replicated in all environments - for example  in #1716  where mockito was being used in an instrumentation test that was being run on an android emulator.;;0;merge: backpressure + scalarvaluequeue dont play nicely;merge drops any values in scalarvaluequeue when mergesubscriber::oncompleted is called and wip  0also if drainqueuesifneeded() is called and that drains the last remaining values and those are in scalarvaluequeue then no oncomplete will be emittedtests + fix (not sure its the best possible fix though as i still dont fully understand everything going on in merge!): https://githubcom/dmgd/rxjava/commit/96fdd9498e3dea2be8b810a423268823dedaa793;thank you `merge` is bloody complicated so thank you for wading into it! i really appreciate all of the unit tests and the proposed fix trying it out || i have merged the changes via  ||;;;;0;1;;
1723;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;change implementation of exceptionfactory to explicitly test for dependent classes;the original implementation of conditional opentest4j support (#1667) relied on some implicit behaviour of the java classloader to generate and catch the exception at the right time. it seems that this behaviour is not always exactly replicated in all environments - for example  in #1716  where mockito was being used in an instrumentation test that was being run on an android emulator.;;1716.0;change implementation of exceptionfactory to explicitly test for dependent classes;the original implementation of conditional opentest4j support (#1667) relied on some implicit behaviour of the java classloader to generate and catch the exception at the right time it seems that this behaviour is not always exactly replicated in all environments - for example in #1716 where mockito was being used in an instrumentation test that was being run on an android emulatorthe new implementation is a bit more direct in how it tests for the dependent classes the existing test cases still pass and @matejdro confirmed that this  his problem1716; merging 1723  < ;mockito-android 226+ tries to use missing opentest4j exceptions;it appears that mockito `226+` on android tries to use exceptions from opentest4j even when opentest4j is not used resulting in tests crashing due to exceptions classes not being foundsteps to reproduce:1 open [mockitoandroiddemo]( project in android studio2 run `exampleinstrumentedtestjava` test on android device/emulator3 test will crash with `javalangnoclassdeffounderror: failed resolution of: lorg/opentest4j/assertionfailederror`lowering version to `2250` fixes the issue;@kriegfrj do you mind taking a look at this? || i cant promise to look at it swiftly ive never run an android emulator before itll take me a while to get set upin the meantime @matejdro  if you could post the stack trace of the error that would help i might be able to get a clue without seeing up the whole environment || here you go:[stacktracetxt]( || thankslooks like youve got some funky classloader in there doing something odd ill try and look more closely later possibly later in the weekend || ive had a quick look and i havent been able to get the emulator running easily to reproduce it myself however having had a closer look at the stack trace i suspect that it is some kind of feature in the test harness (perhaps in androidjunitrunner) that is supposed to detect and warn when your code tries to load classes that it cant find on its classpath attempting to load the opentest4j class is perfectly normal behaviour for this version of mockito though and the attempt is surrounded by a <tt>catch()</tt> which ordinarily would catch any error thrownas a workaround you could try putting opentest4j on your classpath you might lose the visual diff in case of failure though || here is my guess on what happens:exceptions catching for missing classes only [surrounds factory creation not the actual exception creation]( it is possible that desktop jvm verifies all methods on class creation but androids runtime does not and thus no exception is thrown there instead androids runtime throws missing class exception when `create()` method is executed for the first time which does not have`try/catch` around it || i thought about your suggestion but i dont think it fits with the stack trace that you provided in the stack trace its clear that the line its complaining about is line 24 in the static initializer for `exceptionfactory` when the factory implementation is actually created:at orgmockitointernaljunitexceptionfactory<clinit>(exceptionfactoryjava:24)i expect a `classnotfounderror` to get thrown here when opentest4j is not on the class path what is not expected is that this isnt caught by the surrounding `catch(throwable)` statement which is why i think the android test framework is doing something funkyif what youre suggesting were true id expect line 27 to appear at the top of the stack trace but it doesnt appear at all according to the stack trace it is failing before `create()` is even called this scenario would also be contrary to the jvm spec (which from memory specifies that all the classs linkages should be resolved when the class is loaded and not when a method is executed)one way to test this would be to package up a junit test and deploy it as an apk into the emulator and run it directly rather than as part of an instrumentation test if you want to give that a try and let me know how you go we can analyse the result || ok @matejdro  i still havent been able to get the android studio stuff working but based on the above educated guess ive made a change that might do the trick you can find this change under branch `1716-opentest4j-under-android` in my fork of mockito ( if you could download build and install this and give it a try and let me know if it fixes your problem that would be much appreciatedif it does fix your problem ill create a pr from this branch so that @timvdlippe  or @mockitoguy can merge it if not i guess ill go back to the drawing board || sorry for the delay any tips on how to build `mockito-android`? running `gradlew build` only procudes `mockito-core` and i cannot find a way to switch it to androidps: there appear to be checkstyle errors in the branch (i had to disable checkstyle to even get core to build) || never mind figured it out (android project is in the `subprojects` folder) it appears that using your branch fixes the issue i no longer get the crash || thanks for verifying @matejdro i have created a pr for this issue now (#1723)thank you so much for your help - i was dreading having to go through the process of getting the android emulator working! im sure it would have been fun to try but (like most people) im a bit time poor || i am also having this issue i was running v300 but switching back to 2250  it  || > i am also having this issue i was running v300 but switching back to 2250 fixed itsorry @johnmahlon the fix for this was supposed to get merged into 30 but i dropped the ball hopefully it will get merged soonin the meantime as a workaround if you need mockito >2250 then you should be able to run it with any version of mockito if you just put `orgopentest4j` on your runtime classpath || @kriegfrj no problem our app isn’t production yet so using 225 is definitely fine for now  ||;1;0;change implementation of exceptionfactory to explicitly test for the presence of dependent classes rather thandepend on the implicit classloading behaviour this is necessary as android classloading behaviour is slightly different 1716changed to use lambdas now that codebase is on java 18;
1733;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed concurrentmodificationexception when removing a field in the so…;1724. really simple it turned out  no changelog since i m not sure if it was in 3.5. -  -   ( []()?);;0;move to proper location;was accidentally committed in old rxjava-core src folder;;;;;1;1;move to proper locationwas accidentally committed in old rxjava-core src folder;
1733;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed concurrentmodificationexception when removing a field in the so…;1724. really simple it turned out  no changelog since i m not sure if it was in 3.5. -  -   ( []()?);;0;simplify session in preparation for adding session properties;;@martint or @electrum  can you review this quickly as it will not age well?  it is mostly mechanical changes || ;;;;0;1;;
1733;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed concurrentmodificationexception when removing a field in the so…;1724. really simple it turned out  no changelog since i m not sure if it was in 3.5. -  -   ( []()?);;977.0;verifynointeractions guarantees no interactions with mock;with #995 i provided a fix to #977 and #989however that pr targeted `master` which eventually became `old-3x` and its code didnt make it into `release/3x`#977 and #989 should be reopenedi have back-ported that pr to target `release/3x``verifyzerointeractions` is marked as `@deprecated` and a new `verifynointeractions` is added there are no breaking changes afaik so this code is backwards compatiblesince i dont know if/when this code will ship javadocs contain a placeholder `since 3xx`; merging 1733     ||;misleading documentation of verifyzerointeractions;"## problemthe current behavior of verifyzerointeractions can be misleading see the #989in current version of mockito (2x) we can improve the javadoc for verifyzerointeractions to clearly describe how it works (and mention the behavior of strict stubs too)please contribute!## original reportoriginal issue reported by @ffissore:according to the [docs]( `verifyzerointeractions` is like `verify(mock never())method()` when the mock has only one methodthe tests below should both raise an exception instead `testverifyzerointeractions` raises none and fails```javapackage testimport orgjunitbeforeimport orgjunitruleimport orgjunittestimport orgmockitomockimport orgmockitomockitoannotationsimport orgmockitoexceptionsverificationneverwantedbutinvokedimport orgmockitoexceptionsverificationnointeractionswantedimport orgmockitojunitmockitojunitimport orgmockitojunitmockitoruleimport orgmockitoqualitystrictnessimport static orgjunitassertassertequalsimport static orgmockitomockito*public class mockitotest {   private static class collaborator {      public string dostuff(int number) {         throw new runtimeexception()      }   }   private static class container {      private final collaborator collaborator      public container(collaborator collaborator) {         thiscollaborator  collaborator      }      public string dostuff(int number) {         return collaboratordostuff(number)      }   }   @rule   public mockitorule rule  mockitojunitrule()strictness(strictnessstrict_stubs)   @mock   private collaborator collaborator   @before   public void setup() throws exception {      mockitoannotationsinitmocks(this)   }   // passes   @test(expected  neverwantedbutinvokedclass)   public void testverifynever() throws exception {      container container  new container(collaborator)      when(collaboratordostuff(42))thenreturn(""yeah"")      string output  containerdostuff(42)      assertequals(""yeah"" output)      verify(collaborator never())dostuff(42)   }   // fails   @test(expected  nointeractionswantedclass)   public void testverifyzerointeractions() throws exception {      container container  new container(collaborator)      when(collaboratordostuff(42))thenreturn(""yeah"")      string output  containerdostuff(42)      assertequals(""yeah"" output)      verifyzerointeractions(collaborator)   }}```";"forgot to say: im using version 2713 || looking into it || thank you for reporting and your patience waiting for the reply!!!its a really good report - i was able to reproduce the problem easily also thanks a lot for using strict stubbing - im really happy to see it in use!at the moment ""verifyzerointeractions"" is an alias to ""verifynomoreinteractions"" intended to be used to improve readability of tests let me illustrate it on a couple of examples:example 1 - verifynomoreinteractions```javamockfoo()verify(mock)foo()verifynomoreinteractions(mock) //pretty clear i think```example 2 - verifyzerointeractions```javamockfoo()verify(mock)foo()verifyzerointeractions(mock)//above passes because verifyzerointeractions  verifynomoreinteractions//and we already have verified the only method invoked on the mock```example 3 - verifyzerointeractions with regular stubbing```javagiven(mockfoo())willreturn(""x"")assertequals(""x"" mockfoo())verify(mock)foo()verifyzerointeractions(mock)//above passes because verifyzerointeractions  verifynomoreinteractions```example 4 - verifyzerointeractions with new strict stubbing```javagiven(mockfoo())willreturn(""x"")assertequals(""x"" mockfoo())verifyzerointeractions(mock)//above passes because with strict stubbing//stubbed method are implicitly verified when they are ""used""//this is one of key features of strict stubbing (dry dont repeat yourself)```were happy to listen to suggestions about above and the api i think that better documentation is needed for ""verifyzerointeractions"" too || thank you for the clarification then i guess the problem is with the [javadoc]( which states ""verifies that no interactions happened on given mocks"" this made sense to me: a class x may have a number of mocked collaborators and i want to be sure that some of them have not taken part when i called xmethod()i ended up writing my version```javapublic static void verifyzerointeractions(object objects) {  for (int i  0 i < objectslength i++) {    assertequals(""expected 0 interactions with object at index "" + i + "" ("" + objects[i]getclass() + "")"" 0 mockitomockingdetails(objects[i])getinvocations()size())  }}```also thanks for the hint about implicit verification when in strict mode: i didnt get it and it will allow me to delete some tens of lines of code || interesting idea!lets keep this ticket to improve the documentation (want to help out? submit a pr :) i created ticket for discussing change of verifyzerointeractions: #989 || ";1;0;introducing verifynointeractions that checks if the number ofinvocations on given mock(s) is zero failing otherwise;
1733;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed concurrentmodificationexception when removing a field in the so…;1724. really simple it turned out  no changelog since i m not sure if it was in 3.5. -  -   ( []()?);;989.0;verifynointeractions guarantees no interactions with mock;with #995 i provided a fix to #977 and #989however that pr targeted `master` which eventually became `old-3x` and its code didnt make it into `release/3x`#977 and #989 should be reopenedi have back-ported that pr to target `release/3x``verifyzerointeractions` is marked as `@deprecated` and a new `verifynointeractions` is added there are no breaking changes afaik so this code is backwards compatiblesince i dont know if/when this code will ship javadocs contain a placeholder `since 3xx`; merging 1733     ||;misleading behavior of mockitoverifyzerointeractions();"## problemmockitoverifyzerointeractions() actually does not do what it advertises the purpose of this ticket is to discuss whether to change the behavior of this method in mockito 3## detailsbased on user feedback at #977 from @ffissore ""verifyzerointeractions"" api can be misleading when you read that method in test code you expect zero interactions with specified mocks however ""verifyzerointeractions"" is only an alias to ""verifynomoreinteractions"" and in fact it **does not** guarantee that there were zero interactions lets use examples to illustrate the problem## feedback neededplease comment / vote / state your opinion about changing the behavior of ""verifyzerointeractions"" so that it actually ensures that there were **zero** interactions with the mock (regardless if previously verified or not)## examplesbelow examples illustrate current behavior of mockito 2x in case you are puzzled what this ticket is aboutexample 1 - verifynomoreinteractions```javamockfoo()verify(mock)foo()verifynomoreinteractions(mock) //pretty clear i think```example 2 - verifyzerointeractions```javamockfoo()verify(mock)foo()verifyzerointeractions(mock)//above passes because verifyzerointeractions  verifynomoreinteractions//and we already have verified the only method invoked on the mock```example 3 - verifyzerointeractions with regular stubbing```javagiven(mockfoo())willreturn(""x"")assertequals(""x"" mockfoo())verify(mock)foo()verifyzerointeractions(mock)//above passes because verifyzerointeractions  verifynomoreinteractions```example 4 - verifyzerointeractions with new strict stubbing```javagiven(mockfoo())willreturn(""x"")assertequals(""x"" mockfoo())verifyzerointeractions(mock)//above passes because with strict stubbing//stubbed method are implicitly verified when they are ""used""//this is one of key features of strict stubbing (dry dont repeat yourself)```";this was  in #989 ||;1;0;introducing verifynointeractions that checks if the number ofinvocations on given mock(s) is zero failing otherwise;
1733;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fixed concurrentmodificationexception when removing a field in the so…;1724. really simple it turned out  no changelog since i m not sure if it was in 3.5. -  -   ( []()?);;0;listspartition(list<t> list int size) is returning wrong list<list<t>> size; i have gone through the issue - 451  here more discussion is going on ""distribute"" whatever i found the defect quite similar but result is different the listspartition(list&ltt> list int size) is returning wrong size of list&ltlist&ltt>> if the size of ""list&ltt> list"" is 12 in the first parameter and in second parameter ""int size"" is 4 so it should return list&ltlist&ltt>> size 3 rather than 4"; ;;;;0;1;;
1739;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;consistent punctuation in hints list for unfinishedstubbingexception;previously the numbered list had two periods and a colon after the three numbers.;;0;add restart method to stopwatch; it seems useful to have a restart() or resetandstart() method that does a reset() followed by start(); yep the design of this is to let you just chain the methods to get the best of both worlds: its clear what youre doing because youre calling 2 separate methods but you can do it in one line and the api isnt bloated with methods that are just 2 other methods smushed together--- ;;;;0;1;;
1739;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;consistent punctuation in hints list for unfinishedstubbingexception;previously the numbered list had two periods and a colon after the three numbers.;;0;consistent punctuation in hints list for unfinishedstubbingexception;previously the numbered list had two periods and a colon after the three numbersafter it consistently uses dots like other suggestions ie missingmethodinvocation; merging 1739 ;;;;1;1;consistent punctuation in hints list for unfinishedstubbingexception;
1739;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;consistent punctuation in hints list for unfinishedstubbingexception;previously the numbered list had two periods and a colon after the three numbers.;;0;fix hashaggregation infinite loop during multiple partial agg flushes;;looks good is there a test that reproduces this? || looks good  ||;;;;0;1;;
1739;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;consistent punctuation in hints list for unfinishedstubbingexception;previously the numbered list had two periods and a colon after the three numbers.;;0;fix slow non-deterministic test;somehow i missed the threadsleep to force the scenario so most of the time this test would run very slow (or forever)im surprised the unit tests passed before just random luck on thread scheduling;;;;;1;1;fix slow non-deterministic testsomehow i missed the threadsleep to force the scenario so most of the time this test would run very slow (or forever)im surprised the unit tests passed before just random luck on thread scheduling;
1745;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1743: clarify default answer in 3.0.0;api changes postponed to 4.0.0. default answer has not been changed in 3.0.0.;;0;allow removal from cache in cacheloaderreload(); i ran into a situation with cacheloader that doesnt seem to have an easy solution we use cachebuilderrefreshafterwrite() along with an asynchronous reload() method inside reload() we can tell when an object should be invalidated/removed from the cache (for example the remote object has been deleted) when this happens we want to invalidate it immediately rather than continuing to return a stale cached valuethe reload() method cannot call cacheinvalidate() because it does not have a reference to the cache (the loadingcache is constructed using the cacheloader)maybe the reload() method could throw a special exception that would invalidate the entry?; a colleague pointed out an obvious solution: use optional for the cache value || given that theres a decent workaround and that were not likely to make any changes to cache going forward im closing this ||;;;;0;1;;
1745;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1743: clarify default answer in 3.0.0;api changes postponed to 4.0.0. default answer has not been changed in 3.0.0.;;0;fix initialization of hadoop native code;;;;;;0;1;;
1745;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1743: clarify default answer in 3.0.0;api changes postponed to 4.0.0. default answer has not been changed in 3.0.0.;;0;serializedsubject;proposal for a `serializedsubject` type to simplify solution for multi-threaded emissions to a `subject`see https://githubcom/reactivex/rxjava/issues/1744;/cc @davidmgross as this has no javadoc whatsoever right now || im fuzzy on the purpose of this sort of subject is it meant to be abridge between multiple observables operating on multiple threads and theobservers of the subject?on thu oct 9 2014 at 10:51 pm ben christensen notifications@githubcomwrote:> /cc @davidmgross  as this has no javadoc> whatsoever right now> > —> reply to this email directly or view it on github>  david m grossplp consulting || its just a wrapper around other subjects to make it thread-safe for multiples threads to call the `on*` methods on it ||;;;;1;1;serializedsubjectsee https://githubcom/reactivex/rxjava/issues/1744;
1745;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1743: clarify default answer in 3.0.0;api changes postponed to 4.0.0. default answer has not been changed in 3.0.0.;;1743.0;1743: clarify default answer in 300;api changes postponed to 400 default answer has not been changed in 300;oh travis is deeply unhappy i would need to investigate that 😢  || please rebase this pr to fix the travis issue ||  ;clarify javadoc of returns_smart_nulls default answer in mockito 300?;[javadoc for mockitoreturns_smart_nulls]( in version 300 still says:> returnssmartnulls will be probably the default return values strategy in mockito 300as mockito 300 has been released this could now be clarified i see #971 is still open so it looks like the default answer has not been changed?;yes that should be updated to 400 now as we decided not to make any api changes in 300 ||;1;0;1743: clarify default answer in 300api changes postponed to 400;
1760;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;minor bug fixes;1747: removed typo;;0;replaysubject backpressure first try;added backpressure support to the unbounded replaysubject case since it buffers values anyway this is just an attempt to honor the subscribers request amount in addition i removed some unnecessary complications from subjectobserver and replaystate one notable effect is that the oncompleted event isnt immediately delivered (if requested < longmax_value) but only when the client subscriber actually `request()` for the next valuein addition the bounded replay had an unfortunate bug if the list got completely evicted before a terminal event and subscribers had a broken chain not ending in the tail terminal event this was uncovered by the removal of `caughtup` flag;thanks for helping to figure this out! multicasting is the last of the difficult ones im aware of and the last piece i need to solve for the stream processing system were doing trying to grok your changes now  || ```rxinternaloperatorsoperatormergetest > testbackpressureupstream2 failedrxinternaloperatorsoperatorserializetest > testmultithreadedwithnpeinmiddle failed```is there a way to view the generated html file?i was thinking and i guess we can/should add the caughtup flag back it should still work if the downstream doesnt request backpressure and thus the subjectobserver can definitely know it has caught up || > is there a way to view the generated html file? i dont know i cant figure out how to access them> i was thinking and i guess we can/should add the caughtup flag backi havent understood the code well enough yet to comment >  it should still work if the downstream doesnt request backpressure and thus the subjectobserver can definitely know it has caught upmakes sense the other thing im looking at is how `operatormulticast` needs to change to support composing backpressure such as for #1732 and how that will impact this pr || benchmark baseline:```# run complete total time: 00 32benchmark                                              (nextruns)   mode   samples        score  score error    unitsrsreplaysubjectperfsubscribeaftereventscount1                1   avgt 5      269833       11781    ns/oprsreplaysubjectperfsubscribeaftereventscount1             1000   avgt 5    33110526     1266597    ns/oprsreplaysubjectperfsubscribeaftereventscount1          1000000   avgt 5 31247027595  1497433379    ns/oprsreplaysubjectperfsubscribeaftereventsunbounded             1   avgt 5      250081        7426    ns/oprsreplaysubjectperfsubscribeaftereventsunbounded          1000   avgt 5    33098761      528813    ns/oprsreplaysubjectperfsubscribeaftereventsunbounded       1000000   avgt 5 33487413667  5029375490    ns/oprsreplaysubjectperfsubscribebeforeeventscount1               1   avgt 5      331722        8129    ns/oprsreplaysubjectperfsubscribebeforeeventscount1            1000   avgt 5    36893351     1648892    ns/oprsreplaysubjectperfsubscribebeforeeventscount1         1000000   avgt 5 40518042250  1161672131    ns/oprsreplaysubjectperfsubscribebeforeeventsunbounded            1   avgt 5      327369        9550    ns/oprsreplaysubjectperfsubscribebeforeeventsunbounded         1000   avgt 5    42256526    14201533    ns/oprsreplaysubjectperfsubscribebeforeeventsunbounded      1000000   avgt 5 40984927776  1870736245    ns/op```this pr:```# run complete total time: 00 33benchmark                                              (nextruns)   mode   samples        score  score error    unitsrsreplaysubjectperfsubscribeaftereventscount1                1   avgt 5      316748       23857    ns/oprsreplaysubjectperfsubscribeaftereventscount1             1000   avgt 5    30804720      505146    ns/oprsreplaysubjectperfsubscribeaftereventscount1          1000000   avgt 5 32116674111  1472923013    ns/oprsreplaysubjectperfsubscribeaftereventsunbounded             1   avgt 5      289414        7346    ns/oprsreplaysubjectperfsubscribeaftereventsunbounded          1000   avgt 5    31492417      976652    ns/oprsreplaysubjectperfsubscribeaftereventsunbounded       1000000   avgt 5 33848237126  1783110798    ns/oprsreplaysubjectperfsubscribebeforeeventscount1               1   avgt 5      411504        7850    ns/oprsreplaysubjectperfsubscribebeforeeventscount1            1000   avgt 5    54039037     7239158    ns/oprsreplaysubjectperfsubscribebeforeeventscount1         1000000   avgt 5 51122433955  1495835244    ns/oprsreplaysubjectperfsubscribebeforeeventsunbounded            1   avgt 5      392440       11102    ns/oprsreplaysubjectperfsubscribebeforeeventsunbounded         1000   avgt 5    53191895     1654241    ns/oprsreplaysubjectperfsubscribebeforeeventsunbounded      1000000   avgt 5 52500018802  3994205108    ns/op``` || ive been thinking about adding backpressure to the bounded mode but it has the drawback of keeping references to outdated data if the downstream consumes it request by request this isnt an issue with the unbounded since it already retains all data || im closing this at it is now outdated and found a couple of issues (backpressure not working relink of deleted might not be correct under race) ||;;;;0;1;;
1760;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;minor bug fixes;1747: removed typo;;1513.0;minor bug fixes;1747: removed typofixes #1513: added missing tag to fix javadocsupersedes and closes #1748; merging 1760 ` ;mockito docs / javadocs - monospaced font all over the place after point 44;the brilliant mockito javadocs are less brilliant than usual because after[44 deprecated orgmockitopluginsinstantiatorprovider as it was leaking internal api it was replaced by orgmockitopluginsinstantiatorprovider2 (since 2154)]( everything is written with monospaced font which reduces readability apparently some closing tag is missing;this probably broke in #1439 with the dangling `<p>` on line 2540 do you mind opening a pr to fix it? ||;1;0;1747: removed typofixes #1513: added missing tag to fix javadoc;
1760;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;minor bug fixes;1747: removed typo;;1747.0;minor bug fixes;1747: removed typofixes #1513: added missing tag to fix javadocsupersedes and closes #1748; merging 1760 ` ;typo in error message;" does not not support modification of given type""should be ""vm does not support modification of given type""";feel free to open a pr with a fix ||;1;0;1747: removed typofixes #1513: added missing tag to fix javadoc;
1760;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;minor bug fixes;1747: removed typo;;0;schema evolution in parquet;rebase schema evolution in parquet;@dain yes there is no good way to for both cases:using column name access could support column delete but not support column renameusing column index access could support column rename but will have problem with column deletemake it configurable so that users could config what kind of column rename/delete they needhere is the discussion in hive project about adding column index access support for rename: || @dain here is a relevant discussion in the parquet community: they committed: a solution to schema evolutionhive is doing similar things: || now that #2258 is merged can we close this one? || yes the type conversion stuff is covered in  ||;;;;0;1;;
1760;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;minor bug fixes;1747: removed typo;;0;add stringsisnullorwhitespace(); requesting a single method that would allow replacing the following construct:&nbsp&nbspif (stringsisnullorempty(s) || strim()isempty()) with&nbsp&nbspif (stringsisnullorwhitespace(s)) the behavior would be as follows:stringsisnullorwhitespace(null) // truestringsisnullorwhitespace("""") // truestringsisnullorwhitespace("" "") // truestringsisnullorwhitespace(""\t"") // truestringsisnullorwhitespace(""\r"") // truestringsisnullorwhitespace(""\n"") // truestringsisnullorwhitespace(""   \r\n"") // truestringsisnullorwhitespace(""a"") // false"; ;;;;0;1;;
1762;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;1758: method generictypeextractor#findgenericinterface always …;…returns first interface;;0;add to_json function;;question for @martint  and @electrum do we want to model this as the function to_json(map_or_array) or as cast(map_or_array as json)?  the latter would require a new type || ok i rewrote this as a cast and removed the bounded type parameter || looks good  you need more docs but you can send that in another pr ||;;;;0;1;;
1762;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;1758: method generictypeextractor#findgenericinterface always …;…returns first interface;;0;compose generics;;this seems to make my examples all work while still passing the covariance unit tests we have (and with easier to read generics) @davidmoten @akarnokd @zsxwing can you please review this as well?the java 8 code i tried is at  and that code does not compile with current code || lgtm except my comment || manually merged in  ||;;;;1;1;compose generics;
1762;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;1758: method generictypeextractor#findgenericinterface always …;…returns first interface;;1758.0;1758: method generictypeextractor#findgenericinterface always …;…returns first interface; merging 1762 ` ;method generictypeextractor#findgenericinterface always returns first  interface;the method `findgenericinterface` of `generictypeextractor` ( < always returns the first generic interfacethe relevant line seems to be:< instead of `return sourceclassgetgenericinterfaces()[0]` it should be `return sourceclassgetgenericinterfaces()[i]`example:```javainterface myinterface extends runnable consumer<double> {}type result  generictypeextractorfindgenericinterface(myinterfaceclass consumerclass)systemoutprintln(result)// output: interface javalangrunnable// expected output: javautilfunctionconsumer<javalangdouble>```mockito version: 2x 3xjava version: jdk8u202-b08;;1;0;1758: method generictypeextractor#findgenericinterface always returns first interface;
1773;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;added updatefieldpreferences;less dependency on jabrefpreferences in a small part of logic;;0;create a supplierbuilder just like cachebuilder;jensran@ this is related to #﻿1772there are a lot of similarities between a cache and a supplier really a supplier is a specific case of a loadingcache with a single key since the cachebuilder has become a useful pattern of constructing a cache i propose creating a supplierbuilder that incorporates much of the same properties as a cachebuilder this would make it easy to have weak/soft references (see #﻿1772) different eviction strategies as well as removallistener; one thing missing in `suppliershtml#memoize`&nbspis to be able to invalidate the result i propose the above solution also supports this ||;;;;0;1;;
1773;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;added updatefieldpreferences;less dependency on jabrefpreferences in a small part of logic;;0;fix intermittent test failures;;add a test with more map entries which is more likely to trigger the bug || ;;;;0;1;;
1773;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;added updatefieldpreferences;less dependency on jabrefpreferences in a small part of logic;;0;rxjava-core-0206jar not on maven central;only this stuff is there no library jar:```rxjava-core-0206pom  16-oct-2014 16 k   11016e3598798003671a65f303408d050915b399rxjava-core-0206pomasc  16-oct-2014 475 b   257e29bcad64114a88cb79a423308148628e3bc2rxjava-core-0206jarasc  16-oct-2014 475 b   98daba28d2ea5262ec074eb6e6f135d335602296rxjava-core-0206-javadocjar  16-oct-2014 8080 k 9e3b6d5329a3004dcab829d1cb4f57477dacbdffrxjava-core-0206-javadocjarasc  16-oct-2014 475 b   bc0dcec64e4224ce6a4e509f8dee7b2093128d20rxjava-core-0206-sourcesjar  16-oct-2014 3636 k d31f5b92f09011548a731553f9dc6ca3f86e5022rxjava-core-0206-sourcesjarasc  16-oct-2014 475 b   f8bfff8474a8565c15f3e5cd43743b20e81f1934```;"the files are on sonatype: central is sometimes extremely slow to show a new release but this partial release seems odd || maven central still does not show the library jar can this be re-released? || @davidmoten  || not there!on 20 oct 2014 19:03 ""michael nitschinger"" notifications@githubcomwrote:> @davidmoten   > —> reply to this email directly or view it on github>  || ooh i see whats going on - the actual jar is missing! javadoc and sources jar are there but the real one isnt - this must be a sonatype bug because normally they dont let you close a staged one like this || maven finds the dependency so it exists on maven central just doesnt get displayed on maven centrals web page for rxjava-core-0206: view is not important to me so closing || ";;;;0;1;;
1773;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;added updatefieldpreferences;less dependency on jabrefpreferences in a small part of logic;;1769.0;1769: clarify default strict stubbing behaviour in 300;similar to  as requested by @timvdlippe in  #1769; ;are strict stubs really the default in v3?;"the strictnessstrict_stubs javadoc reads: ""planned as default for mockito v3""im using ""orgmockito:mockito-core:300"" and strict stubs do not seem to be the default behaviour are they actually going to be the default in any release soon?";it is not mockito 3 only requires java 8 as minimum no other api changes were made could you submit a pr (similar to #1745) thats updates the doc? || what would be the easiest way of enabling it in junit 5 given that i’m already using another junit extension and lifecycle per class?`@extendwith(vertxextensionclass)``@testinstance(testinstancelifecycleper_class)` || @timvdlippe i just sent the pr any chance you could help me with the previous question? also is there an eta for v4? thanks very much || the junit 5 extension should already use strict stubs by default does it not? || it does in fact seem to use strict stubs but i just double-checked and it does not throw unnecessarystubbingexception when it should potentialstubbingproblem does work perfectly though ||;1;0;1769: clarify default strict stubbing behaviour in 300;
1781;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moved some logic preference instantiation to jabrefpreferences;less passing of jabrefpreferences for better long term architecture.;;0;optimalnumofhashfunctions() may not return what you expect; was experimenting with javascript code when i noticed this  if you call```optimalnumofhashfunctions(319 3072)```it returns 6 a quick javascript version returned 7 the reason is because the division acts only on integers and returns an integer in javascript everything is a float that is in java `3072 / 319`&nbspreturns 9 but in javascript it returns 963 maybe it was intentional to have an implicitly truncated value but im guessing not the fix would be something like:--- a/guava/src/com/google/common/hash/bloomfilterjava+++ b/guava/src/com/google/common/hash/bloomfilterjava@@ -3637 +3637 @@ public final class bloomfilter&ltt> implements predicate&ltt> serializable {&nbsp&nbsp&nbsp&nbsp*/&nbsp&nbsp&nbsp@﻿visiblefortesting&nbsp&nbsp&nbspstatic int optimalnumofhashfunctions(long n long m) {-    return mathmax(1 (int) mathround(m / n \* mathlog(2)))-    return mathmax(1 (int) mathround((float)m / n \* mathlog(2)))  &nbsp&nbsp&nbsp}&nbsp&nbsp&nbsp/**; oops yeah that was too fast :) || ";;;;0;1;;
1781;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moved some logic preference instantiation to jabrefpreferences;less passing of jabrefpreferences for better long term architecture.;;0;update release notes;;;;;;0;1;;
1781;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moved some logic preference instantiation to jabrefpreferences;less passing of jabrefpreferences for better long term architecture.;;0;backpressure: join;backpressure for `join` needs to be reviewed or implemented;i think this cant be reasonably implemented since elements of both sources trigger a separate duration observable backpressure delay could change what overlapping events are in addition once a source emits the value is combined with each open value from the other stream and thus controlling how many elements to emit is difficult it may mean that at a given time only a total of `rxringbuffersize` elements can be active in the form `left * right < rxringbuffersize` || yup backpressure messes up anything that involves time || i believe this operator cant really support backpressure without dropping buffering or simply erroring out the timing of the signals from the other observables and the cross-combination would skew ||;;;;0;1;;
1781;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moved some logic preference instantiation to jabrefpreferences;less passing of jabrefpreferences for better long term architecture.;;178.0;1780: close file handle to avoid a file-handle-leak;fix a small file-handle-leak which pops up when running tests with [file-leak-detector]( 1780;good catch this always gets me as the class name is *file ||;"mockito matchers used in ""when"" impact the ""there was one""";"if you use an `any` matcher in a `when` then if you later try and verify another method was called on the same mock it passes regardless of whether the arguments matchedexample when it (wrongly) passes as the method ""shouldbecalled"" is called but not with the given argument:``` scalaval mockedservice  mock[mockedservice]when(mockedservicemymethod(any)thenreturn(""response"")servicebeingtestedmethodbeingtestedthere was one(mockedservice)shouldbecalled(""incorrect argument"")```example when it fails as it should:``` scalaval mockedservice  mock[mockedservice]when(mockedservicemymethod(""actualargumentbeingused"")thenreturn(""response)servicebeingtestedmethodbeingtestedthere was one(mockedservice)shouldbecalled(""incorrect argument"")```";hi @timgent im not reproducing could you write a junit test reproducing the faced issue with the latest version of mockito and in java please || hiill close this issue as theres no feedback and no reproducible errors ||;1;0;1780: close file handle to avoid a file-handle-leak;
1781;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moved some logic preference instantiation to jabrefpreferences;less passing of jabrefpreferences for better long term architecture.;;1780.0;1780: close file handle to avoid a file-handle-leak;fix a small file-handle-leak which pops up when running tests with [file-leak-detector]( 1780;good catch this always gets me as the class name is *file ||;file-handle leak in inlinebytebuddymockmaker;using [file-leak-detector]( when running unit-tests using mockito-300 we see a file-handle-leak being reported in `inlinebytebuddymockmaker<clinit>` which can easily be  by closing the jarfile after usage properlyill send a pr shortly```#2 \mockitoboot2606807734337514236jar by thread:main on tue sep 17 15 43 cest 2019	at javautilzipzipfile<init>(zipfilejava:156)	at javautiljarjarfile<init>(jarfilejava:166)	at javautiljarjarfile<init>(jarfilejava:130)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmaker<clinit>(inlinebytebuddymockmakerjava:138)	at sunreflectnativeconstructoraccessorimplnewinstance0(native method)	at sunreflectnativeconstructoraccessorimplnewinstance(nativeconstructoraccessorimpljava:62)	at sunreflectdelegatingconstructoraccessorimplnewinstance(delegatingconstructoraccessorimpljava:45)	at javalangreflectconstructornewinstance(constructorjava:423)```;;1;0;1780: close file handle to avoid a file-handle-leak;
1783;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix npe when closing the last tab;the (new?) focus feature lead to an npe when closing the last tab since there was no table to focus -   - introduced in dev version -  manually tested changed features in running jabref;;0;case formatter handling of accronym from camel case;abecc@ when converting a caml case string to upper snake case the desired handling would be to consider the accronym (aka substring of only upcase caracters) as a single word instead the converter treats all consecutive upcase caracter as a single wordreproduce: systemoutprintln(lower_camelto(upper_underscore ""isbn""))(guava 17)result: i_s_b_ndesired output: isbn"; i know it should be the case but even java api is not consistent with acronyms in camel case (ex: url forget about this it might broke for sure existing usage and a found a way around by having a pre-treatment where i convert acronym to real camel case using the following pattern:&nbsp&nbsp/(?<\p{lower}|\a)(\p{upper}+)(?(\p{upper}\p{lower})|\z)/  (groovy string):) || this is waiand fwiw the java `url` class probably should have been named `url` || ";;;;0;1;;
1783;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix npe when closing the last tab;the (new?) focus feature lead to an npe when closing the last tab since there was no table to focus -   - introduced in dev version -  manually tested changed features in running jabref;;0;cleaned up state after stubbing misuse exception;1655; merging 1783  < ;;;;1;1;cleaned up state after stubbing misuse exception1655;
1783;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix npe when closing the last tab;the (new?) focus feature lead to an npe when closing the last tab since there was no table to focus -   - introduced in dev version -  manually tested changed features in running jabref;;0;specify table format in hive test script;;;;;;0;1;;
1783;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix npe when closing the last tab;the (new?) focus feature lead to an npe when closing the last tab since there was no table to focus -   - introduced in dev version -  manually tested changed features in running jabref;;0;improve retry signature;this commit  added a check on the retry signature so that a count of -1 could not be used to represent infinite retry can we get this back again? i ask because the current signature makes coding clunky for example my code was:``` javareturn source        concatmap(stuff)            retry(retries)```and because of the change it now has to be like this:``` javaobservable<boolean> s  source        concatmap(stuff)if (retries < 0)     //infinite    return sretry()else     return sretry(retries)```this is obviously a very minor change feel free to close if you dont care;"we are avoiding -1 as a ""magic value"" for things like this similar to the decision with backpressure `request(n)` i suggest using `longmax_value` to represent infinite retry since it takes a long and even if you did 1 retry per nanosecond (not going to happen) it would take you 292 years to hit the max value || sounds fair thanks ben ill close || ";;;;0;1;;
1787;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removed entry preview toolbar;has been disabled since long so might as well remove the code.  also cleaned up the preferences a bit. -  ;;0;map with immutable keyset; a map where a put on a not-defined key will throw a runtime(?) exception; ;;;;0;1;;
1787;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removed entry preview toolbar;has been disabled since long so might as well remove the code.  also cleaned up the preferences a bit. -  ;;0;invalid cassandra timestamp value;"cassandra table:```create table metrics_rollup60 (   name text  time timestamp  ""count"" counter  sum counter  primary key ((name) time))```cassandra new row:```update metrics_rollup60 set countcount+1 sumsum+900 where namebytes_sentmiss0100amd4 and time2013-06-28 15 00```prestodb query:```presto:storage> select * from metrics_rollup60            name            |     time      | count | sum----------------------------+---------------+-------+----- bytes_sentmiss0100amd4 | 1372432980000 |     1 | 900(1 row)``````presto:storage> select from_unixtime(time) from metrics_rollup60          _col0-------------------------- 45460-09-01 23 00000(1 row)```why last presto query is returning 45460 as date year? is it a bug or am i missing something?";after the patch #1655 - prestodb query result:```presto:test> select * from metrics_rollup60            name            |          time           | count | sum----------------------------+-------------------------+-------+----- bytes_sentmiss0100amd4 | 2013-06-28 15 00000 |     1 | 900(1 row)presto:test > describe metrics_rollup60 column |   type    | null | partition key--------+-----------+------+--------------- name   | varchar   | true | true time   | timestamp | true | false count  | bigint    | true | false sum    | bigint    | true | false(4 rows)``` || thank you @toxeh  ||;;;;0;1;;
1787;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removed entry preview toolbar;has been disabled since long so might as well remove the code.  also cleaned up the preferences a bit. -  ;;0;remove *withindex operators;see  -> remove takewhilewithindex & skipwhilewithindex;;;;;1;1;remove *withindex operatorssee  -> remove takewhilewithindex & skipwhilewithindex;
1787;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removed entry preview toolbar;has been disabled since long so might as well remove the code.  also cleaned up the preferences a bit. -  ;;1786.0;1786 : clarify differences between timeout and after;tries to improve the javadoc for `timeout` to differentiate it from `after` directly in the first sentence;"  the root cause can be  by pr #936 ""unification of timeout() and after() api"" || ";difference between timeout and after not immediately clear;the first few lines of the javadoc for both methods do not exactly specify their difference from `timeout` you have to jump to `after` where at the end of the javadoc the difference is explainedi think this can be improved the first sentence in `timeout` could be more specific to highlight the difference directly;;1;0;1786 : make differences between timeout and after more clear in javadoc;
1788;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;upgraded junit jupiter 5.1.1 -> 5.4.2;we need higher version of junit jupiter to reproduce and 1630;;0;make bytestreamstobytearray(inputstream int) public; id like to suggest making the&nbsp&nbspbytestreamstobytearray(inputstream in int expectedsize)method ""public"" rather than having package visibility im aware that limit() and the single-argument tobytearray() methods could be combined to achieve a similar effect but that would incur an extra array copy since tobytearray(inputstream in) uses bytearrayoutputstreams tobytearray() method"; dang it youre right -- i misread the code however i could still use it in combination with bytestreamslimit -- that would get me the behavior i would like ie avoiding the extra copy of bytestreamstoarray(inputstream) that would probably be too contrived as an api thoughthinking a bit more about it i think ill probably be better off just using a customized bytearrayoutputstream (to gain access to its internal buffer) and using bytestreamscopy()feel free to close this || this appears to be a duplicate of #2616 and the reporter said in their last comment that this issue can be closed ||;;;;0;1;;
1788;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;upgraded junit jupiter 5.1.1 -> 5.4.2;we need higher version of junit jupiter to reproduce and 1630;;0;nullpointerexception verifying schema in hiveclient;the code that verifies the table schema matches the partition schema can throw a npe at:   of the lists is likely null```comfacebookprestospiprestoexception: hive_unknown_error    at comfacebookprestohivehivesplitsourceprovider$hivesplitsourcepropagateprestoexception(hivesplitsourceproviderjava:589) ~[na:na]    at comfacebookprestohivehivesplitsourceprovider$hivesplitsourcegetnextbatch(hivesplitsourceproviderjava:532) ~[na:na]    at comfacebookprestoexecutionconnectorawaresplitsourcegetnextbatch(connectorawaresplitsourcejava:46) ~[presto-main-076jar:076]    at comfacebookprestoexecutionsqlstageexecutionschedulesourcepartitionednodes(sqlstageexecutionjava:633) [presto-main-076jar:076]    at comfacebookprestoexecutionsqlstageexecutionstarttasks(sqlstageexecutionjava:554) [presto-main-076jar:076]    at comfacebookprestoexecutionsqlstageexecutionaccess$200(sqlstageexecutionjava:93) [presto-main-076jar:076]    at comfacebookprestoexecutionsqlstageexecution$4run(sqlstageexecutionjava:526) [presto-main-076jar:076]    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:471) [na:170_51]    at javautilconcurrentfuturetaskrun(futuretaskjava:262) [na:170_51]    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1145) [na:170_51]    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:615) [na:170_51]    at javalangthreadrun(threadjava:744) [na:170_51]caused by: javalangnullpointerexception: null    at comfacebookprestohivehiveclient$1apply(hiveclientjava:1068) ~[na:na]    at comfacebookprestohivehiveclient$1apply(hiveclientjava:1039) ~[na:na]    at comgooglecommoncollectiterators$8transform(iteratorsjava:794) ~[guava-1601jar:na]    at comgooglecommoncollecttransformediteratornext(transformediteratorjava:48) ~[guava-1601jar:na]    at comgooglecommoncollecttransformediteratornext(transformediteratorjava:48) ~[guava-1601jar:na]    at comgooglecommoncollectiterators$5hasnext(iteratorsjava:543) ~[guava-1601jar:na]    at comfacebookprestohivehivesplitsourceproviderloadpartitionsplits(hivesplitsourceproviderjava:190) ~[na:na]    at comfacebookprestohivehivesplitsourceprovideraccess$100(hivesplitsourceproviderjava:80) ~[na:na]    at comfacebookprestohivehivesplitsourceprovider$2run(hivesplitsourceproviderjava:172) ~[na:na]    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:471) [na:170_51]    at javautilconcurrentfuturetaskrun(futuretaskjava:262) [na:170_51]    at comfacebookprestohiveutilboundedexecutorexecuteormerge(boundedexecutorjava:82) ~[na:na]    at comfacebookprestohiveutilboundedexecutoraccess$000(boundedexecutorjava:41) ~[na:na]    at comfacebookprestohiveutilboundedexecutor$1run(boundedexecutorjava:53) ~[na:na]     3 common frames omitted```;still unsolved in 079 version || the source of the error is now at: ||  in #2426 ||;;;;0;1;;
1788;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;upgraded junit jupiter 5.1.1 -> 5.4.2;we need higher version of junit jupiter to reproduce and 1630;;0;remove publishlast/initialvalue;see https://githubcom/reactivex/rxjava/issues/1785;reviewed with @headinthebox  ||;;;;1;1;remove publishlast/initialvaluesee https://githubcom/reactivex/rxjava/issues/1785;
1788;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;upgraded junit jupiter 5.1.1 -> 5.4.2;we need higher version of junit jupiter to reproduce and 1630;;1630.0;upgraded junit jupiter 511 -> 542;we need higher version of junit jupiter to reproduce and 1630added a test to enhance coverage; merging 1788 ! ||;mockito junit jupiter extension does not correctly support parallel test execution;"sorry for not being able to provide the required information but we just noticed that the mockitoextension (mockito-junit-jupiter 2245) leads to spurious test failures (eg due to calls to mocks not being recorded) when using ""junitjupiterexecutionparallelenabledtrue"" with surefire prior we used our much simpler mockitoextension which works fine in the same situation:```javapublic class mockitoextension implements extension testinstancepostprocessor aftereachcallback {   @override   public void postprocesstestinstance(object testinstance extensioncontext context) {      mockitoannotationsinitmocks(testinstance)   }   @override   public void aftereach(extensioncontext extensioncontext) throws exception {      mockitovalidatemockitousage()   }}```";"hey! can you take a look at our faq wiki we documented how mockito supports parallel execution || i took a look at the wiki but found just a very short section about parallel testing in the faq section i issued the bug because the parallel execution of whole test cases with junit 5 seems to be broken i do not have any complex tests which use mocks in combination with multithreadinganyway this seems to be a problem of the mockitoextension not mockito itself because with our simple junit 5 extension for mockito parallel execution of test cases which use mocks with junit 5 works fine || i got a similar issue i have got a workaround if only a few of your ""mockito""-test-classes in you testsuite are failing when running junit jupiter in parallel you can execute those problematic tests using ""same_thread"" for avoiding mockito concurrency issues```import orgjunitjupiterapiextensionextendwithimport orgjunitjupiterapiparallelexecutionimport orgjunitjupiterapiparallelexecutionmodeimport orgmockitojunitjupitermockitoextension@extendwith(mockitoextensionclass)@execution(executionmodesame_thread) // <--- workaroundclass sometest {``` || to be a bit more specific wantedbutnotinvoked exceptions are thrown by verification calls failing because of not recorded invocations: ""actually there were zero interactions with this mock"" || the main difference between the current and the simple implementation above is that the simple one inits the mocks in postprocesstestinstance() whereas the current one inits them in beforeeach() any ideas why that might be a problem? i tried the failing tests with a modified version of the current mockitoextension which was just altered to init the mocks in postprocesstestinstance() and disabled the init in beforeeach() and the tests do no longer fail so this seems to be the source of the problems || hey guys can you provide us a test that reproduces the problem?  @mockitoguy here you go:  am not sure if i reduced the example as much as possible but well the project is not large || thank you! the sample project looks great!i looked at the code but i havent had time to debug it how does the junit5 parallel execution work? are we sharing the test instance (and thus sharing mocks suts?) || you are welcome :-) i dont know details about junits parallelization || > how does the junit5 parallel execution work? are we sharing the test instance (and thus sharing mocks suts?)by default not and the user must be very explicit to enable sharing of the same test class instance with parallel execution enabled ie even if parallel execution mode is enabled by default and a test class is annotated with `lifecycleper_class` its tests will still be executed sequentially _unless_ it is also annotated with `@execution(concurrent)`:  also bumped into this issue in our codebase with some tests using `mockitoextension` failing in parallel mode and some working fine could not spot anything particularly special about the failing ones || i can confirm that the problem exists i also have tests using mockitoextension and they fail in a non-deterministic way randomly only if junit5 parralelization is used || scenario:1 junit 5 creates a single `classextensioncontext `for a multithreaded test but each thread becomes an instance of the test class2 each thread will come into `postprocesstestinstance `where they put their test instance in the same `classextensioncontextgetstore(mockito)` map with the same key (`test_instance`)3 each thread then will get into `beforeeach` they get a thread unique `methodextensioncontext` but each of them contain the same instance of `classextensioncontext` then they fetch the the last updated `test_instance `from the parent `classextensioncontext `inside the `collectparenttestinstances `method each thread gets quasi a random test instance depending on the fact which thread was before inside the `postprocesstestinstance `method then they prepare their broken session inside the store of the current `methodextensioncontext `with a random test instance includedthat is the explanation i am thinking about how to solve thisit is not 100% clear to me why the parent context test instance is included i will check how this scenario looks like in a singlethreaded environment || this is really painful to debug but im making progress what i found out is that ""collectparenttestinstances()"" is non-deterministic:```thread[16] collectparenttestinstances() - returns: [orgmockitoanothertest@2bf588f6]thread[13] collectparenttestinstances() - returns: [orgmockitoanothertest@240da1f5 orgmockitoanothertest@6646267a]thread[17] collectparenttestinstances() - returns: [orgmockitoanothertest@6646267a]thread[14] collectparenttestinstances() - returns: [orgmockitoanothertest@f9b9d48]```notice that anothertest@6646267a is processed twice effectively initmocks() is called twice for that test instance clearing up the invocationsdo you have an idea how to fix collectparenttestinstances()? || perhaps we drop the collectparenttestinstances() complexity and just keep the test instances in static threadlocal object in the extension postprocesstestinstance() feeds the thread local state beforeeach() consumes it i dont know enough about the ""context store"" api though || i have a plan how to fix it first we need to upgrade junit-jupiter (#1788) || @mockitoguy i am not sure why you have closed the issue in the attached commit i cannot see the fix for the problemcontext store api seems to be pretty simple to me it is just a map in the context to store some information the real question is what is this kind of context hierarchy used for in junit 5 and how it behaves in case of nested tests or multithreaded tests or even in multithreaded nested tests i guess it could have some interesting beahaviour in case of parameterized (dynamic) tests probably it would be a good idea simply to ask the junit developers about this issue maybe they could provide some valuable feedback || pr #1789 fixes the problem this ticket got closed by accident thanks for looking into it! || looking forward to the next release!i would like to confirm the bug is gone but i dont know how to do it in  someone add a pr to  using mockito 3012 (at least)?  || release have been already published see  || @mockitoguy when will this fix be released to maven central? || i will publish a release today || i updated  - seems to work without problems using mockito v310 thanks a lot!i will delete  within a few weeks || publish to maven central failed yet again i will need to contact sonatype again || (although  does exist so it might just work) || i can confirm that the solution of 310 version works for all of the tests in my project still i dont understand how junit works but it is fine now since the tests workthanks for your fast fix & release! || ";1;0;bumped junit jupiter and added a testadded a test to enhance coverage we need higher version of junit jupiter to reproduce and 1630;
1789;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replace all file dialogs with new filedialog;and set default filefilter or aggregate filefilter for all supported types. -  database from aux -  remove browseaction;;0;use normal code path for dropping test tables;;;;;;0;1;;
1789;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replace all file dialogs with new filedialog;and set default filefilter or aggregate filefilter for all supported types. -  database from aux -  remove browseaction;;0;groupedobservablefrom/create;see https://githubcom/reactivex/rxjava/issues/1668;;;;;1;1;groupedobservablefrom/createsee https://githubcom/reactivex/rxjava/issues/1668;
1789;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;replace all file dialogs with new filedialog;and set default filefilter or aggregate filefilter for all supported types. -  database from aux -  remove browseaction;;1630.0; junit jupiter parallel issue;1630this fix improves mockito junit jupiter extension however it does not completely resolve all kinds of parallel issues when nested test classes are used ill open a separate ticket for it; merging 1789  < ;mockito junit jupiter extension does not correctly support parallel test execution;"sorry for not being able to provide the required information but we just noticed that the mockitoextension (mockito-junit-jupiter 2245) leads to spurious test failures (eg due to calls to mocks not being recorded) when using ""junitjupiterexecutionparallelenabledtrue"" with surefire prior we used our much simpler mockitoextension which works fine in the same situation:```javapublic class mockitoextension implements extension testinstancepostprocessor aftereachcallback {   @override   public void postprocesstestinstance(object testinstance extensioncontext context) {      mockitoannotationsinitmocks(testinstance)   }   @override   public void aftereach(extensioncontext extensioncontext) throws exception {      mockitovalidatemockitousage()   }}```";"hey! can you take a look at our faq wiki we documented how mockito supports parallel execution || i took a look at the wiki but found just a very short section about parallel testing in the faq section i issued the bug because the parallel execution of whole test cases with junit 5 seems to be broken i do not have any complex tests which use mocks in combination with multithreadinganyway this seems to be a problem of the mockitoextension not mockito itself because with our simple junit 5 extension for mockito parallel execution of test cases which use mocks with junit 5 works fine || i got a similar issue i have got a workaround if only a few of your ""mockito""-test-classes in you testsuite are failing when running junit jupiter in parallel you can execute those problematic tests using ""same_thread"" for avoiding mockito concurrency issues```import orgjunitjupiterapiextensionextendwithimport orgjunitjupiterapiparallelexecutionimport orgjunitjupiterapiparallelexecutionmodeimport orgmockitojunitjupitermockitoextension@extendwith(mockitoextensionclass)@execution(executionmodesame_thread) // <--- workaroundclass sometest {``` || to be a bit more specific wantedbutnotinvoked exceptions are thrown by verification calls failing because of not recorded invocations: ""actually there were zero interactions with this mock"" || the main difference between the current and the simple implementation above is that the simple one inits the mocks in postprocesstestinstance() whereas the current one inits them in beforeeach() any ideas why that might be a problem? i tried the failing tests with a modified version of the current mockitoextension which was just altered to init the mocks in postprocesstestinstance() and disabled the init in beforeeach() and the tests do no longer fail so this seems to be the source of the problems || hey guys can you provide us a test that reproduces the problem?  @mockitoguy here you go:  am not sure if i reduced the example as much as possible but well the project is not large || thank you! the sample project looks great!i looked at the code but i havent had time to debug it how does the junit5 parallel execution work? are we sharing the test instance (and thus sharing mocks suts?) || you are welcome :-) i dont know details about junits parallelization || > how does the junit5 parallel execution work? are we sharing the test instance (and thus sharing mocks suts?)by default not and the user must be very explicit to enable sharing of the same test class instance with parallel execution enabled ie even if parallel execution mode is enabled by default and a test class is annotated with `lifecycleper_class` its tests will still be executed sequentially _unless_ it is also annotated with `@execution(concurrent)`:  also bumped into this issue in our codebase with some tests using `mockitoextension` failing in parallel mode and some working fine could not spot anything particularly special about the failing ones || i can confirm that the problem exists i also have tests using mockitoextension and they fail in a non-deterministic way randomly only if junit5 parralelization is used || scenario:1 junit 5 creates a single `classextensioncontext `for a multithreaded test but each thread becomes an instance of the test class2 each thread will come into `postprocesstestinstance `where they put their test instance in the same `classextensioncontextgetstore(mockito)` map with the same key (`test_instance`)3 each thread then will get into `beforeeach` they get a thread unique `methodextensioncontext` but each of them contain the same instance of `classextensioncontext` then they fetch the the last updated `test_instance `from the parent `classextensioncontext `inside the `collectparenttestinstances `method each thread gets quasi a random test instance depending on the fact which thread was before inside the `postprocesstestinstance `method then they prepare their broken session inside the store of the current `methodextensioncontext `with a random test instance includedthat is the explanation i am thinking about how to solve thisit is not 100% clear to me why the parent context test instance is included i will check how this scenario looks like in a singlethreaded environment || this is really painful to debug but im making progress what i found out is that ""collectparenttestinstances()"" is non-deterministic:```thread[16] collectparenttestinstances() - returns: [orgmockitoanothertest@2bf588f6]thread[13] collectparenttestinstances() - returns: [orgmockitoanothertest@240da1f5 orgmockitoanothertest@6646267a]thread[17] collectparenttestinstances() - returns: [orgmockitoanothertest@6646267a]thread[14] collectparenttestinstances() - returns: [orgmockitoanothertest@f9b9d48]```notice that anothertest@6646267a is processed twice effectively initmocks() is called twice for that test instance clearing up the invocationsdo you have an idea how to fix collectparenttestinstances()? || perhaps we drop the collectparenttestinstances() complexity and just keep the test instances in static threadlocal object in the extension postprocesstestinstance() feeds the thread local state beforeeach() consumes it i dont know enough about the ""context store"" api though || i have a plan how to fix it first we need to upgrade junit-jupiter (#1788) || @mockitoguy i am not sure why you have closed the issue in the attached commit i cannot see the fix for the problemcontext store api seems to be pretty simple to me it is just a map in the context to store some information the real question is what is this kind of context hierarchy used for in junit 5 and how it behaves in case of nested tests or multithreaded tests or even in multithreaded nested tests i guess it could have some interesting beahaviour in case of parameterized (dynamic) tests probably it would be a good idea simply to ask the junit developers about this issue maybe they could provide some valuable feedback || pr #1789 fixes the problem this ticket got closed by accident thanks for looking into it! || looking forward to the next release!i would like to confirm the bug is gone but i dont know how to do it in  someone add a pr to  using mockito 3012 (at least)?  || release have been already published see  || @mockitoguy when will this fix be released to maven central? || i will publish a release today || i updated  - seems to work without problems using mockito v310 thanks a lot!i will delete  within a few weeks || publish to maven central failed yet again i will need to contact sonatype again || (although  does exist so it might just work) || i can confirm that the solution of 310 version works for all of the tests in my project still i dont understand how junit works but it is fine now since the tests workthanks for your fast fix & release! || ";1;0;cleanup traversal of parent contexts;
1790;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;made output of metadata.getencoding() optional;;;0;immutablecollectiontoarray() calls size() twice; in immutablecollectiontoarray() the result of size() is stored in a local variable and then the size() method is invoked again; ;;;;0;1;;
1790;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;made output of metadata.getencoding() optional;;;0;enable spotless to automatically format our source code;spotless [1] has been used by various popular open source projectsincluding junit [2] while working on mockito inside of google idiscovered that our formatting is inconsistent we can use spotless toautomatically take care of thatto be able to format the source code run/gradlew spotlessapplythis check runs on travis to make sure code remains formatted thisshould also reduce the amount of trouble with the checkstyle linter asspotless will automatically resolve these issueson purpose the spotless configuration is quite minimal the currentconfiguration is mostly a reflection on the current state of affairs wecan later discuss different configuration options and how we canintegrate them[1]:  https://githubcom/junit-team/junit5/blob/3f491f3148d2c745808fc75b0a802b60243e104e/buildgradlekts#l124-l144; ;;;;1;1;enable spotless to automatically format our source codespotless [1] has been used by various popular open source projectsincluding junit [2] while working on mockito inside of google idiscovered that our formatting is inconsistent we can use spotless toautomatically take care of thatto be able to format the source code run/gradlew spotlessapplythis check runs on travis to make sure code remains formatted thisshould also reduce the amount of trouble with the checkstyle linter asspotless will automatically resolve these issueson purpose the spotless configuration is quite minimal the currentconfiguration is mostly a reflection on the current state of affairs wecan later discuss different configuration options and how we canintegrate them[1]:  https://githubcom/junit-team/junit5/blob/3f491f3148d2c745808fc75b0a802b60243e104e/buildgradlekts#l124-l144;
1790;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;made output of metadata.getencoding() optional;;;0;minor session property fix;ive found some minor issues at setting session propertiesalso connectorsession which can be used in custom udf might need to access the system session properties;merged except for the change to `sessiontoconnectorsession()` || can you tell us about your use case for functions taking session properties? this seems a bit weird given that functions already take arbitrary parameters :) || our use case is a scheduled query select  from time > scheduled_time() a cron like system sends the same query at its schedule and the scheduled_time is not exactly same as now() at hive weve set the real scheduled_time of the query at a environment variable then a hive udf returns the values from the environment variables when it is calledwe want to use the same behavior at presto a presto client set the real scheduled_time at the session properties and a presto udf returns the value from the property || complement to @miniway:a typical hourly scheduled query is like this:select count(1) from xyz where now() - interval 1 hour < time and time < now()but this doesnt work well because now() is slightly delayed since 00:00 so we want to add scheduled_time() function which returns the time when query is scheduled for for example- scheduled_time(): `2014-01-01 00 00`- now(): `2014-01-01 00 03` (_usually_ slightly after scheduled_time())you may think we can use this query instead:select count(1) from xyz where date_trunc(hour now()) - interval 1 hour < time and time < date_trunc(hour now())this almost works but it is not a complete solution because _occasionally_ users want to rerun formerly scheduled queries again for several reasons (data was broken query was wrong query failed query result storage was down etc)i think alternative idea is to allow clients to overwrite sessionstarttime to fake (sort of fake) the result of now() || we found that we can add a custom optimizer which replaces scheduled_time() function call to a constant set in sessionsystemproperties im not sure whether this is smart idea or not but it works without connectorsession change || im probably missing something but this seems like a normal query parameter:```select count(1) from xyz where ? - interval 1 hour < time and time < ?```we dont yet support bind variables on the server side but it seems easy enough to do it on the client before executing the query || @electrum thank you for your comment thats almost right but we wanted to avoid lexer implementation simple character replacement causes a problem with ? in a quoted string like this: ` where regexp_like(digits [1-9]?[0-9])` || if youre in java check out jdbi it has a query lexer that handles named bind variables || thats good to know but in fact its in ruby ||;;;;0;1;;
1790;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;made output of metadata.getencoding() optional;;;0;time marker is reset when schedule is immediate;;hi @ylecaillez would you mind providing a description of the issue and what your fix is? also can you do a pull request that doesnt modify the whitespace and javadoc formatting of the file? || hi @ylecaillez would you like to help get this cleaned up and merged? || hi ! sure please let me a bit more time because im quite busy those days i should be able to clean things up for the end of this week best regards || thanks  || i manually merged this in  ||;;;;0;1;;
1792;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix grammar;past tense of  to nest  is  nested . also fix plenking.;;0;fix grammar;"past tense of ""to nest"" is ""nested"" also fix plenking";;;;;1;1;"fix grammarpast tense of ""to nest"" is ""nested"" also fix plenking";
1792;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix grammar;past tense of  to nest  is  nested . also fix plenking.;;0; where scanfilterandproject with pagesource might skip data;this can happen when processing the last page due to a broken checkin the isfinished() method the implementation needs to check whethertheres a partial page pending processing before indicating the operatoris done;;;;;0;1;;
1792;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix grammar;past tense of  to nest  is  nested . also fix plenking.;;1791.0;fix for #1791;1791 dont retry (subscribe) to source if child has unsubscribed;thank you for identifying and fixing this ||;observable#first causes retrywhen to trigger retry without an exception;"noticed this behavior using rx-netty as internally it does a take(1) internally:```    atomiclong inc  new atomiclong(0)    observableonsubscribe<long> onsubscribe  subscriber -> {        final long emit  incgetandincrement()        loggerinfo(""emitting: {}"" emit)        subscriberonnext(emit)        subscriberoncompleted()    }    loggerinfo(""done: {}"" observablecreate(onsubscribe)                    retrywhen(attempt -> attemptzipwith(observablerange(1 4) (n i) -> i))                    toblocking()                    first()    )```the test output is:    emitting: 0    emitting: 1    done: 0as you can see the observable is subscribed to twice this is because take in combination with single causes the retrywhen producer to request another item";manually merged in  you @alexwen for submitting a bug report and then this fix! ||;1;0;fix for #1791 - dont retry (subscribe) to source if child has unsubscribed;
1795;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;typos and upcoming warnings;fixed some typos which where found by a spell checker.;;0;are there plans for an immutableoptionallist?; since immutablelists dont accept nulls are there any plans for something like:```immutableoptionallist<t> extends immutablelist<optional<t>>```so that i can construct it with:``` immutableoptionallistof(""foo"" null ""bar"")```and get essentially the behavior as:``` immutablelistof(optionalof(""foo"") optionalabsent() optionalof(""bar""))```i could write this myself but only at a fairly higher storage cost than if guava did it:  the cost of constructing an immutablelist costs an array of n elements but i also have to allocate the n optional elements upfront and those optionals have to stick around for the lifetime of the immutablelista guava immutableoptionallist could be more efficient than this: it could have the same permanent storage cost as an immutablelist (ie only the array of n objects some of which might be null) and the optionals could be lazily created as elements were accessed where an implementation might vaguely look like this:```public t get(int index) {  t t  thisdelegate()get(index)  return (t  null) ? optionalof(t) : optionalabsent()}```(i would expect/hope that in practice the allocation costs for these temporary objects would get optimized away at runtime by the jvm especially in loops that iterate over the whole list?) if guava did choose to supply this i dont think that it would necessarily lead to requests for other immutable/optional combination classes like an immutableoptionalset or immutablemapwithoptionalvalues  (a set version doesnt seem to make sense since it would have at most one optionalabsent() elementand immutablemaps already have enough allocation per entry that the incremental cost of one optional per value seems less significant  this request is only for immutableoptionallist and only if the intuition is correct that it would be a roughly 50% space savings over the best a user can get by rolling their own immutablelist&ltoptional>apologies if this has already been discussed and/or is a duplicate request"; i dont think that adding a whole new suite of apis for this makes sense just wrap elements in optionalof/fromnullable as needed--- ;;;;0;1;;
1795;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;typos and upcoming warnings;fixed some typos which where found by a spell checker.;;0;typos and upcoming warnings; some typos which where found by a spell checkercheck list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_; merging 1795 ` ;;;;1;1;typos;
1795;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;typos and upcoming warnings;fixed some typos which where found by a spell checker.;;0;hive page source updates;;;;;;0;1;;
1795;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;typos and upcoming warnings;fixed some typos which where found by a spell checker.;;0;question regarding `retrywhen` source observable errors;"one thing id like to be able to do is catch any final errors and report them right now `retrywhen` will cause the subscriber to ignore 100% of the errors (unless the observable passed to `retrywhen` sends an `onerror` of course) `retry` and `retrywhen` at least in one of my use cases in a user-facing application mean ""lets wait a sec or try to fix something and then try again""  if this collection of retry attempts completely fails itd be nice to know that instead of just ending up with a `oncompleted` which doesnt tell me whether the thing im potentially retrying ultimately succeeded or failed altogetheris there another way of accomplishing this?";after thinking about this some more i think its actually reasonable for `retrywhen`s arguments to determine when to quit like the example mostly shows the missing ingredient in my use case was to just bubble the error back up from within instead of a `oncompleted` not sure why i didnt think of that earlier ||;;;;0;1;;
1798;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo in the wiki link;1791;;0;remove the import-package of javaxinject; in the pomxml the dependency on javaxinject has been removed but in the &ltimport-package> of the maven bundle plugin configuration there is still a reference to javaxinject optionalthat should be removed too; thanks for the report this has been  and the change will show up the next time we sync--- ;;;;0;1;;
1798;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo in the wiki link;1791;;0;typesignature;;just noticed theres a test failure ill fix that before commiting || looks goodid land this asap to avoid conflicts  then id sweep through the code again and look for uses of `parsetypesignature` and `typesignaturetostring` to see they can be removed also  specifically we may want to introduce constant `typesignature` instances for the standard types ||;;;;0;1;;
1798;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo in the wiki link;1791;;0;remove `not` class;related to #1797 should we remove the `not` class?;;;;;0;1;;
1798;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo in the wiki link;1791;;1791.0;fix typo in the wiki link;1791check list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `fixes #<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_; ;"typo in mockitojava javadoc: ""verification"" in wiki link";" a missing ""i"" in the wiki link:```https://githubcom/mockito/mockito/wiki/greedy-algorithm-of-verfication-inorderhttps://githubcom/mockito/mockito/wiki/greedy-algorithm-of-verification-inorder```";feel free to send a pr! ||;1;0;fix typo in the wiki link1791;
1799;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixes placeholder  3.x.x  version in javadoc with correct  3.0.1;this is a small javadoc fix;;0;missing use case: transforming optional to optional;jensran@ i have a use case where i am transforming an `optional` transforming it into the value of a member variable the issue: the member variable can be null so id like to convert it to an optional if it existsproposal:class optional&ltt>  {&nbsp&nbsp&nbsp&nbsp```public optional<f> optional#transformtooptional(function<t f> transformer) {    try {        return thistransform(transformer)    catch (nullpointerexception e) {        return optional<f>absent()    }}```}(which reservations to typos and probably not catching nullpointerexception in real implementation instead checking for null); ive reported similar issue in october 2012 and cannot wait for resolution see  (the cause of npe can be arbitrary so i feel weird of globally catching npe instead i suggested transforming null result to optional which eventually showed to be consistent with jdk8) || kevin [recently said]( im sorry but the legacy optional class is indeed frozenim closing this and any other `optional` feature requests i see floating around ||;;;;0;1;;
1799;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixes placeholder  3.x.x  version in javadoc with correct  3.0.1;this is a small javadoc fix;;0;fixes placeholder `3xx` version in javadoc with correct `301`;this is a small javadoc fixwhen i contributed with #1733 i didnt know which version of mockito will have included it so i left a placeholder `3xx` in the javadoc i then forgot to update the code once `301` was tagged; ;;;;1;1;fixes placeholder `3xx` version in javadoc with correct `301`;
1799;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixes placeholder  3.x.x  version in javadoc with correct  3.0.1;this is a small javadoc fix;;0;update 079 release notes;;;;;;0;1;;
1799;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixes placeholder  3.x.x  version in javadoc with correct  3.0.1;this is a small javadoc fix;;0;remove actions utility methods;related to #1797 it looks like we should remove the following unused methods in `actions`:``` java    public static <t> action1<t> onnextfrom(final observer<t> observer) {    public static <t> action1<throwable> onerrorfrom(final observer<t> observer) {    public static <t> action1<t> onnextfrom(final observer<t> observer) {```;i added them to support the join patterns but only onerrorfrom was ever used they can be deleted from core but onerrorfrom needs to be moved over and actualized in plan1plann ||;;;;0;1;;
1806;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed junit5 concurrency bug;fixed junit jupiter mockitoextension so that it behaves correctly in a parallel execution with nested tests. i found this issue recently when working on the extension. threadlocal here is ok but i m happy to use a different solution if someone has a better idea.;;0;exceptionininitializererror; hiive got this:javalangexceptionininitializererror&nbsp&nbsp&nbsp&nbspat comgooglecommonbasesplitter&ltinit>(sourcefile:110)&nbsp&nbsp&nbsp&nbspat comgooglecommonbasesplitteron(sourcefile:174)&nbsp&nbsp&nbsp&nbspat comxybaseapplicationcount(sourcefile:900)&nbsp&nbsp&nbsp&nbspat comxychecknewappsdoinbackground(sourcefile:106)&nbsp&nbsp&nbsp&nbspat comxychecknewappsdoinbackground(sourcefile:1)&nbsp&nbsp&nbsp&nbspat androidosasynctask$2call(asynctaskjava:288)&nbsp&nbsp&nbsp&nbspat javautilconcurrentfuturetaskrun(futuretaskjava:237)&nbsp&nbsp&nbsp&nbspat androidosasynctask$serialexecutor$1run(asynctaskjava:231)&nbsp&nbsp&nbsp&nbspat javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1112)&nbsp&nbsp&nbsp&nbspat javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:587)&nbsp&nbsp&nbsp&nbspat javalangthreadrun(threadjava:811)caused by: javalangunsupportedoperationexception&nbsp&nbsp&nbsp&nbspat comgooglecommonbasecharmatchera(sourcefile:775)&nbsp&nbsp&nbsp&nbspat comgooglecommonbasecharmatcher&ltclinit>(sourcefile:212)&nbsp&nbsp&nbsp&nbsp 11 morethis is the code:&nbsppublic int count(string string string substring) {&nbsp&nbsp&nbspint count0&nbsp&nbsp&nbsptry{&nbsp&nbsp&nbsp&nbspcount  iterablessize(splitteron(substring)split(string)) - 1&nbsp&nbsp&nbsp} catch (exception e){&nbsp&nbsp&nbsp}yes count   is the line 900?how can it be? it comes from galaxy s3 444thanks; is it uptodate? seems to be a bit old || given that this is very old and we havent gotten an update im declaring bankruptcy on this report || ";;;;0;1;;
1806;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed junit5 concurrency bug;fixed junit jupiter mockitoextension so that it behaves correctly in a parallel execution with nested tests. i found this issue recently when working on the extension. threadlocal here is ok but i m happy to use a different solution if someone has a better idea.;;0; junit5 concurrency bug; junit jupiter mockitoextension so that it behaves correctly in a parallel execution with nested tests i found this issue recently when working on the extension threadlocal here is ok but im happy to use a different solution if someone has a better ideaadded a new test that was failing prior to this change;> travis is not happy about it :(i made him happy now :-) ||  merging 1806 ;;;;1;1; junit5 concurrency bugfixed junit jupiter mockitoextension so that it behaves correctly in a parallel execution with nested tests i found this issue recently when working on the extension;
1806;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed junit5 concurrency bug;fixed junit jupiter mockitoextension so that it behaves correctly in a parallel execution with nested tests. i found this issue recently when working on the extension. threadlocal here is ok but i m happy to use a different solution if someone has a better idea.;;0;aggregation and ml plugin improvements;;other than the minor comments ;;;;0;1;;
1806;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed junit5 concurrency bug;fixed junit jupiter mockitoextension so that it behaves correctly in a parallel execution with nested tests. i found this issue recently when working on the extension. threadlocal here is ok but i m happy to use a different solution if someone has a better idea.;;0;remove unnecessary utilities;remove utility methods and classes as per  and https://githubcom/reactivex/rxjava/issues/1798;;;;;1;1;remove `not` classas per https://githubcom/reactivex/rxjava/issues/1798;
1807;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add default implementation for verificationmode#description;this method was added in mockito 2 ([1]) and was implemented in all;;0;hashcodefromstring() expects string with an even number of characters; hashcodefromstring() expects an even number of characters making it impossible to get the hash of a string like ""foo""hashfunctionhashstring() does not have this limitation in my opinion the above mentioned function shouldnt have it either"; completely missed that while reading the docs even though it clearly says so my bad thanks for the quick reply || ";;;;0;1;;
1807;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add default implementation for verificationmode#description;this method was added in mockito 2 ([1]) and was implemented in all;;0;add default implementation for verificationmode#description;this method was added in mockito 2 ([1]) and was implemented in allrelevant subclasses however most subclasses do not implement a customdescriptionsince we are now building on java 8 we can ship this as a defaultmethod and remove all duplicate subclass implementations as aside-effect it allows users of mockito 1 to migrate to mockito 3without additional breakages (they could implement it butverificationmodefactory is internal and would require additionalboilerplate)[1]: https://githubcom/mockito/mockito/pull/68; merging 1807 ;;;;1;1;add default implementation for verificationmode#descriptionthis method was added in mockito 2 [1] and was implemented in allrelevant subclasses however most subclasses do not implement a customdescriptionsince we are now building on java 8 we can ship this as a defaultmethod and remove all duplicate subclass implementations as aside-effect it allows users of mockito 1 to migrate to mockito 3without additional breakages (they could implement it butverificationmodefactory is internal and would require additionalboilerplate)[1]: https://githubcom/mockito/mockito/pull/68;
1807;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add default implementation for verificationmode#description;this method was added in mockito 2 ([1]) and was implemented in all;;0;make errorcode an interface;;errorcode is currently json-serializable how does that work with the new structure?also im not convinced we should introduce a type hierarchy for error codes(i havent look at the code yet) || the serialization seems a bit hacky what about an errorcodesupplier interface that things like standarderrorcode implement? then make prestoexception take that instead of errorcode this keeps call sites and serialization clean || sure i can do that instead || rename the commit message || ;;;;0;1;;
1807;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add default implementation for verificationmode#description;this method was added in mockito 2 ([1]) and was implemented in all;;0;incorrect documentation of share;the documentation states that `share` _returns a new observable that multicasts (shares) the original observable as long as there is more than one subscriber this observable will be subscribed and emitting data_i believe it should state **at least one** instead of **more than one**;good point /cc @davidmgross  || got it folks shouldnt feel shy about making their own changes to thejavadocs when they see problems like thison wed oct 29 2014 at 10:26 am ben christensen notifications@githubcomwrote:> good point /cc @davidmgross  > —> reply to this email directly or view it on github>  david m grossplp consulting || ok next time ill try not to be that shy about small tasks like this :) ||;;;;0;1;;
1809;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;update javadoc.io link from /page/ to /doc/  which gives an extra nav…;… bar on the top so that users can easily navigate to old versions;;0;internetdomainnametopprivatedomain() fails on suffix  et - ethiopia and zm - zambia; when calling topprivatedomain() on a domain that ends with et - ethiopia or zm - zambia   i get an illegalstateexception stating that the domain is ""not under a public suffix""et - ethiopia and zm - zambia is on the public suffix list and should return true"; example :  || i cant reproduce this bug with the current version (271-jre) the following unit test passed:```javaimport comgooglecommonnetinternetdomainnameimport orgjunittestimport static orghamcrestcorematchersequaltoimport static orghamcrestcorematchersisimport static orghamcrestmatcherassertassertthatpublic class internetdomainnametest {    @test    public void topprivatedomainet() {        internetdomainname privatedomain  internetdomainname                from(""wwwethiotelecomet"")                topprivatedomain()        assertthat(privatedomaintostring() is(equalto(""ethiotelecomet"")))    }    @test    public void topprivatedomainzm() {        internetdomainname privatedomain  internetdomainname                from(""wwwethiotelecomzm"")                topprivatedomain()        assertthat(privatedomaintostring() is(equalto(""ethiotelecomzm"")))    }}```i suggest closing this bug || ";;;;0;1;;
1809;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;update javadoc.io link from /page/ to /doc/  which gives an extra nav…;… bar on the top so that users can easily navigate to old versions;;0;update javadocio link from /page/ to /doc/ which gives an extra nav…;… bar on the top so that users can easily navigate to old versionsthanks for the contribution this is awesome> as you may have read project members have somehow an opinionated view on what and how should be> mockito eg we dont want mockito to be a feature bloat> there may be a thorough review with feedback -> code change loop> > which branch : > - on mockito 3x make your pull request target `release/3x`> - on mockito 2x make your pull request target `release/2x` (2x is in maintenance mode)>> _this block can be removed_> _something wrong in the template fix it here `github/pull_request_templatemd`check list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_;  raised pr on  fri oct 25 2019 at 9:18 pm tim van der lippe <notifications@githubcom>wrote:> merged #1809 < into> release/3x>> —> you are receiving this because you authored the thread> reply to this email directly view it on github> < or unsubscribe> < > ||;;;;1;1;update javadocio link from /page/ to /doc/ which gives an extra nav bar on the top so that users can easily navigate to old versions;
1809;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;update javadoc.io link from /page/ to /doc/  which gives an extra nav…;… bar on the top so that users can easily navigate to old versions;;0;summarize returned service_unavailable;i am executing an inner join query on presto 079 and i am getting this error 2014-10-14t00 15581-0400    warn   continuoustaskinfofetcher-20141014_045625_00000_h7qwi10-88    comfacebookprestoserver   error updating task 20141014_045625_00000_h7qwi10:  server at  returned service_unavailable    at comfacebookprestoserver ~[presto-main-076jar:076]    at comfacebookprestoserver ~[presto-main-076jar:076]    at comgooglecommonutilconcurrentfutures$4run(futuresjava:1181) ~[guava-1601jar:na]    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1145) ~[na:170_25]    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:615) ~[na:170_25]    at javalangthreadrun(threadjava:724) ~[na:170_25]2014-10-14t00 15582-0400     warn   continuoustaskinfofetcher-20141014_045625_00000_h7qwi20-87    comfacebookprestoserver   error updating task 20141014_045625_00000_h7qwi20:  server at  returned service_unavailable    at comfacebookprestoserver ~[presto-main-076jar:076]    at comfacebookprestoserver ~[presto-main-076jar:076]    at comgooglecommonutilconcurrentfutures$4run(futuresjava:1181) ~[guava-1601jar:na]    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1145) ~[na:170_25]    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:615) ~[na:170_25]    at javalangthreadrun(threadjava:724) ~[na:170_25]it also terminates presto serveri am connecting to mysql database and same query works fine on mysql prompt;i saw a similar issue recently with the 076 release with a query like:```select xsum(y)from t_1join t_2 on (t_2c1  t_1c1 and t_2c2  some_string)left outer join t_3 on (t_3c1  t_1c2)where t_1c3 between 20141005 and 20141018group by 1```and query fails with a `service_unavailable` response retrying the query doesnt help as this query constantly fails with the same error```query 20141023_215934_01130_eiykn failed: encountered too many errors talking to a worker node the node may have crashed or be under too much load this is probably a transient issue so please retry your query in a few minutes ( - 24 failures time since last success 207m)comfacebookprestospiprestoexception: encountered too many errors talking to a worker node the node may have crashed or be under too much load this is probably a transient issue so please retry your query in a few minutes ( - 24 failures time since last success 207m)    at comfacebookprestoserver    at comfacebookprestoserver    at comfacebookprestoserver    at comfacebookprestoserver    at comfacebookprestoserver    at comgooglecommonutilconcurrentfutures$4run(futuresjava:1181)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1145)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:615)    at javalangthreadrun(threadjava:745)    suppressed: javalangruntimeexception: server at  returned service_unavailable         6 more``` || just checked the same query finished successfully with the `079` release ||;;;;0;1;;
1809;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;update javadoc.io link from /page/ to /doc/  which gives an extra nav…;… bar on the top so that users can easily navigate to old versions;;0;remove utility functions from public api;fixes https://githubcom/reactivex/rxjava/issues/1797;;;;;1;1;remove utility functions from public apifixes https://githubcom/reactivex/rxjava/issues/1797;
1810;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;revert  1587 : remove unnecessary loop from injectingannotationengine;reverts mockito/mockito#1588;;0;missing nullity annotations for immutable collection iterators; immutablecollection and sub-interfaces declare to return an unmodifiableiterator from their iterator() methodsunmodifiableiterator deprecates remove() but does not redeclare next() this means that the return type of next() is inferred to be @﻿nullable (at least by eclipse)this means that code like :```for(string s: immutableset) {    // do something with s}```will warn about s being possibly null if used in a nonnull context although the immutable versions of collection set and list at least cannot contain nulls (this also affects immutablemaps which return immutable views from several methods and are not supposed to contain nulls either)i suggest adding a new sub-interface of unmodifiableiterator either immutableiterator or perhaps unmodifiablenonnulliterator (and an analogous list version) which declares next() as @﻿nonnull and using that instead for the relevant methods of the immutable collection(unless that is things are the way they are now for some good reason that i’m not aware of rather than an oversight); i am somewhat inaccurately collapsing a bunch of nullability-annotation bugs into &lt my apologies for the oversimplification--- ;;;;0;1;;
1810;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;revert  1587 : remove unnecessary loop from injectingannotationengine;reverts mockito/mockito#1588;;0;"hiveclientgetpartitions() breaks with  ""__hive_default_partition__""";"hiveclientgetpartitions() does not properly handle null partitions:```example: 20141013_191538_19058_tgxh6for input string: ""__hive_default_partition__""javalangnumberformatexceptionjavalangnumberformatexceptionforinputstring(numberformatexceptionjava:65)javalanglongparselong(longjava:441)javalanglongparselong(longjava:483)comfacebookprestohivehiveclient$4apply(hiveclientjava:1345)comfacebookprestohivehiveclient$4apply(hiveclientjava:1309)comgooglecommoncollectiterators$8transform(iteratorsjava:794)comgooglecommoncollecttransformediteratornext(transformediteratorjava:48)comgooglecommoncollectiterators$7computenext(iteratorsjava:646)comgooglecommoncollectabstractiteratortrytocomputenext(abstractiteratorjava:143)comgooglecommoncollectabstractiteratorhasnext(abstractiteratorjava:138)comgooglecommoncollectiterators$7computenext(iteratorsjava:645)comgooglecommoncollectabstractiteratortrytocomputenext(abstractiteratorjava:143)comgooglecommoncollectabstractiteratorhasnext(abstractiteratorjava:138)comgooglecommoncollectimmutablecollection$builderaddall(immutablecollectionjava:300)comgooglecommoncollectimmutablelist$builderaddall(immutablelistjava:691)comgooglecommoncollectimmutablelistcopyof(immutablelistjava:275)comgooglecommoncollectimmutablelistcopyof(immutablelistjava:226)comgooglecommoncollectfluentiterabletolist(fluentiterablejava:334)comfacebookprestohivehiveclientgetpartitions(hiveclientjava:1032)```"; ||;;;;0;1;;
1810;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;revert  1587 : remove unnecessary loop from injectingannotationengine;reverts mockito/mockito#1588;;0;migrate release from jenkins to travis;id like to migrate our gradle plugin from needing a jenkins job to release to using travis to do itwe have proven the model works in the rxscala project using sbt and have a test project showing the hooks:  code for the grade plugin is at  requirement is to modify the gradle plugin so we can pass in all necessary credentials either as environment variables or as command-line args for the bintray publishingthis will be used for all the rxjava projects except rxscala which is using sbt;/cc @quidryan (who unfortunately is too busy elsewhere to help on this right now) but who i want to be aware of this effort/cc @alkemist so youre aware of what were trying to do (and in case you have the interest and time to help) || @benjchristensen lets meet sometime next week and ill try to make this happen for you  this dovetails nicely with some other things i am thinking of doing anyway || @jkschneider that would be great i would appreciate your help on this!i got some tips from @quidryan for this:```something like:/gradlew build bintrayupload -pversion$versionfromtag -psigningsecretkeyringfilesecringgpg -psigningkeyidsigning_key-psigningpasswordyourpassword -pbintrayuserreactivex-role-pbintraykeybintray_key -psonatypeusernamereactivex-role-psonatypepasswordsonatype_password``` || with the upgrade to gradle 2 and nebula rxjava plugin 2x this is almost working the experiment can be seen at  outstanding issue is that it is not getting the right version number from the git tag it is still resolving the version automatically  || also there are some settings that we may want to change the defaults for:  groovynebularelease {    addreleasebranchpattern(/\d+\\d+\\d+/)    addreleasebranchpattern(head)}if (projecthasproperty(releaseuselasttag)) {    tasksprepareenabled  false}``` || releasing via travis now works version 105 was built and released to bintray solely by adding the tag `v105` the log showing the release can be seen here:  you @rspieldenner and @quidryan for enabling this! ||;;;;0;1;;
1810;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;revert  1587 : remove unnecessary loop from injectingannotationengine;reverts mockito/mockito#1588;;1587.0;"revert ""1587 : remove unnecessary loop from injectingannotationengine""";reverts mockito/mockito#1588related to #1631 heres a pseudo code to describe the issues around this issue# before 22315:	```while (clazz ! objectclazz) {	val mocks  aggregatespyormockfields(clazzgetmockfields())  val fields  aggregateinjectmocksfields(clazz)	val ret  tryconstructorinjection(clazz fields mock)  if (! retfieldwasinitializedusingconstructorinjection()) {    trysetterorpropertyinjection(clazz fields mock)  }	clazz  clazzgetsuperclass()}```# after 22315:```	val mocks  aggregatespyormockfields(clazzgetmockfields())  val fields  aggregateinjectmocksfields(clazz)	val ret  tryconstructorinjection(clazz fields mock)  if (! retfieldwasinitializedusingconstructorinjection()) {    trysetterorpropertyinjection(clazz fields mock)  }```# detailsbefore 22315 if the `@injectmocks` field has a field that not listed in the constructor argument will fill by setter/property injection at the 2nd loop 😃it may not the expected behaviors by mockito authors but some users code depends on this behaviormy suggestion is to revert the [1587 : remove unnecessary loop from injectingannotationengine by lihmeh · pull request #1588 · mockito/mockito · github]( at this time;why travis fails? || this needs a rebase that should fix travis (presumably) ||  merging 1810 ;injectingannotationengine does an unnecessary loop;processinjectmocks method of injectingannotationengine does unnecessary work it might call injectmocks several times while it is sufficient to call injectmocks once    private void processinjectmocks(final class<?> clazz final object testinstance) {        class<?> classcontext  clazz        while (classcontext ! objectclass) {            injectmocks(testinstance)            classcontext  classcontextgetsuperclass()        }    }inside injectmocks loops classes by himself    public void injectmocks(final object testclassinstance) {        class<?> clazz  testclassinstancegetclass()        set<field> mockdependentfields  new hashset<field>()        set<object> mocks  newmocksafehashset()        while (clazz ! objectclass) {            new injectmocksscanner(clazz)addto(mockdependentfields)            new mockscanner(testclassinstance clazz)addpreparedmocks(mocks)            oninjection(testclassinstance clazz mockdependentfields mocks)            clazz  clazzgetsuperclass()        }        new defaultinjectionengine()injectmocksonfields(mockdependentfields mocks testclassinstance)    }why not delete the unnecessary loop?;;1;0;appliied review comment;
1811;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;preview panel height is now saved immediately;the preview panel height is not stored when changed (only when jabref is closed) ### steps - selecting an entry (thus opening the preview panel) - changing the preview panel height - closing the preview panel - selecting an entry (thus opening the preview panel) - the preview panel has the old height  not the new one we just changed;;0;would be nice to have explicit @nullable annotation on immutablemapget; immutablemapget (and its analogue in the various subclasses like bimap) does not have any annotation on its return value as far as i can determine the intent is that it should be (correctly) inferred as possibly nullunfortunately eclipse’s null analysis is (and probably will be for quite a long time) somewhat limited among other things it doesn’t know about the jsr305 annotations using its own versions by default it can be configured to look for the jsr305 ones but unfortunately its default nullity annotation is nonnullbydefault with the semantics that it applies to method return values as well (unlike parametersarenonnullbydefault which is supposed to apply to parameters only)since parametersarenonnullbydefault are used more or less everywhere in guava eclipse at mistakenly infers immutablemapget to never return null which is both dangerous (it cant warn about errors) and annoying (it reports correct null checks as redundant)it would be nice if guava added an explicit @﻿nullable annotation on that method it’d be at worst redundant and since itll take quite a bit for eclipse to improve its nullity annotation support (they were still discussing how the last time i checked) it’d help a lot of developers in the mean time; i am somewhat inaccurately collapsing a bunch of nullability-annotation bugs into &lt my apologies for the oversimplification--- ;;;;0;1;;
1811;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;preview panel height is now saved immediately;the preview panel height is not stored when changed (only when jabref is closed) ### steps - selecting an entry (thus opening the preview panel) - changing the preview panel height - closing the preview panel - selecting an entry (thus opening the preview panel) - the preview panel has the old height  not the new one we just changed;;0;apply consistent import ordering with spotless;spotless allows us to enforce a consistent import order configure itsuch that static imports are first and non-static imports afterwardswithin imports java imports first then javax then all othersthis is consistent with the existing contributingmd guidelines apartfrom the fact that static imports are first (file has been updated) iwould propose that makes more sense but happy to discussin any case spotless already found inconsistent ordering within importsthemselves so that is already providing value for consistencyi have also updated the contributing guidelines to explain how`/gradlew spotlessapply` will fix a lot of issues without thedeveloper having to worry about it that should hopefully help newcomersmake changes more confidently(the only 2 files that are interesting to you are the `buildgradle` and`github/contributingmd` all other file changes were automaticallyperformed after running `/gradlew spotlessapply` locally); merging 1811  < ;;;;1;1;apply consistent import ordering with spotlessspotless allows us to enforce a consistent import order configure itsuch that static imports are first and non-static imports afterwardswithin imports java imports first then javax then all othersthis is consistent with the existing contributingmd guidelines apartfrom the fact that static imports are first (file has been updated) iwould propose that makes more sense but happy to discussin any case spotless already found inconsistent ordering within importsthemselves so that is already providing value for consistencyi have also updated the contributing guidelines to explain how`/gradlew spotlessapply` will fix a lot of issues without thedeveloper having to worry about it that should hopefully help newcomersmake changes more confidently(the only 2 files that are interesting to you are the `buildgradle` and`github/contributingmd` all other file changes were automaticallyperformed after running `/gradlew spotlessapply` locally);
1811;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;preview panel height is now saved immediately;the preview panel height is not stored when changed (only when jabref is closed) ### steps - selecting an entry (thus opening the preview panel) - changing the preview panel height - closing the preview panel - selecting an entry (thus opening the preview panel) - the preview panel has the old height  not the new one we just changed;;0;allow verifier to run multiple suites;;;;;;0;1;;
1811;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;preview panel height is now saved immediately;the preview panel height is not stored when changed (only when jabref is closed) ### steps - selecting an entry (thus opening the preview panel) - changing the preview panel height - closing the preview panel - selecting an entry (thus opening the preview panel) - the preview panel has the old height  not the new one we just changed;;0;code example;hi everyone !im using rxjava for the first time and i have encountered difficulties to implement observer/observable pattern i guess a simple project example  would help and guide through the first steps if anyone could make it available to download to all it would be great !great project btw !thanks;do you have a specific example of what you want to accomplish? there is the tutorials page  || you can also look at this:  || ok thanks to you both ! ill check these :) ||;;;;0;1;;
1813;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1771: upgrade byte-buddy to 1.10.2 (from 1.9.10);release notes:;;0;document immutability of ranges in the javadocs;j@ i didnt find information on the immutability of `range`&nbspinstances in the javadocs [1] only the wiki page [2] explicitly states iti suggest documenting the immutability directly in the javadocs and thus in the implementation itself[1]   unrelated: the comments disappeared from the wiki especially helpful ones which i remembered to be on the page on ranges are gone id like to state that i dont welcome that change); augh! how terrible--- ;;;;0;1;;
1813;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1771: upgrade byte-buddy to 1.10.2 (from 1.9.10);release notes:;;0;check that expressions used in group by are comparable;;;;;;0;1;;
1813;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1771: upgrade byte-buddy to 1.10.2 (from 1.9.10);release notes:;;1771.0;1771: upgrade byte-buddy to 1102 (from 1910);release notes: commits:raphw/byte-buddy@byte-buddy-1910byte-buddy-1102; ;upgrade byte-buddy to a 110x release;currently mockito uses an older build of byte-buddy i dont see any documentation or issues suggesting that theres a reason to avoid using a newer version though the contribution documentation doesnt mention dependency upgrades;":+1:  it should be officially upgraded to newer version of byte-buddyi am experiencing ""unsupported class file major version 57"" (java 13) || we had an attempt in #1772 but travis was unhappy if someone could revive that pr and fix the build that would be greatly appreciated! || ";1;0;ignore java 9 style `jar ` urls;
1813;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;1771: upgrade byte-buddy to 1.10.2 (from 1.9.10);release notes:;;1812.0; #1812 that zip may swallow requests; #1812;thanks for the fix ||;multiple zipped observers never complete;"the following code never executes the oncomplete if the number is greater than 1025 i think it has to due with back pressure which uses a default request of 1024 i am using java 8 ```    observable merged1  observablezip(observablerange(0 1026) observablerange(0 1026)            (o e) -> new int{o e})    observable merged2  observable<int integer int>zip(merged1 observablerange(0 1026)            (o e) -> new int{o[0] o[1] e})serialize()    merged2subscribe(            (o) -> systemoutprintln(o)            e -> {}            () -> {                systemoutprintln(""this never prints"")            }    )```i am using the following version of javajava version ""180_05""java(tm) se runtime environment (build 180_05-b13)java hotspot(tm) 64-bit server vm (build 255-b02 mixed mode)";thanks for reporting it ||;1;0; #1812 that zip may swallow requests;
1816;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;when inserting a duplicate the right entry will be selected;when you insert a duplicate in your database the editor has the wrong entry linked. ### steps to reproduce - select an entry - copy and paste it ( ctrl+c  &  ctrl+v   leave the old entry selected) - now the entry editor is open  edit any value and you ll see that the lower duplicate has changed although the upper one is selected;;0;comgooglecommoniocloseables implementation pointless; this class could be useful if it wasnt so useless the method close(closeable boolean) - why there is a checked exception declared in the method signature? if i wanted to catch and use this exception i wouldnt use this method the whole point of it is closing a closeable without caring about exception the method should be public void closeall(closeable values) no checked exception in the method signature!and why there are separate methods for another two closeable subclasses?? they are doing the same thing just change the signature to the one above and youll have just one useful method in place of 05 useful and 25 useless; the difference from streamclose() is that an exception from closeablesclose wont override a previous exception as a result closeablesclose is useful only when used with the try-finally recipe aboveas for closeall() and other methods that prevent any ioexception from being thrown the danger is in code like this:streamwrite(""foo"")closeall(stream)if streamclose() throws an exception there is no guarantee that ""foo"" was ever written to the underlying file even if write(""foo"") didnt throw an exception || ";;;;0;1;;
1816;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;when inserting a duplicate the right entry will be selected;when you insert a duplicate in your database the editor has the wrong entry linked. ### steps to reproduce - select an entry - copy and paste it ( ctrl+c  &  ctrl+v   leave the old entry selected) - now the entry editor is open  edit any value and you ll see that the lower duplicate has changed although the upper one is selected;;0;fix document error;`listcontains(any())` return a `boolean` value not a `string` value;;;;;1;1;fix document error;
1816;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;when inserting a duplicate the right entry will be selected;when you insert a duplicate in your database the editor has the wrong entry linked. ### steps to reproduce - select an entry - copy and paste it ( ctrl+c  &  ctrl+v   leave the old entry selected) - now the entry editor is open  edit any value and you ll see that the lower duplicate has changed although the upper one is selected;;0;arrays are not comparable;arrays should be comparable and orderable so that they can be used in group-by expressions order by clauses etcthe `` `<` `<` `>` `>` and hashcode operators for a type `array<t>` are defined iff they are defined for tgiven two arrays `a:array<t>` and `b:array<u>` the operators listed above can be applied between a and b as long as the corresponding operators can be applied to t and u `a  b` if they have the same cardinality and every element in a is equal to the corresponding element in b ie`a  b` <> `cardinality(a)  cardinality(b)` and for every `1 < i < cardinality(a)` `a[i]  b[i]``a < b` if they share a possibly empty prefix followed by an element in a less than the corresponding element in b or a is a prefix of b ie:`a < b` if - for some `1 < k < min(cardinality(a) cardinality(b))` `a[i]  b[i]`  for every `i < k` and  `a[k] < b[k]`- or for every `1 < i < cardinality(a)` `a[i]  b[i]` and `cardinality(a) < cardinality(b)`;@martint how should comparisons work for arrays that have nulls in them? i couldnt find it covered in the sql spec ||;;;;0;1;;
1816;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;when inserting a duplicate the right entry will be selected;when you insert a duplicate in your database the editor has the wrong entry linked. ### steps to reproduce - select an entry - copy and paste it ( ctrl+c  &  ctrl+v   leave the old entry selected) - now the entry editor is open  edit any value and you ll see that the lower duplicate has changed although the upper one is selected;;0;synchronous onsubscribe exception skips operators;"if an exception is thrown from a synchronous `onsubscribe` it will skip the operators such as `onerrorresumenext`for example:``` javaobservablecreate(subscriber -> { throw new runtimeexception(""failed!"")})onerrorresumenext(throwable -> {    return observablejust(""fallback value"")})subscribe(systemout::println t -> systemoutprintln(""error: "" + tgetmessage()))```in this case `onerrorresumenext` is not called and the error passes through";;;;;0;1;;
1818;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add check for obsolete database structure. add help popup.;issue:  -  -   ( [](  ~~tests for help.jabref.org may fail while  is not merged.~~  _screenshots:_ ![osd3](  ![migrate-pre-3 6-db](https://cloud.ent.com/assets/15609468/17874551/a81a5da4-68cc-11e6-9fd3-977a8642cb6b.png);;0;preserve the value of argline for surefire plugin;this variable is set by the jacoco plugin to configure the agent;;;;;0;1;;
1818;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add check for obsolete database structure. add help popup.;issue:  -  -   ( [](  ~~tests for help.jabref.org may fail while  is not merged.~~  _screenshots:_ ![osd3](  ![migrate-pre-3 6-db](https://cloud.ent.com/assets/15609468/17874551/a81a5da4-68cc-11e6-9fd3-977a8642cb6b.png);;0;concat breaks with double oncompleted;"this unit tests causes `concat` to never complete:``` java    @test    public void testconcatwithnoncompliantsourcedoubleoncomplete() {        observable<string> o  observablecreate(new onsubscribe<string>() {            @override            public void call(subscriber<? super string> s) {                sonnext(""hello"")                soncompleted()                soncompleted()            }        })        testsubscriber<string> ts  new testsubscriber<string>()        observableconcat(o o)subscribe(ts)        tsawaitterminalevent(500 timeunitmilliseconds)        tsassertterminalevent()        tsassertnoerrors()        tsassertreceivedonnext(arraysaslist(""hello"" ""hello""))    }```this was found by @mattrjacobs ";;;;;0;1;;
1818;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add check for obsolete database structure. add help popup.;issue:  -  -   ( [](  ~~tests for help.jabref.org may fail while  is not merged.~~  _screenshots:_ ![osd3](  ![migrate-pre-3 6-db](https://cloud.ent.com/assets/15609468/17874551/a81a5da4-68cc-11e6-9fd3-977a8642cb6b.png);;181.0;add duration overloads 1815;add new `javatimeduration`-based public apis to `mockito` `after` and `timeout` and deprecate the corresponding `long`-based public apisplumb those `duration` instances through the internals of mockito; merging 1818 ;warning when multiple instances of mock exist;ive ran into this a few times now and think that an error/warning message could be used the situation is having two interfaces of the same type being mocked via annotations then injecting via @injectmocks it seems at run/test time that there is some probability either will be chosenadmittedly this is an edge case but would be faster to track down if there was a warning perhaps that multiple instances of the same interface were found but no injection point (constructor property etc) was found that applies i put together an example which is reproducible easily on my machine under the following:- jdk 16 + mockito 190i dont mind looking into providing a fix for this myself but wanted to formalize it here before looking into itif you run the following a few times youll get different assertion errors each time depending on which myservice gets injected```package exampleimport orgjunittestimport orgjunitrunnerrunwithimport orgmockitoinjectmocksimport orgmockitomockimport orgmockitorunnersmockitojunitrunnerimport orgspringframeworkbeansfactoryannotationautowiredimport orgspringframeworkstereotypeserviceimport static orgmockitomockitoverify@runwith(mockitojunitrunnerclass)public class exampletest {    @service    public static class myservice {        public void dosomething() {        }    }    @service    public static class myclass {        private final myservice myservice        @autowired        public myclass(myservice myservice) {            thismyservice  myservice        }        public void dosomethingwithservice() {            myservicedosomething()        }    }    @mock    private myservice myserviceinstance1    @mock    private myservice myserviceinstance2    @injectmocks    private myclass myclass    @test    public void test1() throws exception {        myclassdosomethingwithservice()        verify(myserviceinstance1)dosomething()        verify(myserviceinstance2)dosomething()    }}```;hithis is a known documented and wanted behavior if by warning you mean writing a line to the console this could probably done however if its about raising an exception then im not sure this is the smart move || since the current behavior is intermittent why it is considered wanted?cheers!on fri apr 3 2015 07:28 brice dutheil notifications@githubcom wrote:> hi> > this is a known documented and wanted behavior if by warning you mean> writing a line to the console this could probably done however if its> about raising an exception then im not sure this is the smart move> > ## > > reply to this email directly or view it on github>  || also @joshes i think more recent version of mockito have a more reproducible behavior (ie not intermittent) (check 195 11019)the wanted behavior im speaking about is **to not fail if injection cannot happen** because a developper **may choose to inject them afterward** this is especially useful with objects that have exotic way of injections || thanks for the explanation @bric3  - that makes sense  ||;1;0;resolve comments on pr;
1819;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;removed globals.prefs init in some logic tests;;;0;nullpointertester should not require @nullable on the param of an equals() override; when i call the following the test case fails (see full test case in attachment)&nbsp&nbspnew classsanitytester()testnulls(myobjectclass)i get the following error: no exception thrown for parameter at index 0 from myobjecttest$myobjectpublic boolean myobjecttest$myobjectequals(javalangobject)[null] for class myobjecttest$myobjectclearly this indicates that it expects a call to ""equals(object)"" to throw a nullpointerexception that method should never throw an exception but rather return true or false the test seems to skip this assertion and im surprised this hasnt been reported earlier please make it so classsanitytester#testnulls(class) doesnt fail when equals is behaving correctly (see the test case where testequals(myobjectclass succeeds)on a side note the text returned should be adapted as it mentions three times myobjecttest$myobject thats 2 too many and it renders the whole error message nearly not understandable"; okay i found one issue on my side: the lack of online javadoc available i had to check in the code online to find out that its playing nice only if @﻿nullable is presenti checked the front-page of guava and no there is no link at all to the testlib javadoc i played a bit with urls and couldnt find any url for the testlib javadoc || while it is possible to add `@nullable` to `equals` for own code it may not always be possible to do this for generated code for example the autovalue team decided to not do this ( i think that `nullpointertester` should special-case `equals` and behave correctly whether the annotation is present or not after all the javadoc of `equals` specifies explicitly that the parameter can be null || i agree that equals() is worth special-casing  ||;;;;0;1;;
1819;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;removed globals.prefs init in some logic tests;;;0;add orcinputstream resetstream;share orcinputstreams between row groups which prevents blocks from being decompressed multiple times;;;;;0;1;;
1819;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;removed globals.prefs init in some logic tests;;;0;fix concat breaks with double oncompleted;fixes https://githubcom/reactivex/rxjava/issues/1818;;;;;1;1;fix concat breaks with double oncompletedfixes https://githubcom/reactivex/rxjava/issues/1818;
1819;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;removed globals.prefs init in some logic tests;;;181.0;deprecate mockitohamcrest;this class was used during the migration period from mockito 1 andmockito 2 but is no longer necessary to be able to remove ourdependency on hamcrest we should remove mockitohamcrestin response to #1817;"friendly ping on this pr || i will submit this pr next week if there are no objections || there were no objections so i am merging this || sorry im late here! i suggest we dont deprecate it the use case (as documented in the javadoc) is the following: ""hamcrest integration is provided so that users can take advantage of existing hamcrest matchers"" that use case is still valid (perhaps the docs need to be clearer to address #1817)for code that does not use hamcrest users should be following standard non-hamcrest argthat() apihope that helps! || > for code that does not use hamcrest users should be following standard non-hamcrest argthat() apithe problem is that this project requires hamcrest as compile-time dependency to be built this is a problem for users who do not want to use hamcrest but still build the source code (as they cant use the pre-built jars)if we want to keep supporting hamcrest users with this api i would suggest a `mockito-hamcrest` artifact that takes care of the integration that way those users who do *not* want to use hamcrest dont rely on it as wellwdyt? || im novice to testing because i have to wear many hats (and i avoided getting into it like the plague in the past) returning to spring development in my career and discovering mockito this year changed my [integration testing] life i rely heavily on googling stack overflow examples until it become memorized (if ever i do)  it seems like there is a much larger documented wealth of knowledge on hamcrest on stack overflow (maybe cause its been around a long time) and so its easy to find solutions to basic challenges while someone new to mockito gets used to itfor example hasentry from this so helped me today  like timvdlippes suggestion because it leverages giving your users the ability to tap into that knowledge/solutions while slimming down the dependencies for the core mockito code basethanks for all your contributions in this area and letting us stand on your shoulders || thanks for that response @mansours ! i will look into introducing a `mockito-hamcrest` artifact and figure out a way forward tomorrow i can revert this pr given the points raised by @mockitoguy and make that work || > this is a problem for users who do not want to use hamcrest but still build the source code (as they cant use the pre-built jars)can you elaborate this problem? we use ""compileonly"" dependency for hamcrest just like we do for junit4 or opentest4j this should not cause problems for consumers || yes we are facing the same issues with junit4 and opentest4j junit4 is not an issue atm as we are also using it but opentest4j is currently an issuewe are not able to include jars as we require source code to be included and built (for security analyses) thus the inclusion of the dependencies during compile time does lead to problems when we want to build mockito in isolationi am currently investigating solutions for junit4 and opentest4j and how that could be decoupled i went ahead with this pr as it was my understanding with mockito 2 is that we wanted to remove our dependency of hamcrest therefore i assumed that deprecation was appropriate especially as there were no objections posted on this pr for almost 2 weeks i understood that this was okayi will revert the pr for us to revisit but i would like to come to a decision on our hamcrest support and whether we want to support it or not at all when we come to a decision i would like to update our javadoc and wiki on that to clarify that for our users || > especially as there were no objections posted on this pr for almost 2 weeks i understood that this was okayof course! thank you for waiting 2 weeks dont block on us> yes we are facing the same issues with junit4 and opentest4j junit4 is not an issue atm as we are also using it but opentest4j is currently an issuecan you elaborate the problem? is it a google mono-repo use case? (i dont object reworking the artifacts - i want understanding for me and others :)) || > can you elaborate the problem? is it a google mono-repo use case? (i dont object reworking the artifacts - i want understanding for me and others :))this is for every repository that includes third_party code that we need to have the original source code for security analyses that includes the mono repository as well as some other repositories that we havesince the hamcrest api is not type-safe (as it requires casting with `object` vs `t` as argument type) we would like to move away from unsafe type casts the `argumentmatcher` interface does not inherit that problem but the older hamcrest api doesby having the hamcrest-compatible api in the mockito artifact users can still use mockito in combination with the hamcrest apii would personally say that while the hamcrest api was originally useful for defining reusable matchers the lack of type-safety does more harm than good i have received good responses when i finished the migration of the `argumentmatcher` to be typed and it already caught bugs in our tests i think we should promote the type-safe `argumentmatcher` and thus deprecate the old api but happy to disagree on that part and leave hamcrest compatibility in for example a separate artifact || > that we need to have the original source code for security analysesso the problem is that in addition to mockito source you have to pull in hamcrest source for the analysis? (i still dont feel i fully understand this use case)> by having the hamcrest-compatible api in the mockito artifact users can still use mockito in combination with the hamcrest apithats a fair argument> leave hamcrest compatibility in for example a separate artifactto keep backwards compatibility we would need ""mockito-core"" -> ""mockito-hamcrest"" are you thinking of reversing the dependency in future major version? || revert of this pr is in  || > so the problem is that in addition to mockito source you have to pull in hamcrest source for the analysis? (i still dont feel i fully understand this use case)correct since jars can be built with any arbitrary code we prefer to not check in a jar as we cant be certain that it was built from the original source code thats why we check in the original source code and build that instead> to keep backwards compatibility we would need ""mockito-core"" -> ""mockito-hamcrest"" are you thinking of reversing the dependency in future major version?yes but since maven does not allow a cyclic dependency we have to figure out what the possibilities are || ";warning when multiple instances of mock exist;ive ran into this a few times now and think that an error/warning message could be used the situation is having two interfaces of the same type being mocked via annotations then injecting via @injectmocks it seems at run/test time that there is some probability either will be chosenadmittedly this is an edge case but would be faster to track down if there was a warning perhaps that multiple instances of the same interface were found but no injection point (constructor property etc) was found that applies i put together an example which is reproducible easily on my machine under the following:- jdk 16 + mockito 190i dont mind looking into providing a fix for this myself but wanted to formalize it here before looking into itif you run the following a few times youll get different assertion errors each time depending on which myservice gets injected```package exampleimport orgjunittestimport orgjunitrunnerrunwithimport orgmockitoinjectmocksimport orgmockitomockimport orgmockitorunnersmockitojunitrunnerimport orgspringframeworkbeansfactoryannotationautowiredimport orgspringframeworkstereotypeserviceimport static orgmockitomockitoverify@runwith(mockitojunitrunnerclass)public class exampletest {    @service    public static class myservice {        public void dosomething() {        }    }    @service    public static class myclass {        private final myservice myservice        @autowired        public myclass(myservice myservice) {            thismyservice  myservice        }        public void dosomethingwithservice() {            myservicedosomething()        }    }    @mock    private myservice myserviceinstance1    @mock    private myservice myserviceinstance2    @injectmocks    private myclass myclass    @test    public void test1() throws exception {        myclassdosomethingwithservice()        verify(myserviceinstance1)dosomething()        verify(myserviceinstance2)dosomething()    }}```;hithis is a known documented and wanted behavior if by warning you mean writing a line to the console this could probably done however if its about raising an exception then im not sure this is the smart move || since the current behavior is intermittent why it is considered wanted?cheers!on fri apr 3 2015 07:28 brice dutheil notifications@githubcom wrote:> hi> > this is a known documented and wanted behavior if by warning you mean> writing a line to the console this could probably done however if its> about raising an exception then im not sure this is the smart move> > ## > > reply to this email directly or view it on github>  || also @joshes i think more recent version of mockito have a more reproducible behavior (ie not intermittent) (check 195 11019)the wanted behavior im speaking about is **to not fail if injection cannot happen** because a developper **may choose to inject them afterward** this is especially useful with objects that have exotic way of injections || thanks for the explanation @bric3  - that makes sense  ||;1;0;deprecate mockitohamcrestthis class was used during the migration period from mockito 1 andmockito 2 but is no longer necessary to be able to remove ourdependency on hamcrest we should remove mockitohamcrest;
1820;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;indent with spaces using spotless;discovered in #1818 that (if new contributors are unaware of our indentation with 4 spaces)  spotless did not fix the formatting.  indentwithspaces(4)  does just that and it actually found other formatting issues.;;0;bloomfiltercreate to accept funnel<? extends t> instead of funnel<t>; for now  bloomfiltercreate accepts strictly funnel&ltt> which makes it impossible to write type-safe string bloomfilter using builtin funnels:bloomfilter&ltstring> filter  bloomfiltercreate(funnelsstringfunnel(charsetdefaultcharset()) 10000) does not compile which is somewhat frustratingid propose to change bloomfiltercreate to accept funnel<? extends t> which should allow such code; 2kak@googlecom: sure my bad || this was  in  ||;;;;0;1;;
1820;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;indent with spaces using spotless;discovered in #1818 that (if new contributors are unaware of our indentation with 4 spaces)  spotless did not fix the formatting.  indentwithspaces(4)  does just that and it actually found other formatting issues.;;0;indent with spaces using spotless;discovered in #1818 that (if new contributors are unaware of our indentation with 4 spaces) spotless did not fix the formatting `indentwithspaces(4)` does just that and it actually found other formatting issues;"yes that is correct i think at that point you need a formatter like `google-java-formatter` or `eclipse-formatter` to fix these kind of ""aesthetics"" || ";;;;1;1;indent with spaces using spotless;
1820;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;indent with spaces using spotless;discovered in #1818 that (if new contributors are unaware of our indentation with 4 spaces)  spotless did not fix the formatting.  indentwithspaces(4)  does just that and it actually found other formatting issues.;;0;move static methods to a separate class;this seems to confuse testng which tries to invoke some of the publicstatic methods during setup;;;;;0;1;;
1820;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;indent with spaces using spotless;discovered in #1818 that (if new contributors are unaware of our indentation with 4 spaces)  spotless did not fix the formatting.  indentwithspaces(4)  does just that and it actually found other formatting issues.;;0;can we optimize rxringbuffer#size  1024 ?;the default capacity of 1024 for rxringbuffers can be significant on memory constrained environments like android also indexedringbuffer#size  512could rxringbuffer#size be smaller made dynamic ( auto-sizing ) or user configurable?;yes we can i always intended to have a solution for android but never got around to it> made dynamic ( auto-sizing )i dont really like this approach as one reason for the ring buffer is to allow object pooling since allocating and deallocating arrays/queues/lists/nodes was killing high-throughput systems until i put in place this current modelalso auto-sizing doesnt make sense to me with backpressure as when backpressure is needed it would end up growing to whatever the max size is that has been set anyways so youd end up growing it to whatever that limit isdo you have a suggested solution for auto-sizing that doesnt have those issues?> could rxringbuffer#size be smallerperhaps it works as small as 1 (though that somewhat defeats the purpose) i found 256/512/1024 to be reasonable defaults im open to changing the overall default to 512 instead of 1024> user configurablethis is a viable option that would should probably enable it would need to be a global default (such as via a system property) that is hit once on initialization then used for all of them (due to object pooling)we can also special case android to default to something lower (such as 32?) and maybe even look at the client/server jre and run 128 for client and 512/1024 for serverwhat do you suggest? || probably a lower default for android would be good ( with a system property to override increase/decrease ) i would have to try it out on our app but 8 or 16 would probably work as an android defaultmaybe start with user configurable and then let android users try it out and make recommendations as an aside i think arraylist defaults to capacity 0 on android ( as opposed to 10 in some other environments )  ||;;;;0;1;;
1821;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;guard against multiple evaluations of before statement;some rules evaluate the base statement multiple times  e.g. to execute;;0;denseimmutabletable$row is not gwt serializable; error from our log  could not get type signature for class comgooglecommoncollectdenseimmutabletable$rowthere is no customfieldserializer for the subclasses of immutablearraymap which is an inner class of denseimmutabletable; thanks im hoping that gwt will make some changes to make this easier ive been hoping that for a while though i just filed a gwt feature request to try to get an update: `package-collect` || the issue got migrated and closed: we now get the same issue with immutabllist$sublist mainly because regularimmutablelistsublist now returns that type instead of a regularimmutablelist caused by the commit: [cb3a29fb67936c2bc52b1cfee08cedab62950282]( || your best bet is to call `immutablelistcopyof(sublist)` to get a `regularimmutablelist` back :(we could probably make `sublist` serialization work under gwt but its unlikely to ever be a high enough priority given the deprecation of gwt-rpc sorry || (id be happy to review a pull request youd probably need to make `sublist` a top-level type) || gwt-rpc support is on the way out:  ||;;;;0;1;;
1821;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;guard against multiple evaluations of before statement;some rules evaluate the base statement multiple times  e.g. to execute;;0;add dummy field to testingsplit;this is to avoid exceptions due to jackson refusing to serialize/deserialize an object with no fields;;;;;0;1;;
1821;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;guard against multiple evaluations of before statement;some rules evaluate the base statement multiple times  e.g. to execute;;0;execution stops after ~1024 events;why does the following code stop executing after roughly 1024 events? am i doing something wrong? im using rxjava-scala 0202 and scala 2111```import rxlangscalaobservableimport rxlangscalasubjectimport rxlangscalasubscriberimport rxlangscalaschedulersnewthreadschedulerobject threadsobserveon {  def main(args: array[string]) {    val obs  observable((s: subscriber[int]) > {        var i  0        while (true) {          sonnext(i)          i  i + 1        }    })    obsobserveon(newthreadscheduler())subscribe(println(_))    readline()  }}```edit: removed the new thread from the example;"first of all never use new thread but instead use a schedulerthat said you have run into a back-pressure issuethe println is probably too slow to keep up with the producer || hi erik thanks for your quick reply! i removed the usage of a new thread and it does not seem to change the behavior i also noticed that when i remove the ""observeon"" everything works and back-pressure is not an issue for many millions of iterations the following example works as i would have expected:```import rxlangscalaobservableimport rxlangscalasubjectimport rxlangscalasubscriberimport rxlangscalaschedulersnewthreadschedulerobject threadsobserveon {  def main(args: array[string]) {    val obs  observable((s: subscriber[int]) > {        var i  0        while (true) {          sonnext(i)          i  i + 1        }    })    obssubscribe(println(_))    readline()  }}``` || the `observable` created here is not ""backpressure aware"" and emits more than `observeon` has requested that is why you get the exception:```0exception in thread ""rxnewthreadscheduler-1"" javalangillegalstateexception: exception thrown on schedulerworker thread add `onerror` handling    at rxinternalschedulersscheduledactionrun(scheduledactionjava:50)    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:511)    at javautilconcurrentfuturetaskrun(futuretaskjava:266)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:180)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:293)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)    at javalangthreadrun(threadjava:745)caused by: rxexceptionsonerrornotimplementedexception    at rxobservable$31onerror(observablejava:7204)    at rxobserverssafesubscriber_onerror(safesubscriberjava:127)    at rxobserverssafesubscriberonerror(safesubscriberjava:96)    at rxinternaloperatorsnotificationliteaccept(notificationlitejava:147)    at rxinternaloperatorsoperatorobserveon$observeonsubscriberpollqueue(operatorobserveonjava:177)    at rxinternaloperatorsoperatorobserveon$observeonsubscriberaccess$000(operatorobserveonjava:65)    at rxinternaloperatorsoperatorobserveon$observeonsubscriber$2call(operatorobserveonjava:153)    at rxinternalschedulersscheduledactionrun(scheduledactionjava:45)     7 morecaused by: rxexceptionsmissingbackpressureexception    at rxinternalutilrxringbufferonnext(rxringbufferjava:222)    at rxinternaloperatorsoperatorobserveon$observeonsubscriberonnext(operatorobserveonjava:115)    at rxlangscalasubscriber$$anon$2onnext(subscriberscala:70)    at threadsobserveon$$anonfun$1apply(threadsobserveonscala:10)    at threadsobserveon$$anonfun$1apply(threadsobserveonscala:8)    at rxlangscalaimplicitfunctionconversions$$anon$1call(implicitfunctionconversionsscala:53)    at rxlangscalaimplicitfunctionconversions$$anon$1call(implicitfunctionconversionsscala:51)    at rxobservable$1call(observablejava:145)    at rxobservable$1call(observablejava:137)    at rxobservablesubscribe(observablejava:7463)    at rxobservablesubscribe(observablejava:7195)    at rxlangscalaobservable$classsubscribe(observablescala:188)    at rxlangscalajavaconversions$$anon$3subscribe(javaconversionsscala:53)    at threadsobserveon$main(threadsobserveonscala:15)    at threadsobserveonmain(threadsobserveonscala)```your `observable` implementation is spinning as fast as it can and not using the `producer` to work with backpressure and is thus a ""hot"" source to consume data from a hot source such as this you would have to choose to buffer throttle sample or drop data if the producer is faster than the consumer (which it is when going via an async boundary such as `observeon`)or you can make it support backpressure which can be done by using `subscribersetproducer` inside the onsubscribe function here is the implementation of the `range` operator in java that supports backpressure:  || ok thanks! i will look into providing for back-pressure i have just run the example with 0202 0200-rc6 and 0206 but i havent got the missingbackpressureexception on my machine? it just blocks after ~1024 events what versions of scala & rxjava are you using?  || add an onerror handler and youll see it or upgrade to the latest version (022 of rxscala) and rxjava 100 as it  an issue where an async operator like observeon could fail silently when an onerror handler was not provided  || add the error handler like this:``` scalaimport rxlangscalaobservableimport rxlangscalasubjectimport rxlangscalasubscriberimport rxlangscalaschedulersnewthreadschedulerobject threadsobserveon {  def main(args: array[string]) {    val obs  observable((s: subscriber[int]) > {        var i  0        while (true) {          sonnext(i)          i  i + 1        }    })    obssubscribe(println(_) _printstacktrace())    readline()  }}``` || ok i will see if i can easily upgrade to the newest versions thanks again you have been a great help! || ";;;;0;1;;
1821;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;guard against multiple evaluations of before statement;some rules evaluate the base statement multiple times  e.g. to execute;;1767.0;guard against multiple evaluations of before statement;some rules evaluate the base statement multiple times eg to executetests repeatedly the changes made in #1672 led to an exception in suchcases because the `mockitolistener` was registered multiple times nowwe only add the listener the first time the statement is evaluated inorder to restore the old behavior1767;oh this fails a lot of tests 😢 could it be that `testfinished` needs the same treatment? || > could it be that `testfinished` needs the same treatment?it does indeed   merging 1821  < ;mismatchreportingtestlistener has already been added and not removed using mockitojunitrunner;" -  the mockito message in the stacktrace have useful information but it didnt help -  the problematic code (if thats possible) is copied here```import static orghamcrestmatchersequaltoimport static orghamcrestmatchershaspropertyimport static orgmockitoargumentmatchersanyimport static orgmockitoargumentmatchersanystringimport static orgmockitomockitoneverimport static orgmockitomockitoverifyimport static orgmockitohamcrestmockitohamcrestargthatimport javaiofileimport javaioioexceptionimport javautilfunctionconsumerimport orgjunitruleimport orgjunittestimport orgjunitrulestemporaryfolderimport orgjunitrunnerrunwithimport orgmockitomockimport orgmockitojunitmockitojunitrunnerimport orgpdfsamsupportparamssingleoutputtaskparametersbuilderimport orgpdfsamtestinitializeandapplyjavafxthreadrule@runwith(mockitojunitrunnerclass)public class browsablepdfoutputfieldtest {    @rule    public temporaryfolder folder  new temporaryfolder()    @rule    public initializeandapplyjavafxthreadrule fxthread  new initializeandapplyjavafxthreadrule()    @mock    private singleoutputtaskparametersbuilder<?> builder    @mock    private consumer<string> onerror    @test    public void valid() throws ioexception {        browsablepdfoutputfield victim  new browsablepdfoutputfield()        file value  foldernewfile(""testpdf"")        victimgettextfield()settext(valuegetabsolutepath())        victimapply(builder onerror)        verify(builder)output(argthat(hasproperty(""destination"" equalto(value))))        verify(onerror never())accept(anystring())    }    @test    public void invalid() {        browsablepdfoutputfield victim  new browsablepdfoutputfield()        victimenforcevalidation(true true)        victimgettextfield()settext(""chucknorris"")        victimapply(builder onerror)        verify(builder never())output(any())        verify(onerror)accept(anystring())    }}``` -  provide versions (mockito / jdk / os / any other relevant information)mockito 300 adoptopenjdk 1104 linux mint -  provide a [short self contained correct (compilable) example]( of the issue       (same as any question on stackoverflowcom) -  read the [contributing guide]( migrated from 11019 to the 300 version and i have few tests using the mockitojunitrunner which are failing with the following stacktrace:```orgmockitoexceptionsmisusingredundantlistenerexception: problems adding mockito listenerlistener of type mismatchreportingtestlistener has already been added and not removedit indicates that previous listener was not removed according to the apiwhen you add a listener dont forget to remove the listener afterwards:  mockitoframework()removelistener(mylistener)for more information see the javadoc for redundantlistenerexception class	at orgmockitointernalrunnersdefaultinternalrunner$1$1evaluate(defaultinternalrunnerjava:41)	at orgjunitrulesexternalresource$1evaluate(externalresourcejava:48)	at orgpdfsamtestjavafxthreadrule$1lambda$evaluate$0(javafxthreadrulejava:48)	at comsunjavafxapplicationplatformimpllambda$runlater$10(platformimpljava:428)	at javabase/javasecurityaccesscontrollerdoprivileged(accesscontrollerjava:389)	at comsunjavafxapplicationplatformimpllambda$runlater$11(platformimpljava:427)	at comsunglassuiinvokelaterdispatcher$futurerun(invokelaterdispatcherjava:96)	at comsunglassuigtkgtkapplication_runloop(native method)	at comsunglassuigtkgtkapplicationlambda$runloop$11(gtkapplicationjava:277)	at javabase/javalangthreadrun(threadjava:835)```it seems something internal i didnt add or remove any `mismatchreportingtestlistener` and moreover the same code was working with the 11019 and is working if i remove the `mockitojunitrunner` and replace the `@mock` annotation with a `mockitomock` in a `@before` method";"a lot of updates exist between 11019 and 300 could you bisect the versions and figure out which minor version introduced the issue? || 2260 looks like the one introducing this issue all green in 2251 || @torakiki can you provide us a simpler test that reproduces the issue? we are looking for a test without dependencies such as initializeandapplyjavafxthreadrule so that we can run & reproduce it in mockito projectthanks for reporting!  || @torakiki any luck? im having the same issue upgrading from 2234@mockitoguy heres a simple test reproducing the issue in my case:```java@runwith(mockitojunitrunnerclass)public class uuidhelpertest {    @test    public void should_get_16_bytes_from_a_uuid() {        uuid uuid  uuidrandomuuid()        byte result  uuidhelpergetbytesfromuuid(uuid)        assertthat(resultlength is(16))    }}public class uuidhelper {    public static final int uuid_size_in_bytes  16    public static byte getbytesfromuuid(uuid uuid) {        bytebuffer bb  bytebufferwrap(new byte[uuid_size_in_bytes])        bbputlong(uuidgetmostsignificantbits())        bbputlong(uuidgetleastsignificantbits())        return bbarray()    }}``` || @sharonhart this test works fine with current mockito (30) can you provide a test that fails with current mockito? thank you! || @mockitoguy it works with the current mockito version for me as well on a clean project but in one specific project it doesnt after a similar upgrade as the one mentioned in this issue  || @marcphilipp @timvdlippe maybe this pr is related? was merged between the versions @torakiki mentioned [here]( used to removelistener in case of test failure during setup the same thing as the exception states that needs to be doneedit: ive reverted the commit locally and published to m2 everything works now can this be reverted or checked for root cause? || @sharonhart which version of junit are you using? we had a regression since 413 which is why we made the changes see  || @timvdlippe junit 412by the way seems like whats causing the regression for me is the withbefores statement part not the started field removal in the runlistener but the regression youve mention was with the prior right? || @sharonhart could you please provide a sample project so we can reproduce the issue? || @marcphilipp unfortunately i cant i tried to copy the test to a clean project and it didnt reproducehappening only in command line build in one project which i cant share due to size and internal dependencies i can verify if a fix works though the same way ive managed to check if reverting the commit  the issue || are you running tests in parallel or anything like that? || yes in our ci pipeline but reproduced locally with a single executor it might be that the single one is running modules in parallel im not sure  || how are you running those tests? maven surefire? || no with gradle without extra plugins || what happens when you upgrade to junit 413-rc-1? || same || while i cannot provide a sample project to reproduce this issue here are some observations that i made when running into the same issue:1 i seems to be related one of the `@rule`: i use a similar rule to what @torakiki has in his example:<pre>public class javafxthreadingrule implements testrule {        /**        * flag for setting up the javafx we only need to do this once for all tests        */        private static boolean jfxissetup        @override        public statement apply(statement statement description description) {            return new onjfxthreadstatement(statement)        }        private static class onjfxthreadstatement extends statement {            private final statement statement            public onjfxthreadstatement(statement astatement) {                statement  astatement            }            private throwable rethrownexception  null            @override            public void evaluate() throws throwable {                if(!jfxissetup) {                    setupjavafx()                    jfxissetup  true                }                final countdownlatch countdownlatch  new countdownlatch(1)                platformrunlater(() -> {                    try {                        statementevaluate()                    } catch (throwable e) {                        rethrownexception  e                    }                    countdownlatchcountdown()                })                countdownlatchawait()                // if an exception was thrown by the statement during evaluation                // then re-throw it to fail the test                if(rethrownexception ! null) {                    throw rethrownexception                }            }            protected void setupjavafx() throws interruptedexception {                long timemillis  systemcurrenttimemillis()                final countdownlatch latch  new countdownlatch(1)                swingutilitiesinvokelater(() -> {                    // initializes javafx environment                    new jfxpanel()                    latchcountdown()                })                systemoutprintln(""javafx initialising"")                latchawait()                systemoutprintln(""javafx is initialised in "" + (systemcurrenttimemillis() - timemillis) + ""ms"")            }        }}</pre>2 my test class contains multiple test methods running them separately woks when running them in combination (from within the ide) the first one succeeds and then the remaining fail with this exception3 removing the rule makes all tests succeed safe the ones that actually require the rule || @hotzst nice! i have managed to find that for me as well a methodrule were implementing is what caused this question is how should it be changed for the updated mockito version```javaimport orgjodatimedatetimezoneimport orgjunitrulesmethodruleimport orgjunitrunnersmodelframeworkmethodimport orgjunitrunnersmodelstatementimport orgmockitomockitoimport orgmockitointernaljunitmockitotestlistenerimport javautiltimezone/** when adding this rule to a junit test any @test method annotated with @timezoned will be ran multiple times each time* with a different system timezone* this rule is useful to ensure you are handling all timezones correctly* note: for mockito you may need to use mockitoreset() if you are using verify()* */public class timezoneupdaterule implements methodrule {    final private timezone timezone    final private datetimezone datetimezone    private final static string alltimezones  {""utc"" ""asia/jerusalem"" ""europe/london"" ""us/pacific"" ""est5edt"" ""us/eastern""            ""australia/sydney"" ""us/central"" ""asia/tokyo"" ""america/chicago"" ""gmt""            ""europe/amsterdam"" ""europe/berlin"" ""brazil/east"" ""asia/jakarta"" ""europe/athens""            ""australia/queensland"" ""asia/singapore"" ""asia/bangkok"" ""america/bogota""            ""america/los_angeles"" ""asia/hong_kong"" ""america/new_york""            ""america/argentina/buenos_aires""}    public timezoneupdaterule() {        timezone  timezonegetdefault()        datetimezone  datetimezonegetdefault()    }    public void reset() {        settimezone(timezone datetimezone)    }    protected void after() {        reset()    }    private void settimezone(string timezoneid) {        settimezone(timezonegettimezone(timezoneid) datetimezoneforid(timezoneid))    }    private void settimezone(timezone timezone datetimezone datetimezone) {        systemsetproperty(""usertimezone"" timezonegetid())        timezonesetdefault(timezone)        datetimezonesetdefault(datetimezone)    }    private static string gettimezones() {        return alltimezones    }    @override    public statement apply(final statement st final frameworkmethod method object target) {        return new statement() {            public void evaluate() throws throwable {                timezoned timezoned  methodgetannotation(timezonedclass)                if(timezoned !null){                    string timezones   timezonedtimezones()length > 0  ? timezonedtimezones() : gettimezones()                    applyalltimezones(st timezones)                }else{                    stevaluate()                }            }        }    }    private void applyalltimezones(statement st string timezones) throws throwable {        try {            for (string tz : timezones) {                settimezone(tz)                stevaluate()            }        }catch (assertionerror t){            throw new assertionerror(getmessage() t)        }catch (exception e){            throw new runtimeexception(getmessage() e)        }        finally {            after()        }    }    private string getmessage() {        return ""test failed for timezone ["" + timezonegetdefault()getid()+ ""]""    }}``` || thanks for the additional info i think #1821 should restore the old behavior ||  ";1;0;reset listener when removing it;
1823;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed #1804: url field is not removed by integrity check;better to disable the check than remove the field from the entry.  -)  1804  -   -   (one may think of adding a test that no fields are removed from the entry in the integrity check  but i haven t done that here  ideally the entry should have every possible field included) -  -   ( []()?);;0;method for using a invokable as a function?;qic@ could there be a method on invokable or static factory in functions to convert invokable to a function assuming arg-less invocation?;the fact that this would only work for no-arg methods seems like a significant blocker ||;;;;0;1;;
1823;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed #1804: url field is not removed by integrity check;better to disable the check than remove the field from the entry.  -)  1804  -   -   (one may think of adding a test that no fields are removed from the entry in the integrity check  but i haven t done that here  ideally the entry should have every possible field included) -  -   ( []()?);;0;fix a word mistake;;  thank you for the fix ) ||;;;;1;1;fix a word mistake;
1823;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed #1804: url field is not removed by integrity check;better to disable the check than remove the field from the entry.  -)  1804  -   -   (one may think of adding a test that no fields are removed from the entry in the integrity check  but i haven t done that here  ideally the entry should have every possible field included) -  -   ( []()?);;0;describing a dropped hive table shows zero rows;"describing a dropped hive table that has been cached results in the describe showing zero rows rather than ""table  does not exist"":```presto> desc some_table column | type | null | partition key | comment --------+------+------+---------------+---------(0 rows)```";working on it || this bug only appears under distributed circumstances the reason is that when the table is deleted from the data source while its still in the coordinators cache when one try to describe the table the coordinator will say hey the table its here and throw the job to a worker the worker doesnt have that cache content so its just gonna fetch from the database and got nothing back so thats where the `(0 rows)` comes fromto repro it you better have started at least a coordinator and a worker they must have different ip addresses (try to use ip on different network interface if youre using a single machine) and have the coordinator started with the following parameters:```-dnode-schedulerinclude-coordinatorfalse-dnode-schedulerlocation-aware-scheduling-enabledfalse```and for the worker:```-dcoordinatorfalse```then try to create a table desc it drop it and then desc it again note that its possible this bug will not appear everytime in most cases it will repro if its not try start more worker nodes ||  ||;;;;0;1;;
1823;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fixed #1804: url field is not removed by integrity check;better to disable the check than remove the field from the entry.  -)  1804  -   -   (one may think of adding a test that no fields are removed from the entry in the integrity check  but i haven t done that here  ideally the entry should have every possible field included) -  -   ( []()?);;0;"native java agent for ""async call stacks""";"speaking with tal weiss at qconsf (@takipi  it sounds like there may be some efficient approaches to capturing the callstack as longs (using c in native code) at each async invocation point in an `observable` sequence so that in event of `onerror` we could rebuild the stacktrace (paying the cost only then) and end up with more useful error information that normal stack traces offer in async and composed systems like rx this could enhance what we can do with  but also allow an ""rxexception"" that contains the graph and callstack at each method invocation point along the way it wont necessarily be a simple stack since an observable can split and merge but we should be able to either capture the full graph or the path to the error";"this would be amazing would it work on android though? i assume not dueto it not being the jvmperhaps a native extension could also be developed on androidon 6 nov 2014 08:02 ""ben christensen"" notifications@githubcom wrote:> speaking with tal weiss at qconsf (@takipi   it sounds like there may be some efficient> approaches to capturing the callstack as longs (using c in native code) at> each async invocation point in an observable sequence so that in event of> onerror we could rebuild the stacktrace (paying the cost only then) and> end up with more useful error information that normal stack traces offer in> async and composed systems like rx> > this could enhance what we can do with>  but also allow an ""rxexception""> that contains the graph and callstack at each method invocation point along> the way it wont necessarily be a simple stack since an observable can> split and merge but we should be able to either capture the full graph or> the path to the error> > —> reply to this email directly or view it on github>  || i doubt this particular option would be available on android i dont know enough about dalvik at this time to understand options if dalvik exposes hooks or apis that allow this type of thing we could definitely take advantage of it  || what is the trick to do that? || more on this topic can be found here:  goes beyond my skill set so can only conceptually discuss it apparently the concept is:- at each call site capture a pointer to memory in c with the callstack information- store this pointer in the java object (observable operator instance?)- if debug occurs (manually or via onerror) read through the pointers and capture the callstacks for each operator- build a ""callstack graph"" for the observable chain (expensive memory allocation getting code lines etc)- if more than x seconds passes free up the memory of those callstacks in c that are being referenced by pointersapparently this can be done very efficiently in c++ deep in the jvm with a native agent in java however it is quite expensive to call `threadgetstacktrace()` as it done many native calls and allocates a large array of strings so we definitely dont want to be doing that on every operator invocation in the happy path || pr is welcome although it might be better to have such tool in a separate project - not sure how wed build and release a separate agent jar with the current infrastructure || android does have ndk (c and c++) with jni access too  || closing as very old and being a complicated topic other async solutions also struggle with this and i havent seen any solution for the either despite the support from their major ide vendor || ";;;;0;1;;
1832;0;1;0;0;0;0;0;1;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add matchers for incompatible type matchers;we discovered that users run into issues with using the wrong mockito;;0;add matchers for incompatible type matchers;we discovered that users run into issues with using the wrong mockitomatcher for arguments examples include `any(integerclass)` instead of`anyint()` and `anyint()` instead of `anyfloat()` users then run intocryptic run-time errors that are difficult to understandthese errorprone checkers make these a compile warning to warn the userbefore hand they also provide the appropriate fixes that can bedirectly applied;" merging 1832  this for now as it upstreams a checker that prevents real issues on runtime we can change the mockito api but i would rather prevent users from running into runtime exceptions when we can || ";;;;1;1;add matchers for incompatible type matcherswe discovered that users run into issues with using the wrong mockitomatcher for arguments examples include `any(integerclass)` instead of`anyint()` and `anyint()` instead of `anyfloat()` users then run intocryptic run-time errors that are difficult to understandthese errorprone checkers make these a compile warning to warn the userbefore hand they also provide the appropriate fixes that can bedirectly applied;
1832;0;1;0;0;0;0;0;1;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add matchers for incompatible type matchers;we discovered that users run into issues with using the wrong mockito;;0;explain droptable dropview and renametable;fix nullpointerexception when trying to explain rename or explain drophttps://githubcom/facebook/presto/issues/1812;havent checked - does explain create table create view etc work? || @snarayananqubole thanks for the note createtableasselect createviewasselect are working only the ddls not having any query associated with it are broken droptable dropview and renametable ive updated the code to add support for these ddls || @martint code rebased also add explain create table || @cberner @martint kindly ping || i think this is the wrong approach instead we should be able to inject `map<class<? extends statement> datadefinitiontask<?>> tasks` into `queryexplainer` (same as `datadefinitionexecutionfactory`) then call `getname()` on the taskthis could be improved later to have an `explain()` method that takes the `statement` allowing it to show `rename table foo to bar` rather than just `rename table` but lets start with `getname()` || @electrum get it thanks for your comment i will do it || @electrum do you mean make queryexplainer an interface and having a factory to create query explain execution for datadefinition and query? || ah yeah the way `queryexplainer` is used makes this more difficult this might take some refactoring would need to play around with it || superseded by #3524 ||;;;;0;1;;
1832;0;1;0;0;0;0;0;1;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add matchers for incompatible type matchers;we discovered that users run into issues with using the wrong mockito;;1804.0;fix take early unsubscription causing interrupts;fixes  is one approach to fixing #1804 that still works with the unit tests that `take` had been changed for originallystill not sure if we should change the default behavior though to not interrupt a thread;seems this fix makes the most sense so that regardless of interrupt behavior things work as expected ||;"""interrupted while waiting for subscription to complete"" in 100-rc8";doesnt happen on rc7  i can repro 100% of the time  happens on both kitkat and lollipop so i dont think its specific to any particular android version```fatal exception: rxcachedthreadscheduler-4process: commycompanymyappdevelopment pid: 4413javalangillegalstateexception: exception thrown on schedulerworker thread add `onerror` handling        at rxinternalschedulersscheduledactionrun(scheduledactionjava:50)        at javautilconcurrentexecutors$runnableadaptercall(executorsjava:422)        at javautilconcurrentfuturetaskrun(futuretaskjava:237)        at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:152)        at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:265)        at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1112)        at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:587)        at javalangthreadrun(threadjava:818)caused by: rxexceptionsonerrornotimplementedexception: interrupted while waiting for subscription to complete         at rxobservable$30onerror(observablejava:7252)        at rxobserverssafesubscriber_onerror(safesubscriberjava:127)        at rxobserverssafesubscriberonerror(safesubscriberjava:96)        at rxinternaloperatorsoperatormap$1onerror(operatormapjava:48)        at rxinternaloperatorsoperatormap$1onnext(operatormapjava:56)        at rxinternaloperatorsnotificationliteaccept(notificationlitejava:150)        at rxsubjectssubjectsubscriptionmanager$subjectobserveremitnext(subjectsubscriptionmanagerjava:254)        at rxsubjectsbehaviorsubjectonnext(behaviorsubjectjava:166)        at rxobservable$34onnext(observablejava:7437)        at rxobserverssafesubscriberonnext(safesubscriberjava:104)        at rxinternaloperatorsoperatormerge$innersubscriberemit(operatormergejava:610)        at rxinternaloperatorsoperatormerge$innersubscriberonnext(operatormergejava:536)        at rxinternaloperatorsoperatorsingle$1oncompleted(operatorsinglejava:75)        at rxinternaloperatorsoperatortake$1onnext(operatortakejava:72)        at rxinternaloperatorsoperatorsubscribeon$1$1$1onnext(operatorsubscribeonjava:76)        at commycompanyservercallservercall$1$1call(servercalljava:56)        at commycompanyservercallservercall$1$1call(servercalljava:47)        at rxobservableunsafesubscribe(observablejava:7464)        at rxinternaloperatorsoperatorsubscribeon$1$1call(operatorsubscribeonjava:62)        at rxinternalschedulersscheduledactionrun(scheduledactionjava:45)         7 more caused by: javalangruntimeexception: interrupted while waiting for subscription to complete         at rxobservablesblockingobservableblockforsingle(blockingobservablejava:474)        at rxobservablesblockingobservablesingle(blockingobservablejava:348)        at commycompanymyappdatacachedthingbuildcachedthing(cachedthingjava:66)        at commycompanymyappdatacachedthing<init>(cachedthingjava:28)        at commycompanymyappdatafilterfunccall(filterfuncjava:189)        at commycompanymyappdatafilterfunccall(filterfuncjava:175)        at commycompanymyappdatacachedthingmerge(cachedthingjava:60)        at commycompanymyappdataresponsecacheupdate(responsecachejava:80)        at commycompanymyappdatatransformfunccall(transformfuncjava:105)        at commycompanymyappdatatransformfunccall(transformfuncjava:99)        at commycompanyservercallcallstate$3map(callstatejava:79)        at commycompanyservercallcallstate$9call(callstatejava:195)        at commycompanyservercallcallstate$9call(callstatejava:193)        at rxinternaloperatorsoperatormap$1onnext(operatormapjava:54)         22 morecaused by: javalanginterruptedexception        at javautilconcurrentlocksabstractqueuedsynchronizeracquiresharedinterruptibly(abstractqueuedsynchronizerjava:1279)        at javautilconcurrentcountdownlatchawait(countdownlatchjava:202)        at rxobservablesblockingobservableblockforsingle(blockingobservablejava:471)         35 morecaused by: rxexceptionsonerrorthrowable$onnextvalue: onerror while emitting onnext value: class         at rxinternaloperatorsoperatormap$1onnext(operatormapjava:56)         22 more````cachedthingbuildcachedthing` has this block of code that i think is the culprit:```list<subthing> subthings  observablefrom(things) //        map(transformfunction) //        filter(not(isnullfunction)) //        distinct() //        tolist() //        toblocking() //        single()```i tried writing a testcase to repro but couldnt get it to fail  im guessing theres something broken between the android runtime and rxjavas thread management but i couldnt get any further than that;"the only thing in rc8 that seems related is this:  || i can not replicate with this code:``` javaimport javautillistimport rxfunctionsfunc1public class testing {    public static void main(string args) {        list<string> subthings  observablerange(0 1000)                map(new func1<integer string>() {                    @override                    public string call(integer i) {                        return stringvalueof(i + 1)                    }                })                filter(new func1<string boolean>() {                    @override                    public boolean call(string t) {                        return t ! null                    }                }) //                distinct() //                tolist() //                toblocking() //                single()        systemoutprintln(subthings)    }}``` || the code that is being interrupted is this:  java        try {            latchawait()        } catch (interruptedexception e) {            threadcurrentthread()interrupt()            throw new runtimeexception(""interrupted while waiting for subscription to complete"" e)        }```this means the thread was blocked on the latch waiting for a result but while it was waiting it got interrupted i dont know what thread you are doing this on nor do i know much about android if android is using pools of threads it could perhaps retain the right to interrupt and reclaim threads? i know event loops in some frameworks do that kind of thing if something is blocked in them and new work is scheduled rxjava itself does not interrupt threads anywhere (that im aware of  and i cant think of any reason we would) so im inclined to suggest looking at what thread you are blocking in and see if android itself could be interrupting it?also could you move to a model where you dont block and instead compose it all together reactively? || moving to 10x as its not obvious yet what is going on here || encountered this on jellybean code in my application subclass:``` javaobservable<somesharedpreferenceswrapper> prefsprefetch  asyncstart(this::prefetchprefs)```and later in same class:``` javareturn prefsprefetchtoblocking()single()```i cant grasp exact circumstances when issue reproduces itself at first glance they seem to be random but happens often enough to make prefetching stuff with rxjava pretty much impossible || im gonna work on putting together a minimal test android app to try and isolate the issue ||  wasnt able to repro until i added the publishsubject layermaybe the issue is the nested toblocking() calls? || does android ever interrupt a thread based on user or system activity? if so then the `toblocking()` will always be vulnerable to interruption since anytime a thread is blocked/waiting it can be interrupted is requestonnext ever being called concurrently or is it sequentially? i cant tell for sure but it looks okay as it looks like its only ever the single ui thread that would trigger an onnext if you intend on calling it concurrently wrap it in a serializedsubjectif the ui event listener triggers before `observethingsstart` completes then `request` may not yet be initialized or the pipeline may not yet be initialized it looks like that could be race condition  but i dont understand how `mainactivity` works well enough is that all on the ui thread or does a background thread do that and then the `setonclicklistener` register with the ui thread?i dont particularly see anything wrong in this code  though to be more idiomatic i would suggest using the observable sequence to manipulate the data instead of doing it inside the `subscribe` you really should never need to use `toblocking` the only 3 times that is ever intended are:1) example code in a main method2) unit tests (and even then you should probably use testsubscribeawaitterminalevent instead)3) bridging between a blocking and non-blocking system such as a servlet in this case instead of doing flatmapsubscribe(all logic here) do something like this instead:``` javarequestflatmap(mapresult)map(transformfunction)filter(notnull())distinct()tolist()subscribe(yourlisthere)```this is more idiomatic doesnt involve creating another observable and never requires doing the `toblocking` stuff which is kind of the point of rx you should only ever have 1 subscribe at the very end of your flow and it should just be the side-effect no actual processing in it || mainactivity all happens on the main thread as does the onclickhandlerive worked around the problem in our app by no longer using `toblocking` in our subscribe method but i still think there might be an rx bug here  android shouldnt interrupt unless theres a deadlock of some sort and im afraid the nested toblocking calls (discouraged though they may be) are causing the thread to stall  regardless the workaround is easy so i dont think this should be a 10 blocker  thanks for looking into it! || you should really only ever call to blocking in command line test scripts but never in production codeif you really need to end up blocking you may as well push all the blocking backwardsvand write regular synchrounius code  || maybe we should mark toblocking as depricated (forever) such that you get a warning every time you use it  || deprecated seems wrong to me since its never actually going to be removed  im all in favor of updating the docs to reflect the recommended uses of toblocking though  or maybe deprecate `toblocking()` and delegate to a new method called `areyoureallysureyouneedtoblocking()` or something obnoxious like that? || > you should really only ever call to blocking in command line test scripts but never in production codenot everyone have their entire codebase under their control also in android there are already plenty of ways to move tasks to background threads: all those legacy `loader`s `asynctask`s and `abstractthreadedsyncadapter`s requires certain data to be available directly without observable shenanigans> does android ever interrupt a thread based on user or system activity?i am not sure about this one but futuretask/executorservice combo was working just fine before migrating to rxjava (so was the previous version of rxjava before updating to rc8) || @edenman> android shouldnt interrupt unless theres a deadlock of some sort and im afraid the nested toblocking calls (discouraged though they may be) are causing the thread to stallcan you provide a reference to documentation about how android does this? that would be helpful if it does this then any sort of blocking would be vulnerable to interruption > not everyone have their entire codebase under their controlunderstood though i still suggest putting most of the processing into the observable chain and not even having a `subscribe` step and just going direct to `toblocking()` if you actually are just using it as an iterable with higher-order functions  || if this doesnt happen on rc7 but does on rc8 then lets binary search what is causing it here is what changed:  is the only change that may be related:  how it now triggers the unsubscribe upwards before the onnext is emitted whereas before it was afterthis could theoretically result in work upstream canceling a future which interrupts a thread if everything is happening on the same thread  || cant find any android docs that describe what were seeing  [here]( the docs on anr (application not responding) but were seeing an actual crash  maybe worth seeing if its rxjava itself that is interrupting the thread? || > maybe worth seeing if its rxjava itself that is interrupting the thread?yup i pointed to a change in rc8 above that could potentially cause this im trying to hunt down options  || here are the two places i can see that may result in an interrupt:-   first one is used by virtually all use of schedulers to allow canceling work on a scheduler i still cant replicate an interrupt with `take` but conceptually i can see how an interrupt could happen || i can replicate:``` java    @test    public void testinterrupt() throws interruptedexception {        final atomicreference<object> exception  new atomicreference<object>()        final countdownlatch latch  new countdownlatch(1)        observablejust(1)subscribeon(schedulerscomputation())take(1)subscribe(new action1<integer>() {            @override            public void call(integer t1) {                try {                    observablejust(t1)toblocking()single()                } catch (exception e) {                    exceptionset(e)                    eprintstacktrace()                } finally {                    latchcountdown()                }            }        })        latchawait()        assertnull(exceptionget())    }``````cancelling  and can interruptjavalangruntimeexception: interrupted while waiting for subscription to complete    at rxobservablesblockingobservableblockforsingle(blockingobservablejava:475)    at rxobservablesblockingobservablesingle(blockingobservablejava:349)    at rxinternaloperatorsoperatortaketest$12call(operatortaketestjava:376)    at rxinternaloperatorsoperatortaketest$12call(operatortaketestjava:1)    at rxobservable$31onnext(observablejava:7209)    at rxobserverssafesubscriberonnext(safesubscriberjava:104)    at rxinternaloperatorsoperatortake$1onnext(operatortakejava:70)    at rxinternaloperatorsonsubscriberedo$2$1onnext(onsubscriberedojava:229)    at rxinternaloperatorsoperatorsubscribeon$1$1$1onnext(operatorsubscribeonjava:76)    at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:41)    at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:1)    at rxobservableunsafesubscribe(observablejava:7374)    at rxinternaloperatorsoperatorsubscribeon$1$1call(operatorsubscribeonjava:62)    at rxinternalschedulersscheduledactionrun(scheduledactionjava:45)    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:511)    at javautilconcurrentfuturetaskrun(futuretaskjava:266)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:180)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:293)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)    at javalangthreadrun(threadjava:745)caused by: javalanginterruptedexception    at javautilconcurrentlocksabstractqueuedsynchronizeracquiresharedinterruptibly(abstractqueuedsynchronizerjava:1302)    at javautilconcurrentcountdownlatchawait(countdownlatchjava:231)    at rxobservablesblockingobservableblockforsingle(blockingobservablejava:472)     20 more```reverting  does fix thisso now to figure out if  can be achieved in a different way or if we need to solve the interruption issue || here is a simpler test:``` java    @test    public void testinterrupt() throws interruptedexception {        final atomicreference<object> exception  new atomicreference<object>()        final countdownlatch latch  new countdownlatch(1)        observablejust(1)subscribeon(schedulerscomputation())take(1)subscribe(new action1<integer>() {            @override            public void call(integer t1) {                try {                    threadsleep(100)                } catch (exception e) {                    exceptionset(e)                    eprintstacktrace()                } finally {                    latchcountdown()                }            }        })        latchawait()        assertnull(exceptionget())    }``` || ugh  choosing whether to default to interrupting or not is a difficult one it seems that perhaps we should not any insights on this? || i have submitted a possible fix but want to think about this morei cant find an authoritative answer on whether we should default to interrupting or not when the scheduled future is canceled i think we should change to not interrupting but want to be sure thats correct as weve had it set to interrupt all along || > but want to think about this more same here || a quick note about `thread` interruptions on android afaik application process is killed in case of anrs (either automatically or after a user confirmation) so anrs do not lead to thread interruptionshowever there is a case when i use `toblocking` and get an interruption: sync adapter thread on android we can create a component that will be plugged to the sync part of the framework basically android framework spawns a new thread for you and invokes your code in that thread application sync is supposed to be finished when this thread finishes in our sync adapter code we build a chain of observables that can perform some operations concurrently using other threads so the sync adapter code invoked in the sync thread looks like `buildchainofobservables()toblocking()single()`sync can be canceled (eg by user request unchecking a checkbox in system settings or when it takes too long) and a default implementation of cancelation request is this sync thread interruption || @headinthebox a consideration here is that the place we are interrupting the threads is really just for unscheduling any scheduled actions from a scheduler i think we intend `subscriptionisunsubscribed()` to be the mechanism for something to gracefully stop it seems to me that we should not interrupt a thread automatically and that if a developer needs to do that their `observable` should register a `subscription` via `subscriberadd` that chooses to do sowe can work around this particular `take` issue but it makes me wonder if we would trigger this type of issue anywhere else it seems that interrupting threads is a very nuanced thing that most code doesnt handle well and that we shouldnt be interrupting threads ""under the covers""therefore i suggest we change from `futurecancel(true)` to `futurecancel(false)` for the 2 places we capture a `future` and cancel it when unsubscribing  || @roman-mazur thanks for that information it is useful information if i understand correctly you are saying there are normal cases when android can and will interrupt a thread and thus application code must account for this is this what youre saying?as far as rxjava is concerned im suggesting we eliminate the two places where rxjava is the culprit for interrupting the thread (despite #1832 working around the particular issue of using `single` that triggers the issue) || > it seems to me that we should not interrupt a thread automaticallywait so you do interrupt threads right now dont you? does that mean that unsubscribing from observale (in currently released version) during interruptable operation will interrupt it? will operations created with `async-utils` (eg via `asyncfromcallable()`) be interrupted? or is it some internal mechanic for disposing of schedulers only?if former it would be really cool to leave it be> if i understand correctly you are saying there are normal cases when android can and will interrupt a thread and thus application code must account for this is this what youre saying?i wouldnt call `abstractthreadedsyncadpter` a normal case interrupting worker thread is just an implementation detail which can be changed by overriding single method also sync framework in general is rather special and restrictive environment and interrupting threads isnt worst thing awaiting developer there (for example failure to intercept any exceptions may result in sync adapter being completely banned from execution by os) || @benjchristensen i would rather say that android framework is unlikely to interrupt an application thread the sync worker is the only known example and interruption is a default behaviour that can be changedbut note that im forced to use `toblocking` within this thread because there is no other way to indicate that sync is finishedi wonder what happens when `toblocking()single()` is interrupted as far as i understand an error is propagated does it lead to un-subscriptions? || @roman-mazur > i wonder what happens when toblocking()single() is interrupted as far as i understand an error is propagated does it lead to un-subscriptions?if it is interrupted while waiting on the single item we just fail right now i suppose we could call `unsubscribe` upwards before throwing this is what currently happens:``` java        try {            latchawait()        } catch (interruptedexception e) {            threadcurrentthread()interrupt()            throw new runtimeexception(""interrupted while waiting for subscription to complete"" e)        }``` || @alexander-- > or is it some internal mechanic for disposing of schedulers only?rxjava core libraries only interrupt when unsubscribing a scheduled action on a `scheduler` that is still running this is in turn just leveraging the `futurecancel` semantics of java rxjava does not actually ever call `threadinterrupt`the async-utils are just utility methods on top of schedulers so unless there is some effort to specifically prevent interrupt (nothing i can see while browsing the code) they will also be interrupted if they are still executing when unsubscribe is invoked > unsubscribing from observale (in currently released version) during interruptable operation will interrupt it?if a scheduler is not involved rxjava itself does nothing other than invoke `subscriptionunsubscribe` which flips a boolean and calls any registered callbacks thus an `observable` implementation can choose to register a `subscription` that then interrupts and interruptible unit of work im wondering if that is better for an observable implementation (via `observablecreate`) to opt-in to interrupts rather than the current `scheduler` interrupt mechanism which seems like it could be surprising  || ";1;0;fix take early unsubscription causing interruptsfixes https://githubcom/reactivex/rxjava/issues/1804;
1845;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix localization entry.;replace determinated with terminated in  en .;;0;cache builder with keys using soft references; building a map whose keys use soft references was possible until guava 13 by calling mapmakersoftkeys()makemap(): resulting map used  to compare keys (by default) then using objects whose classes override equals() as keys was a bad idea even with weak keys and recreating the same () key was impossible therefore weakkeys() and softkeys() had more or less the same effect except that the behavior of the former was more predictablehowever the objects that i use override both equals and hashcode() i will have to use cachebuilderkeyequivalence(equivalence) (which isnt public) to modify the key equivalence and after that using soft keys will make sense thats why id like to reintroduce softkeys() but rather in cachebuilderplease find enclosed my patch ill probably have to test it and improve itwe talked about the limitation that annoyed me and lead me to create this patch here //stackoverflowcom/questions/25666925/implementation-of-a-cache-using-soft-references-both-for-keys-and-values; thats exactly what im saying and im arguing that that gets you essentially the behavior youre looking for || ";;;;0;1;;
1845;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix localization entry.;replace determinated with terminated in  en .;;0;handle nested maps correctly in map_keys;;;;;;0;1;;
1845;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix localization entry.;replace determinated with terminated in  en .;;0;rxringbuffer concurrent unsubscribe non-threadsafe;rx-java version 0206```javalangnullpointerexception        at rxinternalutilrxringbufferpoll(rxringbufferjava:282)        at rxinternaloperatorsoperatormerge$innersubscriberdrainall(operatormergejava:723)        at rxinternaloperatorsoperatormerge$innersubscriberdrainqueue(operatormergejava:744)        at rxinternaloperatorsoperatormerge$innersubscriberaccess$300(operatormergejava:505)        at rxinternaloperatorsoperatormerge$mergesubscriber$1call(operatormergejava:376)        at rxinternaloperatorsoperatormerge$mergesubscriber$1call(operatormergejava:369)        at rxinternalutilindexedringbufferforeach(indexedringbufferjava:281)        at rxinternalutilindexedringbufferforeach(indexedringbufferjava:247)        at rxinternalutilsubscriptionindexedringbufferforeach(subscriptionindexedringbufferjava:131)        at rxinternaloperatorsoperatormerge$mergesubscriberdrainchildrenqueues(operatormergejava:331)        at rxinternaloperatorsoperatormerge$mergesubscriberdrainqueuesifneeded(operatormergejava:308)        at rxinternaloperatorsoperatormerge$mergesubscriberaccess$400(operatormergejava:96)        at rxinternaloperatorsoperatormerge$innersubscriberemit(operatormergejava:674)        at rxinternaloperatorsoperatormerge$innersubscriberonnext(operatormergejava:528)        at rxinternaloperatorsoperatorsubscribeon$1$1$1onnext(operatorsubscribeonjava:76)        at rxobserverssafesubscriberonnext(safesubscriberjava:105)        at rxinternaloperatorsonsubscribefromiterable$iterableproducerrequest(onsubscribefromiterablejava:96)        at rxinternaloperatorsoperatorsubscribeon$1$1$1$1request(operatorsubscribeonjava:88)        at rxsubscribersetproducer(subscriberjava:150)        at rxinternaloperatorsoperatorsubscribeon$1$1$1setproducer(operatorsubscribeonjava:81)        at rxsubscribersetproducer(subscriberjava:144)        at rxinternaloperatorsonsubscribefromiterablecall(onsubscribefromiterablejava:47)        at rxinternaloperatorsonsubscribefromiterablecall(onsubscribefromiterablejava:33)        at rxobservablesubscribe(observablejava:8680)        at ********************        at ********************        at rxobservableunsafesubscribe(observablejava:8591)        at rxinternaloperatorsoperatorsubscribeon$1$1call(operatorsubscribeonjava:62)        at rxschedulersexecutorscheduler$executoractionrun(executorschedulerjava:173)        at rxschedulersexecutorscheduler$executorschedulerworkerrun(executorschedulerjava:99)        at javautilconcurrentforkjointask$adaptedrunnableexec(forkjointaskjava:1265)        at javautilconcurrentforkjointaskdoexec(forkjointaskjava:334)        at javautilconcurrentforkjoinworkerthreadexectask(forkjoinworkerthreadjava:604)        at javautilconcurrentforkjoinpoolscan(forkjoinpooljava:784)        at javautilconcurrentforkjoinpoolwork(forkjoinpooljava:646)        at javautilconcurrentforkjoinworkerthreadrun(forkjoinworkerthreadjava:398)```;are you able to reproduce this and can you provide a unit test?does this also occur with rxjava 100-rc10?  || i was able to consistently reproduce this bug with the following: here is the stack trace for the unit test: fails on both 0206 and 100-rc10 succeeds on 0196 || thanks ill look at this || the queue is null on that line so either it was released before or the pool didnt provide one at start or there is a visibility issue because it is not volatile || > i was able to consistently reproduce this bug with the following:thank you very helpful it fails every time for me  but if i remove `subscribeon` it works so there is a race condition somewhere working on this now || the code can be  by removing the nested `subscribe` and composing things:``` java    private observable<integer> keysobservable() {        return observablerange(0 10000)flatmap(new func1<integer observable<integer>>() {            @override            public observable<integer> call(final integer t1) {                return observablefrom(listitems(1))subscribeon(executorscheduler)//                return observablecreate(new onsubscribe<integer>() {////                    @override//                    public void call(subscriber<? super integer> t2) {//                        observablefrom(listitems(1))subscribe(t2)//                    }//                })subscribeon(executorscheduler)            }        })    }```i am still trying to figure out if there is a way to handle the rxringbuffer issue when it gets unsubscribed prematurely || this is going to have to be done in 10x as its going to take some thought and workthis is an edge case so im comfortable continuing with 10 as is since this code has spent a couple months being used@laktech i suggest you adopt the composition approach shown in my previous comment and avoid using `subscribe` to compose things together it chains subscriptions together which can have unexpected results the composition operators like `merge` (used  flatmap`) take care of this and use `unsafesubscribe` to chain subscriptions throughill come back to this and try to figure out a way for rxringbuffer to behave safely with concurrent unsubscribe while not killing the performance  || @benjchristensen thanks for looking into thisare there any semantical differences between using `subscribe` and the composition approach? my motivation to invoke `subscribe` was to ensure `listfiles(1)` was 1) invoked for each subscriber and 2) not called until there was a subscriber which is very explicit with `subscribe` it seems easy to test but thought id just ask :-p || semantically no it will get invoked the same as what is being done via the manual `observablecreate``subscribe` if you change the `subscribe` to `unsafesubscribe` youll get the correct behavior without the over-eager unsubscribe which is causing the issues || great thanks for the work-around || reading code again the `listfiles(1)` is slightly more eager in the composed version and will happen on the emitting thread rather than the `subscribeon` thread since it happens inside the `flatmap` rather than the `subscribeon` so if you want to solve that you could use `defer`:``` javareturn observabledefer(() -> observablefrom(listitems(1)))subscribeon(executorscheduler)```in my test this moves the `listitems` from the main thread to the scheduler thread || ive tried to fix this but apart from making the npe go away by reading queue once everywhere and not adding the rxringbuffer to the innersubscription to be unsubscribed im lost what i would like to do is to call queueunsubscribe if the inner subscription receives an onerror or oncompleted but due to backpressure im not certain if putting it into drainrequested and drainall is enough || fixed in 105 ||;;;;0;1;;
1845;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix localization entry.;replace determinated with terminated in  en .;;1815.0;"revert ""add duration overloads 1815""";reverts mockito/mockito#18181843; merging 1845 ;fr: add mockitotimeout(javatimeduration) and after(javatimeduration);representing durations as `long`s is very error prone weve seen (and ) hundreds of unit mismatch bugs inside of googlewe (guava) have recently updated most of our public apis to add `javatimeduration`-based overloads [caffeine]( and [selenium]( have done so as wellbasically id like to see the following apis added:`mockitoafter(javatimeduration)``mockitotimeout(javatimeduration)`and ideally the `long`-accepting apis would be deprecated;that would makes sense to me feel free to open a pr to add these methods@mockito/developers we have a lot of evidence of `long`s being misused in common apis do you have any concerns if we deprecate the `after(long)` in favor of `after(javatimeduration)` (and the same for `timeout`)? || ideally wed plumb the `duration` all the way through the various layers of mockito:- `orgmockitoverificationafter`- `orgmockitoverificationtimeout`- `orgmockitointernalverificationverificationovertimeimpl`- `orgmockitointernalutiltimer`i assume `after` and `timeout` need to maintain backwards compatibility but the latter 2 are in an `internal` package - does that mean i dont need to maintain backwards compatibility? am i free to make breaking changes to those apis? || yes any api in `orgmockitointernal` is not included in our semver policy and we are free to change || i second that now that mockito 3 is java 8 based ! ||;1;0;"revert ""add javatimeduration overloads to `timeout` and `after` (#1818)""this reverts commit 9603fb28158de0fb519611d58e931bf7b4bbc33c";
1847;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed undetected unused stubbing when matching previous stubbed call;1846;;0;in guava 18 mapmakermakecomputingmap scope has changed but its referenced from guice 4 beta4;cl@ javalangillegalaccesserror: tried to access method comgooglecommoncollectmapmakermakecomputingmap(lcom/google/common/base/function)ljava/util/concurrent/concurrentmap from class comgoogleinjectinternalannotations$annotationcheckerat comgoogleinjectinternalannotations$annotationchecker(annotationsjava:104)at comgoogleinjectinternalannotations(annotationsjava:122)at comgoogleinjectspiinjectionpoint(injectionpointjava:94)at comgoogleinjectspiinjectionpoint$injectablefieldtoinjectionpoint(injectionpointjava:440)at comgoogleinjectspiinjectionpointgetinjectionpoints(injectionpointjava:725)at comgoogleinjectspiinjectionpointforinstancemethodsandfields(injectionpointjava:358)at comgoogleinjectspiinjectionpointforinstancemethodsandfields(injectionpointjava:377)at comgoogleinjectinternalbindingbuildertoinstance(bindingbuilderjava:84)i know the method is marked as deprecated but changing its scope has resulted in other libraries with dependencies on it that havent been updated including guice;cl@ cross reference guice issue:  || was never a guava bug ||;;;;0;1;;
1847;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed undetected unused stubbing when matching previous stubbed call;1846;;0;update window function api to supply partitionstartposition on reset;this reduces the amount of internal state that each window function needs to track and simplifies their logic; aside from comments;;;;0;1;;
1847;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed undetected unused stubbing when matching previous stubbed call;1846;;0;class observers;```create(action1<? super t> onnext)creates an observer that receives the emissions of any observable it subscribes to via onnext but ignores oncompleted notifications```what happens with `onerror`?;;;;;0;1;;
1847;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fixed undetected unused stubbing when matching previous stubbed call;1846;;1846.0; undetected unused stubbing when matching previous stubbed call;1846; merging 1847 ;broken unused stubbing reporting when matching previous stubbed call;"when stubbing the same method call twice and the second stub setup matches to first stubbed call the first stub is not reported as unused because mockito detects the next stub setup as a usage of the previous stub setup this is an example test:```public class unnecessarystubbingwithimpliciteqmatchers {    @mock imethods mock    mockitosession mockito  mockitomockitosession()initmocks(this)strictness(strictnessstrict_stubs)startmocking()    @after public void after() {        mockitofinishmocking()    }    @test public void unnecessary_stubbing() {        given(mocksimplemethod(""1""))willreturn(""one"")        given(mocksimplemethod(""2""))willreturn(""three"")        given(mocksimplemethod(""1""))willreturn(""two"")        given(mocksimplemethod(""1""))willreturn(""four"")        mocksimplemethod(""1"")        mocksimplemethod(""2"")    }}```the test above should fail with `unnecessarystubbingexception` containing two unused stubs but it does notmockito version: v324";"nice catch! ill review the pr! || hey @mockitoguy @andreisilviudragnea i think this pr has introduced a new bug (or a regression if you like)the problem arises when using deep stubs as every call in a deep stub counts as used stubbing but if you end up stubbing that mock for real this change will change the state of the original stubbing and your test will fail with an `unnecessarystubbingexception`the following example is in scala i dont have a running java project at hand but i can provide a 100% java example if this is not enough to explain the problem```scala  class foo {    def userclass: bar  {}  }  class bar {    def callmemaybe: baz  {}  }  class baz {    def callme: option[string]  {}  }val afoo  mock[foo](defaultanswersreturnsdeepstubs)afoouserclasscallmemaybecallme returns some(""my number"")afoouserclasscallmemaybecallmevalue shouldbe ""my number"that code will fail as there are 2 stubbings for `callme` one automatically created by the deep stub (see `returnsdeepstubsclass` line 67) and one for the actual stubbing im making to return `some(""my number"")` || this also breaks tests that needs to legitimately stub the same invocation multiple times particularly with invocations that have to arguments (since all invocations will match a previous stub) see  simple common example is when stubbing a `clock`:```@mockprivate clock clock@test void test() {    instant instant1  instantofepochmillis()    instant instant2  instant1plus()    when(clockinstant())thenreturn(instant1)    // do something at instant1    when(clockinstant())thenreturn(instant2)    // do something at instant2}``` || @pkoenig10 yes although that may not be the best example as you could use a chain of `thenreturn()` and have a single stubbingthat said for a non-experienced user that may not be obvious at all so wed have to weight it || its not obvious to me how you would work around this if your code calls `clockinstant()` a large or variable number of times i find the suggested work around to be pretty verbose and unergonomic:```when(clockinstant())    thenreturn(instant1)    thenreturn(instant1)    // repeat however many times is necessary    thenreturn(instant2)    thenreturn(instant2)    // repeat however many times is necessary```i think the best and simplest way to improve this behavior is to not unmark the previous stubbing if it has been used if the stubbing has not previously been used then i think the current behavior is appropriate unfortunately this does seem like it will be a simple fix since the a second stubbing causes a previous stubbing to be marked as used || @pkoenig10 i fail to see how that is less verbose than multiple stubbings but in any case thats not the pointi think this change should be reverted until it can be given a deeper thought do you agree? @mockito/developers ? || revert in progress:  || ";1;0;improved the test coverage- made the tests less complicated- added assertions on the _count_ of unnecessary stubbings- made the exception message more informative;
1849;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;performance optimization by using method.getparametercount() where possible;hi;;0;hashing support for bcrypt; please support bcrypt in comgooglecommonhashhashing future-adaptable password scheme"" by niels provos and david mazieres (usenix 1999)http://wwwopenbsdorg/papers/bcrypt-paperps"; > sha256() are outdated and insecurethats pure nonsense sha-256 is still rather modern (sha-3 is out but itll take years) and secure hash functionbcrypt is no hash function its a key derivation function using hash functions as a kdf is insecure no matter how good the functiona kdf is no comgooglecommonhashhashfunction as it always needs a salt this is can be an additional input[1]( or generated randomly[2]( fitting it to the interface by fixing an argument would be a very stupid idea allowing a hash function to behave randomly would be no smarterim not saying that it doesnt belong to guava im just saying that it doesnt belong to the hash package no hf is a kdf and vice versa || closing given the lack of interest in the past 5 years ||;;;;0;1;;
1849;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;performance optimization by using method.getparametercount() where possible;hi;;0;perf fixes;;;;;;0;1;;
1849;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;performance optimization by using method.getparametercount() where possible;hi;;0;class serializedsubscriber<t>;`observer` should be replaced  subscriber`;i didnt see any references to observer in the javadocs inobservers/serializedsubscriberjavaon mon nov 10 2014 at 11:25 am headinthebox notifications@githubcomwrote:> assigned #1849  to> @davidmgross  > —> reply to this email directly or view it on github>  david m grossplp consulting ||  > class serializedsubscriber<t>constructor and descriptionserializedsubscriber(subscriber<? super t> s) method summarymethods modifier and type   method and descriptionvoid    oncompleted()notifies the **observer** that the **observable** has finished sending push-based notificationsvoid    onerror(javalangthrowable e)notifies the **observer** that the **observable** has experienced an error conditionvoid    onnext(t t)provides the **observer** with a new item to observe ||;;;;0;1;;
1849;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;performance optimization by using method.getparametercount() where possible;hi;;1848.0;performance optimization by using methodgetparametercount() where possible;hias described in #1848 we could make use of `methodgetparametercount()` in order to save some overhead from unnecessary cloning caused  methodgetparametertypes()`as this is my first contribution to mockito let me know if i can do something to helplet me know what you thinkcheerschristoph; merging 1849  < ;use methodgetparametercount() where possible;hias of mockito 3x and its java 8 requirement we could make use of `methodgetparametercount()` to avoid unnecessary cloning caused  methodgetparametertypes()`i will shortly open a pr with the proposed changescheerschristoph;;1;0;1848 : use methodgetparametercount() where possible;
1850;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;522 : basic test suite for osgi framework;this is a proposal for a basic test project to ensure that the mockito artifacts can be consumed from an osgi environment. for example  reverting the fix for #678 is caught with the following exception:;;0;class testsubscriber<t>;i think `observer` should be replaced  subscriber` here as well;i didnt find any refs to observer in the javadocs here eitheron mon nov 10 2014 at 11:27 am headinthebox notifications@githubcomwrote:> assigned #1850  to> @davidmgross  > —> reply to this email directly or view it on github>  david m grossplp consulting || public class testsubscriber<t>extends subscriber<t>subscriber usable for unit testing to perform assertions inspect received events or wrap a mocked subscriberconstructor summaryconstructors constructor and descriptiontestsubscriber() testsubscriber(observer<t> delegate) testsubscriber(subscriber<t> delegate) method summarymethods modifier and type   method and descriptionvoid    assertnoerrors()assert that this **subscriber** has received no onerror notificationsvoid    assertreceivedonnext(javautillist<t> items)assert that a particular sequence of items was received by this subscriber in ordervoid    assertterminalevent()assert that a single terminal event occurred either testsubscriberoncompleted() or testsubscriberonerror(javalangthrowable)void    assertunsubscribed()assert that this **subscriber** is unsubscribedvoid    awaitterminalevent()blocks until this **subscriber** receives a notification that the observable is complete (either an oncompleted or onerror notification)void    awaitterminalevent(long timeout javautilconcurrenttimeunit unit)blocks until this subscriber receives a notification that the observable is complete (either an oncompleted or onerror notification) or until a timeout expiresvoid    awaitterminaleventandunsubscribeontimeout(long timeout javautilconcurrenttimeunit unit)blocks until this subscriber receives a notification that the observable is complete (either an oncompleted or onerror notification) or until a timeout expires if the subscriber is interrupted before either of these events take place this method unsubscribes the subscriber from the observable)javalangthread    getlastseenthread()returns the last thread that was in use when an item or notification was received by this subscriberjavautillist<notification<t>> getoncompletedevents()get the notifications representing each time this subscriber was notified of sequence completion via testsubscriberoncompleted() as a listjavautillist<javalangthrowable> getonerrorevents()get the throwables this subscriber was notified of via testsubscriberonerror(javalangthrowable) as a listjavautillist<t>   getonnextevents()get the sequence of items observed by this **subscriber** as an ordered listvoid    oncompleted()notifies the observer that the observable has finished sending push-based notificationsvoid    onerror(javalangthrowable e)notifies the observer that the observable has experienced an error conditionvoid    onnext(t t)provides the **observer** with a new item to observevoid    requestmore(long n)allow calling the protected subscriberrequest(long) from unit tests || ah i see whats going on its just pulling in the underlyingobserveronnext javadocs for onnext because we didnt write our own when weoverloaded the method thats why i didnt notice any mentions in thesource codeon mon nov 10 2014 at 2:02 pm headinthebox notifications@githubcomwrote:> public class testsubscriber> extends subscriber> subscriber usable for unit testing to perform assertions inspect received> events or wrap a mocked subscriber> constructor summary> > constructors> constructor and description> testsubscriber()> testsubscriber(observer delegate)> testsubscriber(subscriber delegate)> method summary> > methods> modifier and type method and description> void assertnoerrors()> assert that this _subscriber_ has received no onerror notifications> void assertreceivedonnext(javautillist items)> assert that a particular sequence of items was received by this subscriber> in order> void assertterminalevent()> assert that a single terminal event occurred either> testsubscriberoncompleted() or testsubscriberonerror(javalangthrowable)> void assertunsubscribed()> assert that this _subscriber_ is unsubscribed> void awaitterminalevent()> blocks until this _subscriber_ receives a notification that the> observable is complete (either an oncompleted or onerror notification)> void awaitterminalevent(long timeout javautilconcurrenttimeunit unit)> blocks until this subscriber receives a notification that the observable> is complete (either an oncompleted or onerror notification) or until a> timeout expires> void awaitterminaleventandunsubscribeontimeout(long timeout> javautilconcurrenttimeunit unit)> blocks until this subscriber receives a notification that the observable> is complete (either an oncompleted or onerror notification) or until a> timeout expires if the subscriber is interrupted before either of these> events take place this method unsubscribes the subscriber from the> observable)> javalangthread getlastseenthread()> returns the last thread that was in use when an item or notification was> received by this subscriber> javautillist> getoncompletedevents()> get the notifications representing each time this subscriber was notified> of sequence completion via testsubscriberoncompleted() as a list> javautillist getonerrorevents()> get the throwables this subscriber was notified of via> testsubscriberonerror(javalangthrowable) as a list> javautillist getonnextevents()> get the sequence of items observed by this _subscriber_ as an ordered> list> void oncompleted()> notifies the observer that the observable has finished sending push-based> notifications> void onerror(javalangthrowable e)> notifies the observer that the observable has experienced an error> condition> void onnext(t t)> provides the _observer_ with a new item to observe> void requestmore(long n)> allow calling the protected subscriberrequest(long) from unit tests> > —> reply to this email directly or view it on github>  david m grossplp consulting ||;;;;0;1;;
1850;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;522 : basic test suite for osgi framework;this is a proposal for a basic test project to ensure that the mockito artifacts can be consumed from an osgi environment. for example  reverting the fix for #678 is caught with the following exception:;;522.0;522 : basic test suite for osgi framework;"this is a proposal for a basic test project to ensure that the mockito artifacts can be consumed from an osgi environment for example reverting the fix for #678 is caught with the following exception:```javalangillegalstateexception: failed to install bundle: mockito-core-323jar	at orgmockitoosgitestosgitestsetup(osgitestjava:55)	 (snipped)caused by: orgosgiframeworkbundleexception: error occurred installing a bundle	at orgeclipseosgistoragestorageinstall(storagejava:739)	at orgeclipseosgiinternalframeworkbundlecontextimplinstallbundle(bundlecontextimpljava:187)	at orgeclipseosgiinternalframeworkbundlecontextimplinstallbundle(bundlecontextimpljava:179)	at orgmockitoosgitestosgitestsetup(osgitestjava:53)	 40 morecaused by: javalangillegalargumentexception: invalid range ""[160"": invalid format	at orgosgiframeworkversionrange<init>(versionrangejava:173)	at orgeclipseosgicontainerbuildersosgimanifestbuilderfactoryaddpackageimports(osgimanifestbuilderfactoryjava:373)	at orgeclipseosgicontainerbuildersosgimanifestbuilderfactorygetpackageimports(osgimanifestbuilderfactoryjava:352)	at orgeclipseosgicontainerbuildersosgimanifestbuilderfactorycreatebuilder(osgimanifestbuilderfactoryjava:111)	at orgeclipseosgicontainerbuildersosgimanifestbuilderfactorycreatebuilder(osgimanifestbuilderfactoryjava:78)	at orgeclipseosgistoragestoragegetbuilder(storagejava:784)	at orgeclipseosgistoragestoragegetbuilder(storagejava:766)	at orgeclipseosgistoragestorageinstall(storagejava:706)	 43 morecaused by: javautilnosuchelementexception	at javautilstringtokenizernexttoken(stringtokenizerjava:349)	at orgosgiframeworkversionrange<init>(versionrangejava:157)	 50 more```the osgi test project consists of three source sets:1 a regular junit4 `test` source set with a single class osgitest starts an osgi framework installs mockito-core byte-buddy and objenesis bundles as well as two test bundles and executes some simple mockito test cases inside the osgi framework2 a source set `testbundle` thats built to an osgi bundle using the `bundle` task from the bnd gradle plugin contains the test classes that run the mockito test cases and thus depends on the mockito bundle3 a source set `otherbundle` thats also built to an osgi bundle but with no other dependencies used for testing mocking of classes from other bundlessome further technical details:- the `test` source set only has compile dependencies on the osgi apis and junit4 ie not on mockito the osgi framework is created using the standard framework api at runtime equinox is added as a dependency to supply an actual framework implementation but the intention is that any framework implementation could be used- the test cases are run by loading classes from the test bundle that all implement `runnable` this is to provide a simple bridge using a common jdk class the reason for setting up such a bridge is that i want to drive the tests using a test runner that gradle supports for example to get good test reports but the test bundles dont know anything about junit4 inside the osgi framework i didnt want to explore adding an osgified version of junit into the mix at this point since that would also entail solving test discovery inside an osgi framework- the osgi bundles are built using the [bnd gradle plugin]( instead of the deprecated `osgi` plugin in gradle the reason is both future proofing to not impede a migration to gradle 60 in this new sub project and that i believe it better mirrors how other projects would consume the mockito artifacts further it paves the way for replacing the usage of the deprecated plugin for the creating the osgi manifests in the root projectsince this is my first contribution ill be happy to fix anything that goes against the grains";" merging 1850  ";provide osgi test project to validate osgi headers automatically;as stated in #82 we should provide a project for osgi to validate correct exports;;1;0;provide orgjunit package to test bundle and run tests inside it;
1850;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;522 : basic test suite for osgi framework;this is a proposal for a basic test project to ensure that the mockito artifacts can be consumed from an osgi environment. for example  reverting the fix for #678 is caught with the following exception:;;678.0;522 : basic test suite for osgi framework;"this is a proposal for a basic test project to ensure that the mockito artifacts can be consumed from an osgi environment for example reverting the fix for #678 is caught with the following exception:```javalangillegalstateexception: failed to install bundle: mockito-core-323jar	at orgmockitoosgitestosgitestsetup(osgitestjava:55)	 (snipped)caused by: orgosgiframeworkbundleexception: error occurred installing a bundle	at orgeclipseosgistoragestorageinstall(storagejava:739)	at orgeclipseosgiinternalframeworkbundlecontextimplinstallbundle(bundlecontextimpljava:187)	at orgeclipseosgiinternalframeworkbundlecontextimplinstallbundle(bundlecontextimpljava:179)	at orgmockitoosgitestosgitestsetup(osgitestjava:53)	 40 morecaused by: javalangillegalargumentexception: invalid range ""[160"": invalid format	at orgosgiframeworkversionrange<init>(versionrangejava:173)	at orgeclipseosgicontainerbuildersosgimanifestbuilderfactoryaddpackageimports(osgimanifestbuilderfactoryjava:373)	at orgeclipseosgicontainerbuildersosgimanifestbuilderfactorygetpackageimports(osgimanifestbuilderfactoryjava:352)	at orgeclipseosgicontainerbuildersosgimanifestbuilderfactorycreatebuilder(osgimanifestbuilderfactoryjava:111)	at orgeclipseosgicontainerbuildersosgimanifestbuilderfactorycreatebuilder(osgimanifestbuilderfactoryjava:78)	at orgeclipseosgistoragestoragegetbuilder(storagejava:784)	at orgeclipseosgistoragestoragegetbuilder(storagejava:766)	at orgeclipseosgistoragestorageinstall(storagejava:706)	 43 morecaused by: javautilnosuchelementexception	at javautilstringtokenizernexttoken(stringtokenizerjava:349)	at orgosgiframeworkversionrange<init>(versionrangejava:157)	 50 more```the osgi test project consists of three source sets:1 a regular junit4 `test` source set with a single class osgitest starts an osgi framework installs mockito-core byte-buddy and objenesis bundles as well as two test bundles and executes some simple mockito test cases inside the osgi framework2 a source set `testbundle` thats built to an osgi bundle using the `bundle` task from the bnd gradle plugin contains the test classes that run the mockito test cases and thus depends on the mockito bundle3 a source set `otherbundle` thats also built to an osgi bundle but with no other dependencies used for testing mocking of classes from other bundlessome further technical details:- the `test` source set only has compile dependencies on the osgi apis and junit4 ie not on mockito the osgi framework is created using the standard framework api at runtime equinox is added as a dependency to supply an actual framework implementation but the intention is that any framework implementation could be used- the test cases are run by loading classes from the test bundle that all implement `runnable` this is to provide a simple bridge using a common jdk class the reason for setting up such a bridge is that i want to drive the tests using a test runner that gradle supports for example to get good test reports but the test bundles dont know anything about junit4 inside the osgi framework i didnt want to explore adding an osgified version of junit into the mix at this point since that would also entail solving test discovery inside an osgi framework- the osgi bundles are built using the [bnd gradle plugin]( instead of the deprecated `osgi` plugin in gradle the reason is both future proofing to not impede a migration to gradle 60 in this new sub project and that i believe it better mirrors how other projects would consume the mockito artifacts further it paves the way for replacing the usage of the deprecated plugin for the creating the osgi manifests in the root projectsince this is my first contribution ill be happy to fix anything that goes against the grains";" merging 1850  ";osgi bundle problem - incorrect version range syntax in manifest file;"the mockito-core version 210 has an incorrect version range syntax for the byte buddy dependencies  in the _meta-inf/manifestmf_ file consequently the bundle cannot be loaded by osgi (tested with equinox r-46) actual: > netbytebuddyversion""[1426""expected: > netbytebuddyversion""[142620)""on the other hand the version ranges for objensis dependencies are specified correctly the problem originates from missing double quotes around the version specification in  stacktrace: > !message error installing bundle: reference plugins/mockito-corejar> !stack 0> orgosgiframeworkbundleexception: error occurred installing a bundle>     at orgeclipseosgistoragestorageinstall(storagejava:562)>     at orgeclipseosgiinternalframeworkbundlecontextimplinstallbundle(bundlecontextimpljava:146)>     at orgeclipsecoreruntimeadaptoreclipsestarterinstallbundles(eclipsestarterjava:974)>     at orgeclipsecoreruntimeadaptoreclipsestarterloadbasicbundles(eclipsestarterjava:583)>     at orgeclipsecoreruntimeadaptoreclipsestarterstartup(eclipsestarterjava:319)>     at orgeclipsecoreruntimeadaptoreclipsestarterrun(eclipsestarterjava:239)>     at sunreflectnativemethodaccessorimplinvoke0(native method)>     at sunreflectnativemethodaccessorimplinvoke(unknown source)>     at sunreflectdelegatingmethodaccessorimplinvoke(unknown source)>     at javalangreflectmethodinvoke(unknown source)>     at orgeclipseequinoxlaunchermaininvokeframework(mainjava:673)>     at orgeclipseequinoxlaunchermainbasicrun(mainjava:610)>     at orgeclipseequinoxlaunchermainrun(mainjava:1519)>     at orgeclipseequinoxlaunchermainmain(mainjava:1492)> caused by: javalangillegalargumentexception: invalid range ""[1426"": invalid format>     at orgosgiframeworkversionrange<init>(versionrangejava:173)>     at orgeclipseosgicontainerbuildersosgimanifestbuilderfactoryaddpackageimports(osgimanifestbuilderfactoryjava:360)>     at orgeclipseosgicontainerbuildersosgimanifestbuilderfactorygetpackageimports(osgimanifestbuilderfactoryjava:339)>     at orgeclipseosgicontainerbuildersosgimanifestbuilderfactorycreatebuilder(osgimanifestbuilderfactoryjava:87)>     at orgeclipseosgicontainerbuildersosgimanifestbuilderfactorycreatebuilder(osgimanifestbuilderfactoryjava:54)>     at orgeclipseosgistoragestoragegetbuilder(storagejava:604)>     at orgeclipseosgistoragestorageinstall(storagejava:531)>      13 more> caused by: javautilnosuchelementexception>     at javautilstringtokenizernexttoken(unknown source)>     at orgosgiframeworkversionrange<init>(versionrangejava:157)>      19 more";ok thank you for the report ! and fix in #679  || now that #679 is closed this one can be closed too i guess ||;1;0;provide orgjunit package to test bundle and run tests inside it;
1850;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;522 : basic test suite for osgi framework;this is a proposal for a basic test project to ensure that the mockito artifacts can be consumed from an osgi environment. for example  reverting the fix for #678 is caught with the following exception:;;0;update to airbase 28 with guava 180;;;;;;0;1;;
1850;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;522 : basic test suite for osgi framework;this is a proposal for a basic test project to ensure that the mockito artifacts can be consumed from an osgi environment. for example  reverting the fix for #678 is caught with the following exception:;;0;inconsistency between cachestats documentation and behaviour;wes@ the class javadoc for cachestats states: ""no stats are modified on a query to {@﻿link cache#getifpresent}""however the localcachegetifpresent() method clearly updates stats:&nbsp&nbsp@﻿nullable&nbsp&nbsppublic v getifpresent(object key) {&nbsp&nbsp&nbsp&nbspint hash  hash(checknotnull(key))&nbsp&nbsp&nbsp&nbspv value  segmentfor(hash)get(key hash)&nbsp&nbsp&nbsp&nbspif (value  null) {&nbsp&nbsp&nbsp&nbsp&nbsp&nbspglobalstatscounterrecordmisses(1)&nbsp&nbsp&nbsp&nbsp} else {&nbsp&nbsp&nbsp&nbsp&nbsp&nbspglobalstatscounterrecordhits(1)&nbsp&nbsp&nbsp&nbsp}&nbsp&nbsp&nbsp&nbspreturn value&nbsp&nbsp}"; we changed the docs ||;;;;0;1;;
1854;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1853: allow @mockitosettings to be inherited;-  read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/contributing.md);;0;implement corr covar_* etc aggregation functions;from the sql specification section 415:> the binary aggregate functions take a pair of arguments the `<dependent variable expression>` and the `<independent variable expression>` which are both `<numeric value expression>`s any row in which either argument evaluates to the null value is removed from the group if there are no rows remaining in the group then the result of regr_count is 0 (zero) and the other binary aggregate functions result in the null value otherwise the computation concludes and the result is:> > - if covar_pop is specified then the population covariance defined as the sum of products of the difference of `<independent variable expression>` from its mean times the difference of `<dependent variable expression>` from its mean divided by the number of rows remaining> -  if covar_samp is specified then the sample covariance defined as the sum of products of the difference of `<independent variable expression>` from its mean times the difference of `<dependent variable expression>` from its mean divided by the number of rows remaining minus 1 (one)> - if corr is specified then the correlation coefficient defined as the ratio of the population covariance divided by the product of the population standard deviation of `<independent variable expression>` and the population standard deviation of `<dependent variable expression>`> - if regr_slope is specified then the slope of the least-squares-fit linear equation determined by the (`<independent variable expression>` `<dependent variable expression>`) pairs> - if regr_intercept is specified then the y-intercept of the least-squares-fit linear equation determined by the (`<independent variable expression>` `<dependent variable expression>`) pairs; by #2772  ||;;;;0;1;;
1854;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1853: allow @mockitosettings to be inherited;-  read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/contributing.md);;0;onbackpressurexxx;change onbackpressuredrop to same style as onbackpressurebufferonbackpressurebuffer()instructs an observable that is emitting items faster than its observer can consume them to buffer these items indefinitely until they can be emittedonbackpressuredrop()use this operator when the upstream does not natively support backpressure and you wish to drop onnext when unable to handle further events;;;;;0;1;;
1854;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1853: allow @mockitosettings to be inherited;-  read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/contributing.md);;1853.0;1853: allow @mockitosettings to be inherited;-  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_;  > > > could you add a regression test in the junit-jupiter-test testsuite?ive just amended the commit with a test ||;allow @mockitosettings to be inherited;" -  the mockito message in the stacktrace have useful information but it didnt help -  the problematic code (if thats possible) is copied here       note that some configuration are impossible to mock via mockito -  provide versions (mockito / jdk / os / any other relevant information) -  provide a [short self contained correct (compilable) example]( of the issue       (same as any question on stackoverflowcom) -  read the [contributing guide]( have a base test class which among other things mocks a ""servicelocator"" and a very common class used by many other services:```java@extendwith(mockitoextensionclass)public abstract class domainservicetests<t> {	@mock	protected servicelocator sl	@spy	protected userenvironmentservice userenvironment	@beforeeach	public void setup() throws exception {		mockitowhen(slget(userenvironmentserviceclass))thenreturn(userenvironment)	}}```but whenever any test try to mock the get method of this servicelocator with a different class i get an unnecessarystubbingexception:```orgmockitoexceptionsmisusingunnecessarystubbingexception:    unnecessary stubbings detected    clean & maintainable test code requires zero unnecessary code    following stubbings are unnecessary (click to navigate to relevant line of code):      1 -> at *domainservicetestssetup(domainservicetestsjava:24)    please remove unnecessary stubbings or use lenient strictness more info: javadoc for unnecessarystubbingexception class```then i specify the strictness in the base test class ```java@mockitosettings(strictness  strictnesswarn)public abstract class domainservicetests<t> {```but even though the strictness is not seen by mockitoi have debugged the code and found that the strictness is retrieved by searching the annotation on the method and the class of the test eventually calls  static <a extends annotation> optional<a> findannotation(annotatedelement element class<a> annotationtype) {	preconditionsnotnull(annotationtype ""annotationtype must not be null"")	boolean inherited  annotationtypeisannotationpresent(inheritedclass)	return findannotation(element annotationtype inherited new hashset<>())}```so if you annotate `mockitosettings` with `javalangannotationinherited` it will work (i turned the inherited variable to true using the debugger to confirm)for now i will have to annotate every test class with```java@mockitosettings(strictness  strictnesswarn)```i am using  gradle 70 with junit 552thanks";feel free to send a pr with a fix awesome issue description :) || hi @timvdlippe i am currently using the **mockito-junit-jupiter v324** and i can see that `@mockitosettings` still does not have inheritance support:```@extendwith(mockitoextensionclass)@retention(runtime)public @interface mockitosettings {   }```do you know when or if there is any plans to release a new version of mockito-junit-jupiter containing this improvement?for now i am including the annotation on each test but it would be great to refactor and keep it on just my abstracttest class || new version should be pushing to maven central as we speak:  || @timvdlippe thats awesome!unfortunately travis is not very happy:```[performrelease] > could not sync mockito/maven/mockito/330 to maven central:  400 bad request [status:sync failed messages:[failed to close repository: orgmockito-1399 server response:[performrelease]    <nexus-error>[performrelease]     <errors>[performrelease]       <error>[performrelease]         <id>*</id>[performrelease]         <msg>unhandled: repository: orgmockito-1399 has invalid state: closed</msg>[performrelease]       </error>[performrelease]     </errors>[performrelease]   </nexus-error> dropping existing partial staging repository]]``` || thats sadly a known issue with maven central but the artifact should be installable for you:  ||;1;0;1853: allow @mockitosettings to be inherited;
1858;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add testrule to mockitojunit;junit has two types of test rules: methodrule and testrule. the existing;;0;converter - findbugs problem; findbugs reports ""inherits equals and uses objecthashcode()"" for converter-subclasses test/testjava @package testimport comgooglecommonbaseconverterimport javaioserializablepublic final class test {&nbsp&nbspprivate static final class testconverter&nbsp&nbsp&nbsp&nbsp&nbsp&nbspextends converter&ltstring string> implements serializable {```/*package*/ static final testconverter instance  new testconverter()private static final long serialversionuid  1@overridepublic string tostring() {  return ""testconvertertestconverter()""}@overrideprotected string doforward(string string) {  return string}@overrideprotected string dobackward(string string) {  return string}private object readresolve() {  return instance}```&nbsp&nbsp}&nbsp&nbsppublic static converter&ltstring string> testconverter() {&nbsp&nbsp&nbsp&nbspreturn testconverterinstance&nbsp&nbsp}&nbsp&nbspprivate test() {&nbsp&nbsp}}@ pomxml @&ltproject xmlns"" xmlns:xsi""  clean install[info] --- findbugs-maven-plugin check (default) @ test ---[info] buginstance size is 1[info] error size is 0[info] total bugs: 1[info] testtest$testconverter inherits equals and uses objecthashcode() [""testtest$testconverter""] at testjava:[lines 9-32][info] ------------------------------------------------------------------------[info] build failure[info] ------------------------------------------------------------------------[info] total time: 6516 s[info] finished at: 2014-09-29t00 54+01:00[info] final memory: 23m/118m[info] ------------------------------------------------------------------------[error] failed to execute goal orgcodehausmojo:findbugs-maven-plugin check (default) on project test: failed with 1 bugs and 0 errors -> [help 1]@@the ""problem"" is the override in converter:&nbsp&nbsp@﻿override&nbsp&nbsppublic boolean equals(@﻿nullable object object) {&nbsp&nbsp&nbsp&nbspreturn superequals(object)&nbsp&nbsp}but there is no corresponding override for hashcode:&nbsp&nbsp@﻿override&nbsp&nbsppublic int hashcode() {&nbsp&nbsp&nbsp&nbspreturn superhashcode()&nbsp&nbsp}this forces everyone to either ignore the findbugs warning or include the snippet above in their subclassplease add &nbsp&nbsp@﻿override&nbsp&nbsppublic int hashcode() {&nbsp&nbsp&nbsp&nbspreturn superhashcode()&nbsp&nbsp}to converter thanks"; to be clear this is actually a false positive from findbugs (since there isnt actually a bug here)looks like we only override equals so we can add additional documentation i wonder if we should just move that documentation into the class docs or drop it all together--- ;;;;0;1;;
1858;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add testrule to mockitojunit;junit has two types of test rules: methodrule and testrule. the existing;;0;add testrule to mockitojunit;junit has two types of test rules: methodrule and testrule the existingmockitojunit rule returns a mockitorule which extends methodrulehowever since this is not a testrule some features of junit do notnicely integrate with mockito for example the rulechain feature ofjunit only works on testrulestherefore add a separate entrypoint to mockitojunit which returns atestrule that can be integrated with rulechain it introduces a separateinterface to make this distinction clear if we would change theexisting mockitorule to also extend testrule the junit logic would nolonger run the methodrule [1] and would thus break existing users[1]: https://githubcom/junit-team/junit4/blob/2df7e0882128d551565f87f688bbe745d85aacba/src/main/java/org/junit/runners/blockjunit4classrunnerjava#l402; merging 1858 ;;;;1;1;process reviewer feedback;
1858;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add testrule to mockitojunit;junit has two types of test rules: methodrule and testrule. the existing;;0;make test helper methods protected;;;;;;0;1;;
1858;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add testrule to mockitojunit;junit has two types of test rules: methodrule and testrule. the existing;;0;zip all overloads;zip(javalangiterable<? extends observable<?>> ws funcn<? extends r> zipfunction)returns an observable that emits the results of a **function of your choosing**function of your choosing > combiner function;;;;;0;1;;
1859;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;add notextensible to ongoingstubbing;this interface is not intended to be subclassed and should therefore be;;0;add notextensible to ongoingstubbing;this interface is not intended to be subclassed and should therefore bemarked as such;  absolutely! ||;;;;1;1;add notextensible to ongoingstubbingthis interface is not intended to be subclassed and should therefore bemarked as such;
1859;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;add notextensible to ongoingstubbing;this interface is not intended to be subclassed and should therefore be;;0;improve support for big queries (joins group bys distincts);;awesome @cberner! looking forward to this ||  this seems fine except for the aggregation memory change  i can see the limit being propagated to the operator context but i dont see it being used anywhere  if you want you can push everything except for the aggregation thing and put that one in another pr || @dain oops got distracted in the middle of writing that im pushing the correctly implemented one now :) ||;;;;0;1;;
1859;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;add notextensible to ongoingstubbing;this interface is not intended to be subclassed and should therefore be;;0;scheduler interface vs abstract class (revisit);`scheduler` is an abstract class and not an interface and i see this as a little bit of ugliness that could be changed easily if we are readythe javadoc contains a discussion below i wonder if given that we are setting the api concrete for 10 it might be time to stop worrying about the risk of additive breaking changes (last point below)?``` java/* * why is this an abstract class instead of an interface? * *  : java doesnt support extension methods and there are many overload methods needing default *    implementations * *  : virtual extension methods arent available until java8 which rxjava will not set as a minimum target for *    a long time * *  : if only an interface were used scheduler implementations would then need to extend from an *    abstractscheduler pair that gives all of the functionality unless they intend on copy/pasting the *    functionality * *  : without virtual extension methods even additive changes are breaking and thus severely impede library *    maintenance */```;what would concretely change when it would be an interface? || nothing at the moment because of the simplicity of the abstract class so good question `scheduler` being an abstract class is a marker for inheritance ugliness to my eyes (side effects like overriding one method on the super class you had no idea you were affecting another method on the super class as well which calls it)  this is one reason composition is pushed instead of inheritance and its usually possible to write an api without any inheritance beyond say some helper classes if desired the risk of additive breaking changes is the one impediment in my eyes at the moment and i have to say that i forgot about #1730 which is exactly that (adding a shutdown method to scheduler)! given that the scheduler api is still in flux and that no side effects are possible with the current inheritance pattern i think ill close this || i often avoid interfaces and favor abstract classes in code that is supposed to live for a long time and is hard to change because of the list of reasons given in that comment above two key places where an interface is necessary are where it makes sense to have an object implement multiple interfaces (which cant be done with an abstract class) or where it is targeted to be used by lambdas  which means the interface can never have more methods added anyways so removes the key reason for using an abstract class for allowing future method additions beyond these two reasons i generally favor abstract classes to better support long-term api evolution this problem is mostly mitigated in java8+ ||;;;;0;1;;
1862;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;revert  performance optimization by using method.getparametercount() where possible;reverts mockito/mockito#1849;;0;order of enqueued events; the post order of enqueued events is not guaranteed in practice the order of enqueued events is the same for the majority of the time but not always in my case each start of my application could have a different order of posted events this makes testing and bugfixing a lot harderchanging the subscribersbytype from hashmultimap to linkedhashmultimap in the eventbus class  it for me;im closing this issue because we are no longer going to be making changes to `eventbus` other than important bug fixes the reasons were discouraging it and some alternatives are listed in the [eventbus javadoc]( ||;;;;0;1;;
1862;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;revert  performance optimization by using method.getparametercount() where possible;reverts mockito/mockito#1849;;0;"revert ""performance optimization by using methodgetparametercount() where possible""";reverts mockito/mockito#1849it breaks all downstream android applications see https://githubcom/mockito/mockito/pull/1849#issuecomment-577139089; merging 1862  < ;;;;1;1;"revert ""performance optimization by using methodgetparametercount() where possible""";
1862;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;revert  performance optimization by using method.getparametercount() where possible;reverts mockito/mockito#1849;;0;fix class loader issues for raptor orc writer;;;;;;0;1;;
1862;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;revert  performance optimization by using method.getparametercount() where possible;reverts mockito/mockito#1849;;0;backpressure suppport for window by size;for #1828 extracted producers from operatorbufferwithsize and reused them in operatorwindowwithsize;;;;;0;1;;
1868;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moved one method from external and fixed some minor things;move regexpfilesearch  two preference constants and removed an ignored test that wasn t close to passing (there is no trace of any nameformatter/layout in regexpfilesearch).;;0;document that predicatesin uses the contains() method of the collection; notice that were creating an in predicate over an arraylist of 500000 integers applying that predicate to the integers between 1 and 500000 takes a few minutesi could think of a couple of ways of fixing it:1) put a disclaimer in the documentation that the user is advised to pass collections with fast containment methods2) convert slow collections into hashsets as in the following snippet:---&nbsp&nbsp&nbsp&nbspprivate static &ltt> predicate&ltt> optimizedin(collection<? extends t> target) {```    if(target instanceof set)        return predicatesin(target)    else        return predicatesin(new hashset<t>(target))}```---here are some experimental results with different sizes for the collection predicate for the original implementation and optimizedin:```  size      original     optimized                                                                                                           10      0m0972s     0m0996s                                                                                                           100      0m1068s     0m1004s                                                                                                          1000      0m1572s     0m0980s                                                                                                         10000      0m8065s     0m1016s                                                                                                        100000      1m5596s     0m1052s                                                                                                        500000      4m56423s    0m1200s               ```regards&nbsposwaldo"; theres a couple points here:&nbsp&nbsp\- the documentation of predicatesin specifies ""it does not defensively copy the collection passed in so future changes to it will alter the behavior of the predicate""  thats a non-@﻿beta method contract that we would almost certainly not change and theres not really any way to satisfy that contract and do anything like what youre proposing&nbsp&nbsp\- we could document better than the collections own contains() method is used and that the performance of the predicate will be equivalent to the performance of the collections contains() method&nbsp&nbsp\- for very short lists it is not always the case that converting to a hashset will help performance&nbsp&nbsp\- its possible that it might make sense as a warning or an error in error-prone ( to pass a list to predicatesin but wed have to investigate this -- and thatd be more appropriate as a bug filed against error-prone rather than guava--- ;;;;0;1;;
1868;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moved one method from external and fixed some minor things;move regexpfilesearch  two preference constants and removed an ignored test that wasn t close to passing (there is no trace of any nameformatter/layout in regexpfilesearch).;;0;update mockito version number for deletion of deprecated classes;; merging 1868 ;;;;1;1;update javadoc regarding deletion of deprecated classes;
1868;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moved one method from external and fixed some minor things;move regexpfilesearch  two preference constants and removed an ignored test that wasn t close to passing (there is no trace of any nameformatter/layout in regexpfilesearch).;;0;fix orc bugs;;;;;;0;1;;
1868;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;moved one method from external and fixed some minor things;move regexpfilesearch  two preference constants and removed an ignored test that wasn t close to passing (there is no trace of any nameformatter/layout in regexpfilesearch).;;0;improve lifecycle docs;based on a twitter conversation we may need to improve docs around lifecycle: https://twittercom/benjchristensen/status/532570727111983104;for future reference: wed nov 12 2014 at 8:31 am ben christensen notifications@githubcomwrote:> based on a twitter conversation we may need to improve docs around> lifecycle:> > —> reply to this email directly or view it on github>  david m grossplp consulting || closing for now as it is not clear what lifecycle docs is this about ||;;;;0;1;;
1878;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;revert  fixed undetected unused stubbing when matching previous stubbed call;reverts mockito/mockito#1847;;0;minor ui changes;;;;;;0;1;;
1878;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;revert  fixed undetected unused stubbing when matching previous stubbed call;reverts mockito/mockito#1847;;0;defaultifempty(observable<t> t);went to use `defaultifempty` and found it only accepts a single value  instead of an `observable` which means i cant pass in an `observableerror`it would be very helpful to have `defaultifempty(observable<t> t)`;"+1 then `tail` in rxscala can be implemented  odefaultifempty(observableerror(new unsupportedoperationexception(""tail of empty list"")))drop(1)` || maybe `switchifempty` would be a better name || ";;;;0;1;;
1878;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;revert  fixed undetected unused stubbing when matching previous stubbed call;reverts mockito/mockito#1847;;1877.0;"revert "" undetected unused stubbing when matching previous stubbed call""";reverts mockito/mockito#18471877 based on feedback in #1846; merging 1878 ;regression: overriding stubbing;hithere seems to be a regression in 330 from 324 (published on maven central)the documentation states : > stubbing can be overridden: for example common stubbing can go to fixture setup but the test methods can override it please note that overridding stubbing is a potential code smell that points out too much stubbingbut by simply making a copy of a stub by duplicating its line (or more realistically returning a different value in the second stub) an `unnecessarystubbingexception` is thrown :```javaimport static orgjunitjupiterapiassertionsassertequalsimport static orgmockitoargumentmatchersanyimport javaiobytearrayinputstreamimport javaioioexceptionimport orgjunitjupiterapitestimport orgjunitjupiterapiextensionextendwithimport orgmockitomockimport orgmockitomockitoimport orgmockitojunitjupitermockitoextension@extendwith(mockitoextensionclass)public class atest {  @mock  private bytearrayinputstream stream  @test  public void duplicate() throws ioexception {    mockitowhen(streamread(any()))thenreturn(1337)    mockitowhen(streamread(any()))thenreturn(1337) // duplicate line    int value  streamread(new byte[2048])    assertequals(1337 value)  }}``````orgmockitoexceptionsmisusingunnecessarystubbingexception: unnecessary stubbings detectedclean & maintainable test code requires zero unnecessary codethere are 1 unnecessary stubbing (click to navigate to relevant line of code):  1 -> at atestduplicate(atestjava:21)please remove unnecessary stubbings or use lenient strictness more info: javadoc for unnecessarystubbingexception class	at orgmockitojunitjupitermockitoextensionaftereach(mockitoextensionjava:181)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorlambda$invokeaftereachcallbacks$11(testmethodtestdescriptorjava:248)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorlambda$invokeallaftermethodsorcallbacks$13(testmethodtestdescriptorjava:268)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorlambda$invokeallaftermethodsorcallbacks$14(testmethodtestdescriptorjava:268)	at javabase/javautilarraylistforeach(arraylistjava:1540)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorinvokeallaftermethodsorcallbacks(testmethodtestdescriptorjava:267)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorinvokeaftereachcallbacks(testmethodtestdescriptorjava:247)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorexecute(testmethodtestdescriptorjava:143)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorexecute(testmethodtestdescriptorjava:71)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:135)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$7(nodetesttaskjava:125)	at orgjunitplatformenginesupporthierarchicalnodearound(nodejava:135)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$8(nodetesttaskjava:123)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:122)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:80)	at orgjunitplatformenginesupporthierarchicalforkjoinpoolhierarchicaltestexecutorservice$exclusivetaskcompute(forkjoinpoolhierarchicaltestexecutorservicejava:171)	at orgjunitplatformenginesupporthierarchicalforkjoinpoolhierarchicaltestexecutorserviceinvokeall(forkjoinpoolhierarchicaltestexecutorservicejava:115)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:139)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$7(nodetesttaskjava:125)	at orgjunitplatformenginesupporthierarchicalnodearound(nodejava:135)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$8(nodetesttaskjava:123)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:122)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:80)	at orgjunitplatformenginesupporthierarchicalforkjoinpoolhierarchicaltestexecutorservice$exclusivetaskcompute(forkjoinpoolhierarchicaltestexecutorservicejava:171)	at orgjunitplatformenginesupporthierarchicalforkjoinpoolhierarchicaltestexecutorserviceinvokeall(forkjoinpoolhierarchicaltestexecutorservicejava:115)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:139)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$7(nodetesttaskjava:125)	at orgjunitplatformenginesupporthierarchicalnodearound(nodejava:135)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$8(nodetesttaskjava:123)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:122)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:80)	at orgjunitplatformenginesupporthierarchicalforkjoinpoolhierarchicaltestexecutorservice$exclusivetaskcompute(forkjoinpoolhierarchicaltestexecutorservicejava:171)	at javabase/javautilconcurrentrecursiveactionexec(recursiveactionjava:189)	at javabase/javautilconcurrentforkjointaskdoexec(forkjointaskjava:290)	at javabase/javautilconcurrentforkjoinpool$workqueuetoplevelexec(forkjoinpooljava:1020)	at javabase/javautilconcurrentforkjoinpoolscan(forkjoinpooljava:1656)	at javabase/javautilconcurrentforkjoinpoolrunworker(forkjoinpooljava:1594)	at javabase/javautilconcurrentforkjoinworkerthreadrun(forkjoinworkerthreadjava:177)``` -  the mockito message in the stacktrace have useful information but it didnt help -  the problematic code (if thats possible) is copied here       note that some configuration are impossible to mock via mockito -  provide versions (mockito / jdk / os / any other relevant information) -  provide a [short self contained correct (compilable) example]( of the issue       (same as any question on stackoverflowcom) -  read the [contributing guide](https://githubcom/mockito/mockito/blob/release/3x/github/contributingmd);;1;0;"revert "" undetected unused stubbing when matching previous stubbed call""";
1881;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix unnecessarystubbingexception javadoc;1880;;0;improve error message for scalar subqueries in groupby;fix https://githubcom/facebook/presto/issues/1829;thank you for your pull request and welcome to our community we require contributors to sign our contributor license agreement and we dont seem to have you on file in order for us to review and merge your code please sign up at  - and if you have received this in error or have any questions please drop us a line at cla@fbcom  ;;;;0;1;;
1881;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix unnecessarystubbingexception javadoc;1880;;0;scan/reduce overloads & type erasure;"i think the recent additions to `scan`/`reduce` may cause issues``` javascan(r func2<r ? super t r>)scan(func0<r> func2<r ? super t r>)```the `func0` passed in looks like it can be treated like an `object` and considered ambiguous and match with `r` instead of `func0`here is a compilation error:```[error] failed to execute goal orgapachemavenplugins:maven-compiler-plugin compile (default-compile) on project learnrxjava: compilation failure: compilation failure:[error] /users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/scanvsreduceexamplejava:[1032] reference to reduce is ambiguous[error] both method <r>reduce(rrxfunctionsfunc2<r? super tr>) in rxobservable and method <r>reduce(rxfunctionsfunc0<r>rxfunctionsfunc2<r? super tr>) in rxobservable match[error] /users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/scanvsreduceexamplejava:[1039] incompatible types: cannot infer type-variable(s) r[error] (argument mismatch javalangobject is not a functional interface)[error] /users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/scanvsreduceexamplejava:[1732] reference to scan is ambiguous[error] both method <r>scan(rrxfunctionsfunc2<r? super tr>) in rxobservable and method <r>scan(rxfunctionsfunc0<r>rxfunctionsfunc2<r? super tr>) in rxobservable match[error] /users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/scanvsreduceexamplejava:[1737] incompatible types: cannot infer type-variable(s) r[error] (argument mismatch javalangobject is not a functional interface)[error] -> [help 1]```here is example code:  javapackage learnrxjavaexamplesimport javautilarraylistimport rxobservablepublic class scanvsreduceexample {    public static void main(string args) {        observablerange(0 10)reduce(() -> new arraylist<integer>() (list i) -> {            listadd(i)            return list        })foreach(systemout::println)        systemoutprintln("" vs "")        observablerange(0 10)scan(() -> new arraylist<integer>() (list i) -> {            listadd(i)            return list        })foreach(systemout::println)    }}```it looks like we need to do one of 3 things:1) remove one of several things:``` javascan(r func2<r ? super t r>)scan(func0<r> func2<r ? super t r>)```2) rename one of them3) add an extra argument so arity solves iti actually think the most correct thing to do is remove `scan(r func2<r ? super t r>)` since an initial value is most often intended for mutable state in `scan`/`reduce` cc @headinthebox as this is a last minute api fix we need prior to monday for 10";id be happy with `func<0>` as the only way but then we have to do the same for `reduce` and anything else that takes a seed || btw if we do this then we should consider generalizing to returning `s` since we are side-effecting `r` so it does not matter to return return the mutable state variable since that is passed in by the implementation`scan(func0<r> func2<r ? super t s>)` || i have submitted #1883 to fix the ambiguity that happens with lambdas i have changed `scan` `reduce` and `collect` i dont see anywhere else that needs to change || im going to pull the factory overload until 11 so we make sure we get this right  ||  in #1884 by deleting the ambiguous new factory overloads for `scan` and `reduce` and modifying `collect` to support the mutable case with a seed factory and side-affection action ||;;;;0;1;;
1881;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix unnecessarystubbingexception javadoc;1880;;1880.0;fix unnecessarystubbingexception javadoc;1880;;unbalanced html tags in javadoc of unnecessarystubbingexception;in the [javadoc of that class]( the `<code` is not closed properly because of this the following paragraphs are rendered in monospace font as wellwhile here `effect not` should be `effect of not`;could you send us a pr to fix this? || wouldnt it be easier if you just added the missing `</code>` and `of`? its just two words || yeah if you could open a pr to make that change we can fix it 😄  || closed due to too complicated workflow || lets reopen so that someone else can make the pr ||;1;0;fix unnecessarystubbingexception javadoc;
1890;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix mocks throwing same instance with throwable class;fixes mocks throwing the same throwable instance consecutively after specifying the mock behaviour with  dothrow(class)  or  thenthrow(class) .;;0;internetdomainnametopprivatedomain() fails for s3amazonawscom;the expected output is `amazonawscom` but an `illegalstateexception` is thrown;"""s3amazonawscom"" does not have a private domain as it itself is a public suffix: || ";;;;0;1;;
1890;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix mocks throwing same instance with throwable class;fixes mocks throwing the same throwable instance consecutively after specifying the mock behaviour with  dothrow(class)  or  thenthrow(class) .;;0;update 080 release notes;;;;;;0;1;;
1890;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix mocks throwing same instance with throwable class;fixes mocks throwing the same throwable instance consecutively after specifying the mock behaviour with  dothrow(class)  or  thenthrow(class) .;;0;backpressure issue;"the following piece of code used to emit all 1024 items and print ""done"" using rxjava 0196 / hystrix 1318when using rxjava versions 020 to 100 the code stops emitting after 20 items and never prints ""done"" we tried to simplify this further unfortunately it stops reproducing if we remove any of the operators from the chain belowwe suspect that its due to backpressure support since it was added when this stopped working``` javapublic class test {  public static void main(string args) {    observablerange(0 1024)        buffer(20)        concatmap(value -> (new echocommand<>(value))toobservable())        flatmap(observable::from)        concatmap(value -> (new echocommand<>(value))toobservable())        doonnext(value -> systemoutprintln(""value: "" + value))        toblocking()lastordefault(null)    systemoutprintln(""done"")    hystrixreset()  }  public static class echocommand<t> extends hystrixcommand<t> {    private final t value    public echocommand(t value) {      super(hystrixcommandgroupkeyfactoryaskey(""echo""))      thisvalue  value    }    @override    protected t run() throws exception {      return value    }  }}```";"as an interesting data point: i saw it complete the first time i ran it in the debugger but not the second  i was using hystrix 140 || adding a `onbackpressurebuffer()` after the first concatmap worked though i thought concatmap supported backpressure already? || concatmap should be fine i bet `buffer` is the issue someone else the other day told me there may be an issue with it || assuming i can replace the hystrix part with observable::just i ran this in a loop with the fixes in #1893 and got all 1024 values all the time || im not sure that its `buffer` since ``` java    list<integer> source  new arraylist<>(1024)    for (int i  0 i < 1024 i++) {      sourceadd(i)    }    observablefrom(listspartition(source 20))        concatmap(value -> (new echocommand<>(value))toobservable())        flatmap(observable::from)        concatmap(value -> (new echocommand<>(value))toobservable())        doonnext(value -> systemoutprintln(""value: "" + value))        toblocking()lastordefault(null)    systemoutprintln(""done"")    hystrixreset()```still has the issue and no longer uses `buffer` `listspartition` is from guava || #1893 fixes this issue tried with the simple hystrix example above and our actual codebase where we hit this initially  #1893 is merged so closing this thanks @vadims for the report and helping fix this  || ";;;;0;1;;
1890;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;fix mocks throwing same instance with throwable class;fixes mocks throwing the same throwable instance consecutively after specifying the mock behaviour with  dothrow(class)  or  thenthrow(class) .;;1875.0;fix mocks throwing same instance with throwable class;fixes mocks throwing the same throwable instance consecutively after specifying the mock behaviour with `dothrow(class)` or `thenthrow(class)`this is achieved by moving the instantiation of the throwable into a new answer called throwsexceptionclass - much like throwsexception then `thenthrow(class)` calls `thenanswer(answer)` with a new instance of throwsexceptionclass rather than `thenthrow(throwable)` similar for `dothrow(class)` `dothrow(throwable)` and `doanswer(answer)`1875 @timvdlippe just have a quick inquiry: the test in uninstantiablethrowabletest is failing because it expects an instantiationerror to be thrown in the middle of stubbing (check pr #1549) the new code doesnt instantiate in the middle of stubbing anymore how do i ignore the test? or do i just delete the test file? im used to using an annotation to ignore tests the pr should be ready after thats sorted and any other suggested changes;;thenthrow(class) no longer creates new instances;as of #1162 `thenthrow(class)` no longer creates new instances for each invocation  we had tests that were reliant on that behavior for example:```	@test	public void thenthrow() {		supplier<object> r  mock(supplierclass)		when(rget())thenthrow(runtimeexceptionclass)		runtimeexception first  null		for (int i  0 i < 2 i++) {			try {				rget()			} catch (runtimeexception e) {				if (first  null) {					first  e				} else {					firstaddsuppressed(e)				}			}		}		if (first ! null) {			throw first		}	}```these tests now fail:```javalangillegalargumentexception: self-suppression not permitted	at javalangthrowableaddsuppressed(throwablejava:1043)	at exampletestthenthrow(testjava:10)```;hello ive taken a look at the issue and it is still apparent in commit 560adf377677a4a2c658a0b24e2f9c2e0b373c20 it appears to be that `thenthrow(class)` instantiates the throwable when it is called rather than instantiating it upon mock interaction### backgroundto why this leads to the behaviour described in the issue is that the throwable is passed to `thenthrow(throwable)` which instantiates a custom answer with `new throwsexception(throwable)` and passes into `thenanswer(answer)` this answer of course stores the throwable and throws it with every repeat mock interactionbefore the merge `thenthrow(class)` used to call `thenanswer(answer)` directly with its own custom answer throwsexceptionclass this answer instantiated the exception with each mock interaction### suggested solutionmy suggestion is to introduce an answer similar to throwsexceptionclass described above (or a modified version of throwsexception) and have `thenthrow(class)` create that and call `thenanswer(answer)`i can think of two ways to implement the suggestion both ways involve storing the class\<throwable\> and using objenesis to instantiate the throwable in the new answer class however:1 create the new answer class with similar code to throwsexception but instead of throwing the stored throwable it uses a new instance based of the stored class\<throwable\>2 modify throwsexception to use a protected getter method for the throwable then extend throwsexception with the new answer for class\<throwable\> which overrides the getter method to instantiate a new throwableoption 1 doesnt modify existing behaviour that works but has more duplicate code option 2 offers less duplicate code but modifies existing behaviour that worksi prefer option 2 || happy to review a pr for this we probably need to make a few iterations on the design but agreed we can fix this issuehowever if the necessary changes appear to be complicated i am inclined to close this as working as intended ||;1;0;1875 : fix mocks throwing same instance with throwable classfixes mocks throwing the same instance consecutively of a giventhrowable class after specifying the mock behaviour with dothrow(class)or thenthrow(class);
1893;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix invalid bibtexkey freeze;1882. reference: #1863. -   -  manually tested changed features in running jabref;;0;id : 1888;pr to fix the typo in the documentation;;;;;1;1;id : 1888;
1893;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix invalid bibtexkey freeze;1882. reference: #1863. -   -  manually tested changed features in running jabref;;0;nan in array or map not handled correctly;select array[sqrt(-1)]the above query should work but instead fails with an error;;;;;0;1;;
1893;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix invalid bibtexkey freeze;1882. reference: #1863. -   -  manually tested changed features in running jabref;;0; incorrect error merging;the `wip` was decremented if the parent received an onerror which prevented legitimate inner subscribers from delivering events;thanks for hunting down and fixing this ||;;;;1;1;avoid request(0) to trigger a recursive call;
1895;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1894 checkstyle error on windows;windows has some issues with relative paths in checkstyle config files  additionally it failed with an euro sign in code.;;0;presto 08 with cassandra 211;im getting this error starting presto against a 211 cassandra installation```2014-11-05t02 39478+0000    error   main    comfacebookprestoserverprestoserver nulljavalangexceptionininitializererror: null    at orgslf4jloggerfactorybind(loggerfactoryjava:128) ~[slf4j-api-175jar:175]    at orgslf4jloggerfactoryperforminitialization(loggerfactoryjava:107) ~[slf4j-api-175jar:175]    at orgslf4jloggerfactorygetiloggerfactory(loggerfactoryjava:295) ~[slf4j-api-175jar:175]    at orgslf4jloggerfactorygetlogger(loggerfactoryjava:269) ~[slf4j-api-175jar:175]    at orgslf4jloggerfactorygetlogger(loggerfactoryjava:281) ~[slf4j-api-175jar:175]    at comdatastaxdrivercorecluster<clinit>(clusterjava:64) ~[na:na]    at comfacebookprestocassandracassandraclientmodulecreatecassandrasession(cassandraclientmodulejava:95) ~[na:na]    at sunreflectnativemethodaccessorimplinvoke0(native method) ~[na:170_65]    at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:57) ~[na:170_65]    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43) ~[na:170_65]    at javalangreflectmethodinvoke(methodjava:606) ~[na:170_65]    at comgoogleinjectinternalprovidermethodget(providermethodjava:104) ~[guice-30jar:na]    at comgoogleinjectinternalinternalfactorytoprovideradapterget(internalfactorytoprovideradapterjava:40) ~[guice-30jar:na]    at comgoogleinjectinternalprovidertointernalfactoryadapter$1call(providertointernalfactoryadapterjava:46) ~[guice-30jar:na]    at comgoogleinjectinternalinjectorimplcallincontext(injectorimpljava:1031) ~[guice-30jar:na]    at comgoogleinjectinternalprovidertointernalfactoryadapterget(providertointernalfactoryadapterjava:40) ~[guice-30jar:na]    at comgoogleinjectscopes$1$1get(scopesjava:65) ~[guice-30jar:na]    at comgoogleinjectinternalinternalfactorytoprovideradapterget(internalfactorytoprovideradapterjava:40) ~[guice-30jar:na]    at comgoogleinjectinternalinternalinjectorcreator$1call(internalinjectorcreatorjava:204) ~[guice-30jar:na]    at comgoogleinjectinternalinternalinjectorcreator$1call(internalinjectorcreatorjava:198) ~[guice-30jar:na]    at comgoogleinjectinternalinjectorimplcallincontext(injectorimpljava:1024) ~[guice-30jar:na]    at comgoogleinjectinternalinternalinjectorcreatorloadeagersingletons(internalinjectorcreatorjava:198) ~[guice-30jar:na]    at comgoogleinjectinternalinternalinjectorcreatorinjectdynamically(internalinjectorcreatorjava:179) ~[guice-30jar:na]    at comgoogleinjectinternalinternalinjectorcreatorbuild(internalinjectorcreatorjava:109) ~[guice-30jar:na]    at comgoogleinjectguicecreateinjector(guicejava:95) ~[guice-30jar:na]    at ioairliftbootstrapbootstrapinitialize(bootstrapjava:286) ~[bootstrap-096jar:096]    at comfacebookprestocassandracassandraconnectorfactorycreate(cassandraconnectorfactoryjava:74) ~[na:na]    at comfacebookprestoconnectorconnectormanagercreateconnection(connectormanagerjava:113) ~[presto-main-080jar:080]    at comfacebookprestoconnectorconnectormanagercreateconnection(connectormanagerjava:99) ~[presto-main-080jar:080]    at comfacebookprestometadatacatalogmanagerloadcatalog(catalogmanagerjava:88) ~[presto-main-080jar:080]    at comfacebookprestometadatacatalogmanagerloadcatalogs(catalogmanagerjava:70) ~[presto-main-080jar:080]    at comfacebookprestoserverprestoserverrun(prestoserverjava:113) [presto-main-080jar:080]    at comfacebookprestoserverprestoservermain(prestoserverjava:61) [presto-main-080jar:080]caused by: javalangsecurityexception: prohibited package name: javautilconcurrent    at javalangclassloaderpredefineclass(classloaderjava:658) ~[na:170_65]    at javalangclassloaderdefineclass(classloaderjava:794) ~[na:170_65]    at javasecuritysecureclassloaderdefineclass(secureclassloaderjava:142) ~[na:170_65]    at javaneturlclassloaderdefineclass(urlclassloaderjava:449) ~[na:170_65]    at javaneturlclassloaderaccess$100(urlclassloaderjava:71) ~[na:170_65]    at javaneturlclassloader$1run(urlclassloaderjava:361) ~[na:170_65]    at javaneturlclassloader$1run(urlclassloaderjava:355) ~[na:170_65]    at javasecurityaccesscontrollerdoprivileged(native method) ~[na:170_65]    at javaneturlclassloaderfindclass(urlclassloaderjava:354) ~[na:170_65]    at comfacebookprestoserverpluginclassloaderloadclass(pluginclassloaderjava:82) ~[presto-main-080jar:080]    at javalangclassloaderloadclass(classloaderjava:358) ~[na:170_65]    at orgslf4jimpljdk14loggerfactory<init>(jdk14loggerfactoryjava:45) ~[na:na]    at orgslf4jimplstaticloggerbinder<init>(staticloggerbinderjava:72) ~[logback-classic-1013jar:na]    at orgslf4jimplstaticloggerbinder<clinit>(staticloggerbinderjava:43) ~[logback-classic-1013jar:na]     33 common frames omitted```and if i rollback to 079 the connection is made but i get the message:```query 20141105_015842_00025_mfbng failed: replicate_on_write is not a column defined in this metadata```which i believe was addressed in #1694have tested 080 against 2011 - same issue;same issue here when running 080 against cassandra 209 || +1 || +1 211 || is there a fix for this yet? || this should be  now || yes it was just that release forgot to update issue to say it was working || @simonmorley hey did it work for you? i still have the same issue (presto 087 + cassandra 21):i just tested it against cassandra 21 using presto 087:results are the same```2014-12-08t13 51075+0000    error   main    comfacebookprestoserverprestoserver nulljavalangexceptionininitializererror: null    at orgslf4jloggerfactorybind(loggerfactoryjava:128) ~[slf4j-api-175jar:175]    at orgslf4jloggerfactoryperforminitialization(loggerfactoryjava:107) ~[slf4j-api-175jar:175]    at orgslf4jloggerfactorygetiloggerfactory(loggerfactoryjava:295) ~[slf4j-api-175jar:175]    at orgslf4jloggerfactorygetlogger(loggerfactoryjava:269) ~[slf4j-api-175jar:175]    at orgslf4jloggerfactorygetlogger(loggerfactoryjava:281) ~[slf4j-api-175jar:175]    at comdatastaxdrivercorecluster<clinit>(clusterjava:64) ~[na:na]    at comfacebookprestocassandracassandraclientmodulecreatecassandrasession(cassandraclientmodulejava:95) ~[na:na]    at sunreflectnativemethodaccessorimplinvoke0(native method) ~[na:180_25]    at sunreflectnativemethodaccessorimplinvoke(unknown source) ~[na:180_25]    at sunreflectdelegatingmethodaccessorimplinvoke(unknown source) ~[na:180_25]    at javalangreflectmethodinvoke(unknown source) ~[na:180_25]    at comgoogleinjectinternalprovidermethodget(providermethodjava:104) ~[guice-30jar:na]    at comgoogleinjectinternalinternalfactorytoprovideradapterget(internalfactorytoprovideradapterjava:40) ~[guice-30jar:na]    at comgoogleinjectinternalprovidertointernalfactoryadapter$1call(providertointernalfactoryadapterjava:46) ~[guice-30jar:na]    at comgoogleinjectinternalinjectorimplcallincontext(injectorimpljava:1031) ~[guice-30jar:na]    at comgoogleinjectinternalprovidertointernalfactoryadapterget(providertointernalfactoryadapterjava:40) ~[guice-30jar:na]    at comgoogleinjectscopes$1$1get(scopesjava:65) ~[guice-30jar:na]    at comgoogleinjectinternalinternalfactorytoprovideradapterget(internalfactorytoprovideradapterjava:40) ~[guice-30jar:na]    at comgoogleinjectinternalinternalinjectorcreator$1call(internalinjectorcreatorjava:204) ~[guice-30jar:na]    at comgoogleinjectinternalinternalinjectorcreator$1call(internalinjectorcreatorjava:198) ~[guice-30jar:na]    at comgoogleinjectinternalinjectorimplcallincontext(injectorimpljava:1024) ~[guice-30jar:na]    at comgoogleinjectinternalinternalinjectorcreatorloadeagersingletons(internalinjectorcreatorjava:198) ~[guice-30jar:na]    at comgoogleinjectinternalinternalinjectorcreatorinjectdynamically(internalinjectorcreatorjava:179) ~[guice-30jar:na]    at comgoogleinjectinternalinternalinjectorcreatorbuild(internalinjectorcreatorjava:109) ~[guice-30jar:na]    at comgoogleinjectguicecreateinjector(guicejava:95) ~[guice-30jar:na]    at ioairliftbootstrapbootstrapinitialize(bootstrapjava:286) ~[bootstrap-098jar:098]    at comfacebookprestocassandracassandraconnectorfactorycreate(cassandraconnectorfactoryjava:76) ~[na:na]    at comfacebookprestoconnectorconnectormanagercreateconnection(connectormanagerjava:113) ~[presto-main-087jar:087]    at comfacebookprestoconnectorconnectormanagercreateconnection(connectormanagerjava:99) ~[presto-main-087jar:087]    at comfacebookprestometadatacatalogmanagerloadcatalog(catalogmanagerjava:88) ~[presto-main-087jar:087]    at comfacebookprestometadatacatalogmanagerloadcatalogs(catalogmanagerjava:70) ~[presto-main-087jar:087]    at comfacebookprestoserverprestoserverrun(prestoserverjava:108) [presto-main-087jar:087]    at comfacebookprestoserverprestoservermain(prestoserverjava:60) [presto-main-087jar:087]caused by: javalangsecurityexception: prohibited package name: javautilconcurrent    at javalangclassloaderpredefineclass(unknown source) ~[na:180_25]    at javalangclassloaderdefineclass(unknown source) ~[na:180_25]    at javasecuritysecureclassloaderdefineclass(unknown source) ~[na:180_25]    at javaneturlclassloaderdefineclass(unknown source) ~[na:180_25]    at javaneturlclassloaderaccess$100(unknown source) ~[na:180_25]    at javaneturlclassloader$1run(unknown source) ~[na:180_25]    at javaneturlclassloader$1run(unknown source) ~[na:180_25]    at javasecurityaccesscontrollerdoprivileged(native method) ~[na:180_25]    at javaneturlclassloaderfindclass(unknown source) ~[na:180_25]    at comfacebookprestoserverpluginclassloaderloadclass(pluginclassloaderjava:82) ~[presto-main-087jar:087]    at javalangclassloaderloadclass(unknown source) ~[na:180_25]    at orgslf4jimpljdk14loggerfactory<init>(jdk14loggerfactoryjava:45) ~[na:na]    at orgslf4jimplstaticloggerbinder<init>(staticloggerbinderjava:72) ~[logback-classic-1013jar:na]    at orgslf4jimplstaticloggerbinder<clinit>(staticloggerbinderjava:43) ~[logback-classic-1013jar:na]     33 common frames omitted2014-12-08t13 53465+0000     info   thread-55   ioairliftbootstraplifecyclemanager   life cycle stopping``` || ill have to fire up the machine again to test it was fine unless id foolishly used a previous version || @mauricioabreu the fix is committed but we havent released a new version yet can try building from master and see if that works? || @martint well sorry for this i did not know that i am going to try against master and check if it solves the issue || hey @martint just to let you know: i ran against master branch and it is ok  ||;;;;0;1;;
1895;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1894 checkstyle error on windows;windows has some issues with relative paths in checkstyle config files  additionally it failed with an euro sign in code.;;0;merge many fixes;contains the pr #1893 and a possible fix for the premature rxringbuffer unsubscription and npe;"its incomplete if the downstream unsubscribes it has to unsubscribe each active innersubscribers queue but simply having `actualadd(iq)` is not good enough because terminated innersubscribers need to remove their q to avoid memory leaks that in turn would need to happen from inside rxringbuffer itself || performance of 101 alone and then with these changes:v101/gradlew benchmarks -pjmh-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 _operatormergeperf_```benchmark                                          (size)   mode   samples        score  score error    unitsrooperatormergeperfmerge1syncstreamofn               1  thrpt         5  5325435841   355975709    ops/srooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    48829633     3244714    ops/srooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       54394        4383    ops/srooperatormergeperfmergenasyncstreamsofn             1  thrpt         5    97373673    11044130    ops/srooperatormergeperfmergenasyncstreamsofn          1000  thrpt         5        4809        0368    ops/srooperatormergeperfmergensyncstreamsof1              1  thrpt         5  4437715882   251805970    ops/srooperatormergeperfmergensyncstreamsof1            100  thrpt         5   437548282    37953173    ops/srooperatormergeperfmergensyncstreamsof1           1000  thrpt         5    49829496     8208868    ops/srooperatormergeperfmergensyncstreamsofn              1  thrpt         5  5345381694   388031049    ops/srooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       49858        3909    ops/srooperatormergeperfmergetwoasyncstreamsofn           1  thrpt         5    74373157    20872747    ops/srooperatormergeperfmergetwoasyncstreamsofn        1000  thrpt         5     2998045       83685    ops/srooperatormergeperfonestreamofnthatmergesin1         1  thrpt         5  5193516375   377830538    ops/srooperatormergeperfonestreamofnthatmergesin1      1000  thrpt         5    34618127     4024212    ops/srooperatormergeperfonestreamofnthatmergesin1   1000000  thrpt         5       34271        5933    ops/sbenchmark                                          (size)   mode   samples        score  score error    unitsrooperatormergeperfmerge1syncstreamofn               1  thrpt         5  5448592507   410246278    ops/srooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    54425611     1288398    ops/srooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       52477        4962    ops/srooperatormergeperfmergenasyncstreamsofn             1  thrpt         5    92792488    19384124    ops/srooperatormergeperfmergenasyncstreamsofn          1000  thrpt         5        4957        0783    ops/srooperatormergeperfmergensyncstreamsof1              1  thrpt         5  4608856070   201592479    ops/srooperatormergeperfmergensyncstreamsof1            100  thrpt         5   431920261    48373173    ops/srooperatormergeperfmergensyncstreamsof1           1000  thrpt         5    52309410     3940133    ops/srooperatormergeperfmergensyncstreamsofn              1  thrpt         5  5815289623   254128928    ops/srooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       52525        0524    ops/srooperatormergeperfmergetwoasyncstreamsofn           1  thrpt         5    77640706      905177    ops/srooperatormergeperfmergetwoasyncstreamsofn        1000  thrpt         5     3000748      263071    ops/srooperatormergeperfonestreamofnthatmergesin1         1  thrpt         5  5397752619   130514965    ops/srooperatormergeperfonestreamofnthatmergesin1      1000  thrpt         5    29257005     3984630    ops/srooperatormergeperfonestreamofnthatmergesin1   1000000  thrpt         5       35506        0864    ops/s```![merge-1 0 1]( + akarnokd:mergemanyfixes```benchmark                                          (size)   mode   samples        score  score error    unitsrooperatormergeperfmerge1syncstreamofn               1  thrpt         5  4652677182   124504915    ops/srooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    53208545     1880771    ops/srooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       54342        1369    ops/srooperatormergeperfmergenasyncstreamsofn             1  thrpt         5    96872888     3721793    ops/srooperatormergeperfmergenasyncstreamsofn          1000  thrpt         5        4776        0303    ops/srooperatormergeperfmergensyncstreamsof1              1  thrpt         5  4164810391   165025373    ops/srooperatormergeperfmergensyncstreamsof1            100  thrpt         5   464592905    10825917    ops/srooperatormergeperfmergensyncstreamsof1           1000  thrpt         5    51914168     3224118    ops/srooperatormergeperfmergensyncstreamsofn              1  thrpt         5  4864870326   180200813    ops/srooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       50731        2126    ops/srooperatormergeperfmergetwoasyncstreamsofn           1  thrpt         5    74211611     1191372    ops/srooperatormergeperfmergetwoasyncstreamsofn        1000  thrpt         5     3037404      196364    ops/srooperatormergeperfonestreamofnthatmergesin1         1  thrpt         5  4712305017   181033640    ops/srooperatormergeperfonestreamofnthatmergesin1      1000  thrpt         5    35506729      565008    ops/srooperatormergeperfonestreamofnthatmergesin1   1000000  thrpt         5       25865        1935    ops/sbenchmark                                          (size)   mode   samples        score  score error    unitsrooperatormergeperfmerge1syncstreamofn               1  thrpt         5  4720853728   189280311    ops/srooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    51373021     7032876    ops/srooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       54310        5412    ops/srooperatormergeperfmergenasyncstreamsofn             1  thrpt         5    97443762     1708086    ops/srooperatormergeperfmergenasyncstreamsofn          1000  thrpt         5        4435        0388    ops/srooperatormergeperfmergensyncstreamsof1              1  thrpt         5  4127156675    65289944    ops/srooperatormergeperfmergensyncstreamsof1            100  thrpt         5   464984192    21772305    ops/srooperatormergeperfmergensyncstreamsof1           1000  thrpt         5    51828432     3159051    ops/srooperatormergeperfmergensyncstreamsofn              1  thrpt         5  4867636838   178784669    ops/srooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       51096        1170    ops/srooperatormergeperfmergetwoasyncstreamsofn           1  thrpt         5    74124786     4567624    ops/srooperatormergeperfmergetwoasyncstreamsofn        1000  thrpt         5     3084738       61171    ops/srooperatormergeperfonestreamofnthatmergesin1         1  thrpt         5  4692041733   111905033    ops/srooperatormergeperfonestreamofnthatmergesin1      1000  thrpt         5    35294723     1908378    ops/srooperatormergeperfonestreamofnthatmergesin1   1000000  thrpt         5       35231        1361    ops/s```![merge-1 0 1 changes]( || rooperatormergeperfmerge1syncstreamofn drops from 5325435/second to 4720853/secondrooperatormergeperfmergensyncstreamsofn drops from 5815289/second to 4867636/second/rooperatormergeperfonestreamofnthatmergesin1 drops from 5397752/second to 4692041/secondid like to explore alternatives to this that dont allocate the `compositesubscription` unless there is contention requiring buffering  || i also am curious why we see so many linkednodes in the allocation analysis i thought we had eliminated all of those  || if i read the perf tables correctly the fix seems to work as good as before if size ! 1 in the test the size  1 test seem to suffer from increased overhead probably because the volatile read on queue which prevents register optimizations || yes it is only when size  1 but that is a very common case many of the performance optimizations in merge are for exactly that case as that is primarily what broke netflix apps when i didnt have it optimized i cant prove it yet but past experience with this code leads me to believe its the extra `compositesubscription` allocation that kills the perf there is a reason i worked so hard to completely eliminate use of that type in `merge` thats why `subscriber` uses `subscriptionlist` instead of `compositesubscription`  || id like to remove the changes for handling `rxringbuffer` unsubscribe but move forward on the rest of the fixes we need more time to consider concurrent handling of an `unsubscribe` and/or whether we can eliminate object pooling without killing perf do you have time right now to separate those changes or should i go ahead and manually merge this and make those changes? || subscriber is add-only but merge sources may terminate in any order maybe a specialized indexed-composite may help a biti believe a composite subscription is necessary to ensure the correct release in case of external termination (but not enough) ive thought about a test where a lot of merge+take(n) operation is in progress independently and concurrently to each other which may step on each others toes if an early return is picked up by someone else || > subscriber is add-only but merge sources may terminate in any orderyes thats what makes `compositesubscription` so expensive and why its not the default behavior for `subscriber` > correct releasewith the current use of object pooling youre probably right > ive thought about a test where a lot of merge+take(n) operation is in progress independently and concurrently to each otherthat kind of test would be valuable  || this pr contains the fixes of #1893 (already merged) and everything else is the npe & ringbuffer fixes which are still under debate the occasional npe can be  by reading the queue into a local variable which i can do now || the ""onerror from parent"" and ""emitted > 0"" checks seem valid and good to merge those are not included in the other fix and seem separate from the ringbuffer discussion arent they? || the first 3 commits on this pr is identical to the 3 in #1893  the rest is the fix in the ringbuffer and the added composite || im looking at the diff not the individual commits the diff shows changes such as these:``` java                        if (emitted > 0) {                            request(emitted)                        }```and``` java                   if (!parent) {                       wip--                   }``` || i turned off use of the `ringbuffer` with pooling so it uses `synchronizedqueue` with a linkedlist under it:```benchmark                                          (size)   mode   samples   linkedlist   ringbufferrooperatormergeperfmerge1syncstreamofn               1  thrpt         5  5378007404  5325435841rooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    50969202    48829633rooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       52712       54394rooperatormergeperfmergenasyncstreamsofn             1  thrpt         5    97399587    97373673rooperatormergeperfmergenasyncstreamsofn          1000  thrpt         5        4197        4809rooperatormergeperfmergensyncstreamsof1              1  thrpt         5  4447883122  4437715882rooperatormergeperfmergensyncstreamsof1            100  thrpt         5   442266165   437548282rooperatormergeperfmergensyncstreamsof1           1000  thrpt         5    50053290    49829496rooperatormergeperfmergensyncstreamsofn              1  thrpt         5  5537145541  5345381694rooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       48565       49858rooperatormergeperfmergetwoasyncstreamsofn           1  thrpt         5    77854621    74373157rooperatormergeperfmergetwoasyncstreamsofn        1000  thrpt         5     2446907     2998045rooperatormergeperfonestreamofnthatmergesin1         1  thrpt         5  5135540942  5193516375rooperatormergeperfonestreamofnthatmergesin1      1000  thrpt         5    34182359    34618127rooperatormergeperfonestreamofnthatmergesin1   1000000  thrpt         5       35466       34271```the perf is actually okayhere is the memory allocation ![screen shot 2014-11-29 at 1 28 31 pm]( wonder if all of the other perf optimizations i ended up doing to `merge` to handle scalar cases and non-contended hot paths basically makes it so the object pooling with ringbuffer is unnecessary im going to spend more time playing with this if we can eliminate object pooling it simplifies a lot for merge the `observeon` use cases probably still is going to be better with a ring buffer because it always goes via a queue whereas merge tries to avoid the queue at all costs  || those diff lines are already in 1x branch because of #1893  the changes page compares against the version which was the head at that time not now || oh really thats not very helpful of github! :-)i look at the branch name at the top and it says 1x so i figure its showing me the diff against the actual branch not some snapshot in time  || @akarnokd i have opened  for us to discuss and evaluate other options so we can eliminate the object pooling and associated problems it brings  || excellent! || closing because the queueing is re-evaluated || ";;;;0;1;;
1895;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1894 checkstyle error on windows;windows has some issues with relative paths in checkstyle config files  additionally it failed with an euro sign in code.;;1894.0;1894 checkstyle error on windows;windows has some issues with relative paths in checkstyle config files additionally it failed with an euro sign in codeplease verify if it also works on unix env; ;checkstyle error on windows;hi i cant build the project on windows it ends with error:<details>$ /gradlew clean build --parallel> configure project :  building version 2283 (value loaded from versionproperties file)> task  checkstyletest failed> task  checkstylemain failed> task  checkstylemain failed> task :junit-jupiter:checkstylemain failed> task  checkstyletest failedw: detected multiple kotlin daemon sessions at build\kotlin\sessionsfailure: build completed with 5 failures1: task failed with an exception-----------* what went wrong:execution failed for task  checkstyletest> unable to create root module: config {g:\programowanie\forki\mockito\config\checkstyle\checkstylexml} classpath {g:\programowanie\forki\mockito\subprojects\deprecatedpluginstest\build\classes\java\testg:\programowanie\forki\mockito\subprojects\deprecatedpluginstest\build\resources\testg:\programowanie\forki\mockito\subprojects\deprecatedpluginstest\build\classes\java\maing:\programowanie\forki\mockito\subprojects\deprecatedpluginstest\build\resources\maing:\programowanie\forki\mockito\build\libs\mockito-core-2283jarf:\programowanie\gradlecache\caches\modules-2\files-21\junit\junit\412\2973d150c0dc1fefe998f834810d68f278ea58ec\junit-412jarf:\programowanie\gradlecache\caches\modules-2\files-21\netbytebuddy\byte-buddy\1910\211a2b4d3df1eeef2a6cacf78d74a1f725e7a840\byte-buddy-1910jarf:\programowanie\gradlecache\caches\modules-2\files-21\netbytebuddy\byte-buddy-agent\1910\9674aba5ee793e54b864952b001166848da0f26b\byte-buddy-agent-1910jarf:\programowanie\gradlecache\caches\modules-2\files-21\orgobjenesis\objenesis\26\639033469776fd37c08358c6b92a4761feb2af4b\objenesis-26jarf:\programowanie\gradlecache\caches\modules-2\files-21\orghamcrest\hamcrest-core\13\42a25dc3219429f0e5d060061f71acb49bf010a0\hamcrest-core-13jar}* try:run with --stacktrace option to get the stack trace run with --info or --debug option to get more log output run with --scan to get full insights2: task failed with an exception-----------* what went wrong:execution failed for task  checkstylemain> unable to create root module: config {g:\programowanie\forki\mockito\config\checkstyle\checkstylexml} classpath {g:\programowanie\forki\mockito\subprojects\android\build\classes\java\maing:\programowanie\forki\mockito\subprojects\android\build\resources\maing:\programowanie\forki\mockito\build\libs\mockito-core-2283jarf:\programowanie\gradlecache\caches\modules-2\files-21\netbytebuddy\byte-buddy-android\1910\fda8cb1715f7063c6177b0b3e9c09096b13b4bbb\byte-buddy-android-1910jarf:\programowanie\gradlecache\caches\modules-2\files-21\netbytebuddy\byte-buddy\1910\211a2b4d3df1eeef2a6cacf78d74a1f725e7a840\byte-buddy-1910jarf:\programowanie\gradlecache\caches\modules-2\files-21\netbytebuddy\byte-buddy-agent\1910\9674aba5ee793e54b864952b001166848da0f26b\byte-buddy-agent-1910jarf:\programowanie\gradlecache\caches\modules-2\files-21\orgobjenesis\objenesis\26\639033469776fd37c08358c6b92a4761feb2af4b\objenesis-26jarf:\programowanie\gradlecache\caches\modules-2\files-21\comjakewhartonandroidrepackaged\dalvik-dx\1\5344672f614ef1df39f7a9d88a5aa0e44d74d4d9\dalvik-dx-1jarf:\programowanie\gradlecache\caches\modules-2\files-21\comjakewhartonandroidrepackaged\libcore-dex\2\1d3c98644912295ca8cb80069b1cdea4389085b2\libcore-dex-2jar}* try:run with --stacktrace option to get the stack trace run with --info or --debug option to get more log output run with --scan to get full insights3: task failed with an exception-----------* what went wrong:execution failed for task  checkstylemain> unable to create root module: config {g:\programowanie\forki\mockito\config\checkstyle\checkstylexml} classpath {g:\programowanie\forki\mockito\subprojects\errorprone\build\classes\java\maing:\programowanie\forki\mockito\subprojects\errorprone\build\resources\maing:\programowanie\forki\mockito\build\libs\mockito-core-2283jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgoogleerrorprone\error_prone_core\232\d5d121a23bcd48df2fe42dc3f1424cd05872993\error_prone_core-232jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgoogleautoservice\auto-service\10-rc5\d25246bae325b4bcc63b55d6d782515fac32215a\auto-service-10-rc5jarf:\programowanie\gradlecache\caches\modules-2\files-21\netbytebuddy\byte-buddy\1910\211a2b4d3df1eeef2a6cacf78d74a1f725e7a840\byte-buddy-1910jarf:\programowanie\gradlecache\caches\modules-2\files-21\netbytebuddy\byte-buddy-agent\1910\9674aba5ee793e54b864952b001166848da0f26b\byte-buddy-agent-1910jarf:\programowanie\gradlecache\caches\modules-2\files-21\orgobjenesis\objenesis\26\639033469776fd37c08358c6b92a4761feb2af4b\objenesis-26jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgoogleerrorprone\error_prone_check_api\232\7415438c00adec8ba707689ec4168c8484d8403b\error_prone_check_api-232jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgoogleerrorprone\error_prone_annotation\232\7c554c59dd2ea8c4e9e36b3308f8bf92db83e70c\error_prone_annotation-232jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgoogleerrorprone\error_prone_type_annotations\232\e79e88b9051888c8ea806f49c86fa7e3e3728180\error_prone_type_annotations-232jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgithubstephencjcip\jcip-annotations\10-1\ef31541dd28ae2cefdd17c7ebf352d93e9058c63\jcip-annotations-10-1jarf:\programowanie\gradlecache\caches\modules-2\files-21\orgpcollections\pcollections\212\15925fd6c32a29fe3f40a048d238c5ca58cb8362\pcollections-212jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgoogleauto\auto-common\010\c8f153ebe04a17183480ab4016098055fb474364\auto-common-010jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgoogleguava\guava\2701-jre\bd41a290787b5301e63929676d792c507bbc00ae\guava-2701-jrejarf:\programowanie\gradlecache\caches\modules-2\files-21\comgooglecodefindbugs\jformatstring\300\d3995f9be450813bc2ccee8f0774c1a3033a0f30\jformatstring-300jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgooglecodefindbugs\jsr305\302\25ea2e8b0c338a877313bd4672d3fe056ea78f0d\jsr305-302jarf:\programowanie\gradlecache\caches\modules-2\files-21\orgcheckerframework\dataflow\253\edf284e0838290d661b22483ecf648065e7ec440\dataflow-253jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgoogleerrorprone\javac\9+181-r4173-1\bdf4c0aa7d540ee1f7bf14d47447aea4bbf450c5\javac-9+181-r4173-1jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgoogleerrorprone\error_prone_annotations\232\d1a0c5032570e0f64be6b4d9c90cdeb103129029\error_prone_annotations-232jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgoogleprotobuf\protobuf-java\340\b32aba0cbe737a4ca953f71688725972e3ee927c\protobuf-java-340jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgoogleautoservice\auto-service-annotations\10-rc5\6ea999af2b6262a7179a09c51a3d54e7b40a3833\auto-service-annotations-10-rc5jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgooglecodejava-diff-utils\diffutils\130\7e060dd5b19431e6d198e91ff670644372f60fbd\diffutils-130jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgithubkevinstern\software-and-algorithms\10\5e77666b72c6c5dd583c36148d17fc47f944dfb5\software-and-algorithms-10jarf:\programowanie\gradlecache\caches\modules-2\files-21\orgcheckerframework\javacutil\253\c545ca6fc7a57e3bc65d46e8e9438376f0db35ea\javacutil-253jarf:\programowanie\gradlecache\caches\modules-2\files-21\orgcheckerframework\checker-qual\253\4fe154d21bd734fe8c94ada37cdc41a9a6d61776\checker-qual-253jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgoogleguava\failureaccess\101\1dcf1de382a0bf95a3d8b0849546c88bac1292c9\failureaccess-101jarf:\programowanie\gradlecache\caches\modules-2\files-21\comgoogleguava\listenablefuture\99990-empty-to-avoid-conflict-with-guava\b421526c5f297295adef1c886e5246c39d4ac629\listenablefuture-99990-empty-to-avoid-conflict-with-guavajarf:\programowanie\gradlecache\caches\modules-2\files-21\comgooglej2objc\j2objc-annotations\11\ed28ded51a8b1c6b112568def5f4b455e6809019\j2objc-annotations-11jarf:\programowanie\gradlecache\caches\modules-2\files-21\orgcodehausmojo\animal-sniffer-annotations\117\f97ce6decaea32b36101e37979f8b647f00681fb\animal-sniffer-annotations-117jar}* try:run with --stacktrace option to get the stack trace run with --info or --debug option to get more log output run with --scan to get full insights4: task failed with an exception-----------* what went wrong:execution failed for task :junit-jupiter:checkstylemain> unable to create root module: config {g:\programowanie\forki\mockito\config\checkstyle\checkstylexml} classpath {g:\programowanie\forki\mockito\subprojects\junit-jupiter\build\classes\java\maing:\programowanie\forki\mockito\subprojects\junit-jupiter\build\resources\maing:\programowanie\forki\mockito\build\libs\mockito-core-2283jarf:\programowanie\gradlecache\caches\modules-2\files-21\orgjunitjupiter\junit-jupiter-api\511\fcca73c9c2825c9a966380c6d146a71acba233ca\junit-jupiter-api-511jarf:\programowanie\gradlecache\caches\modules-2\files-21\netbytebuddy\byte-buddy\1910\211a2b4d3df1eeef2a6cacf78d74a1f725e7a840\byte-buddy-1910jarf:\programowanie\gradlecache\caches\modules-2\files-21\netbytebuddy\byte-buddy-agent\1910\9674aba5ee793e54b864952b001166848da0f26b\byte-buddy-agent-1910jarf:\programowanie\gradlecache\caches\modules-2\files-21\orgobjenesis\objenesis\26\639033469776fd37c08358c6b92a4761feb2af4b\objenesis-26jarf:\programowanie\gradlecache\caches\modules-2\files-21\orgjunitplatform\junit-platform-commons\111\36fca464a84454cf56ae2759a8ba18d6d99d1113\junit-platform-commons-111jarf:\programowanie\gradlecache\caches\modules-2\files-21\orgapiguardian\apiguardian-api\100\3ef5276905e36f4d8055fe3cb0bdcc7503ffc85d\apiguardian-api-100jarf:\programowanie\gradlecache\caches\modules-2\files-21\orgopentest4j\opentest4j\100\6f09c598e9ff64bf0ce2fa7e7de49a99ba83c0b4\opentest4j-100jar}* try:run with --stacktrace option to get the stack trace run with --info or --debug option to get more log output run with --scan to get full insights5: task failed with an exception-----------* what went wrong:execution failed for task  checkstyletest> unable to create root module: config {g:\programowanie\forki\mockito\config\checkstyle\checkstylexml} classpath {g:\programowanie\forki\mockito\subprojects\inline\build\classes\java\testg:\programowanie\forki\mockito\subprojects\inline\build\resources\testg:\programowanie\forki\mockito\subprojects\inline\build\classes\java\maing:\programowanie\forki\mockito\subprojects\inline\build\resources\maing:\programowanie\forki\mockito\build\libs\mockito-core-2283jarf:\programowanie\gradlecache\caches\modules-2\files-21\junit\junit\412\2973d150c0dc1fefe998f834810d68f278ea58ec\junit-412jarf:\programowanie\gradlecache\caches\modules-2\files-21\netbytebuddy\byte-buddy\1910\211a2b4d3df1eeef2a6cacf78d74a1f725e7a840\byte-buddy-1910jarf:\programowanie\gradlecache\caches\modules-2\files-21\netbytebuddy\byte-buddy-agent\1910\9674aba5ee793e54b864952b001166848da0f26b\byte-buddy-agent-1910jarf:\programowanie\gradlecache\caches\modules-2\files-21\orgobjenesis\objenesis\26\639033469776fd37c08358c6b92a4761feb2af4b\objenesis-26jarf:\programowanie\gradlecache\caches\modules-2\files-21\orghamcrest\hamcrest-core\13\42a25dc3219429f0e5d060061f71acb49bf010a0\hamcrest-core-13jar}* try:run with --stacktrace option to get the stack trace run with --info or --debug option to get more log output run with --scan to get full insights* get more help at  gradle features were used in this build making it incompatible with gradle 60use --warning-mode all to show the individual deprecation warningssee  failed in 38s108 actionable tasks: 87 executed 7 from cache 14 up-to-date</details>ive  this issue but just need an issue for pr;could you paste the full build output? you can wrap it in `<details></details>` here on github to prevent a wall of textalso feel free to open your pr and happy to take a look || pr created -  please verify on unix(there are 2 commits because at first i didnt know that v2 is in maintenance only so i created new branch from release/3x hence the second commit) ||;1;0;1894 : windows has some issues with relative paths in config files additionally it failed with an euro sign in code;
1896;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;more tests and some cleanups of bibtexkeypatternutil;removed some unused/unnecessary code and added a number of tests. -  ;;0;documentation issue: object common methods its still pointing to objects;as per i can see on the docs ( the documentation is still using _objects_ when it should say _moreobjects_ (objects its deprecated on the 18 version) how can i fix this minor issue?thanks!;just  this (for moreobjectstostringhelper) thanks for the report! || cool thanks a lot! ;;;;0;1;;
1896;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;more tests and some cleanups of bibtexkeypatternutil;removed some unused/unnecessary code and added a number of tests. -  ;;0;feature/returns empty java8 time;im not sure why i see the commit [ that was already merged in changes but:when creating this pr i had in mind that i would merge with branch 2x (i didnt know back then that v2x is maintenance only) hence the reflection-based methods (also to keep the coding style of the returnsemptyvalues class);@kluever could you review this please? you are the expert on the these apis 😄  || wow its crazy how much effort has to be done to maintain pre-java8 compatibility!left a comment about potential other defaults for other `javatime` types but otherwise  yes it is very unfortunate that android does not ship these java 8 apis 😭  || a few more cleanups but otherwise lgtm ||  merging 1896 ;;;;1;1;removing leftovers;
1896;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;more tests and some cleanups of bibtexkeypatternutil;removed some unused/unnecessary code and added a number of tests. -  ;;0;add 081 release notes;;;;;;0;1;;
1896;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;more tests and some cleanups of bibtexkeypatternutil;removed some unused/unnecessary code and added a number of tests. -  ;;0;duplicates when using delay(duration) in combination with buffer(count duration);"this gist shows we may get duplicates when using delay(duration) with buffer(count duration) short :``` java    @test // fails    public void issuehere() {        final atomicinteger count  new atomicinteger(0)        observablerange(1 1)delay(10 timeunitseconds)buffer(10 3 timeunitseconds)asobservable()toblocking()foreach(new action1<list<integer>>() {            @override            public void call(list<integer> values) {                loginfo(""values  {}"" values)                countaddandget(valuessize())            }        })        assertassertequals(1 countget()) // actual  4    }```";that method is the buffer(long long timespan) which in this case creates buffers every 3 seconds for a duration of 10 seconds the first buffer might be empty because it might just miss the value after 10 seconds the second buffer overlaps 3-13 seconds the second 6-16 and the final 9-19 seconds all these last ones will see the single emitted value at 10 seconds you need the buffer(long timespan int) to have buffers with limited size and limited duration || youre right this is my mistakethank you @akarnokd   ||;;;;0;1;;
1906;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;check integrity year check added;#1897 added last four nonpunctuation characters should be numerals in check integrity year -   -   -  manually tested changed features in running jabref;;0;[documentation] change deprecated warnings from 3x -> 4x;problemwith the release of mockito 3x as a purely java language versionchange most of the comments referencing 3x are wrongsolutionmigrate the references to 3x that i could find to 4x[ci skip-release] -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_;;;;;1;1;[documentation] change deprecated warnings from 3x -> 4xproblemwith the release of mockito 3x as a purely java language versionchange most of the comments referencing 3x are wrongsolutionmigrate the references to 3x that i could find to 4x[ci skip-release];
1906;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;check integrity year check added;#1897 added last four nonpunctuation characters should be numerals in check integrity year -   -   -  manually tested changed features in running jabref;;0;optimize planning for queries with large number of fields;this improves planning time by ~70x (from 3 minutes to 25s) when selecting from a table with 16k columns; ;;;;0;1;;
1906;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;check integrity year check added;#1897 added last four nonpunctuation characters should be numerals in check integrity year -   -   -  manually tested changed features in running jabref;;0; potential npe due to many reads to an instance variable;factored out of #1895;i guess the original issue has been caused by merge so closing this ||;;;;0;1;;
1907;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0; fileutil: copy files using files methods;jabref now copies files by using java.nio package instead of java.io  see: 23;;0;provide subset and submap methods for navigableset/map that takes a range object;`navigableset` provides `headset()` `subset()` and `tailset()` methods for viewing the contents of a ordered slice of the set (and similar methods exist for `navigablemap`)  but these methods involve manually keeping track of separate from and to keys (and whether each is included)  working with `range` is often much cleaner but these methods arent available in guava presentlyfrom @kevinb9n :> for the case where the user has a pre-existing range it seems like we really should do _something_ like this for them because translating that into the right subset call would be uuuuglyit might be good to call out in the javadocs for these methods that users may end up with simpler code by calling the direct methods instead if they dont already have a range theyre trying to use;this was implemented in c85eacce7d ||;;;;0;1;;
1907;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0; fileutil: copy files using files methods;jabref now copies files by using java.nio package instead of java.io  see: 23;;0;[tests] use argumentmatchers over matchers;problemmatchers are considered deprecated but our own tests still use themsolutionstop using using them replace with argumentmatchers[ci skip-release]check list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style - [/] mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_;this pr ignores verificationusingmatcherstest which while undocumented i take to mean should explicitly use `matchers` while they exist ||  ;;;;1;1;[tests] use argumentmatchers over matchersproblem`matchers` are considered deprecated but our own tests still use themsolutionstop using using them replace with `argumentmatchers`[ci skip-release];
1907;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0; fileutil: copy files using files methods;jabref now copies files by using java.nio package instead of java.io  see: 23;;0;fix o(n^2) loop in inputextractorvisittablescan;the loop in visittablescan does one metadata lookup for each column referenced by the tablescan node the implementation of getcolumnmetadata is o(n) for some connectors (eg hive) resulting in o(n^2) overallfixing this may require updating the spi to be able to return multiple column metadata entries in one call;;;;;0;1;;
1907;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0; fileutil: copy files using files methods;jabref now copies files by using java.nio package instead of java.io  see: 23;;0;experimental: onbackpressureblock;an experimental implementation of `onbackpressureblock`an open question is whether this should be allowed to block if running on a known eventloop such as `schedulerscomputation()` or should instead emit an error in that situation;;;;;1;1;marking onbackpressureblock as @experimentali chose experimental instead of beta since we may still change how it behaves based on what scheduler is being used;
1911;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1910: update description of argumentmatcher javadoc;for any()  the doc says that;;0;improve error messages for hive partition value parsing;add extra handling for partition value in method hiveclienttopartition() for issue #1070 it can provide error message with the name of the partition column when any of the parsing functions fail attached is the test table and error message![test_table](https://cloudentcom/assets/2613617/4932755/b6a57c3a-658d-11e4-901f-a595221717dfpng)![error_message](https://cloudgithubusercontentcom/assets/2613617/4932764/cd56616a-658d-11e4-9038-05d3882337a4png);thanks @martint  has removed that || ;;;;0;1;;
1911;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1910: update description of argumentmatcher javadoc;for any()  the doc says that;;0;atomic operations jmh benchmarks;created some jmh benchmarks for the typical volatile and atomic operations;"some results run on i7 920 @ 266ghz jdk 18u25 windows 7 x64```benchmark                                       (times)   mode   samples        score  score error    unitsriatomicperfatomicintcascheckfailure               1   avgt         5        2668        0057    ns/opriatomicperfatomicintcascheckfailure            1000   avgt         5     1534512       74719    ns/opriatomicperfatomicintcascheckfailure         1000000   avgt         5  2284937183    28254968    ns/opriatomicperfatomicintcaschecksuccess               1   avgt         5       16064        0576    ns/opriatomicperfatomicintcaschecksuccess            1000   avgt         5    11408954      213337    ns/opriatomicperfatomicintcaschecksuccess         1000000   avgt         5 11417083239   142717458    ns/opriatomicperfatomicintcasfailure                    1   avgt         5        7985        0131    ns/opriatomicperfatomicintcasfailure                 1000   avgt         5     6899117      377535    ns/opriatomicperfatomicintcasfailure              1000000   avgt         5  6861438949   224204293    ns/opriatomicperfatomicintcassuccess                    1   avgt         5       17949        0298    ns/opriatomicperfatomicintcassuccess                 1000   avgt         5     7208543      140543    ns/opriatomicperfatomicintcassuccess              1000000   avgt         5  7251170709   306098222    ns/opriatomicperfatomicintfieldcasfailure               1   avgt         5        9892        0096    ns/opriatomicperfatomicintfieldcasfailure            1000   avgt         5    10664317      136754    ns/opriatomicperfatomicintfieldcasfailure         1000000   avgt         5  8024782072   305465473    ns/opriatomicperfatomicintfieldcassuccess               1   avgt         5       19520        0528    ns/opriatomicperfatomicintfieldcassuccess            1000   avgt         5    11772415      265342    ns/opriatomicperfatomicintfieldcassuccess         1000000   avgt         5  8361572721   162622626    ns/opriatomicperfatomicintfieldgetandincrement          1   avgt         5       15282        0405    ns/opriatomicperfatomicintfieldgetandincrement       1000   avgt         5    15215159      139704    ns/opriatomicperfatomicintfieldgetandincrement    1000000   avgt         5 12560260811   334571720    ns/opriatomicperfatomicintfieldincrementandget          1   avgt         5       15238        0191    ns/opriatomicperfatomicintfieldincrementandget       1000   avgt         5    12954997      161420    ns/opriatomicperfatomicintfieldincrementandget    1000000   avgt         5 12557229845   138688873    ns/opriatomicperfatomicintfieldlazyset                  1   avgt         5        4179        0065    ns/opriatomicperfatomicintfieldlazyset               1000   avgt         5     3049292       47938    ns/opriatomicperfatomicintfieldlazyset            1000000   avgt         5  3481701210   290943430    ns/opriatomicperfatomicintgetandincrement               1   avgt         5       11794        0212    ns/opriatomicperfatomicintgetandincrement            1000   avgt         5    11799472      422497    ns/opriatomicperfatomicintgetandincrement         1000000   avgt         5 11851958773   433823735    ns/opriatomicperfatomicintincrementandget               1   avgt         5       11449        0238    ns/opriatomicperfatomicintincrementandget            1000   avgt         5    11404258      206021    ns/opriatomicperfatomicintincrementandget         1000000   avgt         5 11411961183   194850135    ns/opriatomicperfatomicintlazyset                       1   avgt         5        2286        0025    ns/opriatomicperfatomicintlazyset                    1000   avgt         5     1150760       10376    ns/opriatomicperfatomicintlazyset                 1000000   avgt         5  1142247802    12846952    ns/opriatomicperfatomiclongcascheckfailure              1   avgt         5        2663        0027    ns/opriatomicperfatomiclongcascheckfailure           1000   avgt         5     1541088       88716    ns/opriatomicperfatomiclongcascheckfailure        1000000   avgt         5  2285668598   108122588    ns/opriatomicperfatomiclongcaschecksuccess              1   avgt         5       16014        0616    ns/opriatomicperfatomiclongcaschecksuccess           1000   avgt         5    11391372      175883    ns/opriatomicperfatomiclongcaschecksuccess        1000000   avgt         5 11445626686   192965285    ns/opriatomicperfatomiclongcasfailure                   1   avgt         5        7608        0071    ns/opriatomicperfatomiclongcasfailure                1000   avgt         5     6841162      143312    ns/opriatomicperfatomiclongcasfailure             1000000   avgt         5  6856431735   113946099    ns/opriatomicperfatomiclongcassuccess                   1   avgt         5       17938        0332    ns/opriatomicperfatomiclongcassuccess                1000   avgt         5     7253693       99541    ns/opriatomicperfatomiclongcassuccess             1000000   avgt         5  7235321845    78547957    ns/opriatomicperfatomiclongfieldcasfailure              1   avgt         5        9564        0463    ns/opriatomicperfatomiclongfieldcasfailure           1000   avgt         5     9830242      187956    ns/opriatomicperfatomiclongfieldcasfailure        1000000   avgt         5  8022695593   330115681    ns/opriatomicperfatomiclongfieldcassuccess              1   avgt         5       19403        0292    ns/opriatomicperfatomiclongfieldcassuccess           1000   avgt         5     9179600      460020    ns/opriatomicperfatomiclongfieldcassuccess        1000000   avgt         5  7989544345    68693036    ns/opriatomicperfatomiclongfieldgetandincrement         1   avgt         5       15203        0142    ns/opriatomicperfatomiclongfieldgetandincrement      1000   avgt         5    12964216      153536    ns/opriatomicperfatomiclongfieldgetandincrement   1000000   avgt         5 12579871025   407386205    ns/opriatomicperfatomiclongfieldincrementandget         1   avgt         5       15261        0192    ns/opriatomicperfatomiclongfieldincrementandget      1000   avgt         5    13886679      129986    ns/opriatomicperfatomiclongfieldincrementandget   1000000   avgt         5 12570775806   138961157    ns/opriatomicperfatomiclongfieldlazyset                 1   avgt         5        4183        0076    ns/opriatomicperfatomiclongfieldlazyset              1000   avgt         5     3077770      131585    ns/opriatomicperfatomiclongfieldlazyset           1000000   avgt         5  3446711809   107526958    ns/opriatomicperfatomiclonggetandincrement              1   avgt         5       11841        0329    ns/opriatomicperfatomiclonggetandincrement           1000   avgt         5    11788437      110213    ns/opriatomicperfatomiclonggetandincrement        1000000   avgt         5 11813940290   129279063    ns/opriatomicperfatomiclongincrementandget              1   avgt         5       11421        0139    ns/opriatomicperfatomiclongincrementandget           1000   avgt         5    11493952      396706    ns/opriatomicperfatomiclongincrementandget        1000000   avgt         5 11497876406   797429030    ns/opriatomicperfatomiclonglazyset                      1   avgt         5        2293        0043    ns/opriatomicperfatomiclonglazyset                   1000   avgt         5     1157337       55157    ns/opriatomicperfatomiclonglazyset                1000000   avgt         5  1147311576    55736976    ns/opriatomicperfvolatileintread                        1   avgt         5        3060        0155    ns/opriatomicperfvolatileintread                     1000   avgt         5     1920303       48465    ns/opriatomicperfvolatileintread                  1000000   avgt         5  1910374684    41195249    ns/opriatomicperfvolatileintwrite                       1   avgt         5        9178        0287    ns/opriatomicperfvolatileintwrite                    1000   avgt         5     8029069      271625    ns/opriatomicperfvolatileintwrite                 1000000   avgt         5  7986386165   146129049    ns/opriatomicperfvolatilelongread                       1   avgt         5        3055        0070    ns/opriatomicperfvolatilelongread                    1000   avgt         5     1912078       40309    ns/opriatomicperfvolatilelongread                 1000000   avgt         5  1906103736    21611386    ns/opriatomicperfvolatilelongwrite                      1   avgt         5        9175        0217    ns/opriatomicperfvolatilelongwrite                   1000   avgt         5     8029490       78576    ns/opriatomicperfvolatilelongwrite                1000000   avgt         5  7984140211   151524011    ns/opriatomicperfatomicintgetandset          1   avgt         5       11036        0129    ns/opriatomicperfatomicintgetandset       1000   avgt         5    11030586      191069    ns/opriatomicperfatomicintgetandset    1000000   avgt         5 11052108014   294789921    ns/opriatomicperfatomiclonggetandset         1   avgt         5       11044        0164    ns/opriatomicperfatomiclonggetandset      1000   avgt         5    11033459      135330    ns/opriatomicperfatomiclonggetandset   1000000   avgt         5 11093528851   543185442    ns/op```few observations:- incrementandget and getandincrement are practically the same- lazyset is generally twice as fast as volatile write- plain cas success and failure take roughly the same time- avoiding certain cas failure is a great win but reading before certain cas success has extra cost- there isnt much difference between ints and longs on x64- atomicfieldupdaters seem to have around 10% overhead- getandset costs more than compareandset (so using getandset for swapping in a terminal state lowers performance) || this is cool information thanks  || sorry for coming into the year old thread (im reviewing rxjava sources…) but my runs of `/gradlew benchmark` for `operatorobserveon` show that switching to plain atomic fields intead of `volatile` + `atomicfieldupdater` give pretty significant performance boost (ill do more tests tomorrow and probably will open a pr)im not a jmh master but as far as i understand tests in this pr are not very good for one big reason — loops afaik loops in benchmark tests are bad because jit is too smart about them see  i remove loops from these tests i see that atomicfieldupdaters have 25-30% overhead not 10% (especially in `getandincrement` and `incrementandget`)@akarnokd @benjchristensen thoughts? probably its a reason to reconsider switch to `volatile` + `atomicfieldupdater` instead of `atomic*` of course in some (rare) cases its good because of slightly lower memory usage but reflection costs too much especially on android :(i guess @benjchristensen in your usage cases (netflix) you would like to have faster code than save few bytes of memory for android it will be nice to avoid this reflection too || > benchmark tests are bad because jit is too smart about themexcept when there are atomic operations inside the loop> i see that atomicfieldupdaters have 25-30% overheadjit can sometimes properly eliminate the class-validation in the updater and it should run as fast as unsafe sometimes not most likely when there are some other implementation of the host class around> some (rare) cases its good because of slightly lower memory usage but reflection costs too much especially on androidits a tradeoff between portability memory usage the cost of validation vs dereference do you know a benchmark tool for android where these cases could be run? || > its a tradeoff between portability memory usage the cost of validation vs dereferencesince rxjava needs a lot of `atomicinteger`s and `atomiclong`s and also rxjava should be fast and memory-friendly what do you think about object pools for them? it will: - remove some amount of memory allocations- remove need in reflection (`atomicfieldupdater`)- make operators faster > do you know a benchmark tool for android where these cases could be run?no :( but we can create one similar to jmh :) || > rxjava should be fast and memory-friendlyconcurrent operators can become faster by padding away heavily mutated counters but at a cost of higher memory usage and increased class complexity these latter two become drawbacks with short lived tasks that are run from a tight loop (ie benchmarking just()observeon()subscribe() with jmhin addition having a reference to atomic classes may still end up with false sharing as gc may pack them next to each other or their owner class sometimes even if they are further away there could be a false-sharing issue with the object header itself java 8 atomic variables _might_ get padded but thats unreliable whats left is manually assembling classes with padding fields and either using unsafe (unavailable in android) or field updatersthe same is true for our copies of the jctools queues: class padding may help element padding may help up to a certain limit> what do you think about object pools for themi generally try to avoid them because they can become the new contention point> remove some amount of memory allocationsallocation is pretty performant in desktop java and if you dont run short-lived tasks that frequently it isnt a problem i saw the tendency for the need of optimizing for short-lived tasks (ie just() and single) and i believe there is an upper bound on how few operations can achieve the functionality without endangering concurrent-safety> remove need in reflection (atomicfieldupdater)i think android is in disadvantage here i never had any problems with desktop java reflection since java 7 the 2-second long reflective lookup of all methods (newthreadworker issue) baffled me i think the android platform is so behind that it requires an independent rxjavaandroid port that specifically knows about such problems> make operators fastermost benchmarks really test for operator overhead by doing nothing but blackholing source values many of these by using boxed integers test for gc+operator overhead together (although i think there should be perf test that specifically avoid gc interference) || > i think android is in disadvantage hereyeah :(though i dont like manual paddings because its platform specific thing…okay your arguments were enough convincing for me lets leave `atomicfieldupdater` :) || @artem-zinnatullin i didnt mean to discourage you from doing performance improvements just saying that there are tradeoffs per platform and per implementation aimwith `observeon` we can check for the platform android and run a different inner subscriber for each for example desktop could run a padded version and android could run with atomicxxx instancesthere is however another effect usually found with async benchmarks and the computation scheduler: each inner iteration may end up on different cores which may trigger more thread migrations and soak up interference from other programs ive resolved this in 2x with the introduction of the `schedulerssingle()` which routes to the same underlying thread all the timefinally there is sometimes an effect going on i call emission-grabbing where the thread which requests grabs the emission logic and the whole source-sink ends up on the same thread boosting the throughput considerably in terms of the `observeon` that means padding optimization may not mean too much because there is going to be little-to-none concurrency happening therefor example in the range test ive added a pipelined version where the emission is forced to a different thread than the observation:( you can see pipelined has 6x less throughput than non-pipelined also note that 2x observeon is 1  cache line padded (the usual padding is 2x for compensating for adjacent prefetch but i was a bit sloppy)that being said im always open to optimizations would you like to pursue this further? || > i didnt mean to discourage you to do performance imporvements just saying that there are tradeoffs per platform and per implementation aimyeah i understand> with observeon we can check for the platform android and run a different inner subscriber for each for example desktop could run a padded version and android could run with atomicxxx instancesthis requires jmh-like tool for android first ill work on it in my spare time feel free to review/comment/follow  as you can see pipelined has 6x less throughput than non-pipelinedwow> that being said im always open to optimizations would you like to pursue this further?yep ill continue my ""investigations"" :) || the cas vs getandadd conclusion is somewhat misleading from jdk8 getandadd is intrinsified into xadd which scales better than cas under contention to see the effect measure with different thread countsthe volatile read cost is misleading in the sense that side effects of volatile are not measured/discussed in the single value read there should be no difference volatile reads can stop many other memory reads from optimizing || ";;;;1;1;getandset benchmarks;
1911;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1910: update description of argumentmatcher javadoc;for any()  the doc says that;;1910.0;1910: update description of argumentmatcher javadoc;"for any() the doc says that""any() is an alias of: anyobject() and any(javalangclass)""but in the note it says that""since mockito 210 any(class) is not anymore an alias of this method""this is confusing so the alias in the doc should exclude any(javalangclass) to simply be""any() is an alias of: anyobject()""also update the same issue of anyobject()check list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_";;documentation of argumentmatchers any() is confusing; doc says that > any() is an alias of: anyobject() and any(javalangclass)but in the note it says that > since mockito 210 any(class) is not anymore an alias of this methodthis is confusing so the alias in the doc should exclude any(javalangclass) to simply be > any() is an alias of: anyobject()the doc of anyobject() also has the same confusing issue;;1;0;"1910: update description of argumentmatcher javadocfor any() the doc says that""any() is an alias of: anyobject() and any(javalangclass)""but in the note it says that""since mockito 210 any(class) is not anymore an alias of this method""this is confusing so the alias in the doc should exclude any(javalangclass) to simply be""any() is an alias of: anyobject()""also update the same issue of anyobject()";
1914;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;check integrity edition check implemented;#1912 implemented a check for the field edition. the check differentiates between bibtex and biblatex mode of the database. -   -   -  manually tested changed features in running jabref;;0;thread interruption on unsubscribe;"a few issues recently have been related to thread interruption and brings into question why we interrupt the thread when we unsubscribe a scheduled action (via a `scheduler`) - #1913 computation scheduler gets interrupted thousands of times per second?- #1898 scheduled action no interrupt- #1832 fix take early unsubscription causing interrupts- #1804 ""interrupted while waiting for subscription to complete"" in 100-rc8the code that causes this is from  that wraps a `subscription` around a `future` this in turn is used  scheduledaction` which is used when scheduling work via a `scheduler` issue #1898 is working to not cause an interrupt after successful termination but i want to question why we ever interrupt as default behavior i dont think much thought went into choosing to call `cancel(true)` instead of `cancel(false)` and id like to discuss changing this to not interrupt the implication of interrupting are difficult to manage well and add a lot of complexity the only time interrupting seems wanted is if unsubscribing early to a `scheduledaction` doing blocking io otherwise the `subscription` itself is the cancellation token that work should be checking (most code doesnt properly use `threadisinterrupted()` anyways so it rarely helps) if an `observable` is doing blocking io it seems it should opt itself into doing thread interruption perhaps we should figure out an idiomatic approach to that for opting into that behavior without requiring interruption all the time ";@benjchristensen makes total sense im not so into the details maybe we can only do the interruption on the io scheduler? especially not on the computation one || the developers of the jdk threadpool couldnt decide it either so they went for providing the option to the programmer either we dont do interrupts on the computation scheduler but do it everywhere else or we extend the api and inject an `interruptible` flag all around two clarifications: scheduledaction has its own future wrapper scheduledaction wraps an action0 and the scheduledaction itself is not accessible inside this action0 so it cant act as a cancellation token nor can be manipulated to gain access to the future it holds to issue an cancel(true) one would need to exfiltrate the worker thread but then it becomes dangerous to call interrupt on it || i have a `scheduledaction` enhancements that will support customization of the interrupt behavior see #2592 || resolved in  || following #2579 to #2592 to #2761 to #2772 it doesnt look like this is actually resolved is it @akarnokd? || none of the customizations made it and it seems hystrix solved it internally there were a few changes made to scheduledaction so it doesnt call cancel(true) when cancelling from the same thread ||;;;;0;1;;
1914;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;check integrity edition check implemented;#1912 implemented a check for the field edition. the check differentiates between bibtex and biblatex mode of the database. -   -   -  manually tested changed features in running jabref;;1905.0;fix pattern matcher not matching to subregion;issue #1905 talked about a particular pattern using javas pattern class that causes mockito to not properly match the argument (provided with an invocation) to the expected answerit was later discovered that the pattern matcher matches to the entire region not some subregion by using javas `matchermatch()` (see [comment]( in #1905) this commit fixes that by using `matcherfind()`1905;;argumentmatchersmatches not working;"* ver mockito-core:333* java pattern and java matcher```javapattern pat  patterncompile(""^zman-server-"")matcher mat  patmatcher(""zman-server-storeproperties"")matfind() // return true```* mockito matcher not wrking:```when(streamerload( matches(pat)))thenreturn(stream)output:- this invocation of load method:    streamerload(    ""zman-server-storeproperties"") - has following stubbing(s) with different arguments:    1 streamerload("""")```";helloive taken a look at the issue and after doing some digging i found that `matches(pattern)` uses [`javautilregexmatchersmatches()`]( in `orgmockitointernalmatchersmatchesmatches(object)` which requires the entire region to match not just some sub-region like [`matchersfind()`]( does this means that your matcher fail when testing to see if your answer `thenreturn(stream)` is suitable for the mocks `load()` invocationill probably make a pr with the solution appropriate acceptance testing and any needed documentation changes || thx that explain a lot ||;1;0;1905 : fix pattern matcher not matching to subregionissue #1905 talked about a particular pattern using javas pattern thatcauses mockito to not properly match the argument (provided with aninvocation) to the expected answer it was later discovered that thepattern matcher matches to the entire region not some subregion byusing javas matchermatch() this commit fixes that by usingmatcherfind();
1914;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;check integrity edition check implemented;#1912 implemented a check for the field edition. the check differentiates between bibtex and biblatex mode of the database. -   -   -  manually tested changed features in running jabref;;190.0;fix pattern matcher not matching to subregion;issue #1905 talked about a particular pattern using javas pattern class that causes mockito to not properly match the argument (provided with an invocation) to the expected answerit was later discovered that the pattern matcher matches to the entire region not some subregion by using javas `matchermatch()` (see [comment]( in #1905) this commit fixes that by using `matcherfind()`1905;;build fails with noclassdeffounderror on cglibmockmaker;hi   my maven build fails when i try to mock a class with the error below i am beginner with mockito can someone please help with this? i am trying to build from command line i am trying to build a scala project java version: 17project type: scala projectmockito version: ``` xml<dependency>    <groupid>orgmockito</groupid>    <artifactid>mockito-all</artifactid>    <version>11019</version></dependency>```error that i get during maven build:```←[31m*** run aborted ***←[0m←[31m  javalangnoclassdeffounderror: org/mockito/internal/creation/cglibmockmaker←[0m←[31m  at orgpowermockapimockitointernalmockmakerpowermockmaker<init>(powermockmakerjava:40)←[0m←[31m  at sunreflectnativeconstructoraccessorimplnewinstance0(native method)←[0m←[31m  at sunreflectnativeconstructoraccessorimplnewinstance(nativeconstructoraccessorimpljava:57)←[0m←[31m  at sunreflectdelegatingconstructoraccessorimplnewinstance(delegatingconstructoraccessorimpljava:45)←[0m←[31m  at javalangreflectconstructornewinstance(constructorjava:526)←[0m←[31m  at javalangclassnewinstance(classjava:374)←[0m←[31m  at orgmockitointernalconfigurationpluginspluginloaderloadimpl(pluginloaderjava:61)←[0m←[31m  at orgmockitointernalconfigurationpluginspluginloaderloadplugin(pluginloaderjava:24)←[0m←[31m  at orgmockitointernalconfigurationpluginspluginregistry<init>(pluginregistryjava:12)←[0m←[31m  at orgmockitointernalconfigurationpluginsplugins<clinit>(pluginsjava:11)←[0m←[31m  ←[0m←[31m  cause: javalangclassnotfoundexception: orgmockitointernalcreationcglibmockmaker←[0m←[31m  at javaneturlclassloader$1run(urlclassloaderjava:366)←[0m←[31m  at javaneturlclassloader$1run(urlclassloaderjava:355)←[0m←[31m  at javasecurityaccesscontrollerdoprivileged(native method)←[0m←[31m  at javaneturlclassloaderfindclass(urlclassloaderjava:354)←[0m←[31m  at javalangclassloaderloadclass(classloaderjava:425)←[0m←[31m  at sunmisclauncher$appclassloaderloadclass(launcherjava:308)←[0m←[31m  at javalangclassloaderloadclass(classloaderjava:358)←[0m←[31m  at orgpowermockapimockitointernalmockmakerpowermockmaker<init>(powermockmakerjava:40)←[0m←[31m  at sunreflectnativeconstructoraccessorimplnewinstance0(native method)←[0m←[31m  at sunreflectnativeconstructoraccessorimplnewinstance(nativeconstructoraccessorimpljava:57)←[0m←[31m  ←[0m```;hiwe are happy that you are using mockito but for support please use the [mockito mailing-list]( or [stackoverflow]( :)with the given info theres not enough info to diagnose the issue it seems to be related to classpath though  || oh i just identified the issue this project is using powermock which is depending / hacking in mockito internals those have change in version 1108 however theres a new version of powermock 162 that work with mockito 11019 || thanksit did the trick  and saved my time!! :) || this trick saved my life || you saved the day bro!thanks :) || thanks a lot bric3 :) ||;1;0;1905 : fix pattern matcher not matching to subregionissue #1905 talked about a particular pattern using javas pattern thatcauses mockito to not properly match the argument (provided with aninvocation) to the expected answer it was later discovered that thepattern matcher matches to the entire region not some subregion byusing javas matchermatch() this commit fixes that by usingmatcherfind();
1914;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;check integrity edition check implemented;#1912 implemented a check for the field edition. the check differentiates between bibtex and biblatex mode of the database. -   -   -  manually tested changed features in running jabref;;0;track peak task memory usage;;"this should be recorded in operatorstats and rolled up into pipelinestats taskstats stagestats and querystats || i am looking into this task || @martinthi! i am still doing the set up in the meantime can you explain more about the requirements of this task as well as how to test? presto tracks the amount of memory requested by operators (joins aggregations sort etc) but it only reports the currently allocated amount when an operator finishes it gives up its reservation and the value drops to 0 this metric can be seen via the coordinator ui under ""memory"" its also available via the query stats url (/v1/query/<queryid>) as ""totalmemoryreservation"" what wed like is to also track the peak memory usage for these components throughout the query execution it might not be trivial to roll up the peak memory to the driver pipeline task stage etc so alternatively we could track and report the cumulative amount of memory reserved || xinfb is not working on it any more i am claiming this task || returning this task || im claiming this task || this is being implemented in  || ";;;;0;1;;
1914;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;check integrity edition check implemented;#1912 implemented a check for the field edition. the check differentiates between bibtex and biblatex mode of the database. -   -   -  manually tested changed features in running jabref;;0;support for context in eventbus;let me start explaining the problem through my use-case:i have a set of pojo classes generated with `xjc` from xml schemas i would like to use these classes as events so that i can do `eventbuspost(somereceivedxmlevent)` the problem is that processing these events requires information (eg network connection from which `somereceivedxmlevent` was received) that is independent of `somereceivedxmlevent` itself and hence not part of either its xml schema or pojo signature eventbus is based on the premise that event objects contain all the information required to process them while this is a good assumption for hand-written event classes that can be extended anytime it does not work for event classes for which no control over the source code is given generics would normally help here but type erasure gets in the wayproposed solution:1) extend `eventbus` object with method `eventbuspost(event context)`2) extend the `annotatedsubscriberfinder` to accept methods with a second parameter specifying required context type3) when searching the subscribers to be notified we have two cases a) an `eventbuspost(event)` - would match only subscribers that are context independentb) an `eventbuspost(event context)` - would match subscribers that are context independent and those that are context dependent and are compatible with the provided context;it seems that alternatively you could wrap events the idea would be to post and receive `contextualevent` instances which provide both a jaxb object and the associated context any reason that would not work for your use case? || if i wrap all my events in a `contextualevent` then every subscriber will have to implement additional logic to filter the events it cares for this is additional boilerplate in the code and makes runtime much slower as all contextualevent subscribers (and i will have only contextualevent subscribers) will be run  || fair points if indeed an api extension is inevitable let me toss in an alternative avenue of investigation (didnt think long and hard about this but the idea should come across): what if `eventbus` would allow greater control over the registration and dispatch logic?making `subscriberfindingstrategy` public could be part of the solution though it would not be enough by itself one would also need to be able to inject a dispatch strategy this would require more fancy logic on the users side (in you case perhaps a custom annotation on `@subscribe` methods that identifies the type of event expected to be wrapped inside a given `contextualevent` along with strategy implementations that understand said annotation) but on the plus side this approach might also cater to completely different use casesreally just thinking out loud here || allowing extension of certain api parts (eg `subscriberfindingstrategy`) would definitely benefit other use cases as well i dont mind extending the class to meet my own needs and i guess my scenario is not exactly typical || were unlikely to add significant features to eventbus anymore ||;;;;0;1;;
1928;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;support citationstyles;implements #119.  the user can choose multiple citationstyles which he can cycle threw in the preview panel (forward with <kbd>f9</kbd>  backwards <kbd>shift</kbd> + <kbd>f9</kbd>  both are in the context menu and the menu bar) . as discussed i removed the 2nd preview. ### preview before:  ![preview_before]( ### preview after:  ![preview_after]( ### preferences before:  ![preferences_before]( ### preferences after:  ![preferences_after](  i didn t include the localization (other the english) on purpose because they create unnecessary conflicts when rebasing quite often (i push them when everything else is fine).  the help page has to be updated too. i do that as soon as this pr is merged. -   -   -   () -  -   ( [](  warning: currently i read the available citationstyles at runtime. i had problems reading them from the gradle dependency thus currently they are only found when jabref is started from the jar.;;0;junit 5 strict stubs check should not suppress the regular test failure;if the test fails mockitoextension should not check for strict stubs at the end of the test because the possible unnecessarystubbingexception will end up as a suppressed exception on the tests initial failure;good idea will review shortly thank you for the contribution! ||  merging 1928 ` ;;;;1;1;fortified an assertion;
1928;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;support citationstyles;implements #119.  the user can choose multiple citationstyles which he can cycle threw in the preview panel (forward with <kbd>f9</kbd>  backwards <kbd>shift</kbd> + <kbd>f9</kbd>  both are in the context menu and the menu bar) . as discussed i removed the 2nd preview. ### preview before:  ![preview_before]( ### preview after:  ![preview_after]( ### preferences before:  ![preferences_before]( ### preferences after:  ![preferences_after](  i didn t include the localization (other the english) on purpose because they create unnecessary conflicts when rebasing quite often (i push them when everything else is fine).  the help page has to be updated too. i do that as soon as this pr is merged. -   -   -   () -  -   ( [](  warning: currently i read the available citationstyles at runtime. i had problems reading them from the gradle dependency thus currently they are only found when jabref is started from the jar.;;0;update 082 release notes;; ;;;;0;1;;
1928;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;support citationstyles;implements #119.  the user can choose multiple citationstyles which he can cycle threw in the preview panel (forward with <kbd>f9</kbd>  backwards <kbd>shift</kbd> + <kbd>f9</kbd>  both are in the context menu and the menu bar) . as discussed i removed the 2nd preview. ### preview before:  ![preview_before]( ### preview after:  ![preview_after]( ### preferences before:  ![preferences_before]( ### preferences after:  ![preferences_after](  i didn t include the localization (other the english) on purpose because they create unnecessary conflicts when rebasing quite often (i push them when everything else is fine).  the help page has to be updated too. i do that as soon as this pr is merged. -   -   -   () -  -   ( [](  warning: currently i read the available citationstyles at runtime. i had problems reading them from the gradle dependency thus currently they are only found when jabref is started from the jar.;;0;add onbackpressurebuffer with capacity;the operator takes an optional capacity for the buffer and a callbackthat will be invoked if the buffer fills up along with amissingbackpressureexception in the observables onerror;@benjchristensen this should fix the bug (it was in the test actually which i was overcomplicating) it passes the full suite locally i squashed the improvements you added earlier on the same commit let me know if you prefer me to separate them  thank you! (and this time all tests are passing so looks like its all happy now) ||;;;;1;1;add onbackpressurebuffer with capacitythe operator takes an optional capacity for the buffer and a callbackthat will be invoked if the buffer fills up along with amissingbackpressureexception in the observables onerror;
1931;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;export number field as number if not patent or issue in office 07 xml;add : export key field (not to be confused with bibtexkey field)   add test for custom entry type and key field  refs #1851   documentation has to be updated.     --> -   -   -   () -  -   ( []()?);;0;add @checkreturnvalue for a few specific methods;- `listsreverse`- `futuresimmediate*future`- `*filter`see  trick will be cleaning up google-internal callers of those methods so that we dont break builds;"fyi im tackling listsreverse() internally || ok never mind i got bored and im doing all of them || we could get a small bit of value out of also doing these methods too:- `iterablestransform` (3 bugs 2 ambiguous)- `collections2transform` (1 bug)- `liststransform` (1 bug 1 harmless call) || - `iterableselementsequal` (2 bugs)- `futuressuccessfulaslist` (1 bug 1 probably harmless)after that were scraping the bottom of the barrel (at least for the classes that i checked): lots of ""sketchy but not really buggy"" code like people calling `iteratorssize` to exhaust an iterator or people making harmless no-op calls to the no-arg or varargs `listsnewarraylist` and other factory methods || - `stringsnulltoempty` (1 bug 1 harmless maybe others that my search didnt find) || - futuresallaslist/successfulaslist (bug 17205818)- filter() and transform() methods (bug 9072648) || as best i can tell these are all done except for `collections2transform` || `collections2` has `@checkreturnvalue` on the entire class so this can probably be closed? || oops thanks :) || ";;;;0;1;;
1931;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;export number field as number if not patent or issue in office 07 xml;add : export key field (not to be confused with bibtexkey field)   add test for custom entry type and key field  refs #1851   documentation has to be updated.     --> -   -   -   () -  -   ( []()?);;0;update report message to use any() instead of anyobject();because `anyobject()` has already been deprecated it would be better to push to use `any()` insteadthanks for the contribution this is awesome> as you may have read project members have somehow an opinionated view on what and how should be> mockito eg we dont want mockito to be a feature bloat> there may be a thorough review with feedback -> code change loop> > which branch : > - on mockito 3x make your pull request target `release/3x`> - on mockito 2x make your pull request target `release/2x` (2x is in maintenance mode)>> _this block can be removed_> _something wrong in the template fix it here `github/pull_request_templatemd`check list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_; ;;;;1;1;update report message to use any()because anyobject() has already been deprecated it would be better to push to use any();
1931;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;export number field as number if not patent or issue in office 07 xml;add : export key field (not to be confused with bibtexkey field)   add test for custom entry type and key field  refs #1851   documentation has to be updated.     --> -   -   -   () -  -   ( []()?);;0;using distinct on non-comparable types fails in execution engine;"the analyzer allows queries to specify ""distinct"" on non comparable types which may fail in the execution engine check for this in analysis and fail the query early with the correct error message ";working on it   by #1956  ||;;;;0;1;;
1931;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;export number field as number if not patent or issue in office 07 xml;add : export key field (not to be confused with bibtexkey field)   add test for custom entry type and key field  refs #1851   documentation has to be updated.     --> -   -   -   () -  -   ( []()?);;0;abstractonsubscribe to help implement backpressure-respecting;observablesproposed implementation for #1930 see tests for use cases;great stuff! i knocked up some backpressure support a couple of days ago for rxjavastring and was quite bothered by the dry aspect this will make implementing `onsubscribe` way easier let alone getting backpressure support for free  just so i remember an unrelated test failure:rxschedulerstrampolineschedulertest > testsequenceofdelayedactions failed    orgmockitoexceptionsverificationverificationinorderfailure:     verification in order failure    wanted but not invoked:    action0call()    -> at rxschedulersabstractschedulerteststestsequenceofdelayedactions(abstractschedulertestsjava:220)    wanted anywhere after following interaction:    action0call()    -> at rxschedulerssleepingactioncall(sleepingactionjava:53)i wonder if this is the queue capacity bug of the jctools queues we adapted || few enhancement options:- subscriptionstate could be a producer as well no need for separate class- there is no point in refcounting a null custom state and thus overhead could be reducedin addition there is a potential bug when a next call doesnt produce an event nor does it unsubscribe with backpressure present this may stop producing altogether without backpressure it may loop indefinitely this comes up whne phasing is needed by the state machine the programmer implements so either we detect phase change but no events we just loop again or we throw an exception stating the lack of event emissions or explicit unsubscription || can you give an example for the method`abstractonsubscribeonsubscribe(subscriber<? super t> subscriber)`where an overriding implementation uses the subscriber? || the subscriber is not accessible in next by default to make sure developers only interact with the abstraction but there might be a case you somehow need the subscriber or you need to add some things to unsubscribe if downstream unsubscribes that might be a schedulerworker another subscriber to another observable now with the lambda convenience cases i just forgot about this by accident ill make the fixes in a day || re the potential bug what about making `next` even simpler by not including a reference to the subscriber (or the abstraction) at all:``` javaoptional<t> next(s state)```the `iterable<t>` use case would look like:``` java@overridepublic optional<t> next(iterator<t> state) {    if (statehasnext())        return optionalof(statenext())    else        return optionalabsent()}``` || had another look at your use cases and i see that we would have less flexibility like with calling `oncomplete` straight after the `itnext` call in your `iterator<t>` example nevertheless it might be an attractive simplification in a class like `abstractonsubscribesimple` || abstractiterable doesnt seem to give the possibility to have custom state per iterator() calls so i wanted to work around that your iterator example has some limitations namely you can only produce one response per call and you need to wrap/unwrap things which leads to really unnecessary gcwhat ive said about free backpressure with abstractiterable is still true if you can express your iterative computation with it then there is no need to use aos || this looks really useful and the docs in the code are great would you mind rebasing the commits since this is brand new stuff and could be cleanly committed as a single commit?thank you for marking it as experimental as it would be good to get feedback and allow changes before we commit to itis there anything we can learn from generators? (see  @headinthebox as i think it would be good to have your input on this  || on my todo! || please ignore my previous comments i just misunderstood the meaning of `phase` || > is there anything we can learn from generators?without language support you are at a loss || seems like a useful addition i agree about making it available as experimental so we can evolve it || > without language support you are at a lossi know we cant do what real generator implementations do with `yield` are the signatures of generators completely affected by the use of `yield` and thus not at all useful to this exploration? || > seems like a useful addition i agree about making it available as experimental so we can evolve itgood glad there is alignment im going to merge #1946 so we can start using and iterating  ||;;;;0;1;;
1934;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removed external dependency in logic;an alternative to #1924 : hard coded  ps  and  pdf  as file type names.  still some methods that can be removed in  externalfiletype  (the original thing done in #1924 .  i created three  gui  packages: -  externalfiletypes  for things related to  externalfiletype  -  externalfiles  for things (primarily) related to the actual files -  filelist  for things related to  filelist  -  ;;0;feature request: a new callback for receiving status updates before callback completion;there are cases where the actual work done takes substantial amount of time and the consumer might want to receive any progress updates if possible it is fine for the task to get failed or completed after zero or more updates i m expecting a new callback which could be like:public interface newcallback<v w> extends futurecallback<v> {    void onupdate(w w)};unfortunately this would require coordination between the future execution and the callback system (as currently implemented futurecallbacks are processed at the end of the execution of the future so itll be too late to post updates to newcallback)if you need something like this i would suggest registering a listener or callback in the normal execution flow of the long process youre looking to get updates on and then adding a normal `addcallback` to be notified when the long process future is done ||;;;;0;1;;
1934;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removed external dependency in logic;an alternative to #1924 : hard coded  ps  and  pdf  as file type names.  still some methods that can be removed in  externalfiletype  (the original thing done in #1924 .  i created three  gui  packages: -  externalfiletypes  for things related to  externalfiletype  -  externalfiles  for things (primarily) related to the actual files -  filelist  for things related to  filelist  -  ;;0;use google-java-format in spotless;google-java-format is an open source formatter [1] it automatically formatssource code based on the google java stylethe mockito source code to a very large extent already adheres to this styleguide while this pr in itself is large many of the changes are related tostring formatting and nested method calls most notably google-java-formatis an improvement over the current formatting strategy in that:1 it handles comment formatting (eg spacing between comments)2 it handles nested method calls you can see the difference inour usage of the bytebuddy api which is now more consistent3 it enforces the max-line lengthit essentially automates all of the styling rules we list in such for new contributors it should be a lot easier (and less scary)to contribute to mockito as they no longer have to be concerned aboutformatting hopefully this once again lowers the bar for external contributorswho want to help the project but would otherwise feel overwhelmed bythe rules we have to adhere to (if we wouldnt have these rules it wouldbe a lot harder for us to maintain a consistent and maintainable codebase)the only interesting changes in this pr are those in `buildgradle` allother changes were auto-generated by running `/gradlew spotlessapply`note that i disabled the formatting of javadoc as i think we should keep formattingthat ourselves we normally put a lot of time and effort in our javadoc and changingthat all at once seems like the wrong decision at this point in time[1]: https://githubcom/google/google-java-format;ah i see gjf requires java 11 to run but we run on older versions of java we could configure travis to only run the check on java 11 since our formatting is not java-version specific || @mockitoguy @raphw @bric3 do you have any objections/thoughts on this pr? if you dont have any i can polish the pr and make sure travis happy and all || thanks @mockitoguy and @bric3 for the review i will relay the feedback about the formatting output to the google-java-format team and get them take a look since on the overall this change is a plus i think we can merge without the fixes but i will make sure they will be followed up on i agree with your comments so we can probably make a good case for fixing 😄 i will address the travis changes in a separate pr as that requires some cleanup there as well then i will rebase this pr and regenerate the formatting changesthanks for the quick response after the ping greatly appreciated!  ||   merging 1934 ;;;;1;1;fix test that puts 2 statements on the same line;
1934;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removed external dependency in logic;an alternative to #1924 : hard coded  ps  and  pdf  as file type names.  still some methods that can be removed in  externalfiletype  (the original thing done in #1924 .  i created three  gui  packages: -  externalfiletypes  for things related to  externalfiletype  -  externalfiles  for things (primarily) related to the actual files -  filelist  for things related to  filelist  -  ;;0;count star on sysnode table returns error;this is in version 077 not sure if it has been  since```presto:default> select count(*) from sysnodequery 20141108_143132_00003_rrx9x failed 2 nodes 1 total 0 done (000%)cpu time: 00s total     0 rows/s     0b/s 0% activeper node: 00 parallelism     0 rows/s     0b/sparallelism: 000:00 [0 rows 0b] [0 rows/s 0b/s]query 20141108_143132_00003_rrx9x failed: must provide at least one columnjavalangillegalargumentexception: must provide at least one column    at comgooglecommonbasepreconditionscheckargument(preconditionsjava:125)    at comfacebookprestoconnectorsystemsystemrecordsetprovidergetrecordset(systemrecordsetproviderjava:55)    at comfacebookprestosplitrecordpagesourceprovidercreatepagesource(recordpagesourceproviderjava:40)    at comfacebookprestosplitpagesourcemanagercreatepagesource(pagesourcemanagerjava:56)    at comfacebookprestooperatortablescanoperatoraddsplit(tablescanoperatorjava:150)    at comfacebookprestooperatordriverprocessnewsource(driverjava:252)    at comfacebookprestooperatordriverprocessnewsources(driverjava:217)    at comfacebookprestooperatordriveraccess$300(driverjava:53)    at comfacebookprestooperatordriver$driverlockresultclose(driverjava:501)    at comfacebookprestooperatordriverupdatesource(driverjava:195)    at comfacebookprestoexecutionsqltaskexecution$driversplitrunnerfactorycreatedriver(sqltaskexecutionjava:447)    at comfacebookprestoexecutionsqltaskexecution$driversplitrunnerfactoryaccess$1500(sqltaskexecutionjava:414)    at comfacebookprestoexecutionsqltaskexecution$driversplitrunnerprocessfor(sqltaskexecutionjava:535)    at comfacebookprestoexecutiontaskexecutor$prioritizedsplitrunnerprocess(taskexecutorjava:444)    at comfacebookprestoexecutiontaskexecutor$runnerrun(taskexecutorjava:578)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1145)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:615)    at javalangthreadrun(threadjava:744)```;@snarayananqubole i still see this problem with the latest master || i see this also ||;;;;0;1;;
1934;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;removed external dependency in logic;an alternative to #1924 : hard coded  ps  and  pdf  as file type names.  still some methods that can be removed in  externalfiletype  (the original thing done in #1924 .  i created three  gui  packages: -  externalfiletypes  for things related to  externalfiletype  -  externalfiles  for things (primarily) related to the actual files -  filelist  for things related to  filelist  -  ;;0;request hook;adding the ability to track `request(n)` events with the rxjavadebug hooksand a fix for #1933;there is a subtle anomaly regarding sending oncompleted after unsubscription when window() take and merge() is used because a terminating upstream will never send oncompleted so the merge itself will never complete see #1880 so since by contract unsubscription is best effort receiving a few events after the fact is perfectly okay and the relevant operators such as take will take the necessary steps to not let things slip byi also wanted to mention that maybe a diagnostic operator would be better: you could then check request behavior at specific locations and not deal with all irrelevant rest || @akarnokd this is a completely synchronous test case so the best effort should be the expected behavior  point operators are great when you already know where the problem is ||;;;;0;1;;
1938;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;update javadoc - remove deprecated class;the javadoc is misleading - pointing to the deprecated class returnselementsof that should later be internal or moved;;0;need a maps class method that receives iterator<v> values and a function<? super v k> keyfunction an returns a map<k iterable<v>>;as the description says i need a way to group the received iterator based on what the function returns as k valueis not hard to do and i can even work on it it could be like method [maps#uniqueindex](http://docsguava-librariesgooglecodecom/git/javadoc/com/google/common/collect/mapshtml#uniqueindex%28javautiliterator%20comgooglecommonbasefunction%29);are you looking for [multimapsindex]( can call `asmap()` on the result to get a `immutablemap<kcollection<v>>` || thats exactly what i wanted thank you so muchwe can close this issue ||;;;;0;1;;
1938;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;update javadoc - remove deprecated class;the javadoc is misleading - pointing to the deprecated class returnselementsof that should later be internal or moved;;0;update javadoc - remove deprecated class;the javadoc is misleading - pointing to the deprecated class returnselementsof that should later be internal or moved;;;;;1;1;update javadoc - remove deprecated classthe javadoc is misleading - pointing to the deprecated class returnselementsof that should later be internal or moved;
1938;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;update javadoc - remove deprecated class;the javadoc is misleading - pointing to the deprecated class returnselementsof that should later be internal or moved;;0;support iam roles in prestos3filesystem;currently `prestos3filesystem` reads aws credentials from hadoop configuration and because of that we need to put our aws keys in core-sitexml ideally we dont want to store our keys in any config file on the cluster and we want to use iam roles instead of keys ( this pr brings iam role support to `prestos3filesystem` the `prestos3filesystem` first checks the credentials in hadoop configuration as usual and fallbacks to the aws ec2 metadata service if credentials are not found we have verified this patch in our cluster;closing this one as #1948 supersedes this pr ||;;;;0;1;;
1938;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;update javadoc - remove deprecated class;the javadoc is misleading - pointing to the deprecated class returnselementsof that should later be internal or moved;;1935.0;any/all should not unsubscribe downstream;should  #1935 when in doubt see `take`;thanks ill give this a go and verify it fixes it for meothers that look like they may be susceptible:operatoralldebouncewithselectoroperatorskiptimedoperatorskipuntil || thanks for the other cases ill add the fixes for them in this pr || i find `debouncewithselector` `operatorskiptimed` and `operatorskipuntil` suspicious but since these dont just return a single value i dont know what effect it has on backpressure if i break the chain the way any or all does while we are at it i think any and all should request(longmax_value) regardless of the downstream because they spin on a single flag and thus can handle any throughput the current version request 1-by-1 which adds large overhead || >  i think any and all should request(longmax_value) regardless of the downstream because they spin on a single flag and thus can handle any throughputagreed > since these dont just return a single value i dont know what effect it has on backpressure if i break the chain the way any or all doeswe would have to manually compose through the backpressure if we break the chain why though should we need to decouple on those as they shouldnt need to unsubscribe early? if we are we probably shouldnt be having them chained is far more efficient so we dont want to break the chain if we dont need to  || > we would have to manually compose through the backpressure if we break the chain why though should we need to decouple on those as they shouldnt need to unsubscribe early? if we are we probably shouldnt be having them chained is far more efficient so we dont want to break the chain if we dont need tothey unsubscribe themselves in `oncompleted()` and `onerror()` and may prevent the async use of the preceding `onnext()` in other words if i manually schedule a task for each `onnext` event and add the cancellation subscription to the downstream subscriber the oncompleted() in these operators will cancel that task (observeon was  a couple of times to make this not a problem) || but why do they need to `unsubscribe` in `oncomplete` and `onerror`? those are terminal events we shouldnt need to unsubscribe as that will happen automatically after the terminal event is emitted  || because they need to terminate a companion observable or timer when the main terminates || i know they need to cleanup but why does it need to happen eagerly right then? the contract is that after it emits `onerror` or `oncomplete` it will eventually be unsubscribed after all downstream work is done so why do we need to call `unsubscribe` eagerly? if i remove those `unsubscribe` calls no tests break and `unsubscribe` will still end up being called for all three it seems there is no need to be eager as these do not terminate their origin early cleanup of their companion observable can happen eager if they want (such as `skipuntil`) but that is not part of the chain nor does it require unsubscribing the entire operator  || merging as this pr is fine the discussion is about other things  ||;operatorany unsubscribe issue;"operatorany (eg used in observableisempty) does an unsubscribe after seeing that there are any items in the observable its subscribing to to avoid needing to generate un-needed items unfortunately it seems to be unsubscribing subscribing observables as well which can cause it to breakhere is an example this code:```object operatoranyissue extends app {  def debug(message: string value: any): unit  printf(s""%30s %-14s $value\n"" ""["" + threadcurrentthread()getname + ""]"" message)  def sleepthengenerateinverse(n: boolean)()  {    debug(""generating"" !n)    threadsleep(800)    debug(""sending"" !n)    n  }  observablefrom(1 to 5)    doonnext(debug(""generated"" _))    doonunsubscribe(debug(""unsubscribed generator"" """"))    isempty // to fix change this line to: toseqmap(_isempty)    doonnext(debug(""is empty"" _))    flatmap(i > observabledefer { observablejust(sleepthengenerateinverse(i)) }subscribeon(ioscheduler()))    doonunsubscribe(debug(""unsubscribed"" """"))    subscribe(debug(""received"" _))  threadsleep(10000)}```outputs the following - the sleepthengenerateinverse function gets cut off half way through:```                        [main] generated      1                        [main] is empty       false                        [main] unsubscribed      [rxcachedthreadscheduler-1] generating     true                        [main] unsubscribed generator ```changing the isempty line to toseqmap(_isempty) results in the following which is the expected behaviour:```                        [main] generated      1                        [main] generated      2                        [main] generated      3                        [main] generated      4                        [main] generated      5                        [main] is empty       false   [rxcachedthreadscheduler-1] generating     true   [rxcachedthreadscheduler-1] sending        true   [rxcachedthreadscheduler-1] received       true   [rxcachedthreadscheduler-1] unsubscribed      [rxcachedthreadscheduler-1] unsubscribed generator ```";hi and thanks for the report if you can try the fixes in pr #1938 and see if it works for you as well || with the pr i get:```                        [main] generated      1                        [main] is empty       false                        [main] unsubscribed generator    [rxcachedthreadscheduler-1] generating     true   [rxcachedthreadscheduler-1] sending        true   [rxcachedthreadscheduler-1] received       false   [rxcachedthreadscheduler-1] unsubscribed   ```which is correct it would be great if this can be included in 103 || the fix should be in 104+ thanks for reporting ||;1;0; operatorall unsubscribing downstream;
1942;0;1;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;mods importer;regarding: #1920   adds an importer for the mods (xml) format. the importer is written with a jaxb parser. details on the format and the newest xml schema can be found [here]( i ve used the newest schema (version 3.6). -   -   -  manually tested changed features in running jabref;;0;line comment on requiring java 6;please see  java 6 available?if it is should that comment be removed?should the method be removed? (it is private and only used in a single place);i think youre right seems like just the reason we left this comment thatsaid theres probably no hurry to do thison sun jan 11 2015 at 10:28 pm bernardo sulzbach <notifications@githubcom> wrote:> please see>  > > isnt java 6 available?> if it is should that comment be removed?> should the method be removed? (it is private and only used in a single> place)> > —> reply to this email directly or view it on github>  kevin bourrillion | java librarian | google inc | googlecom || thank you for your answercan something like this be merged? || we actually need to do this for all of the primitive utility classes in cgcommonprimitives im submitting a fix internally and itll get mirrored out within the next few days thanks for finding this! || glad i could help || maybe [this]( is also of interest || actuallyas it turns out we cant fix this quite yet because the methods dont exist in gwt 261 (they do in gwt 270) so we cant fix this until we upgrade to gwt 270 ||;;;;0;1;;
1942;0;1;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;mods importer;regarding: #1920   adds an importer for the mods (xml) format. the importer is written with a jaxb parser. details on the format and the newest xml schema can be found [here]( i ve used the newest schema (version 3.6). -   -   -  manually tested changed features in running jabref;;0;add queries that fail before starting to expiration queue;this was a bug introduced in https://githubcom/facebook/presto/pull/1917;looks good  ||;;;;0;1;;
1942;0;1;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;mods importer;regarding: #1920   adds an importer for the mods (xml) format. the importer is written with a jaxb parser. details on the format and the newest xml schema can be found [here]( i ve used the newest schema (version 3.6). -   -   -  manually tested changed features in running jabref;;0;operatormerge does not request enough #1941;looks to me that an inner request count is needed and tracked so that more can be requested from the inner observable if required review from anyone familiar with `operatormerge` very welcome as im not that familiar with its current incarnation and its a tricky place!just one unit test included but i imagine more would be nice;ci build failure looks to be unrelated: #1703  || more changes to come on this and i think i can make the unit test deterministically fail on the existing code base  || abandoning this pr because requests to the innersubscriber must be coordinated by the mergesubscriber ||;;;;0;1;;
1942;0;1;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;mods importer;regarding: #1920   adds an importer for the mods (xml) format. the importer is written with a jaxb parser. details on the format and the newest xml schema can be found [here]( i ve used the newest schema (version 3.6). -   -   -  manually tested changed features in running jabref;;189.0;1898 : return mock name from tostring method for deep stub mocks;return mock name from tostring for deep stub mocks it was previously returning null1898; merging 1942 ;compatibility of bddmockitothen() with assertj and catch-exception;"mockitos `bddmockitothen()` clashes with assertjs `bddassertionsthen()` and catch-exceptions `bddcatchexceptionthen()` meaning that in a same test class it is not possible to use bdd style to assert simultaneously:- a mocks behaviour (bddmockito: `then(dependency)delete(1)`)- a return value (bddassertions: `then(result)isequalto(""value"")`)- an exception throw (bddcatchexception: `then(caughtexception())isinstanceof(blahexceptionclass)`)it is not clear which library exactly could resolve this issue but currently this conflict reduces the usability of all three of them if they are all needed within a same test class then static import cannot be used and even when used in separate test classes the developer can get quite easily confused as to which static import is required";"correction > it is not possible to use bdd style to assert simultaneously **when using static imports**_catch-exception_ lib will no more be updated as stated by his author then i dont see any reasonable way to fix this in any lib as they are not coupled and they have no reason to we wont remove or rename this api `bddmockitothen` and id rather not introduce too many aliasesin the mean time the only sensible thing to do would be to create a class that can serve as an api dispatcher in pseudo code something like:``` javabdddispatcher {     assertjthen()    thenverify()    }``` || > catch-exception lib will no more be updated as stated by his authorcould you show where this is stated?  is currently active or what system should be used instead to test exceptions in bdd style?> in the mean time the only sensible thing to do would be to create a class that can serve as an api dispatcherwhat do you mean by in the meantime? what is the long-term solution to cleanly test mocks exceptions and return values in bdd style? `assertjthen` and `thenverify` are quite less readable than `then` and this places the maintenance burden on the developermaybe i will try the spock library to avoid these limitations || > > catch-exception lib will no more be updated as stated by his author> > could you show where this is stated?  is currently active or what system should be used instead to test exceptions in bdd style?i remember i saw it at some point last year on gc at their old home :  but it seem they have changed their plan i didnt even know they migrated to gh actually i prefer assertj for assertions with version 200 theres nifty api on that matter> > in the mean time the only sensible thing to do would be to create a class that can serve as an api dispatcher> > what do you mean by in the meantime?i mean that until mockito team reach consensus on this api change this issue is on hold> what is the long-term solution to cleanly test mocks exceptions and return values in bdd style?its probably a question of taste but i dont see any clarity problem if not using _static imports_ note that the little pseudo code is just random ideas but this can of course be renamed according to your taste maybe asking on the mockito mailing list can help on that matterspock is indeed a great tool i dont know they integrate stuff still if you have feedback im interested || im a guy from catch-exception team :) i would recommend to use `bddassertionsthen` instead of `bddcatchexceptionthen` this combo works fine for java6 and java7 `bddcatchexceptionthen` is here only for compatibility with java8<del>java8 has some problem with generics (bug? or feature) and do not compile i would recommend using assertj `bddassertionsthenthrownby` alone (without catch-exception)</del>issue with java8 is  in latest catch-exception `bddcatchexceptionthen` is deprecated now use `bddassertionsthen` instead || ok great :) i use java 8 and your solution works so things are settled regarding catch-exception by using the assertj api (`bddassertionsthen()`)now the solution on mockito side should imho be the same: use the assertj api (a nifty api as you mentioned) otherwise we are stuck with using `verify()` instead of `then()should()` to check mock interactions and thus cannot use bdd stylei also tested spock 10 (spock-core + spock-spring) to write unit tests and spring integration tests (including with `mockmvc` and transactions) and i can recommend it so far as it covers everything i asked here and much more with a clean bdd style just need some patience to learn groovy and some things which are approached in a different way (eg ""mocking and stubbing of the same method call has to happen in the same interaction"" cfr  || ok thanks for the feedback @mariuszs and thanks for the feedback on spock too :)> now the solution on mockito side should imho be the same: use the assertj apii dont follow you there the only possible thing to do is to add other _tactical_ aliases @szczepiq and i have mixed feelings about that thats why i proposed to create a custom _dispatch_ api with those tactical aliases eg``` javathen(bike)contains(a_handlebar)thena(person)should(times(2))ride(bike)``` || from my users endpoint i see that catch-exception has been able to resolve this issue of conflicting `then()`s by checking caught exceptions through the assertj api so all im saying is that mockito should imho do the same so that the only `then()` that the user should call would be assertjs (which makes sense it _is_ an assertion api) || indeed but assertj has nothing to do with mocks )its not the role of assertj to know mockito internals to check the interactions also current mockito matchers api is based on hamcrest and for several reason upgrading hamcrest has proven to be a difficult task we now even want to remove the dependency on external framework as much as possible including hamcrest || ";1;0;1898 : return mock name from tostring method for deep stub mocks;
1942;0;1;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;mods importer;regarding: #1920   adds an importer for the mods (xml) format. the importer is written with a jaxb parser. details on the format and the newest xml schema can be found [here]( i ve used the newest schema (version 3.6). -   -   -  manually tested changed features in running jabref;;1898.0;1898 : return mock name from tostring method for deep stub mocks;return mock name from tostring for deep stub mocks it was previously returning null1898; merging 1942 ;returns_deep_stubs override a mocks tostring to `null`;"this example describes the issue:```  @test  public void mockswithdeepstubsreturnnameontostring() {    object proudmock  mockitomock(        objectclass        mockitowithsettings()            name(""im a mock!"")            defaultanswer(mockitoreturns_deep_stubs))    // fails tostring() returns null    assertthat(proudmocktostring())isequalto(""im a mock!"")  }```im experiencing this on 2260 (looking at [returnsdeepstubs]( looks like it hasnt changed much since then)i think tostring should still return the mocks name right now it returns a `null`";;1;0;1898 : return mock name from tostring method for deep stub mocks;
1945;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;[travis] replace jdk 9/10 with 14;9/10 are eol since september 2018. 14 is the currently supported;;0;document default null ordering for ordering;i couldnt find how a `natural()` [`ordering`]( orders `null`s if not calling if `nullsfirst()`/`nullslast()` is not called  didnt give me anything eitherwill the ordering thrown an npe or will it default to `nullsfirst()`? should probably be documentedlet me know if ive missed something;"the link youve included takes me to this""""""returns a serializable ordering that uses the natural order of the values the ordering throws a nullpointerexception when passed a null parameterthe type specification is <c extends comparable> instead of the technically correct <c extends comparable<? super c>> to support legacy types from before java 5""""""which seems to speak to the issue any suggestions for how we could make it better? || ah! thank you for pointing out my blindness ) || ";;;;0;1;;
1945;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;[travis] replace jdk 9/10 with 14;9/10 are eol since september 2018. 14 is the currently supported;;0;[travis] replace jdk 9/10 with 14;9/10 are eol since september 2018 14 is the currently supportedjava version;yeah i am working on resolving the build issue we need to upgrade our gradle version sadly that turns out to be a whole rabbithole but i think i am close || @timvdlippe it looks like we also have to use errorprone 240 since this is the first version which actually supports java 14> task :compilejava/home/travis/build/mockito/mockito/src/main/java/org/mockito/invocation/invocationonmockjava  error: an unhandled exception was thrown by the error prone static analysis plugin    <t> t getargument(int index)          ^     please report this at  and include the following:     error-prone version: 232     bugpattern: typeparameterunusedinformals     stack trace:     javalangnosuchfielderror: bound  	at comgoogleerrorpronebugpatternstypeparameterunusedinformalsmatchmethod(typeparameterunusedinformalsjava:73)  	at comgoogleerrorpronescannererrorpronescannervisitmethod(errorpronescannerjava:890) || @epeee yes indeed were you able to get gradle working on your machine?! || yes furthermore also the latest travis build ( is failing with the message posted previously || interesting because i was looking at  which is failing for a completely different reason :o || i wonder maybe if the build cache is not working on one job but is working on the other not sure how to diagnose this issue though || oh on the push travis build both tasks failed on the errorprone issue but not the gradle compilation issue so out of 3 tasks only the 1 on the pr build is failing ||  merging 1945 ;;;;1;1;merge branch release/3x into reconfigure-travis;
1945;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;[travis] replace jdk 9/10 with 14;9/10 are eol since september 2018. 14 is the currently supported;;0;fix handling of null collections in unnest;;;;;;0;1;;
1945;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;[travis] replace jdk 9/10 with 14;9/10 are eol since september 2018. 14 is the currently supported;;0;fix the isunsubscribed issue for subscrptionsempty();as per #1943;test? || > test?done ||;;;;0;1;;
1949;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1712 : prepend description to assertionerror thrown in verification;;;0;nullpointertester: allow to override the exception type policy;"nullpointertester already knows the concept of a exceptiontypepolicyhowever the field ""policy"" is always set to a default valuethis patch adds an option to overwrite the policy toallow illegalargumentexceptions it also adds some unit tests";"hmm travis breaks because of an unrelated error:testlargenumberofinsertions(comgooglecommonhashbloomfiltertest): java heap space || apparently _even more_ heap space is necessary see this commit from yesterday: fa24bad4e4ca19c18294062da539cdc78837efa2 || afaict we actually have this already implemented but restricted to @googleinternal ||  maybe it is called ""acceptillegalargumentexception""? that is mentioned in the commit message where the exceptiontypepolicy was extracted (2be342881ace329a9ebdc31990f719301de5f7c0)i found the option to accept illegalargumentexceptions very useful especially for existing code if you can make it non-internally available it would be greatby the way are there any plans to move the nullpointertester from the internal guava-testlib to the exported part of guava? from my experience it is useful for any code base and not limited to guava itself not long ago i introduced a slightly modified version of it at my company (including this illegalargument fix and the  nullable annotation had to be changed) today i was positively surprised that it is now being used all over our code base || @philipp-classen we dont actually consider guava-testlib to be ""internal"" users are free to depend on guava-testlib from their tests we dont want to include the stuff there in the main guava artifact because depending on utilities intended for testing in non-test code isnt something you want to do generally || @cgdecker yes that makes sense to be able to depend on guava-testlib is fine too || 👍 we are using `checkargument(!stringsisnullorempty(xyz))` a lot which is why this addition would be really great i know its called nullpointertester and not preconditionstester or something but if you have it internally could you publish it? :) || marvin isnt it easier to write checkargument(!xyzisempty())?i consider the internal support to be an experiment we entered into underpressure and i dont see any value having coming from it at all is therea rational reason why different apis should throw different exceptions inresponse to null input? could one recognize which type of api should bewhich? i dont think so it comes down to mere developer preference so webenefit from having a single standard instead which weve had for wellover a decadeon sat jan 28 2017 at 4:26 am marvin z <notifications@githubcom> wrote:> 👍 we are using checkargument(!stringsisnullorempty(xyz)) a lot which> is why this addition would be really great i know its called> nullpointertester and not preconditionstester or something but if you have> it internally could you publish it? :)>> —> you are receiving this because you are subscribed to this thread> reply to this email directly view it on github> < or mute> the thread> < >-- kevin bourrillion | java librarian | google inc | googlecom || solid point i agree kevinb9n i guess this should be closed then? || ";;;;0;1;;
1949;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1712 : prepend description to assertionerror thrown in verification;;;0;fix distinct keyword on non-comparable type;solves issue 1931;;;;;0;1;;
1949;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1712 : prepend description to assertionerror thrown in verification;;;0;missingbackpressureexception;when i create  an observable like thisi always get missingbackpressureexceptionand that method works well on 0196```@override    public observable<object> getxxx() {        return observablecreate(new observableonsubscribe<object>() {            @override            public void call(subscriber<? super object> subscriber) {                try {                   for(int ii<100i++){                    subscriberonnext(null)                  }                    subscriberoncompleted()                } catch (exception e) {                    subscriberonerror(e)                }            }        })subscribeon(schedulersio())observeon(androidschedulersmainthread())    }```;you have a fast producer (the observable) which is decoupled due to the `subscribeon`/`observeon` operators from a relatively slow consumer (the observer) also your observable doesnt support backpressure hence the `missingbackpressureexception` you should either change your observable to support backpressure or add operators to calm down the producer the [wiki]( shows some techniques to accomplish this || so i can not to improve it with backpressure subscriber? || what do you mean by backpressure subscriber? || since you mention that your code worked fine with rx version `0196` (which didnt have backpressure support yet) you should be able to go back to the old situation by adding the `onbackpressurebuffer` operator after the `observablecreate` || @georgikhomeriki   thx i got it@benjchristensen  thx  i mean to implement an subscriber  witch can request reactive pull backpressuresorryi didnt fully understand the ‘backpressure’ || yes youll want to implement a subscriber that uses `request` but the source needs to support it the `onbackpressure*` operators are there to add strategies to sources that dont natively support reactive pull ||;;;;0;1;;
1949;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1712 : prepend description to assertionerror thrown in verification;;;1712.0;1712 : prepend description to assertionerror thrown in verification;extended mockitoassertionerror to wrap instance of assertionerror in addition to mockitoassertionerror so that the various possible exceptions thrown for non-matching arguments have description prepended to the message;oh it seems like you need to run `/gradlew spotlessapply` locally to fix the formatting issues || i think you need to rebase on release/3x to pick up the latest changes your spotless configuration locally appears to be out-of-date || are you running `/gradlew spotlessapply`? i can take a look on monday why it is not formatting as expected || thanks tim ive rebased now hopefully should fix the formatting issue just squashed the commits ||  merging 1949 ;"""description"" not printing when verify args dont match";"mockito version 2270i have a test that uses `description` inside a `verify` method the `description` is correctly printing when the test fails because we dont interact with the mock```import static orgmockitomockitodescriptionimport static orgmockitomockitospyimport static orgmockitomockitoverifyimport orgjunittestpublic class exampletest {    @test    public void shouldfailwithdescription() {        dependency dependency  spy(dependencyclass)        systemundertest systemundertest  new systemundertest()        systemundertestdosomething(dependency)        verify(dependency description(""failed to call dosomethingelse""))dosomethingelse(false)    }    static class systemundertest {        void dosomething(dependency dependency) {            // dependencydosomethingelse(true) // <---- test fails because we dont interact with mock        }    }    static class dependency {        void dosomethingelse(boolean value) {            //         }    }}```results in this failure message:```orgmockitoexceptionsbasemockitoassertionerror: failed to call dosomethingelse <---- see our descriptionwanted but not invoked:dependencydosomethingelse(false)-> at comexampleexampletest$dependencydosomethingelse(exampletestjava:28)actually there were zero interactions with this mock```in this case the test failed because there were no interactions with this mock however if we update the sut so that it calls the method with the wrong argument:```public class exampletest {    @test    public void shouldfailwithdescription() {        dependency dependency  spy(dependencyclass)        systemundertest systemundertest  new systemundertest()        systemundertestdosomething(dependency)        verify(dependency description(""failed to call dosomethingelse""))dosomethingelse(false)    }    static class systemundertest {        void dosomething(dependency dependency) {             dependencydosomethingelse(true)  // <---- test fails because we pass wrong args        }    }    static class dependency {        void dosomethingelse(boolean value) {            //         }    }}```the test still fails but this time it **does not include the description**:```argument(s) are different! wanted: <----- we should see descriptiondependencydosomethingelse(false)-> at comexampleexampletest$dependencydosomethingelse(exampletestjava:28)actual invocation has different arguments:dependencydosomethingelse(true)-> at comexampleexampletest$systemundertestdosomething(exampletestjava:21)comparison failure: expected :dependencydosomethingelse(false)actual   :dependencydosomethingelse(true)```";"not pretty but this seems to work if i use a `verificationlistener` and manually log the error:```import static orgmockitomockitodescriptionimport static orgmockitomockitospyimport static orgmockitomockitoverifyimport orgjunittestimport orgmockitomockitoimport orgmockitomockitoframeworkimport orgmockitolistenersverificationlistenerpublic class exampletest {    @test    public void shouldfailwithdescription() {        mockitoframework framework  mockitoframework()        string failuremessage  ""failed to call dosomethingelse""        // not all test failures will print the description so we have to manually log it (        verificationlistener listener  verificationevent -> {            if (verificationeventgetverificationerror() ! null) {                systemoutprintln(""failure: "" + failuremessage)            }        }        frameworkaddlistener(listener)        dependency dependency  spy(dependencyclass)        systemundertest systemundertest  new systemundertest()        systemundertestdosomething(dependency)        verify(dependency description(failuremessage))dosomethingelse(false)        // not sure if we need to remove for next test or if mockito will auto-clear        frameworkremovelistener(listener)    }    static class systemundertest {        void dosomething(dependency dependency) {            dependencydosomethingelse(true)  // <---- test fails because we pass wrong args        }    }    static class dependency {        void dosomethingelse(boolean value) {            //         }    }}```now prints out ```failure: failed to call dosomethingelseargument(s) are different! wanted:dependencydosomethingelse(false)-> at comexampleexampletest$dependencydosomethingelse(exampletestjava:47)actual invocation has different arguments:dependencydosomethingelse(true)-> at comexampleexampletest$systemundertestdosomething(exampletestjava:40)comparison failure: expected :dependencydosomethingelse(false)actual   :dependencydosomethingelse(true)``` || i would like to analyze this issue and eventually provide fixes  || i can also verify the same issue || seems like a bug please submit a pr  the cause of this is that reporterargumentsaredifferent() can return-  an orgmockitoexceptionsverificationopentest4jargumentsaredifferent a subclass of orgopentest4jassertionfailederror- an orgmockitoexceptionsverificationjunitargumentsaredifferent a subclass of junitframeworkcomparisonfailureaccording to whether opentest or junit is available in the classpath neither of these crucially extends mockitoassertionerror hence the exception is not caught in descriptionverify and wrapped in a mockitoassertionerror with the description that would only happen if neither opentest nor junit were in the classpathi think the catch block there should also catch these other exceptions and handle them in a similar way to include the description text || its extending those because of tooling and ide support i believe in intellij idea for example this error is displayed really nice you can see and compare the differences on the arguments || the various argumentsaredifferent exceptions come from orgmockitointernaljunitexceptionfactory which deals solely with that condition the header comment of mockitoassertionerror suggests it should be the base of all verification errors triggered by verify() methods so maybe some refactoring is required i dont know enough to say whether the solution is to handle the exceptions which are actually being thrown or change to throw subclasses of mockitoassertionerror which would then fix the issue || created a pr with a possible solution:  || ";1;0;1712 : fix formatting;
1951;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0; adjusted key bindings according to master branch;recently the keybindings at the master branch have been changed with #1525 . this pr will change the keybindings in the javafx branch accordingly. -   -   -   () -  -   ( []()?);;0;increase test heap to 3g;this pull request is just for testing whether increasing the max heap for tests to 3 gb works and solves the problem with the bloomfilter test thats ooming;;;;;0;1;;
1951;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0; adjusted key bindings according to master branch;recently the keybindings at the master branch have been changed with #1525 . this pr will change the keybindings in the javafx branch accordingly. -   -   -   () -  -   ( []()?);;0;use errorprone 240;in order to get java14 readysee  for details;;;;;1;1;use errorprone 240in order to get java14 readysee  for details;
1951;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0; adjusted key bindings according to master branch;recently the keybindings at the master branch have been changed with #1525 . this pr will change the keybindings in the javafx branch accordingly. -   -   -   () -  -   ( []()?);;0;fix resource leak in query queue;;;;;;0;1;;
1951;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0; adjusted key bindings according to master branch;recently the keybindings at the master branch have been changed with #1525 . this pr will change the keybindings in the javafx branch accordingly. -   -   -   () -  -   ( []()?);;0;remove extraneous request(n) and oncompleted() calls when unsubscribed;added simple checks to make the best effort to not do anything after the down stream has unsubscribed;;;;;1;1;remove extraneous request(n) and oncompleted() calls when unsubscribed;
1953;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;add key shortcuts to search result frame and main table;- <kbd>pos1</kbd> / <kbd>home</kbd> now select the first/last entry in the main table and the search result frame. - <kbd>up</kbd> / <kbd>down</kbd> / <kbd>tab</kbd> / <kbd>shift+tab</kbd> in the search result frame have now the same functionality as in the main  table.;;0;error running project;error:execution failed for task  dexdebug> comandroididecommoninternalloggederrorexception: failed to run command:>     /android sdk/build-tools/2112/dx --dex --no-optimize --output app/build/intermediates/dex/debug --input-listapp/build/intermediates/tmp/dex/debug/inputlisttxt>   error code:>     2>   output:>     unexpected top-level exception:>     comandroiddexdexexception: multiple dex files define lcom/google/common/base/function>         at comandroiddxmergedexmergerreadsortabletypes(dexmergerjava:596)>         at comandroiddxmergedexmergergetsortedtypes(dexmergerjava:554)>         at comandroiddxmergedexmergermergeclassdefs(dexmergerjava:535)>         at comandroiddxmergedexmergermergedexes(dexmergerjava:171)>         at comandroiddxmergedexmergermerge(dexmergerjava:189)>         at comandroiddxcommanddexermainmergelibrarydexbuffers(mainjava:454)>         at comandroiddxcommanddexermainrunmonodex(mainjava:303)>         at comandroiddxcommanddexermainrun(mainjava:246)>         at comandroiddxcommanddexermainmain(mainjava:215)>         at comandroiddxcommandmainmain(mainjava:106);this is not a problem with guava it is a problem with your buildyou have multiple guava jars in your build only use one or better yet use proper gradle dependencies which will take care of including only one and applying version resolution semantics automatically ||;;;;0;1;;
1953;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;add key shortcuts to search result frame and main table;- <kbd>pos1</kbd> / <kbd>home</kbd> now select the first/last entry in the main table and the search result frame. - <kbd>up</kbd> / <kbd>down</kbd> / <kbd>tab</kbd> / <kbd>shift+tab</kbd> in the search result frame have now the same functionality as in the main  table.;;0;fix a confusing typo in subclassing error message;; ;;;;1;1;merge branch release/3x into patch-1;
1953;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;add key shortcuts to search result frame and main table;- <kbd>pos1</kbd> / <kbd>home</kbd> now select the first/last entry in the main table and the search result frame. - <kbd>up</kbd> / <kbd>down</kbd> / <kbd>tab</kbd> / <kbd>shift+tab</kbd> in the search result frame have now the same functionality as in the main  table.;;0;implement min_by aggregation function;;martin you want to merge 1953 into 1958 || @jaytangopen #1953 is the issue we filed originally while #1958 is the pull request that implements it once the pr is merged well close this issue ||;;;;0;1;;
1953;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;add key shortcuts to search result frame and main table;- <kbd>pos1</kbd> / <kbd>home</kbd> now select the first/last entry in the main table and the search result frame. - <kbd>up</kbd> / <kbd>down</kbd> / <kbd>tab</kbd> / <kbd>shift+tab</kbd> in the search result frame have now the same functionality as in the main  table.;;0; timer cast-to-int crash causing incorrect benchmark;the perf benchmark uses a 1 millisecond timer to interfere with the serializing process however the original benchmark used `cast(integerclass)` which just simply throws an error on a long value thus terminating the whole serialization process almost immediately what gets measured is how fast can the whole process restarted to fail againwith the fix i get the following numbers:```benchmark                                        (size)         score  score errorroospnoserializationsinglethreaded                 1  15632242955   576291356roospnoserializationsinglethreaded              1000    143971769     1129048roospnoserializationsinglethreaded           1000000       153444        8286roospserializedsinglestream                        1   7249531621   140827908roospserializedsinglestream                     1000     52595958     1845084roospserializedsinglestream                  1000000        53001        1155roospserializedtwostreamshighlycontended           1    143335868     3643346roospserializedtwostreamshighlycontended        1000      3453108       22826roospserializedtwostreamshighlycontended     1000000         3113        0127roospserializedtwostreamsonefastoneslow            1     99417300     5162370roospserializedtwostreamsonefastoneslow         1000     14857037     7131489roospserializedtwostreamsslightlycontended         1     82621317     1977208roospserializedtwostreamsslightlycontended      1000         1007        0026```clearly the serializedtwostreamsslightlycontended() shows that under a second you can serialize two 1 millisecond sourcesfor comparison with my latest endeavors the custom writerreaderphaser + atomicresizablearray + fast-path queue drain with front check produces the following values:(mode: thrpt samples: 5)```roospserializedsinglestream                        1   4702012445    65485925    6486%roospserializedsinglestream                     1000     43189631     1508771    8212%roospserializedsinglestream                  1000000        42384        1531    7997%roospserializedtwostreamshighlycontended           1    138302278     3530496    9645%roospserializedtwostreamshighlycontended        1000      3085205      118029    8934%roospserializedtwostreamshighlycontended     1000000         3284        0555   10549%roospserializedtwostreamsonefastoneslow            1    100760210     6614699   10135%roospserializedtwostreamsonefastoneslow         1000      1464140     1015858     985%roospserializedtwostreamsslightlycontended         1     82823995      835143   10244%roospserializedtwostreamsslightlycontended      1000         1002        0014```a specialized two-way only striped custom writerreaderphaser produces these:```roosp2serializedsinglestream                        1  4551488444   776149420roosp2serializedsinglestream                     1000    14567954      246157roosp2serializedsinglestream                  1000000       14358        0574roosp2serializedtwostreamshighlycontended           1   165429534     1245682roosp2serializedtwostreamshighlycontended        1000     3383878       62534roosp2serializedtwostreamshighlycontended     1000000        3459        0759roosp2serializedtwostreamsonefastoneslow            1   105104317     1247636roosp2serializedtwostreamsonefastoneslow         1000      265691       90654roosp2serializedtwostreamsslightlycontended         1    82814850     1824645roosp2serializedtwostreamsslightlycontended      1000        1002        0014```im not quite sure why `serializedtwostreamsonefastoneslow` is so low in my versions my guess is that since they are lock-free the timers thread ends up shoveling the events more frequently than in the synchronized case (because it can sleep);thanks :-) ||;;;;1;1; timer cast-to-int crash causing incorrect benchmark;
1955;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;merged master into javafx branch;updating javafx branch to include all the latest changes from the master branch. -   -   -   () -  -   ( []()?);;0;internetdomainname tostring() method unexpected behavior;"tostring() method returns  ""internetdomainname{name**domainortldorwhatever**}"" should not simply return the **domainortldorwhatever**?example code:internetdomainname owner  internetdomainnamefrom(""wwwelmundoes"")topprivatedomain()systemoutprintln(ownertostring())print:internetdomainname{nameelmundoes}what i expect is:elmundoesis it an error? is it an expected behavior?im using: <dependency>    <groupid>comgoogleguava</groupid>    <artifactid>guava</artifactid>    <version>180</version></dependency>thanks!";"tostring() has worked as you describe since 150 do you have an older version of guava on your classpath alongside 180? || (sorry ""worked as you describe"" meaning ""returns the name"") || yeah deleted my comment when i realized storm 092 was overriding with guava 13 pardon me || i have the same problem  storm is overriding guava with a older version is there any solution to this problem? || @chethan is this apache storm or another storm? :) || ";;;;0;1;;
1955;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;merged master into javafx branch;updating javafx branch to include all the latest changes from the master branch. -   -   -   () -  -   ( []()?);;0;fix distinct on non-comparable type;solves issue //githubcom/facebook/presto/issues/1931;can you squash it into a single commit? after that we can merge it thanks!  ||;;;;0;1;;
1955;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;merged master into javafx branch;updating javafx branch to include all the latest changes from the master branch. -   -   -   () -  -   ( []()?);;0;onbackpressurexxx: support for common drain manager & fix for former concurrency bugs;this is quite a complex operator with lots of casesproperties:1) if there arent any elements queued up and nothing is requested but terminal event received emit terminal event and quit2) if there are elements in the queue and a terminal flag and at least the same amount is requested deliver the events and the terminal event3) if more was requested and more became available just after the loop and before the synchronized block keep looping3a) if more was requested but nothing is available or nothing was requested and something is available: quit and let either the onnext or request do the subsequent drain3b) if elements and termination was produced but not requested: quit and let the request do the drain3c) if termination was requested and no elements produced: loop  emit terminal event and quitin table form:```available | terminated | requested | action | reason   yes         yes          yes       loop    can deliver available   yes         yes          false     quit    cant deliver available   yes         no           yes       loop    can deliver available   yes         no           no        quit    cant deliver available   no          yes          yes       loop    loop will deliver termination only and quit   no          yes          no        loop    loop will deliver termination only and quit   no          no           yes       quit    nothing to deliver   no          no           no        quit    nothing to deliver```;this is complicated stuff maybe an (internal) helper class should be created to help with future producer-backpressure-consumer management || i hope the new `backpressuredrainmanager` provides a common abstraction that lets build backpressure-providing operators that themselves do buffering of some sorts || wow this is some non-trivial stuff thanks for tackling this its going to take me a bit to grok it  || anyone else have the time and interest to also do a code review on the concurrency code in this? id appreciate more eyes than my own  || i think this code is good to merge ive asked a variety of clarifying questions that i want to review with you before i merge and release  || re-trigger travis || could you change crlfs to lfs in backpressuredrainmanager?  || > looks aaccept(o) will always return false right?we cant know the consumer way want to terminate after a certain item has been accepted> isterminated terminate terminate are not used could you explain why adding them?this is a base class some operators may need to do something after termination and before calling drain> this is really a complex class so i prefer to keep it as simple as possiblethis is an internal base class to help implement backpressure over an abstract queue the unavoidable complexity is in `drain()` || lgtm now || @benjchristensen your review would be welcome ||;;;;1;1;added value null check;
1955;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;merged master into javafx branch;updating javafx branch to include all the latest changes from the master branch. -   -   -   () -  -   ( []()?);;1013.0;mockito #1013: defines and implements api for static mocking;1013 - allows for static method mocking in mockito;"i thought about it but i am pretty confident that this is what its gonna be! i suggest we put the apis as incubating as we have done with the inline mock maker if we commit to the api even in a separate artifact i think the android folks will still go for it and have a similar expectation on its stabilityyou think a separate artifact would be cleaner? || i mostly prefer a conservative route if we have that option but keeping as incubating is okay with me || i think id prefer the single artifact its fully opt-in and does not touch any existing code i think this way it will be used more and well find out the adoption quicker ||  merging 1955  ";enable mocking static methods in mockito;# static methods mocking with mockitothis is a placeholder ticket for enabling mocking static methods in mockito example action items that are totally negotiable and can ran in parallel were looking for someone who can lead this effort-  research + discuss whether it is a good idea to enable static methods mocking in mockito the theory is that it is useful for legacy code which is most code in the world-  research on how other mocking frameworks do that and whether it is considered useful feature for their users-  design and present for discussion an api for static mocking (slightly relevant ticket: #643)-  work with @raphw / bytebuddy to come up with hacky prototype (the hackier the better!)-  mold the prototype with the api remove enough rough edges so that the feature is good enough for incubating rollout-  ship it!;"i am torn on this one if we provide this possibility we might invite developers into bad practices every time a developer uses this feature it should be very explicit that it is bad practice imo would it be possible to come up with a solution that is clear on this front but still allows the developer to opt-in? || great feedback thats the first thing to figure out when working on this ticket :) || the way i saw mocking of static methods for myself was to only mock calls to static methods that happen within a mock this would be useful for example for implementing spies in a situation like:```javaclass foo {  string bar() { return utilmakestring() }}```with mockito i would like to see something like:```javafoo foo  spy(new foo())doreturn(""foo"")when(foo)invokesstatic(utilclass)makestring()assertthat(foobar())isequalto(""foo"")```what do you think? as for a hack i am missing a component in byte buddy which i was supposed to write for a customer at some point what did however not pull through i am not currently in a position to spend so much time to build this component due to my personal situation but please prototype away i think the api and spec work is crucial to make this a success || great feedback! thank you rafael for sharing your thoughtsis the component you mentioned a lot of work in bytebuddy? is this something that we can ask the community to help out or youre the best person to take on?id rather see more robust api but your api idea is certainly workable mocking statics should be rare and our api should be optimized for common use cases and not edge/rare cases we can always iterate based on feedback :)heres my preference as of today:```java//setupmockstatic(utilclass)//thendoanswer()when(() -> utilfoo())when(utilfoo())thenreturn(""foo"")verify(() -> utilfoo())verify(never() () -> utilfoo())```if we choose to support mocking static methods id rather offer api that is robust enough to support all kinds of use cases i like when tools are separated from policies and are opinionated but not dogmatic :) if we think that mocking static is disgusting we can ship it in a different jar called ""mockito-for-crappy-code"" loosely following @timvdlippe ideathe main use cases for mocking statics i see are: - legacy code (i really really want to write a unit test but i dont dare to change some ancient ugly code) - dealing with some awkward static 3rd party apis this scenario is currently workable by developing some injectable api layer on top of 3rd party statics however the workaround could be cumbersome and can spoil the clarity of codebasewithout addressing above 2 use cases developers around the world will be looking for help in tools like powermockito and suchthe biggest downside of offering static mocking is making it too easy to test crappy procedural code full of static methods we would remove a motivation to refactor the code into clean oo / di || should we also send out a tweet to gather some community insights? || if this feature uses the java instrumentation api it will not work on android devices so it might confuse android developersif so i think it should not be integrated into the `mockito-core` artifact || i came across this issue by chance (i was just curious to know what you were planning for mockito 3) but id like to share my experiences of working with static method mockingi used to work on several large codebases that made extensive use of static methods and used powermock (and powermockito) heavily for testing my main memories of that time were that the tests were really slow to run (in some cases tests that use powermock were literally ten times slower than those that didnt) and that we ultimately had to remove all usages of powermock because it wasnt compatible with newer versions of java i also recall there being incompatibilities with some libraries were using that required special setup in the tests to make them pass although i no longer remember the details of thati can understand concerns about promoting bad code but as a mockito user id be more worried about the impact on performance and robustness not all of the code we were using powermock for was legacy some of it was new code written by an inexperienced team (of which i was part of) and knowing that mockito devs disapproved of our design patterns probably wouldnt have made any differencethis was a few years ago now and techniques for mocking static methods may have improved significantly since then if you think theres a performant and robust way to implement this feature then id welcome it (even though id hope i never have to use it) || really good feedback thank you guys i helps us make good decisions about the features/api we plan || in my opinion in general testing static methods is a bad idea and it would be better to refactor the code however sometimes its something that is needed for instance testing a default method `given()` in [mockito-java8 interface]( delegating to a static method in `bddmockitogiven()` the easiest solution i see is to generate in runtime a list of static methods in `bddmockito` and execute parameterized test for every of them verifying that a corresponding method in `withbddmockito` interface delegates to it with proper parameters in that case static method mocking would be beneficial maybe i will wait for powermockito for mockito v2 to test mockito itselfalternatively i would need to play with aop and load-time weaving code generation in runtime or some other not very pleasant to use technique (unless you have some good ideas how to do it easier) || @szpak thank you for the feedback! interesting use casei think we all agree that mocking statics is a bad practice and an anti-pattern in general the question is whether we enforce the ""no mocking statics"" policy (eg not offer the feature in the tool) or let the user decide to enforce it or not (eg offer the feature) || please consider the legacy code issue sometimes you dont have any choice enforcing or not a practice shouldnt be the decision of a framework but of the teamalso for now were using powermock as a workaround for this need but its not compliant with the last versions of mockito were blocked with 19x version of mockitoits another good reason to get this feature: limit dependencieswe already need all these libraries to get decent unit test in pure java world:junitjunitparams as junit parametrized are awfullassertj for expressive and clear assertionsmockito  and powermockand i shouldnt mention other peripheral libraries:dbunitspringdbunitjbehave jgiven for bdd style  then you can write all your testing stuf in groovy and you only need  spockplease! let user choose othewise why did you provide private method mocking in the recent versions athough its considered as a ""bad"" practice for tdd purists ? finally thanks for your great work mockito is really a nice framework  || mocking static methods is a different use case maybe that means it should be a different tool answer the following questions (to yourself):- do you want to support a double tool in the long term? - does it use the same set of dependencies and only those? - does mocking static methods fall nicely into the current design?if you answer all 3 with ""yes"" then go ahead if at least one is a ""no"" consider the alternatives:- build a mockito extension- build a new tool and call it mackarita- leave the other tool to someone elsejust my two cents || i agree with most of you and think that mocking static methods is not a good ideaif some method uses static method provided by legacy library/framework then it can be easily wrapped in object and provided as mockable dependency its not perfect solution but is educational - shows developers that writing too complex static util methods hurts and makes code hard to test if mockito had such feature many of developers would consider it as acceptable practise and produce bad codeanother issue is parallel tests execution in my current project we used to use powermockito to mock static methods and after some time our tests started to fail because of concurrency issues:1 thread a mocked static method xy and stopped2 thread b mocked static method xy and stopped3 thread a was awaken and run test - it failed because thread b overwritten static methods behaviour expected in test run by awe ended up with wrapping static methods in injectable objects and removed powermockito from project dependencies || i had asked about this at some point in the past and was told it was being considered glad to see thats actually happeningin my opinion support for mocking static methods is a good idea for the simple reason that the standard java classes that ship with the jre have tons of static methods consider the nio2 api as an example if you want to read a file using that api you might do something like:```javafilesreadalllines(pathsget(""myfile""))```now is there a way to test this without mocking static methods? obviously yes you could make a ifiles interface and then make a jrefilesimpl that passes the calls through to the static methods but thats a bunch of extra effort it adds complexity to your code and obscures the methods that are actually being called in my opinion i shouldnt need to do that to test my codes ability to properly read some fileso +1 for the ability to mock static methods || > now is there a way to test this without mocking static methods?well in my opinion file name/path from your example is good candidate for passing it to method/setter/constructor instead of hardcoding it and you can just create test file in filesystem such java api methods are considered as simple and reliable and there is no need to mock them like you wouldnt mock `javautillist` if your method operated on data from given list you would just create actual list with test data || there are at least 2 problems with that argument: a) you cant test behavior when exceptions occur and b) you cant test behavior if the path is for a different os i realize the latter is an esoteric use case but i actually am working on a project that is developed on windows but runs exclusively on linux || i think the recurring theme right now is: either you are pro or you are strictly against it personally i am for clean tests and therefore consider static mocking very bad practice however our users apparently have usecases that require (intrusive?) solutions such as powermock given that these users opt for such solutions signals that the other solution would be no tests at all and that is probably what we would never wantgiven that solutions like powermock are built not only on mockito but also other libraries they can not be easily updated like mockito can this incentives mockito to solve static mocking if users opt-in for iteven though i inherently disagree with static mocking i think it is only fair that we as mockito developers offer users the option to opt-in a less intrusive and upgrade-compatible solution therefore i would vouch for a different artifact (probably called `mockito-legacy`) which offers static mocking this should signal our users that this is for legacy purposes and should be strictly discouraged but at least gives them a way out this particular solution would tick off all points of @jlinkin the end no matter which outcome there will always be disappointed developers we will not be able to find a golden solution for this particular problem and i am fairly convinced it will never happen eitherwe can always try it out with the new artifact and discontinue it later if it is significantly misusedone sidenote: putting everything in a new artifact would scatter the mockito ecosystem we should probably find a better solution for this potentially in mockito 3 || i disagree with @timvdlippe  i dont believe that in an open source world you can ""try it out with the new artifact and discontinue it later if it is significantly misused"" once its there in the library users will require it to be there youll have to support that feature etc either its there or not not often can you easily deprecate sth and roll it back afterwards typically it requires a couple of release cycles@timvdlippe youre mentioning this "" however our users apparently have usecases that require (intrusive?) solutions such as powermock"" i have a comment on that as an exercise from time to time im trying to answer powermock questions on stackoverflow typically someone says that theres a static method somewhere that theyre calling and it does some logic that they want to stub the question i often ask to those people is ""why are you doing this?"" would you really want to stub a call to `stringutils` ? another frequent problem is that the design is flawed and thats why one is looking for hacks (eg      or  why i fully agree with @karollewandowski  ""every problem can be solved with a layer of abstraction"" ) you cant mock a static method? ok then wrap it in a class which you can stub is it wrong? quite the contrary rarely should you call static methods directly and if you do most likely these are utils that you dont want to stub you should encapsulate the logic of a static method in an object that makes business sense to use itsumming it up giving people a tool to stub static methods is making them even easier to write bad code instead of thinking of how to fix the design theyll be able to make the design even worse  || @timvdlippe just one thing: if you create a new artifact like ""mockito-legacy"" communicate clearly if youre planning to support it mid/long-term or if its just an experiment some people are willing to experiment together with you others will be pissed off when you quit support after they have heavily used it || @rdicroce i completely disagree with this statement:> now is there a way to test this without mocking static methods? obviously yes you could make a ifiles interface and then make a jrefilesimpl that passes the calls through to the static methods but thats a bunch of extra effort it adds complexity to your code and obscures the methods that are actually being called in my opinion i shouldnt need to do that to test my codes ability to properly read some fileyoure design is wrong if you had ```filesreadalllines(pathsget(myfilepath))```you could via a constructor inject `myfilepath` to point to your test resources you dont even need to create any additional classes || the android community would like mock static methods well at least mewhy? : the android sdk provides many static utility methods with classes like textutils the downside is that there implementation is only provided on the device or emulator when users run unit-test on there local machine they will get the famous ""method not mocked"" exception> the androidjar file that is used to run unit tests does not contain any actual code - that is provided by the android system image on real devices instead all methods throw exceptions (by default) this is to make sure your unit tests only test your code and do not depend on any particular behaviour of the android platform (that you have not explicitly mocked eg using mockito) they are many workarounds for this issue like powermock or roboelectric roboelectric is a great testing framework but it is damn slow and maintainance intensiv powermock is not stable state to be used with mockito 2 so i think at least android users will love this feature   || @christianschwarz i do not agree using android static utils or android framework in your business logic is a bad smell well structured android app do not need mocking static methods nor roboelectric calls to android framework must be abstracted and current mockito implementation helps to enforce that if you want to test view layer then go with instrumentation tests and espresso || @dbacinski i am not an expert on android so bear with me please :) adding extra layer introduces more method calls which can be problematic on large apps that hit dex method limit right? || @szczepiq you are right that you need additional methods to abstract android apis but this is a cost of good architecture dex method limit is not a huge problem anymore because now there is native platform support for multidex apps || @marcingrzejszczak your response a) does not address the call to readalllines() and b) does not address either of the issues i raised in  all: it seems to me theres a fundamental divide in this thread between people who are of the opinion that its fine to just make a wrapper class for static calls and people who are of the opinion that wrapper classes add bloat and shouldnt be necessary i dont see either side convincing the other so im not sure where that leaves us || > your response a) does not address the call to readalllines() and b) does not address either of the issues i raised in #1013 (comment)@rdicroce i havent explicitly but the answer is simple> a) does not address the call to readalllines()if the path is a parameter you dont have to mock the call at all you can pass a) a path that exists - to test the positive scenariob) a path that doesnt exist - that way it will blow up and youll test an exception>  i realize the latter is an esoteric use case but i actually am working on a project that is developed on windows but runs exclusively on linuxyou can write a couple of tests that are exclusively executed depending on the os (example for windows -  ) again if you use parameters instead of magic values then you can do basically whatever you want> to all: it seems to me theres a fundamental divide in this thread between people who are of the opinion that its fine to just make a wrapper class for static calls and people who are of the opinion that wrapper classes add bloat and shouldnt be necessary i dont see either side convincing the other so im not sure where that leaves usid say that the divide is between people who want to design their code properly and those who want to take the path of least resistance (which isnt a wrong choice sometimes) || >id say that the divide is between people who want to design their code properly and those who want to take the path of least resistancestatic members arent something good i hope its quite obvious but java has them and will support them whether we like it or not so id say that educating and influencing is good forcing might be not its like ""oooh your code is using statics so it cant be tested with mockito""(not to mention that some people would like to have nice unclebobish tests but arent allowed to refactor the code they have to maintain i know its sick but hey this is reality sometimes) || @marcingrzejszczak > if the path is a parameter you dont have to mock the call at all you can pass>> a) a path that exists - to test the positive scenario> b) a path that doesnt exist - that way it will blow up and youll test an exceptionthat may solve this particular case what about other static apis that can throw a variety of different exceptions? are you saying users should go through the hassle of setting up every possible scenario? what happens if there are scenarios the user cant set up? you may as well not bother with a mocking framework at all in that case> you can write a couple of tests that are exclusively executed depending on the os (example for windows -  ) again if you use parameters instead of magic values then you can do basically whatever you wantthis makes it impossible to run the tests in the environment where the code is developed again i know this is an esoteric use case but it is a valid one imo> id say that the divide is between people who want to design their code properly and those who want to take the path of least resistancei wont speak for anyone else in favor of mocking static methods but i dont see that as designing code improperly adding a whole extra layer of abstraction thats completely unnecessary outside of testing? that does strike me as being improper || this will be my last answer cause obviously we are not going anywhere with this@pioorg> static members arent something good i hope its quite obvious but java has them and will support them whether we like it or notyes its obvious someone has to afterwards maintain that code both the business and the library another thing is that you dont have to mock all of those calls why would you stub a `stringutils` class ? makes absolutely no sense @rdicroce>  are you saying users should go through the hassle of setting up every possible scenario? what happens if there are scenarios the user cant set upof course not you can catch a generic exception and thats enough > this makes it impossible to run the tests in the environment where the code is developedthats false some of your tests will be executed only on windows some others on linux etc > i wont speak for anyone else in favor of mocking static methods but i dont see that as designing code improperlythats why i would just call the static method if in your static method you have a lot of complex logic then it should get wrappedall in all - i think that this is a wrong decision for mockito but thats only my opinion || > yes its obvious someone has to afterwards maintain that code both the business and the library another thing is that you dont have to mock all of those calls why would you stub a stringutils class ? makes absolutely no sensewith all the respect i dont care about any *utils classes or any other particular code snippetswhat i mean is that:1 statics are valid from syntax pov2 they already exist in legacy code 3 some folks cant change that code ""only because wed like to have mockito in tests""so if one cant change the code refactor it and add the wrappers around the static calls they also cant use mockito because ""mockito doesnt support statics"" to me it comes to ""bad code -> bad tests"" sorry -)while i perfectly understand there are reasons not to include it in ""standard"" distribution artefact having another one being mockito-extension-for-ppl-who-dont-have-nice-codejar might be acceptable || just some toughts about  the prevailing opinion ""statics methods are evil"" from my experience there are 2 different kinds of static methods ""good"" and ""evil"" i wouldnt say that all static methods are evil * static methods are ""evil""  when they alter the state of a of a static member or in other words they depend on a state when such a method is called the result may be an other when called in the future with the same inputeg:```java class logmanager {     static loggerplugin plugin       static void loginfo(string message){        pluginwrite(infomessage)     } }``` when the loggerplugin changes during runtime the result may be different eg logged to a different media *  static methods are also ""evil"" when they call a static method that is ""evil"" as described above cause they inherit the nasty side effectseg:```java class log{  static void info(string message){      loggermanangerloginfo(message)   } }``` * static methods are are ""good"" when they dont depend on a state / access a static member and thus have the same result on every calleg:  `mathmax(intint) `in the java eco system exists both evil and good static methods i dont see a much points to mock ""good"" static methods it makes only sense when they do quite complex stuff and you dont want to mock all bits of there input to satisfy there implementation even in famous frameworks we are faced with ""evil"" static methods (hello `singletongetinstance()`) to handle these evil cases mockito can do its part and support the poor devs among us who have to deal with it i wouldnt blame mockito if devs start to introduce the ""evils""  to there code base mockito is a mocking framework not a good style enforcement tool thats the task for the team and/or lead developer || @christianschwarz > static methods are are ""good"" when they dont depend on a state / access a static member and thus have the same result on every calltrue there are even some schools in which all private methods should be static dont depend on anything apart arguments dont change the state of any object and dont do anything beside computing the result so theyre functions just like sin(angle) is: the angle isnt changed and sin is only the result of the angle always the same (provided the geometry is always the same -) )i find this functional style of programming very good but in fact it has rather not much to do with statics as such imho sometimes its better to tell newbies ""dont use statics couse theyre generally bad"" its a kind of ""lie for children"" || unfortunately as history has shown multiple times when developers see a tool and its use cases they do not always understand the impact and weight of its features they consider all features equal and do not understand that some of them should only be used as a last resortthe canonical example in the java world is the abuse of java introspection/reflection and aop for even trivial scenarios even outside the java world we see the misuse of advanced features by developers who use them ""simply because they are there"" if we are to go forward with this (and i am strongly against this as i considered a major advantage of mockito the fact that it did not allow testing of static methods) i would suggest the following:- create a ""mockito-legacy"" artifact/extension/add-on - require a configuration file option for mockito to actually enable this add-on- print in the log file when the test runs a huge warning (similar to what maven does when you dont define a version) that using this add-on is an anti-pattern and a code-smell- provide a link to the user that has a page with common refactoring scenarios that show how we can get rid of static methodsmaybe i am missing something but i really would like some examples on how legacy code cannot be refactored to remove the static dependency unless of course you cannot change the code at all which for me makes the creation of unit tests questionable (because if a unit test fails what are you going to do then?) || @kkapelon: i also wish all java code was pure oo design and that everyone actually knows what that means -) i hope such a huge warning ""youre doing it wrong"" could educate and maybe convert a few folks> maybe i am missing something but i really would like some examples on how legacy code cannot be refactored to remove the static dependencyits not about the code itself ive seen big name companies enforcing policies in which before bugfixing the case has to be replicated in tests (kinda tdd they claim sometimes) then once the test fails just like the ticket describes the support team is allowed to change the code to make it pass (and sadly usually minimum changes) its rather difficult to make a test to cover statics if your testing tool set doesnt allow that chicken and egg problemits like all these the daily wtf stories in which ""dont change it it aint broke couse it works!"" so the code is like java 14 || this would be great! we could finally stop bikeshedding ""static is *eeevil*"" because not testable || > we could finally stop bikeshedding ""static is eeevil"" because not testablewell imho static is eeevil in many cases not only because not testable :-d || the mocking framework shouldnt restrict the design options - its just not the job of a mocking framework! ive seen a lot of code polluted with mocking-only interfaces and there are a lot of cases where a simple static method is a perfect design decision `final` is also rarely used because mocking frameworks (besides the great [jmockit]( have trouble with it || dont do it!  powermockito exists for those cases where you absolutely need to mock static methods  right now mockito conforms to the commonly held opinion that static is for methods that are testable without mocks (think: stringutils)  static for other stuff should be discouraged (there are exceptions obviously) - in those situations encapsulating the static calls in a protected @visiblefortesting method should suffice for unit testing and for those other ""legacy or not"" situations theres always powermockito   || @trumpetx i just wanted to note that the reason we are investigating this change is that some companies are in the legacy code situation where adopting powermockito would be too disruptive therefore these companies would be unable to test their classes even if they could adopt powermockito the tests become significantly more difficult to understand just to be able to test their legacy codethe question is: should we as mockito give the opt-in for these situations as other options are too invasive? i think every mockito core developer agrees that static mocking is bad and should not be done but sadly we can not dictate what the industry does or has to deal withjust wanted to give perspective on why we are opening this issue || @timvdlippe  i cant see how powermockito would be disruptive for tests (certainly no more disruptive than adding mockitostaticwhatever)additionally too difficult to understand?  seriously?  if someone has static mocks in their tests and theyre too difficult to understand they probably need to find a new career  im not saying this to be mean spirited or whatnot but it sounds like youre just making reasons to adopt this change || also for reference i cross-posted this issue on reddit and there some other arguments/viewpoints posted there:  || @timvdlippe thanks for your link the recent posts have led me to another just wondering why so many of them || i havent had experience with bytebuddy but id be willing to give it a shot as far as names how do we feel about `mockito-gore` to really indicate you need a strong reason to use this jar? || just a few more words from me maybe last ones -)theres a method in mockito:`orgmockitomatchers#isnull(javalangclass<t>)`isnt null considered to be ""the billion dollar mistake""? shouldnt the programmers all around the world be educated that passing a null reference (instead of a `javautiloptional`) is a very bad practice?maybe this `isnull` method should be deprecated and eventually removed in future versions?ive seen a lot of code being polluted  if (reference  null)` and `catch (nullpointerexception e)` more than by ""incorrect use of statics"" (but ymmv)if supporting statics is going to create such bad habits among programmers and mockito is meant to be a forced education then i guess support for nulls should be removed in future versions and people should write wrappers to handle nulls from their legacy code as null is worse habit imho -)unless mockito is meant to be a testing/mocking framework not forced education coursethank you || i would like to add some comments from my own experience i completely understand the people that are saying to add an abstraction to the static methods that you are invoking however in a legacy code that is expensive and requires a lot of effort additionally there are frameworks like [gwt]( that support polymorphism but not like you would think one needs to call a static method that will do the creation of the object on runtime and runtime there is javascript there ware ways that you can write tests that will emulated the client code for gwt but they are really slow currently we use powermockito with mockito 195 because we cant update to a later mockito however if mockito had this support it would be much easier to do the testing || this discussion has been very active and helpful thank you everyone for participating!i think we have sufficient background information to make a final decision @mockito/core shall we discuss this on slack and write a wiki page on our full analysis and final verdict? then we can inform the community for a final review (of a potential implementation) and round up this feature || > shall we discuss this on slack and write a wiki page on our full analysis and final verdict? then we can inform the community for a final review (of a potential implementation) and round up this featurehas the verdict on static support been reached? || we have not every single core member has been swamped with various irl activities probably this fall we will be back in full force this is one of the features that we will be addressing    || the team was not actively working on this the ticket is marked ""please contribute"" for a reason ) currently i work with @thekingnothing on creating mockito apis so that powermock can cleanly integrate (#1110) this will effectively provide reasonable support for static mocking hope this clarifies the status! thank you for reminder - this is useful for us to manage our priorities || static methods are totally ok you just have to know when to use themi think the following code is entirely correct and sufficiently abstracted for the purpose of a modern-day application:    // guava imports    class applicationresources {      // points to a file in the war      private static final charsource default_config_source  resourcesascharsource(resourcesget(""etc/defaultconfig"") utf_8)      static charsource defaultconfigsource() {        return default_config_source      }    }i need to access a static value in my application but for the purpose of proper testing i need to test various default values so it makes sense to provide another `charsource` during the tests than at runtimejust imagine that this is embedded in some jee application there is no sense in writing this method as non-static i could write `new applicationresources()defaultconfigsource()` what is that code? is it real? others might imagine i make this class a (singleton) bean a bean requires the class to be public i dont want any of its method to be accessed outside of the package so there are no reasons to make this class public so this class has no reasons to be a beanhowever i still have to test classes that use this class but im stuck in the testing because i just cant mock its methods (besides using all the workarounds mentioned above)i agree that mocking static method should be used very very rarely but it should exist for those rare cases || personally i plan to add this feature i still need to do some ground work in byte buddy to make this feasible it is not as easy as i hoped unfortunately and it might take some time the same goes for the seamless integration with powermockif anybody would be willing to sponsor the development i am happy to use paid hours within my open source commitment this might take a few more month to complete but i am certain to finish this at some point java 9 compatibility takes priority at the moment || ;1;0;update src/main/java/org/mockito/captorjavaco-authored-by: tim van der lippe <timvdlippe@usersnoreplygithubcom>;
1961;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix when editing a bibentry field the searchbar would be focused;fix for #1549 ### steps to reproduce: - select a bibentry - edit a field - save the change (eg. click outside the field) - the searchbar would be focused;;0;make immediatefailedfuture and immediatecancelledfuture return a trustedfuture?;"on the theory that most things should be a `trustedfuture` :)we would probably skip `immediatefuture` because theres little to optimize there: wed basically be replacing one field access with anotherbut why not do `immediatefuture` anyway? `trustedfuture` is a bit larger than `immediatefuture` since it stores listeners and waiters (""would increase the size of the immediatefuture implementations by a least 8 bytes a piece (+ padding)"" per luke)we care about that less with failed and cancelled futures since they have large `exception` objects associated with them alreadyalternatively we could special-case `immediatefuture` in the same way that we special-case `trustedfuture` -- either with a separate `instanceof` branch or with an interface then we could do all the whole `immediate*future` family with no cost unless the branch/interface has a performance cost";we had to roll this back right after submitting it well probably try again || done again ||;;;;0;1;;
1961;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix when editing a bibentry field the searchbar would be focused;fix for #1549 ### steps to reproduce: - select a bibentry - edit a field - save the change (eg. click outside the field) - the searchbar would be focused;;0;fix locationawareschedulingdisabled schedule local;fix https://githubcom/facebook/presto/issues/1950;@martint thanks get comments addressed || rebased and ;;;;0;1;;
1961;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix when editing a bibentry field the searchbar would be focused;fix for #1549 ### steps to reproduce: - select a bibentry - edit a field - save the change (eg. click outside the field) - the searchbar would be focused;;0;remove request batching in merge;removing the batching until we can find a correct way to do it as per discussion at  performance impact of this change is seen here:```benchmark                                          (size)   mode   samples          1x    no request batchingrooperatormergeperfmerge1syncstreamofn               1  thrpt         5  4585554607    4666745314 102%rooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    51273033      39922246 78%rooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       47515         37634 79%rooperatormergeperfmergenasyncstreamsofn             1  thrpt         5    90901735      93454726 103%rooperatormergeperfmergenasyncstreamsofn          1000  thrpt         5        5407          4910 91%rooperatormergeperfmergensyncstreamsof1              1  thrpt         5  4181618767    4173322551 100%rooperatormergeperfmergensyncstreamsof1            100  thrpt         5   422193599     408972130 97%rooperatormergeperfmergensyncstreamsof1           1000  thrpt         5    36886812      36448978 99%rooperatormergeperfmergensyncstreamsofn              1  thrpt         5  4815945720    4887943643 101%rooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       43926         39027 89%rooperatormergeperfmergetwoasyncstreamsofn           1  thrpt         5    72578046      70412656 97%rooperatormergeperfmergetwoasyncstreamsofn        1000  thrpt         5     3260024       3064403 94%rooperatormergeperfonestreamofnthatmergesin1         1  thrpt         5  4678858201    4808504588 103%rooperatormergeperfonestreamofnthatmergesin1      1000  thrpt         5    34407547      36364476 106%rooperatormergeperfonestreamofnthatmergesin1   1000000  thrpt         5       31312         32261 103%```;should i proceed with this and release 103 or does someone have a better recommendation of what to do as an immediate fix?major changes in how `merge` is implemented to try and improve performance should wait for 11 which we can do release candidates for  || the perf isnt that bad the `merge1syncstreamofn` seems to be bad because emitting just 1 item needs a lot of orchestration on the iterable/range source im not claiming i understand all aspects of merge optimizations done but perhaps just these synchronous sources could override the request(1) sent to them and produce n elements emitting them one-by-one from a cheap buffer || maybe this is unrelated but [this]( code gives me ints dominated results meaning that merge prefers synchronous sources over asynchronous even though they theoretically can produce at the same rate using observeon on both inputs seems to balance out things much nicer || > merge prefers synchronous sources `merge` becomes `concat` with synchronous sources that is always how it will behave unless concurrency is added are you saying something different than that? || > the perf isnt that bad i agree it is not bad enough to not move forward it it still good perf just not as good as we could be if we figure this batching out im going to move forward with this change for 103 as the correctness is more important and the perf hit is not significant enough (in my opinion) to not get a fix out  ||;;;;1;1;remove request batching in mergeremoving the batching until we can find a correct way to do itthe performance impact of this change is seen here:benchmark                                          (size)   mode   samples          1x    no request batchingrooperatormergeperfmerge1syncstreamofn               1  thrpt         5  4585554607    4666745314 102%rooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    51273033      39922246 78%rooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       47515         37634 79%rooperatormergeperfmergenasyncstreamsofn             1  thrpt         5    90901735      93454726 103%rooperatormergeperfmergenasyncstreamsofn          1000  thrpt         5        5407          4910 91%rooperatormergeperfmergensyncstreamsof1              1  thrpt         5  4181618767    4173322551 100%rooperatormergeperfmergensyncstreamsof1            100  thrpt         5   422193599     408972130 97%rooperatormergeperfmergensyncstreamsof1           1000  thrpt         5    36886812      36448978 99%rooperatormergeperfmergensyncstreamsofn              1  thrpt         5  4815945720    4887943643 101%rooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       43926         39027 89%rooperatormergeperfmergetwoasyncstreamsofn           1  thrpt         5    72578046      70412656 97%rooperatormergeperfmergetwoasyncstreamsofn        1000  thrpt         5     3260024       3064403 94%rooperatormergeperfonestreamofnthatmergesin1         1  thrpt         5  4678858201    4808504588 103%rooperatormergeperfonestreamofnthatmergesin1      1000  thrpt         5    34407547      36364476 106%rooperatormergeperfonestreamofnthatmergesin1   1000000  thrpt         5       31312         32261 103%;
1961;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix when editing a bibentry field the searchbar would be focused;fix for #1549 ### steps to reproduce: - select a bibentry - edit a field - save the change (eg. click outside the field) - the searchbar would be focused;;1960.0;document using `@mock` with method parameters;although weve called it out in the [junit extension] we should alsomake sure its clear in the core documentation to make it more visiblewe can fully-quality the `@test` annotation to make clear that it has tobe with junit 5closes #1960[junit extension]: https://javadocio/doc/orgmockito/mockito-junit-jupiter/latest/org/mockito/junit/jupiter/mockitoextensionhtml; merging 1961 ;documentation: `@mock` on method parameters;"while writing [an article about using `@mock` as a method parameter]( i noticed that the [javadoc for mockito]( doesnt mention the ability to use `@mock` as a parameter to a test methodhow would be best to add that as a pr given its dependent on the test runner?i was thinking something like:``` * <h3 id""9"">9 <a class""meaningful_link"" href""#mock_annotation"" name""mock_annotation"">shorthand for mocks creation - <code>&#064mock</code> annotation</a></h3> * * <ul> * <li>minimizes repetitive mock creation code</li> * <li>makes the test class more readable</li> * <li>makes the verification error easier to read because the <b>field name</b> * is used to identify the mock</li> * </ul> * * <pre class""code""><code class""java""> *   public class articlemanagertest { * *       &#064mock private articlecalculator calculator *       &#064mock private articledatabase database *       &#064mock private userprovider userprovider * *       private articlemanager manager * *       @test *       void testsomething(@mock articledatabase database) { * </code></pre>```";we mention that information in  as we dont support initiating mocks on parameters with junit4 therefore we should add a parameter something like:```java *       @test *       void testsomething(@mock articledatabase canonlybeinstantiatedwithjunit5) {```other than that please open a pr 😄  || oh i didnt realise that thanks! ill amend my article with that knowledge tooam i ok to add a pr for both the v2 and v3 documentation given it works on both versions? || we no longer publish v2 updates so v3 only ||;1;0;document using `@mock` with method parametersalthough weve called it out in the [junit extension] we should alsomake sure its clear in the core documentation to make it more visiblewe can fully-quality the `@test` annotation to make clear that it has tobe with junit 5closes #1960[junit extension]: https://javadocio/doc/orgmockito/mockito-junit-jupiter/latest/org/mockito/junit/jupiter/mockitoextensionhtml;
1968;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored remotepreferences;as logic should not reference  jabrefpreferences .;;0;functionsformap should accept map<? extends k ? extends v> like collectionsunmodifiablemap;the function returned by functionsformap is like a limited read-only map so it should be able to accept more inputsthis is similar to `javautilcollectionsunmodifiablemap` which has the following signature:`public static <kv> map<kv> unmodifiablemap(map<? extends k ? extends v> m)`for example the following is only possible by wrapping the input map:``` javamap<integerstring> map  function<numbercharsequence> f      functionsformap(collections<numbercharsequence>unmodifiablemap(map))```;"this use case seems a little odd to me: youre returning a function that claims to accept number but it really only works on integers and i believe it throws on other inputs  is that really behavior it makes sense to encourage? || you say that it ""should be able to accept more inputs"" but it will already accept your `map<integer string>` just fine as it is it returns you a `function<integer string>` which is the correct type for what it is now if you have a reason to want to cast that to a different type thats up to you || fair enough thanks for the reply  || ";;;;0;1;;
1968;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored remotepreferences;as logic should not reference  jabrefpreferences .;;0;update to arlift 097;- remove redundant classes;;;;;0;1;;
1968;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored remotepreferences;as logic should not reference  jabrefpreferences .;;0;upgrade to gradle 22;;this is great @quidryan thank you  ||;;;;1;1;apply java plugin;
1968;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;refactored remotepreferences;as logic should not reference  jabrefpreferences .;;1967.0;1967: correctly handle mocks with limited life-cycle in listeners;due to the limited lifetime of static mocks they cannot be validated within a mockito session since they might have expired when the validation is applied this patch excludes static mocks from all validation to support static mocks in the regular session validation we would rather need to trigger the validation upon release of any static mock;it only tests part of the issue for actually testing it we would need to run the junit tests with the inline mock maker and create subprojects for it i am going on a two week vacation tomorrow so i did not want to open that barrel of wine tonight but i validated the working manually if you have some time could you add additional subprojects? i validated the runners manually however || ah okay i got confused as the commit mentions that the issue is  so thats why i thought we had test the whole scenario please go on vacation we can figure it out later 😄  ||  merging 1968 ;static method mocks incompatible with mockitoextension (notamockexception);helloi am experimenting with the newly released functionality of mocking static methodsit appears that static mocks are not compatible with the `mockitoextension` designed for junit 5following error message is produced when using the extension:```orgmockitoexceptionsmisusingnotamockexception: argument passed to mockitomockingdetails() should be a mock but is an instance of class javalangclass!```full stacktrace: [static-mock-mockito-extension-stacktracetxt]( have created following minimal example which is composed of a `utils` class (containing the static method) and a `utilsuser` class (calls the static utils method) `utilsusertest` tests the functionality of the `utilsuser` class```javapublic class utils {    public static long millis() {        return systemcurrenttimemillis()    }}``````javapublic class utilsuser {    public long use() {        return utilsmillis()    }}``````javaimport orgjunitjupiterapitestimport orgjunitjupiterapiextensionextendwithimport orgmockitoinjectmocksimport orgmockitomockedstaticimport orgmockitomockitoimport orgmockitojunitjupitermockitoextensionimport static orgjunitjupiterapiassertionsassertequals@extendwith(mockitoextensionclass)class utilsusertest {    @injectmocks    private utilsuser utilsuser    @test    void use() {        try (mockedstatic<utils> mockedutils  mockitomockstatic(utilsclass)) {            mockedutilswhen(utils::millis)thenreturn(17l)            assertequals(17l utilsuseruse())        }    }}```when converting this test to a test which does not use the extension (removing `@extendwith` removing `@injectmocks` adding ` new utilsuser()` after the field declaration) the test passescan you tell me if there is something special i have to accomodate for when using the static mocks in junit jupiter?or is this indeed a bug (which you can hopefully reproduce)?i am using mockito-inline and mockito-junit-jupiter in version 340thanks in advance and thanks for the new static mocks functionality!david;thanks for reporting we already found the error it slipped us i think we can have a release ready fairly soon ||;1;0; \#1967: correctly handle mocks with limited life-cycle in listeners;
1971;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;add support for creating constructors without using objenesis (and unsafe api);this pr adds code to constructors to allow short-wiring a constructor without avoiding to call it  thus making the use of objenesis obsolete. this is desired since objenesis relies on unsafe api which is deprecated and will be removed in a future release.;;0;google code conventions;hii have applied the eclipse formatter using the google configuration for java projects available at  there another formatter configuration for this project?thanks!;  done :) ||   we have found that no matter what the configuration eclipse does not do anacceptable job of auto-formatting code to google style we are planning toopen-source our own formatter in the next few months thanks for yourintereston thu feb 12 2015 at 2:50 am raquel pau notifications@githubcomwrote:> hi> > i have applied the eclipse formatter using the google configuration for> java projects available at>  is there another formatter configuration for this project?> > ## thanks!> > you can view comment on or merge this pull request online at:> >    commit summary> - google style> > file changes> - _a_ google-stylexml>    (337)> - _m_>   guava-gwt/src/com/google/common/forceguavacompilationentrypointjava>    (24)> - _m_>   guava-gwt/src/com/google/common/base/absent_customfieldserializerjava>    (27)> - _m_>   guava-gwt/src/com/google/common/base/gwtserializationdependenciesjava>    (63)> - _m_>   guava-gwt/src/com/google/common/base/pairwiseequivalence_customfieldserializerjava>    (23)> - _m_>   guava-gwt/src/com/google/common/base/present_customfieldserializerjava>    (20)> - _m_>   guava-gwt/src/com/google/common/collect/allequalordering_customfieldserializerjava>    (26)> - _m_>   guava-gwt/src/com/google/common/collect/arraylistmultimap_customfieldserializerjava>    (37)> - _m_>   guava-gwt/src/com/google/common/collect/byfunctionordering_customfieldserializerjava>    (38)> - _m_>   guava-gwt/src/com/google/common/collect/comparatorordering_customfieldserializerjava>    (38)> - _m_>   guava-gwt/src/com/google/common/collect/compoundordering_customfieldserializerjava>    (38)> - _m_>   guava-gwt/src/com/google/common/collect/denseimmutabletable_customfieldserializerjava>    (20)> - _m_>   guava-gwt/src/com/google/common/collect/emptyimmutablebimap_customfieldserializerjava>    (29)> - _m_>   guava-gwt/src/com/google/common/collect/emptyimmutablelistmultimap_customfieldserializerjava>    (33)> - _m_>   guava-gwt/src/com/google/common/collect/emptyimmutablesetmultimap_customfieldserializerjava>    (33)> - _m_>   guava-gwt/src/com/google/common/collect/emptyimmutableset_customfieldserializerjava>    (31)> - _m_>   guava-gwt/src/com/google/common/collect/emptyimmutablesortedmap_customfieldserializerjava>    (38)> - _m_>   guava-gwt/src/com/google/common/collect/emptyimmutablesortedset_customfieldserializerjava>    (45)> - _m_>   guava-gwt/src/com/google/common/collect/explicitordering_customfieldserializerjava>    (38)> - _m_>   guava-gwt/src/com/google/common/collect/forwardingimmutablelist_customfieldserializerjava>    (27)> - _m_>   guava-gwt/src/com/google/common/collect/forwardingimmutableset_customfieldserializerjava>    (27)> - _m_ guava-gwt/src/com/google/common/collect/gwtplatformjava>    (29)> - _m_>   guava-gwt/src/com/google/common/collect/gwtserializationdependenciesjava>    (102)> - _m_>   guava-gwt/src/com/google/common/collect/hashbasedtable_customfieldserializerjava>    (9)> - _m_>   guava-gwt/src/com/google/common/collect/hashmultimap_customfieldserializerjava>    (36)> - _m_>   guava-gwt/src/com/google/common/collect/hashmultiset_customfieldserializerjava>    (36)> - _m_>   guava-gwt/src/com/google/common/collect/immutableaslist_customfieldserializerjava>    (27)> - _m_>   guava-gwt/src/com/google/common/collect/immutablebimap_customfieldserializerjava>    (28)> - _m_>   guava-gwt/src/com/google/common/collect/immutableentry_customfieldserializerjava>    (35)> - _m_>   guava-gwt/src/com/google/common/collect/immutableenummap_customfieldserializerjava>    (33)> - _m_>   guava-gwt/src/com/google/common/collect/immutableenumset_customfieldserializerjava>    (37)> - _m_>   guava-gwt/src/com/google/common/collect/immutablelistmultimap_customfieldserializerjava>    (32)> - _m_>   guava-gwt/src/com/google/common/collect/immutablelist_customfieldserializerjava>    (28)> - _m_>   guava-gwt/src/com/google/common/collect/immutablemultiset_customfieldserializerjava>    (28)> - _m_>   guava-gwt/src/com/google/common/collect/immutablesetmultimap_customfieldserializerjava>    (35)> - _m_>   guava-gwt/src/com/google/common/collect/immutableset_customfieldserializerjava>    (28)> - _m_>   guava-gwt/src/com/google/common/collect/immutablesortedmap_customfieldserializerjava>    (23)> - _m_>   guava-gwt/src/com/google/common/collect/immutablesortedmap_customfieldserializerbasejava>    (23)> - _m_>   guava-gwt/src/com/google/common/collect/immutablesortedset_customfieldserializerjava>    (28)> - _m_>   guava-gwt/src/com/google/common/collect/immutabletable_customfieldserializerbasejava>    (11)> - _m_>   guava-gwt/src/com/google/common/collect/lexicographicalordering_customfieldserializerjava>    (40)> - _m_>   guava-gwt/src/com/google/common/collect/linkedhashmultimap_customfieldserializerjava>    (32)> - _m_>   guava-gwt/src/com/google/common/collect/linkedhashmultiset_customfieldserializerjava>    (37)> - _m_>   guava-gwt/src/com/google/common/collect/linkedlistmultimap_customfieldserializerjava>    (32)> - _m_>   guava-gwt/src/com/google/common/collect/multimap_customfieldserializerbasejava>    (44)> - _m_>   guava-gwt/src/com/google/common/collect/multiset_customfieldserializerbasejava>    (30)> - _m_>   guava-gwt/src/com/google/common/collect/naturalordering_customfieldserializerjava>    (31)> - _m_>   guava-gwt/src/com/google/common/collect/nullsfirstordering_customfieldserializerjava>    (38)> - _m_>   guava-gwt/src/com/google/common/collect/nullslastordering_customfieldserializerjava>    (38)> - _m_>   guava-gwt/src/com/google/common/collect/regularimmutableaslist_customfieldserializerjava>    (37)> - _m_>   guava-gwt/src/com/google/common/collect/regularimmutablebimap_customfieldserializerjava>    (40)> - _m_>   guava-gwt/src/com/google/common/collect/regularimmutablelist_customfieldserializerjava>    (42)> - _m_>   guava-gwt/src/com/google/common/collect/regularimmutablemap_customfieldserializerjava>    (38)> - _m_>   guava-gwt/src/com/google/common/collect/regularimmutablemultiset_customfieldserializerjava>    (35)> - _m_>   guava-gwt/src/com/google/common/collect/regularimmutableset_customfieldserializerjava>    (39)> - _m_>   guava-gwt/src/com/google/common/collect/regularimmutablesortedmap_customfieldserializerjava>    (38)> - _m_>   guava-gwt/src/com/google/common/collect/regularimmutablesortedset_customfieldserializerjava>    (42)> - _m_>   guava-gwt/src/com/google/common/collect/reversenaturalordering_customfieldserializerjava>    (34)> - _m_>   guava-gwt/src/com/google/common/collect/reverseordering_customfieldserializerjava>    (38)> - _m_>   guava-gwt/src/com/google/common/collect/singletonimmutablebimap_customfieldserializerjava>    (29)> - _m_>   guava-gwt/src/com/google/common/collect/singletonimmutablelist_customfieldserializerjava>    (36)> - _m_>   guava-gwt/src/com/google/common/collect/singletonimmutableset_customfieldserializerjava>    (34)> - _m_>   guava-gwt/src/com/google/common/collect/singletonimmutabletable_customfieldserializerjava>    (16)> - _m_>   guava-gwt/src/com/google/common/collect/sparseimmutabletable_customfieldserializerjava>    (20)> - _m_>   guava-gwt/src/com/google/common/collect/table_customfieldserializerbasejava>    (9)> - _m_>   guava-gwt/src/com/google/common/collect/treebasedtable_customfieldserializerjava>    (21)> - _m_>   guava-gwt/src/com/google/common/collect/treemultimap_customfieldserializerjava>    (37)> - _m_>   guava-gwt/src/com/google/common/collect/usingtostringordering_customfieldserializerjava>    (31)> - _m_>   guava-gwt/src/com/google/common/primitives/unsignedlong_customfieldserializerjava>    (21)> - _m_>   guava-testlib/src/com/google/common/collect/testing/abstractcollectiontestsuitebuilderjava>    (66)> - _m_>   guava-testlib/src/com/google/common/collect/testing/abstractcollectiontesterjava>    (37)> - _m_>   guava-testlib/src/com/google/common/collect/testing/abstractcontainertesterjava>    (122)> - _m_>   guava-testlib/src/com/google/common/collect/testing/abstractiteratortesterjava>    (376)> - _m_>   guava-testlib/src/com/google/common/collect/testing/abstractmaptesterjava>    (91)> - _m_>   guava-testlib/src/com/google/common/collect/testing/abstracttesterjava>    (45)> - _m_ guava-testlib/src/com/google/common/collect/testing/anenumjava>    (20)> - _m_>   guava-testlib/src/com/google/common/collect/testing/basecomparablejava>    (26)> - _m_>   guava-testlib/src/com/google/common/collect/testing/collectiontestsuitebuilderjava>    (48)> - _m_>   guava-testlib/src/com/google/common/collect/testing/derivedcollectiongeneratorsjava>    (164)> - _m_>   guava-testlib/src/com/google/common/collect/testing/derivedcomparablejava>    (20)> - _m_>   guava-testlib/src/com/google/common/collect/testing/derivedgeneratorjava>    (27)> - _m_>   guava-testlib/src/com/google/common/collect/testing/derivediteratortestsuitebuilderjava>    (48)> - _m_>   guava-testlib/src/com/google/common/collect/testing/derivedtestiteratorgeneratorjava>    (27)> - _m_>   guava-testlib/src/com/google/common/collect/testing/exampleiteratortesterjava>    (23)> - _m_>   guava-testlib/src/com/google/common/collect/testing/featurespecifictestsuitebuilderjava>    (103)> - _m_ guava-testlib/src/com/google/common/collect/testing/helpersjava>    (126)> - _m_>   guava-testlib/src/com/google/common/collect/testing/iteratorfeaturejava>    (49)> - _m_>   guava-testlib/src/com/google/common/collect/testing/iteratortestsuitebuilderjava>    (38)> - _m_>   guava-testlib/src/com/google/common/collect/testing/iteratortesterjava>    (71)> - _m_>   guava-testlib/src/com/google/common/collect/testing/listiteratortesterjava>    (53)> - _m_>   guava-testlib/src/com/google/common/collect/testing/listtestsuitebuilderjava>    (59)> - _m_>   guava-testlib/src/com/google/common/collect/testing/mapinterfacetestjava>    (160)> - _m_>   guava-testlib/src/com/google/common/collect/testing/maptestsuitebuilderjava>    (139)> - _m_>   guava-testlib/src/com/google/common/collect/testing/minimalcollectionjava>    (64)> - _m_>   guava-testlib/src/com/google/common/collect/testing/minimaliterablejava>    (59)> - _m_>   guava-testlib/src/com/google/common/collect/testing/minimalsetjava>    (46)> - _m_>   guava-testlib/src/com/google/common/collect/testing/navigablemaptestsuitebuilderjava>    (91)> - _m_>   guava-testlib/src/com/google/common/collect/testing/navigablesettestsuitebuilderjava>    (126)> - _m_>   guava-testlib/src/com/google/common/collect/testing/onesizegeneratorjava>    (33)> - _m_>   guava-testlib/src/com/google/common/collect/testing/onesizetestcontainergeneratorjava>    (35)> - _m_>   guava-testlib/src/com/google/common/collect/testing/percollectionsizetestsuitebuilderjava>    (91)> - _m_ guava-testlib/src/com/google/common/collect/testing/platformjava>    (31)> - _m_>   guava-testlib/src/com/google/common/collect/testing/queuetestsuitebuilderjava>    (40)> - _m_>   guava-testlib/src/com/google/common/collect/testing/reserializingtestcollectiongeneratorjava>    (28)> - _m_>   guava-testlib/src/com/google/common/collect/testing/reserializingtestsetgeneratorjava>    (29)> - _m_>   guava-testlib/src/com/google/common/collect/testing/safetreemapjava>    (159)> - _m_>   guava-testlib/src/com/google/common/collect/testing/safetreesetjava>    (137)> - _m_>   guava-testlib/src/com/google/common/collect/testing/sampleelementsjava>    (54)> - _m_>   guava-testlib/src/com/google/common/collect/testing/settestsuitebuilderjava>    (61)> - _m_>   guava-testlib/src/com/google/common/collect/testing/sortedmapinterfacetestjava>    (47)> - _m_>   guava-testlib/src/com/google/common/collect/testing/sortedmaptestsuitebuilderjava>    (80)> - _m_>   guava-testlib/src/com/google/common/collect/testing/sortedsettestsuitebuilderjava>    (69)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testcharacterlistgeneratorjava>    (27)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testcollectiongeneratorjava>    (23)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testcollidingsetgeneratorjava>    (23)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testcontainergeneratorjava>    (59)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testenummapgeneratorjava>    (39)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testenumsetgeneratorjava>    (20)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testintegersetgeneratorjava>    (47)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testintegersortedsetgeneratorjava>    (32)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testiteratorgeneratorjava>    (20)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testlistgeneratorjava>    (20)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testmapentrysetgeneratorjava>    (32)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testmapgeneratorjava>    (23)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testqueuegeneratorjava>    (20)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testsetgeneratorjava>    (20)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testsortedmapgeneratorjava>    (44)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testsortedsetgeneratorjava>    (20)> - _m_>   guava-testlib/src/com/google/common/collect/testing/teststringcollectiongeneratorjava>    (23)> - _m_>   guava-testlib/src/com/google/common/collect/testing/teststringlistgeneratorjava>    (27)> - _m_>   guava-testlib/src/com/google/common/collect/testing/teststringmapgeneratorjava>    (42)> - _m_>   guava-testlib/src/com/google/common/collect/testing/teststringqueuegeneratorjava>    (24)> - _m_>   guava-testlib/src/com/google/common/collect/testing/teststringsetgeneratorjava>    (38)> - _m_>   guava-testlib/src/com/google/common/collect/testing/teststringsortedmapgeneratorjava>    (26)> - _m_>   guava-testlib/src/com/google/common/collect/testing/teststringsortedsetgeneratorjava>    (35)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testsubjectgeneratorjava>    (24)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testunhashablecollectiongeneratorjava>    (30)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testsforlistsinjavautiljava>    (276)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testsformapsinjavautiljava>    (258)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testsforqueuesinjavautiljava>    (146)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testsforsetsinjavautiljava>    (359)> - _m_>   guava-testlib/src/com/google/common/collect/testing/unhashableobjectjava>    (29)> - _m_>   guava-testlib/src/com/google/common/collect/testing/wrongtypejava>    (25)> - _m_>   guava-testlib/src/com/google/common/collect/testing/features/collectionfeaturejava>    (87)> - _m_>   guava-testlib/src/com/google/common/collect/testing/features/collectionsizejava>    (59)> - _m_>   guava-testlib/src/com/google/common/collect/testing/features/conflictingrequirementsexceptionjava>    (29)> - _m_>   guava-testlib/src/com/google/common/collect/testing/features/featurejava>    (20)> - _m_>   guava-testlib/src/com/google/common/collect/testing/features/featureutiljava>    (194)> - _m_>   guava-testlib/src/com/google/common/collect/testing/features/listfeaturejava>    (41)> - _m_>   guava-testlib/src/com/google/common/collect/testing/features/mapfeaturejava>    (63)> - _m_>   guava-testlib/src/com/google/common/collect/testing/features/setfeaturejava>    (27)> - _m_>   guava-testlib/src/com/google/common/collect/testing/features/testerannotationjava>    (31)> - _m_>   guava-testlib/src/com/google/common/collect/testing/features/testerrequirementsjava>    (42)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/abstractbimaptesterjava>    (26)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/abstractlistmultimaptesterjava>    (11)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/abstractmultimaptesterjava>    (34)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/abstractmultisetsetcounttesterjava>    (90)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/abstractmultisettesterjava>    (23)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/bimapcleartesterjava>    (20)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/bimapgeneratorsjava>    (36)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/bimapinversetesterjava>    (25)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/bimapputtesterjava>    (28)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/bimapremovetesterjava>    (20)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/bimaptestsuitebuilderjava>    (50)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/derivedgooglecollectiongeneratorsjava>    (52)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/listgeneratorsjava>    (90)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/listmultimapasmaptesterjava>    (45)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/listmultimapequalstesterjava>    (25)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/listmultimapputalltesterjava>    (11)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/listmultimapputtesterjava>    (6)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/listmultimapremovetesterjava>    (6)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/listmultimapreplacevaluestesterjava>    (11)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/listmultimaptestsuitebuilderjava>    (65)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/mapgeneratorsjava>    (65)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapasmapgettesterjava>    (44)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapasmaptesterjava>    (42)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapcleartesterjava>    (37)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapcontainsentrytesterjava>    (34)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapcontainskeytesterjava>    (23)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapcontainsvaluetesterjava>    (23)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapentriestesterjava>    (50)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapequalstesterjava>    (35)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapfeaturejava>    (23)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapgettesterjava>    (43)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapkeysettesterjava>    (14)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapkeystesterjava>    (40)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapputallmultimaptesterjava>    (72)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapputiterabletesterjava>    (44)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapputtesterjava>    (25)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapremovealltesterjava>    (31)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapremoveentrytesterjava>    (28)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapreplacevaluestesterjava>    (45)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapsizetesterjava>    (25)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimaptestsuitebuilderjava>    (271)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimaptostringtesterjava>    (9)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multimapvaluestesterjava>    (7)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisetaddtesterjava>    (49)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisetcontainstesterjava>    (11)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisetcounttesterjava>    (49)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisetelementsettesterjava>    (26)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisetentrysettesterjava>    (117)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisetequalstesterjava>    (31)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisetfeaturejava>    (21)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisetiteratortesterjava>    (29)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisetnavigationtesterjava>    (43)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisetreadstesterjava>    (64)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisetremovetesterjava>    (100)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisetserializationtesterjava>    (23)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisetsetcountconditionallytesterjava>    (45)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisetsetcountunconditionallytesterjava>    (38)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/multisettestsuitebuilderjava>    (83)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/setgeneratorsjava>    (232)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/setmultimapasmaptesterjava>    (45)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/setmultimapequalstesterjava>    (27)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/setmultimapputalltesterjava>    (9)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/setmultimapputtesterjava>    (9)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/setmultimapreplacevaluestesterjava>    (10)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/setmultimaptestsuitebuilderjava>    (82)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/sortedmapgeneratorsjava>    (47)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/sortedmultisettestsuitebuilderjava>    (245)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/sortedsetmultimapasmaptesterjava>    (14)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/sortedsetmultimapgettesterjava>    (28)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/sortedsetmultimaptestsuitebuilderjava>    (58)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/testbimapgeneratorjava>    (24)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/testenummultisetgeneratorjava>    (26)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/testlistmultimapgeneratorjava>    (24)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/testmultimapgeneratorjava>    (24)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/testmultisetgeneratorjava>    (20)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/testsetmultimapgeneratorjava>    (24)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/teststringbimapgeneratorjava>    (42)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/teststringlistmultimapgeneratorjava>    (39)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/teststringmultisetgeneratorjava>    (24)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/teststringsetmultimapgeneratorjava>    (39)> - _m_>   guava-testlib/src/com/google/common/collect/testing/google/unmodifiablecollectiontestsjava>    (178)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/abstractlistindexoftesterjava>    (54)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/abstractlisttesterjava>    (45)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/abstractqueuetesterjava>    (20)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/abstractsettesterjava>    (25)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectionaddalltesterjava>    (77)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectionaddtesterjava>    (81)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectioncleartesterjava>    (35)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectioncontainsalltesterjava>    (38)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectioncontainstesterjava>    (40)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectioncreationtesterjava>    (32)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectionequalstesterjava>    (33)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectionisemptytesterjava>    (25)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectioniteratortesterjava>    (67)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectionremovealltesterjava>    (57)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectionremovetesterjava>    (58)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectionretainalltesterjava>    (86)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectionserializationequaltesterjava>    (28)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectionserializationtesterjava>    (23)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectionsizetesterjava>    (25)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectiontoarraytesterjava>    (98)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/collectiontostringtesterjava>    (41)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listaddallatindextesterjava>    (47)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listaddalltesterjava>    (38)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listaddatindextesterjava>    (43)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listaddtesterjava>    (37)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listcreationtesterjava>    (24)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listequalstesterjava>    (39)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listgettesterjava>    (25)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listhashcodetesterjava>    (31)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listindexoftesterjava>    (35)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listlastindexoftesterjava>    (34)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listlistiteratortesterjava>    (57)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listremovealltesterjava>    (33)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listremoveatindextesterjava>    (28)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listremovetesterjava>    (39)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listretainalltesterjava>    (30)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listsettesterjava>    (55)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listsublisttesterjava>    (148)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/listtoarraytesterjava>    (37)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/mapcleartesterjava>    (37)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/mapcontainskeytesterjava>    (45)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/mapcontainsvaluetesterjava>    (45)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/mapcreationtesterjava>    (35)> - _m_>   guava-testlib/src/com/google/common/collect/testing/testers/mapentrysettesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/mapequalstesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/mapgettesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/maphashcodetesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/mapisemptytesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/mapputalltesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/mapputtesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/mapremovetesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/mapserializationtesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/mapsizetesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/maptostringtesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/navigablemapnavigationtesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/navigablesetnavigationtesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/platformjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/queueelementtesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/queueoffertesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/queuepeektesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/queuepolltesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/queueremovetesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/setaddalltesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/setaddtesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/setcreationtesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/setequalstesterjava>    (0)> - _i_>   guava-testlib/src/com/google/common/collect/testing/testers/sethashcodetesterjava>    (0)> > patch links:> -  -  > —> reply to this email directly or view it on github>  kevin bourrillion | java librarian | google inc | googlecom || to be clear guava code is currently thoroughly hand-formatted || > but do you follow the guide of java code conventions writen by google?yes  some of our team members are on the committee that writes googles java style guide> if so could you explain me why the eclipse formater produces an invalid format and you have decided to build your own formater? im not sure what you expect here other than ""it generates awkward code or code that doesnt satisfy our style guide no matter how we configure it""> then if i would like to contribute to improve guava how i can configure my editor formater?dont use an automatic formatter format only the lines you change by hand || it seems unproductive to try to give a long explanation of what we found unacceptable about eclipses formatter when we will be releasing our formatter and you can see the differences for yourself || perfect thanks for recovering my text and answer my questions :) || @rpau your comment was posted four times so i removed the redundant copies but left one in place  i wonder if maybe someone else was trying to do that at the same time  sorry about that || ";;;;0;1;;
1971;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;add support for creating constructors without using objenesis (and unsafe api);this pr adds code to constructors to allow short-wiring a constructor without avoiding to call it  thus making the use of objenesis obsolete. this is desired since objenesis relies on unsafe api which is deprecated and will be removed in a future release.;;0;add support for creating constructors without using objenesis (and unsafe api);this pr adds code to constructors to allow short-wiring a constructor without avoiding to call it thus making the use of objenesis obsolete this is desired since objenesis relies on unsafe api which is deprecated and will be removed in a future releasethe idea is as follows: any constructor for a class:```javaclass foo extends bar {  foo() {    super(somethingwithsideeffect())  }}```is rewritten as follows:```javaclass foo {  foo() {    if (mockdispatcherismockedconstruction()) {      super(null)      return    }    super(somethingwithsideeffect())  }}```the mock dispatcher then applies a thead-local check to see if the current construction is supposed to be short-wired and suppresses the original construction in such a case the check is repeated along the super class hierarchy until reaching the `object` constructor which is by definition side-effect free as a result a mock was created without triggering any user code and without relying on unsafe api; merging 1971 ;;;;1;1;add support for creating constructors without using objenesis (and unsafe api);
1971;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;add support for creating constructors without using objenesis (and unsafe api);this pr adds code to constructors to allow short-wiring a constructor without avoiding to call it  thus making the use of objenesis obsolete. this is desired since objenesis relies on unsafe api which is deprecated and will be removed in a future release.;;0;make row type comparable;this pr addresses #1957 to make `row` type comparable and implements the `equal` and `not_equal` operators for the `row` type;"@martint can you look at the two places i tagged you? || great let me know when youve updated this @nezihyigitbasi  || @cberner updated || looks like this is on the right track let me know when youve addressed the comments || @cberner updated thanks for the reviewone issue is when the type inside a row is not comparable and since we specify a comparable type is required in the signature the analyzer fails with ""function not registered"" instead of ""function requires a comparable argument"" i think we should open an issue to fix that i guess one of the main issues is that method `signaturematchandbind` returns a boolean and when it returns false it doesnt tell the reason why it cant bind parameters and the analyzer just says it cant find a suitable function to call  || ya totally agree that we should have a better error message there but right now theres no support for those i think @martint has some ideas for a better type analysis system but thats probably a ways down the road || looks almost right back to you for a few more comments || @cberner addressed your comments ||  ";;;;0;1;;
1971;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;add support for creating constructors without using objenesis (and unsafe api);this pr adds code to constructors to allow short-wiring a constructor without avoiding to call it  thus making the use of objenesis obsolete. this is desired since objenesis relies on unsafe api which is deprecated and will be removed in a future release.;;0;update gradle files;the project doesnt open in the android studio 10 lots of dsl error there are many dependencies in projects buildgradle whereas any newly created project contains these lines in projects buildgradle```// note: do not place your application dependencies here they belong// in the individual module buildgradle files  ```;;;;;0;1;;
1974;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1855 and #939: improve error message when the inline mock maker cannot be used.;improves the error message and does not create a hard dependency on the compiler module. it also points out that byte buddy can now emulate the attachment api using jna if it s added to the class path.;;0;allow greater access to the smoothbursty rate limiter;create a method such as `create(permitspersecond maxburst timeunit)` so that the full functionality of the `smoothbursty` class can be utilised**use case**use a `ratelimiter` when the rate is applied on a wider timescale than just a single second an example of this would be the github api which has a rate limit of 5000 per hour;i guess this is a duplicate of #1707that being sad i would also appreciate this being made available we would like to limit sending out notification emails with something like a low hourly limit but a burst size of 10-15 minutes || we need bursting as well  sad to have to reinvent the wheel || ping on this || we recently switched from guava to  due to this issue it helped us a lot to implement rate limiting with bursts || also interested in this || we released a small library for this:  || agreed with @philippwendler that this is a dupduplicate of #1707  || duplicate of #1707 ||;;;;0;1;;
1974;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1855 and #939: improve error message when the inline mock maker cannot be used.;improves the error message and does not create a hard dependency on the compiler module. it also points out that byte buddy can now emulate the attachment api using jna if it s added to the class path.;;0;add the symbols from sample node;sampling table with `poissonized` (such as `select * from table tablesample poissonized (10) rescaled`) would get the error `javalangillegalargumentexception: key $sampleweight not present in map` this issue was also reported before in #1307that problem is due to that the output symbols of sample node are not imported this pr adds the symbols of sample node and fixes this problem;looks good can you add a unit test? then we can merge this || thanks unit test is added || thanks but i guess i meant to say integration test: can you add a query to abstracttestqueries or abstracttestapproximatequeries that reproduces the failure? || new commit only adds sample weight symbol || about the integration test this problem will only occur when the parameter `createsinglenodeplan` of `distributedlogicalplanner` is set to `false` but in the `localqueryrunner` used  abstracttestqueries` `createsinglenodeplan` is set to `true` when constructing `distributedlogicalplanner` so adding a query to `abstracttestqueries` can not reproduce the failure any suggestion? to keep the unit test i added?  ah youre right i think this was refactored since i looked at it last take a look at `abstracttestdistributedqueries` that sounds like it does what you want || thanks the test is added to `abstracttestdistributedqueries` || ;;;;0;1;;
1974;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1855 and #939: improve error message when the inline mock maker cannot be used.;improves the error message and does not create a hard dependency on the compiler module. it also points out that byte buddy can now emulate the attachment api using jna if it s added to the class path.;;0;update wiki to reference latest rxandroid (023) with new groupid/artifactid;see  where ive made this changei made this issue to ensure someone was aware of this change and that this was the correct thing to do if so please just confirm & close this issue;lgtm ;;;;0;1;;
1974;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;1855 and #939: improve error message when the inline mock maker cannot be used.;improves the error message and does not create a hard dependency on the compiler module. it also points out that byte buddy can now emulate the attachment api using jna if it s added to the class path.;;1855.0;1855 and #939: improve error message when the inline mock maker cannot be used;improves the error message and does not create a hard dependency on the compiler module it also points out that byte buddy can now emulate the attachment api using jna if its added to the class path; merging 1974 ;javaxtoolstoolprovider could not be found in inlinebytebuddymockmaker;"hi guysim encountering a crash when i run `androidtest` that contain mocking class cause the bytebuddy didnt found `javaxtoolstoolprovider` i tried to reinstall jdk 8 but doesnt work it seems to be `javaxtoolstoolprovider` not existing in it could you guys help me please?cheernatthawut## environment------------------------------------------------------------gradle 541------------------------------------------------------------build time:   2019-04-26 08 42 utcrevision:     261d171646b36a6a28d5a19a69676cd098a4c19dkotlin:       1321groovy:       254ant:          apache ant(tm) version 1913 compiled on july 10 2018jvm:          180_231 (oracle corporation 25231-b11)os:           mac os x 10152 x86_64## dependencies```    implementation filetree(dir: libs include: [*jar])    implementation""orgjetbrainskotlin:kotlin-stdlib-jdk8:$kotlin_version""    implementation androidxappcompat 110    implementation androidxcore:core-ktx:110    implementation androidxconstraintlayout 113    testimplementation junit 412    testimplementation orgmockito:mockito-core:324    androidtestimplementation androidxtestext 111    androidtestimplementation androidxtestespresso:espresso-core:320    androidtestimplementation orgmockito:mockito-android:324    androidtestimplementation ""iomockk:mockk-android:193kotlin12"## strack trace```e/testrunner: failed: mockfoo(cosamplemockitoandroidmockwithmockitotest)    ----- begin exception -----e/testrunner: javalangillegalstateexception: could not initialize plugin: interface orgmockitopluginsmockmaker (alternate: null)        at orgmockitointernalconfigurationpluginspluginloader$1invoke(pluginloaderjava:74)        at javalangreflectproxyinvoke(proxyjava:1006)        at $proxy3istypemockable(unknown source)        at orgmockitointernalutilmockutiltypemockabilityof(mockutiljava:29)        at orgmockitointernalutilmockcreationvalidatorvalidatetype(mockcreationvalidatorjava:22)        at orgmockitointernalcreationmocksettingsimplvalidatedsettings(mocksettingsimpljava:241)        at orgmockitointernalcreationmocksettingsimplbuild(mocksettingsimpljava:229)        at orgmockitointernalmockitocoremock(mockitocorejava:62)        at orgmockitomockitomock(mockitojava:1908)        at orgmockitomockitomock(mockitojava:1817)        at cosamplemockitoandroidmockwithmockitotest<init>(mockwithmockitotestkt:17)        at javalangreflectconstructornewinstance0(native method)        at javalangreflectconstructornewinstance(constructorjava:343)        at orgjunitrunnersblockjunit4classrunnercreatetest(blockjunit4classrunnerjava:217)        at orgjunitrunnersblockjunit4classrunner$1runreflectivecall(blockjunit4classrunnerjava:266)        at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)        at orgjunitrunnersblockjunit4classrunnermethodblock(blockjunit4classrunnerjava:263)        at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)        at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)        at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)        at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)        at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)        at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)        at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)        at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)        at androidxtestextjunitrunnersandroidjunit4run(androidjunit4java:104)        at orgjunitrunnerssuiterunchild(suitejava:128)        at orgjunitrunnerssuiterunchild(suitejava:27)        at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)        at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)        at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)        at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)        at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)        at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)        at orgjunitrunnerjunitcorerun(junitcorejava:137)        at orgjunitrunnerjunitcorerun(junitcorejava:115)        at androidxtestinternalrunnertestexecutorexecute(testexecutorjava:56)        at androidxtestrunnerandroidjunitrunneronstart(androidjunitrunnerjava:392)        at androidappinstrumentation$instrumentationthreadrun(instrumentationjava:2145)     caused by: javalangnoclassdeffounderror: failed resolution of: ljavax/tools/toolprovider        at orgmockitointernalcreationbytebuddyinlinebytebuddymockmaker<init>(inlinebytebuddymockmakerjava:172)        at javalangclassnewinstance(native method)        at orgmockitointernalconfigurationpluginsplugininitializerloadimpl(plugininitializerjava:49)        at orgmockitointernalconfigurationpluginspluginloaderloadplugin(pluginloaderjava:57)        at orgmockitointernalconfigurationpluginspluginloaderloadplugin(pluginloaderjava:44)        at orgmockitointernalconfigurationpluginspluginregistry<init>(pluginregistryjava:22)        at orgmockitointernalconfigurationpluginsplugins<clinit>(pluginsjava:19)        at orgmockitointernalconfigurationpluginspluginsgetmockmaker(pluginsjava:35)        at orgmockitointernalutilmockutil<clinit>(mockutiljava:24)        at orgmockitointernalutilmockutiltypemockabilityof(mockutiljava:29)         at orgmockitointernalutilmockcreationvalidatorvalidatetype(mockcreationvalidatorjava:22)         at orgmockitointernalcreationmocksettingsimplvalidatedsettings(mocksettingsimpljava:241)         at orgmockitointernalcreationmocksettingsimplbuild(mocksettingsimpljava:229)         at orgmockitointernalmockitocoremock(mockitocorejava:62)         at orgmockitomockitomock(mockitojava:1908)         at orgmockitomockitomock(mockitojava:1817)         at cosamplemockitoandroidmockwithmockitotest<init>(mockwithmockitotestkt:17)         at javalangreflectconstructornewinstance0(native method)         at javalangreflectconstructornewinstance(constructorjava:343)         at orgjunitrunnersblockjunit4classrunnercreatetest(blockjunit4classrunnerjava:217)         at orgjunitrunnersblockjunit4classrunner$1runreflectivecall(blockjunit4classrunnerjava:266)         at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)         at orgjunitrunnersblockjunit4classrunnermethodblock(blockjunit4classrunnerjava:263)         at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)         at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)         at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)         at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)         at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)         at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)         at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)         at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)         at androidxtestextjunitrunnersandroidjunit4run(androidjunit4java:104)         at orgjunitrunnerssuiterunchild(suitejava:128)         at orgjunitrunnerssuiterunchild(suitejava:27)         at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)         at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)         at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)         at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)         at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)         at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)         at orgjunitrunnerjunitcorerun(junitcorejava:137)         at orgjunitrunnerjunitcorerun(junitcorejava:115)         at androidxtestinternalrunnertestexecutorexecute(testexecutorjava:56)         at androidxtestrunnerandroidjunitrunneronstart(androidjunitrunnerjava:392)         at androidappinstrumentation$instrumentationthreadrun(instrumentationjava:2145)      caused by: javalangclassnotfoundexception: didnt find class ""javaxtoolstoolprovider"" on path: dexpathlist[[zip file ""/system/framework/androidtestrunnerjar"" zip file ""/system/framework/androidtestmockjar"" zip file ""/data/app/cosamplemockitoandroidtest-zjfawug-    ----- end exception -----```<img width""968"" alt""screen shot 2563-01-07 at 12 45 26"" src""https://user-imagesentcom/2638321/71871412-a93ee100-314b-11ea-9815-31a5d95056d4png"">[mockitoandroidzip](https://githubcom/mockito/mockito/files/4029049/mockitoandroidzip)";i think this commit is part of the problem:  || > i think this commit is part of the problem:  tried with mockito 2220 which should be a release before  the commit but the error is still there  what  the issue for me was removing the `mock-maker-inline` resource file || the inline mockmaker is not supported on android (as listed in the exception) however we should probably not crash before we can show that message to the user i would welcome a pr to fix this problem || @timvdlippe what should people do for android then? kotlin uses final classes only || @raphw what is our advice for android? i dont remember what our final resolution was for inline + android for kotlin || i just started using  its kotlin friendly also || on android the inline mock maker wont work (neither will mockk which uses the same approach as we do) it does not support the instrumentation api alltogetheri do agree that the error message is misleading currently preparing a pr to improve this || you can achieve this by using comlinkedindexmaker:dexmaker-mockito-inline for apis > 28 ||;1;0;1855 and #939: improve error message when the inline mock maker cannot be used;
1978;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix javadoc invalid syntax;escape @ character to html entity.;;0;" presentor should ""short circuit""";"currently presentor(argument) does null check on argument causing it not to ""short circuit"" the or so if aor(b()) is called b() will always be executed even though a ispresent() this is not consistent to javas standard or operator";"aor( whatever() ) will always run whatever() there is nothing you can do on thu feb 19 2015 at 10 27 pm yohan notifications@githubcom wrote:> currently presentor(argument) does null check on argument causing it not> to ""short circuit"" the or so if aor(b()) is called b() will always be> executed even though a ispresent() this is not consistent to javas> standard or operator> > —> reply to this email directly or view it on github>  || you can do [`optionalor(supplier)`]( || ";;;;0;1;;
1978;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix javadoc invalid syntax;escape @ character to html entity.;;0;fix javadoc invalid syntax;escape @ character to html entityfixes https://githubcom/mockito/mockito/issues/1977; merging 1978 ;;;;1;1;fix javadoc invalid syntax;
1978;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix javadoc invalid syntax;escape @ character to html entity.;;0;reduce gc pressure on coordinator;;;;;;0;1;;
1984;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo;this pr fixes a typo.;;0;add a weight() method to cache;"cache objects currently do not have a method of introspecting on the current ""weight"" value  i am replacing an implementation of a cache that is just a synchronized linkedhashmap  in my current implementation of the cache im keeping track of the weights of things being stored and exposing that as a metric about my cache  this is the _only_ feature of my current implementation that is not covered by guavas cachefrom looking at the code it seemed relatively easy to just create another method parallel to `size()` to handle this case so i just went ahead and did it  the guidelines do state that api changes should start as an issue but i didnt realize that until i had already done this and it is such a simple fix it doesnt bother me if it gets thrown away (as long as i do get some method of introspecting on the current weight value ) )i do realize that this is a public api change it is only an addition but it does mean that if anyone else is implementing the cache interface from scratch their code will have to be updated before it can work with this  im not sure what level of api compatibility is maintained with guava but as long as people are only using guava-built cache objects it should be a forward-compatible changealso i updated unit tests as i could find ones that seemed relevant but i will admit that i didnt read and comprehend all tests so i mightve missed a good place to add some more verification of the weight computation  let me know if there are other tests to update and ill be happy toif you think this is going to work let me know and ill make sure to get a cla";  it seems to be failing when trying to generate the gwt source  ill see if i can repro the failure on my local machine and try to fix but any pointers to what might cause the gwt compilation to fail would be helpful || ok on my local machine i cannot seem to download comgoogleguava java-source:190-snapshotlooks like it is not in sonatype-nexus-snapshotsso its failing but for a different reason  i guess ill wait on fixing that until the discussion of whether this api change could even be considered has happened || the predecessor [concurrentlinkedhashmap]( introduced the concept of weights and provides a `weightedsize` method that may be a simpler migration path (note: currently moving to github due to google code shutdown)the jdk8 rewrite [caffeine]( exposes additional inspection including the weighted size through the `policy` abstraction that project is maturing quickly but not yet released || @ben-manes so are you suggesting that instead of using a `cache` in my code i use `concurrentlinkedhashmap`?cant really use something that isnt released yet :) || im offering it as an option as your changes may not be accepted and you would have to wait for the next release if they are if all you need are the basic features of its predecessor then its a reasonable option the old wiki is in the github wiki branch since the migration didnt move it over properly ||  ||;;;;0;1;;
1984;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo;this pr fixes a typo.;;0;fix typo;this pr fixes a typo; merging 1984 ;;;;1;1;fix typo;
1984;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo;this pr fixes a typo.;;0;replace murmur3 with xxhash;;;;;;0;1;;
1989;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;rewrite mods exporter and add test for it;regarding: #1920  rewrite the mods exporter with a jaxb parser.  details on the format and the newest xml schema can be found [here]( i ve used the newest schema (version 3.6). this pr uses the same gradle script and schema as in #1942 .  -  internal qs -   -  manually tested changed features in running jabref;;0;implement json equality operators;"this pr implements the equality operators for the json type and updates the current `equalto()` implementation to use the jackson library instead of just checking the equality of the backing slices the reason is that the equality implementation of the jackson library seems to be closer (not sure whether it implements the spec completely) to the ietf spec (see  than just checking the equality of the backing slices for example the below test fails with the current implementation while it is ok according to the spec && the new implementation:```assertfunction(""cast({\""a\"":1 \""b\"":2} as json)  cast({\""b\"":2 \""a\"":1} as json)"" true)```i guess with this pr #1857 is now addressed";let me know when youve updated this || @cberner addressed your comments  ;;;;0;1;;
1989;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;rewrite mods exporter and add test for it;regarding: #1920  rewrite the mods exporter with a jaxb parser.  details on the format and the newest xml schema can be found [here]( i ve used the newest schema (version 3.6). this pr uses the same gradle script and schema as in #1942 .  -  internal qs -   -  manually tested changed features in running jabref;;1988.0;do not pass static mocks to regular listener callback;does not include static mocks in regular listener logic as it might distort existing mock collectors that do not expect scoped mocks 1988we have passed `class` objects to the listener to indicate a static mock the class object is of course itself not a regular mock and its cleaner to create a callback method of its own this way existing listeners remain logically backwards compatible including our own listener that is used within the junit runner (we have only tested the rule i added a test for the runner too); merging 1989 ;mockitojunitrunner causes npe when using @mock on mockedstatic fields;check that -  the mockito message in the stacktrace have useful information but it didnt help -  the problematic code (if thats possible) is copied here       note that some configuration are impossible to mock via mockito -  provide versions (mockito / jdk / os / any other relevant information) -  provide a [short self contained correct (compilable) example]( of the issue       (same as any question on stackoverflowcom) -  read the [contributing guide]( - mockito: 344 - junit: 412 - jdk: 18 - os: windows 10**example:**1 [mockitojunitrunnerwithmockedstatictest](    * reproduces the problem documented in this issue1 [mockitoopenmocksmockedstatictest](    * same tests but manually opens and closes the mocks (doesnt use the runner) shows the tests are ran as expected**problem:**the `mockitojunitrunner` is causing a `nullpointerexception` when the test class contains a `@mock` instance field with a type of `mockedstatic` this exception only occurs for tests that are ran after a prior test fails if all the tests pass there are no issuesstack trace (test 1):```javalangassertionerror: intentional failure	at orgjunitassertfail(assertjava:88)	at orgmockitoexamplemockitojunitrunnerwithmockedstatictesttestname1(mockitojunitrunnerwithmockedstatictestjava:40)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)	at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)	at orgmockitointernalrunnersdefaultinternalrunner$1$1evaluate(defaultinternalrunnerjava:54)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orgmockitointernalrunnersdefaultinternalrunner$1run(defaultinternalrunnerjava:99)	at orgmockitointernalrunnersdefaultinternalrunnerrun(defaultinternalrunnerjava:105)	at orgmockitointernalrunnersstrictrunnerrun(strictrunnerjava:40)	at orgmockitojunitmockitojunitrunnerrun(mockitojunitrunnerjava:163)	at orgeclipsejdtinternaljunit4runnerjunit4testreferencerun(junit4testreferencejava:86)	at orgeclipsejdtinternaljunitrunnertestexecutionrun(testexecutionjava:38)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:538)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:760)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerrun(remotetestrunnerjava:460)	at orgeclipsejdtinternaljunitrunnerremotetestrunnermain(remotetestrunnerjava:206)orgmockitoexceptionsmisusingnotamockexception: argument passed to mockitomockingdetails() should be a mock but is an instance of class javalangclass!	at orgmockitointernalrunnersdefaultinternalrunner$1$2testfinished(defaultinternalrunnerjava:81)	at orgjunitrunnernotificationsynchronizedrunlistenertestfinished(synchronizedrunlistenerjava:56)	at orgjunitrunnernotificationrunnotifier$7notifylistener(runnotifierjava:190)	at orgjunitrunnernotificationrunnotifier$safenotifierrun(runnotifierjava:72)	at orgjunitrunnernotificationrunnotifierfiretestfinished(runnotifierjava:187)	at orgjunitinternalrunnersmodeleachtestnotifierfiretestfinished(eachtestnotifierjava:38)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:331)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orgmockitointernalrunnersdefaultinternalrunner$1run(defaultinternalrunnerjava:99)	at orgmockitointernalrunnersdefaultinternalrunnerrun(defaultinternalrunnerjava:105)	at orgmockitointernalrunnersstrictrunnerrun(strictrunnerjava:40)	at orgmockitojunitmockitojunitrunnerrun(mockitojunitrunnerjava:163)	at orgeclipsejdtinternaljunit4runnerjunit4testreferencerun(junit4testreferencejava:86)	at orgeclipsejdtinternaljunitrunnertestexecutionrun(testexecutionjava:38)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:538)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:760)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerrun(remotetestrunnerjava:460)	at orgeclipsejdtinternaljunitrunnerremotetestrunnermain(remotetestrunnerjava:206)```stack trace (test 2):```javalangnullpointerexception	at orgmockitoexamplemockitojunitrunnerwithmockedstatictesttestname2(mockitojunitrunnerwithmockedstatictestjava:54)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)	at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)	at orgmockitointernalrunnersdefaultinternalrunner$1$1evaluate(defaultinternalrunnerjava:54)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orgmockitointernalrunnersdefaultinternalrunner$1run(defaultinternalrunnerjava:99)	at orgmockitointernalrunnersdefaultinternalrunnerrun(defaultinternalrunnerjava:105)	at orgmockitointernalrunnersstrictrunnerrun(strictrunnerjava:40)	at orgmockitojunitmockitojunitrunnerrun(mockitojunitrunnerjava:163)	at orgeclipsejdtinternaljunit4runnerjunit4testreferencerun(junit4testreferencejava:86)	at orgeclipsejdtinternaljunitrunnertestexecutionrun(testexecutionjava:38)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:538)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerruntests(remotetestrunnerjava:760)	at orgeclipsejdtinternaljunitrunnerremotetestrunnerrun(remotetestrunnerjava:460)	at orgeclipsejdtinternaljunitrunnerremotetestrunnermain(remotetestrunnerjava:206)```**investigation:**after some investigation it appears the first test is failing twice (once in the test and once in the testfinished listener) this code: 81 is where it fails the second time if we navigate down the call hierarchy it appears it fails because the static mock has already been cleaned up so the framework doesnt think its a mock and fails with a `notamockexception`  since it fails there it doesnt set the listener to null which will in-turn result in the mocks not being initialized on the next test thats ran (hits line 51): the mocks are not initialized for the second test it ultimately causes the `nullpointerexception`its also causing the remaining tests after the first test failure to bounce back and forth between `nullpointerexception` and `notamockexception` the reason for this appears to be because [this failure]( object never gets reset after its processed so it keeps restarting the chain of throwing the two exceptions back and forthalso i did include a sample test that manually opens and closes the mocks (doesnt use mockitojunitrunner) and everything is working as expected using the try-with-resource works fine as welli did investigate further and noticed something related to this might have been addressed in [this pr]( it only updated the findstubbings method to skip the static mocks though was the allinvocationsfinderfind() method intentional left out of that or just an oversight?;just tried the tests with using mockitorule and its working as expected as well || @raphw this issue still exists in 346 was the pr supposed to fix all of this or only a part of it? the linked example above still causes npe this one: [mockitojunitrunnerwithmockedstatictest]( || i was under the impression that i  it but i will take another look if it is not i refactored your test and added it to the built but maybe i broke it in the process || i just ran the test with the latest mocktio and it works as expected are you sure that you are running the right version?  || yep just doubled checked its using 346 are you running my test class (without modification) or your refactored version of it? if you modified it can you send me modified one and ill double check it || copy pasted it as it is i to the release/3x branch  || okay sorry for the confusion when i was investigating this issue on july 25 i must have installed into locally and it got shoved into my local m2 repo as 346 without the fix then when you fixed it and i updated the pom version to point to 346 it didnt redownload it because it was already in my local repoi deleted it from my local m2 repo and redownloaded it from maven-central everything is good now  perfect gradle does not work with snapshot versions happened to me a few times too  ||;1;0;does not include static mocks in regular listener logic as it might distort existing mock collectors that do not expect scoped mocks 1988;
1991;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;some minor code cleanups;not thrown exceptions etc.;;0;mockitoverify(): fix typo in javadoc;i noted this while reading the javadocs in my ide they were referring to a `get(0)` reference which isnt quite easy to grasp in this context   after looking at this class a bit more i think its just a copy-paste mistake from this line in the class-level javadocs: https://githubcom/mockito/mockito/blob/release/3x/src/main/java/org/mockito/mockitojava#l212; merging 1991 ;;;;1;1;mockitoverify(): fix typo in javadoc;
1991;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;some minor code cleanups;not thrown exceptions etc.;;0;query input rows/size stats not tracked properly for join queries;the query-level stats only include the row/size from the leaf stage the should include the inputs for all stages that perform table scansfor example:```1:20 [ 130m rows 141gb] [164m rows/s  182mb/s] [  <>                                     ]     stages   rows  rows/s  bytes  bytes/s  queued    run   done0r      0       0     0b       0b       0      1      0  1r      0       0     0b       0b       0     20      0    2s    13b    163m  182t    234g    1478   8870  27560      3f  431m       0  238g       0b       0      0     20        4f   130m       0  141g       0b       0      0   2363```the bug is possibly due to the following check in `querystatemachinegetqueryinfo()` line 193:``` javaif (stageinfogetsubstages()isempty()) {```;;;;;0;1;;
1994;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo in contributing.md and spyoninjectedfieldshandler;fix typo in contributing.md and spyoninjectedfieldshandler.java;;0;make it easier to implement cache with similar functionality to localcache;im implementing my own `cache` and there are several features of `localcache` that i would like to copy that i currently cant because the relevant methods are package-access:1 `removalnotification` constructor is package-private meaning `removallistener` cant be used in custom caches2 `cacheloaderunsupportedloadingoperationexception` is package-private so custom caches cannot replicate the localcache behaviour of falling back on `load` if `loadall` is not implementedalso `abstractcache` could do a bit more with default implementations of the `cache` methods for example `get(k callable)` could have a basic body using `getifpresent` and `put` and `abstractloadingcache` could check for and throw `invalidcacheloadexception` or `executionexception` itself when loading;1 while ugly the best short-term solution is to write a factory class that resides in the guava package2 the reason that the `unsupportedloadingoperationexception` is package-private is that it should never be thrown by user code instead the intent was to switch to using reflection to determine at configuration-time if the `loadall` method was implemented that would avoid the unnecessary exception bloat that occurs i think that performance change was lost in the backlog so the rational isnt obvious || `removalnotification` now has a public factory:  i dont think were at a point where all you want is public || were unlikely to make significant changes to commoncache we recommend [caffeine]( ||;;;;0;1;;
1994;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo in contributing.md and spyoninjectedfieldshandler;fix typo in contributing.md and spyoninjectedfieldshandler.java;;0;fix typo in contributingmd and spyoninjectedfieldshandler;fix typo in contributingmd and spyoninjectedfieldshandlerjava; ;;;;1;1;fix typo in spyoninjectedfieldshandler todo;
1994;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo in contributing.md and spyoninjectedfieldshandler;fix typo in contributing.md and spyoninjectedfieldshandler.java;;0;add ntile window function;;;;;;0;1;;
1996;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;add invoker api to allow for alternative invocation modes to better support the module system.;adds a  memberaccessor  abstraction for accessing fields  methods and constructors where the default implementation  reflectionmemberaccessor  implements the current behavior of using reflection and  setaccessible .;;0;atomicdouble post-jdk5 optimization;atomicdouble has the following code including comment  it is my understanding that guava has dropped jdk 15 support so the code optimization in comments can be applied``` java  public final void lazyset(double newvalue) {    set(newvalue)    // todo(user): replace with code below when jdk5 support is dropped    // long next  doubletorawlongbits(newvalue)    // updaterlazyset(this next)  }```;;;;;0;1;;
1996;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;add invoker api to allow for alternative invocation modes to better support the module system.;adds a  memberaccessor  abstraction for accessing fields  methods and constructors where the default implementation  reflectionmemberaccessor  implements the current behavior of using reflection and  setaccessible .;;0;add invoker api to allow for alternative invocation modes to better support the module system;adds a `memberaccessor` abstraction for accessing fields methods and constructors where the default implementation `reflectionmemberaccessor` implements the current behavior of using reflection and `setaccessible` also this pr adds a new implementation `modulememberaccessor` where the instrumentation api is leveraged to open modules to mockito before using method handles to access any such member this way module boundaries are no longer stopping mockito from functioning on java 9 and onwards since the instrumentation api is already used by the inline-mock-maker it is enabled for this mock maker by default; merging 1996 ;;;;1;1;add invoker api to allow for alternative invocation modes to better support the module system;
1996;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;add invoker api to allow for alternative invocation modes to better support the module system.;adds a  memberaccessor  abstraction for accessing fields  methods and constructors where the default implementation  reflectionmemberaccessor  implements the current behavior of using reflection and  setaccessible .;;0;skip partition pruning during predicate pushdown for queries that cant benefit from it;the partition pruning logic triggered by the predicate pushdown optimizer can get very expensive for tables with hundreds of thousands of partitions there are some queries that cant benefit from partition pruning at all so trying to enumerate them eagerly is costly and introduces unnecessary latency eg``` sqlselect * from t limit 10`````` sqlselect * from t where pred(<non-partition-column>) limit 10```here are a couple of ideas on how we could improve this further analysis is needed to determine whether they are reasonable changes and what impact they may have:- keep track of whether the pushdown optimizer needs partition information as it walks down the plan (eg due to joins or where clauses) and only ask for partitions from the splitmanager if necessary- avoid enumerating partitions in connectors if the effective predicate is over non-partition-key columns;this issue has been automatically marked as stale because it has not had recent activity it will be closed if no further activity occurs ||;;;;0;1;;
2003;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;pre release 3.5.0;merged several pull requests into a branch prior to release.;;0;pre release 350;merged several pull requests into a branch prior to release; merging 2003 ;;;;1;1;merging constructor mocks with safe accessibility whilst fixing use of reflection where new deprecations are better considered;
2003;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;pre release 3.5.0;merged several pull requests into a branch prior to release.;;0;validate types for in subquery expression;;;;;;0;1;;
2004;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;remove help suffix at help pages;implements  in jabref.;;0;"documentation error in cachesexplained section ""interruption""";" in an exceptionexception)""should probably be""(wrapped in an executionexception)""";i dont see the difference? || exceptionexception vs executionexception??? || ah that was silly  done ||;;;;0;1;;
2004;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;remove help suffix at help pages;implements  in jabref.;;0;pre release 350;merged several pull requests into a branch prior to release; merging 2004 ;;;;1;1;merging constructor mocks with safe accessibility whilst fixing use of reflection where new deprecations are better considered;
2004;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;remove help suffix at help pages;implements  in jabref.;;0;throw proper exception when memory size exceeded in topn;;;;;;0;1;;
2006;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;introduce animal sniffer;introduces animal sniffer with exclusion of inline-mock-maker classes which would never be present on android. avoids calling invoke/invokeexact methods of handles directly but rather puts the invocations into generated code to avoid breaking android builds.;;0;provide treetraverserfromfunction(function);"instead of implementing treetraverserchildren(t) in anonymous classes each time a function that retrieves children from each node could be handy alsowhat about this static method at treetraverser ``` javastatic <t> treetraverser<t> fromfunction(final function<? super t ? extends iterable<? extends t>> descendants) {  return new treetraverser ()}```and a possible implementation as proposal``` java/** * @see traversers#fromfunction(function) */static final class treetraverserfromfunction<t> extends treetraverser<t> {  private final function<? super t ? extends iterable<? extends t>> descendants  treetraverserfromfunction(final function<? super t ? extends iterable<? extends t>> children) {    descendants  checknotnull(children)  }  @override  public iterable<t> children(final t root) {    @suppresswarnings(""unchecked"")    final iterable<t> checkediterable  (iterable<t>) descendantsapply(root)    return checkediterable  }  @override  public string tostring() {    return ""treetraverserfromfunction("" + descendants + "")""  }}```";i think the chances of this being accepted are high given that we did the exact same thing for converter and cacheloader its very annoying in jdk 8 to be unable to use a lambda i would call the method treetraverserfrom()  and id go ahead with the unchecked cast in the constructor so the field can just be a plain old function<t iterable<t>>  || id prefer to find a method name that made clearer what the function was being used for -- to get the children of a node || +1 || i see this has been completed now (at least to some extent)does any more work need to be done on this (like doing a lambda version of `binarytreetraverser`)? or can this issue be closed now? || yeah we still need to do it for binarytreetraverser tooon sat sep 24 2016 at 11:43 am jonathan bluett-duncan <notifications@githubcom> wrote:> i see this has been completed now (at least to some extent)> > does any more work need to be done on this (like doing a lambda version of> binarytreetraverser)? or can this issue be closed now?> > —> you are receiving this because you commented> reply to this email directly view it on github>  or mute> the thread>  ## kevin bourrillion | java librarian | google inc | googlecom || i believe this is taken care of by [`commongraphtraverserfortree(successorsfunction)`]( once its implemented (which should be very soon) ||;;;;0;1;;
2006;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;introduce animal sniffer;introduces animal sniffer with exclusion of inline-mock-maker classes which would never be present on android. avoids calling invoke/invokeexact methods of handles directly but rather puts the invocations into generated code to avoid breaking android builds.;;0;introduce animal sniffer;introduces animal sniffer with exclusion of inline-mock-maker classes which would never be present on android avoids calling invoke/invokeexact methods of handles directly but rather puts the invocations into generated code to avoid breaking android builds; merging 2006 ;;;;1;1;do not use invoke/invokeexact directly but from generated code to avoid breaking android builds which cannot process these methods;
2006;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;introduce animal sniffer;introduces animal sniffer with exclusion of inline-mock-maker classes which would never be present on android. avoids calling invoke/invokeexact methods of handles directly but rather puts the invocations into generated code to avoid breaking android builds.;;0;change tpch dates to be date type;fix date handling bugs in query tests kafka tests and jdbc connectormap date to text in cassandra connector;;;;;0;1;;
2013;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;[ci maven-central-release] constructor dispatch;use constructor instantiation if explicitly specified.;;0;cancelling the output of futurestransform/catching should eagerly null out its fields;well have to make sure that `run()` methods are resilient to this of course currently for `futurestransform` we let `run()` do its thing even if the output has been cancelled! (were about to fix that);;;;;0;1;;
2013;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;[ci maven-central-release] constructor dispatch;use constructor instantiation if explicitly specified.;;0;[ci maven-central-release] constructor dispatch;use constructor instantiation if explicitly specified;;;;;1;1;attempts to fix stack overflow error;
2013;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;[ci maven-central-release] constructor dispatch;use constructor instantiation if explicitly specified.;;0;presto client return 0 even when query failed;presto client always return 0 even when query failedthis makes it hard to detect the errorthe current way we do is to rely on the stderr and see if stderr is emptybut its a hack not a proper way;we hit the same issue some time ago and updated the presto-cli please see my branch for the fix (i just rebased it to the current master):   will go ahead and create a pr for this shortly  || systemexit(success ? 0 : 1)i see this fixhopefully the pr will be granted soon :) || it would be nice to have the actual error code returned as exit code thats what we did in our internal fix || a new pr is wip to fix this issue: #2770  ||;;;;0;1;;
2017;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;only enable mocking of types right before instantiation to avoid circular interception of constructor creation.;2015.;;0;add missing serialversionuid field to converter and verifyexception classes;both converter and verifyexception implement serializable interface so they should declare a static final serialversionuid field;i added second commit (_deprecated objectstostringhelper()_) by mistake to this pull request ||;;;;0;1;;
2017;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;only enable mocking of types right before instantiation to avoid circular interception of constructor creation.;2015.;;0;expire queries only after maxqueryage;"this fixes a regression introduced in c918b549cf0cca6c3329b8f8ea5c9d23beadb128 wherethe expiration queue would get trimmed to maxqueryhistory regardless of how long agothe queries had finished this can result in clients getting ""not found"" errorsin highly loaded clusters that retire queries quicklythis implementation now keeps queries around until for at least maxqueryage afterthey are finished but it can keep them longer if the history is less than maxqueryhistory long";otherwise ;;;;0;1;;
2017;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;only enable mocking of types right before instantiation to avoid circular interception of constructor creation.;2015.;;2015.0;only enable mocking of types right before instantiation to avoid circular interception of constructor creation;2015;;issues mocking java framework classes in robolectric with mockito-inline;"hi mockito folkscurrently it is not possible to mock a java framework class (eg javaiofile) in robolectric when mockito-inline is used this issue has come up a bunch of times in robolectric mostly when kotlin is used to write robolectric tests instance if a trivial tests is run with the robolectric test runner with mockito-inline:```java  @test  public void file_getabsolutepath_ismockable() throws exception {    file file  mock(fileclass)    doreturn(""absolute/path"")when(file)getabsolutepath()    assertthat(filegetabsolutepath())isequalto(""absolute/path"")  }```an npe will result:```javalangnullpointerexception	at orgmockitointernalcreationbytebuddyinjectmockmethoddispatcherisconstructormock(mockmethoddispatcherjava:41)	at javabase/javaiofile<init>(filejava)	at javabase/sunnetwwwprotocolfilehandleropenconnection(handlerjava:80)	at javabase/sunnetwwwprotocolfilehandleropenconnection(handlerjava:72)	at javabase/javaneturlopenconnection(urljava:1063)	at javabase/sunnetwwwprotocoljarjarurlconnection<init>(jarurlconnectionjava:84)	at javabase/sunnetwwwprotocoljarhandleropenconnection(handlerjava:41)	at javabase/javaneturlopenconnection(urljava:1063)	at javabase/javaneturlclassloadergetresourceasstream(urlclassloaderjava:327)	at orgrobolectricinternalbytecodesandboxclassloadergetclassbytesasstreampreferringlocalurls(sandboxclassloaderjava:101)	at orgrobolectricinternalbytecodesandboxclassloadergetbytecode(sandboxclassloaderjava:172)	at orgrobolectricinternalbytecodesandboxclassloadermaybeinstrumentclass(sandboxclassloaderjava:129)	at orgrobolectricinternalbytecodesandboxclassloaderlambda$loadclass$0(sandboxclassloaderjava:115)	at orgrobolectricutilperfstatscollectormeasure(perfstatscollectorjava:53)	at orgrobolectricinternalbytecodesandboxclassloaderloadclass(sandboxclassloaderjava:115)	at javabase/javalangclassloaderloadclass(classloaderjava:521)	at orgrobolectricshadowsreset(shadowsjava:2298)	at orgrobolectricandroidinternalandroidtestenvironmentresetstate(androidtestenvironmentjava:518)	at orgrobolectricrobolectrictestrunnerlambda$finallyaftertest$0(robolectrictestrunnerjava:349)	at orgrobolectricutilperfstatscollectormeasure(perfstatscollectorjava:75)	at orgrobolectricrobolectrictestrunnerfinallyaftertest(robolectrictestrunnerjava:347)	at orgrobolectricinternalsandboxtestrunner$2lambda$evaluate$0(sandboxtestrunnerjava:272)	at orgrobolectricinternalbytecodesandboxlambda$runonmainthread$0(sandboxjava:89)	at javabase/javautilconcurrentfuturetaskrun(futuretaskjava:264)	at javabase/javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1128)	at javabase/javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:628)	at javabase/javalangthreadrun(threadjava:834)```robolectric uses an instrumenting classloader that transforms android classes to use real implementations: is a fork of robolectric that has a test that captures the issue: can see the failure using the following command:`/gradlew   mockito-experimental:test`any tips/help debugging would be greatly appreciated it would be nice to figure out what robolectric is doing to prevent this from working";are you moving `orgmockitointernalcreationbytebuddyinjectmockmethoddispatcher` to another class loader? normally mockito injects this class into the bootstrap class loader and then initializes this dispatcher with a random identifier all inline mocks call this class with the very same identifier to communicate with mockito the bootstrap loader is used to avoid any issues with class loader hierarchiesthe null pointer exception suggests that the class `orgmockitointernalcreationbytebuddyinjectmockmethoddispatcher` exists on multiple class loaders and that the initialization hit another class loader then the dispatcher the easiest would be to build something into robolectric that makes sure that the class loader tricks you apply never targets the `mockmethoddispatcher` it must only exist in the boot loader at all times || this is indeed the problem the loader of `mockmethoddispatcher` if resolved from the mock type is `orgrobolectricinternalandroidsandbox$sdksandboxclassloader` the dispatcher must always be loaded by the bootstrap class loader you need to exclude it from your class loader shadowing for it to work with boot classes otherwise the boot classes cannot communicate with mockito || can you try again with the release from just now? i defined the window of intercpting construction as narrowly as possible || thanks for taking a look! im excited to give this a shot seems like [354]( hasnt been pushed completely to the maven repo so i may do a local build if it doesnt show uprobolectric does indeed instrument the `orgmockito*` classes so ill make sure that orgmockitointernalcreationbytebuddyinjectmockmethoddispatcher is not being instrumented do any other mockito classes have to be excluded from instrumentation? i tried to exclude all mockito classes from being instrumented but then it became impossible to use mockito to mock android classes which is another use case that we would like to support if we do not instrument orgmockitointernalcreationbytebuddyinjectmockmethoddispatcher do you see any issues with using mockito to mock classes instrumented in the robolectric class loader? || that seemed to work! thanks!! || we struggled with bintray for a while and releases got brokenits all about the mock being able to communicate with mockito a class on the bootstrap loader can only communicate with classes on the boot loader i assume your class loaders are child-first? even those should be parent first for the boot loader normally  this way frameworks dispatching via the bootloader would generally function with robolectric ||;1;0;only enable mocking of types right before instantiation to avoid circular interception of constructor creation;
2018;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;only enable mocking of types right before instantiation to avoid circular interception of constructor creation.;2015.;;0;broken link: elementcostindatastructures;the project [memory-measurer]( was removed guavas documentation link [footprint of jdk/guava data structures]( is 403 (forbidden)i wanted to verify my [analysis]( using [jamm]( using openjdks [java object layout]( will be the best but due to its immaturity it isnt as easy to quickly script;"its been moved here: for the confusionon mon mar 30 2015 at 8:13 pm ben manes notifications@githubcom wrote:> the project memory-measurer  was removed guavas documentation link footprint of jdk/guava data> structures>  is 403 (forbidden)> > i wanted to verify my analysis>  using jamm>  using openjdks java object layout>  will be the best but> due to its immaturity it isnt as easy to quickly script> > —> reply to this email directly or view it on github>  kak || theres a broken link to this page in the sidebar still || @dimo414 which sidebar? can you give a link please?  sorry ""the sidebar"" isnt very helpful is it?  at the bottom of the [_wiki_ sidebar]( theres a link titled ""footprint of jdk/guava data structures"" that points to ` || cool  thanks! || ";;;;0;1;;
2018;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;only enable mocking of types right before instantiation to avoid circular interception of constructor creation.;2015.;;0;add jmx counters for query bytes rate distribution;;;;;;0;1;;
2018;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;only enable mocking of types right before instantiation to avoid circular interception of constructor creation.;2015.;;2015.0;only enable mocking of types right before instantiation to avoid circular interception of constructor creation;2015;;issues mocking java framework classes in robolectric with mockito-inline;"hi mockito folkscurrently it is not possible to mock a java framework class (eg javaiofile) in robolectric when mockito-inline is used this issue has come up a bunch of times in robolectric mostly when kotlin is used to write robolectric tests instance if a trivial tests is run with the robolectric test runner with mockito-inline:```java  @test  public void file_getabsolutepath_ismockable() throws exception {    file file  mock(fileclass)    doreturn(""absolute/path"")when(file)getabsolutepath()    assertthat(filegetabsolutepath())isequalto(""absolute/path"")  }```an npe will result:```javalangnullpointerexception	at orgmockitointernalcreationbytebuddyinjectmockmethoddispatcherisconstructormock(mockmethoddispatcherjava:41)	at javabase/javaiofile<init>(filejava)	at javabase/sunnetwwwprotocolfilehandleropenconnection(handlerjava:80)	at javabase/sunnetwwwprotocolfilehandleropenconnection(handlerjava:72)	at javabase/javaneturlopenconnection(urljava:1063)	at javabase/sunnetwwwprotocoljarjarurlconnection<init>(jarurlconnectionjava:84)	at javabase/sunnetwwwprotocoljarhandleropenconnection(handlerjava:41)	at javabase/javaneturlopenconnection(urljava:1063)	at javabase/javaneturlclassloadergetresourceasstream(urlclassloaderjava:327)	at orgrobolectricinternalbytecodesandboxclassloadergetclassbytesasstreampreferringlocalurls(sandboxclassloaderjava:101)	at orgrobolectricinternalbytecodesandboxclassloadergetbytecode(sandboxclassloaderjava:172)	at orgrobolectricinternalbytecodesandboxclassloadermaybeinstrumentclass(sandboxclassloaderjava:129)	at orgrobolectricinternalbytecodesandboxclassloaderlambda$loadclass$0(sandboxclassloaderjava:115)	at orgrobolectricutilperfstatscollectormeasure(perfstatscollectorjava:53)	at orgrobolectricinternalbytecodesandboxclassloaderloadclass(sandboxclassloaderjava:115)	at javabase/javalangclassloaderloadclass(classloaderjava:521)	at orgrobolectricshadowsreset(shadowsjava:2298)	at orgrobolectricandroidinternalandroidtestenvironmentresetstate(androidtestenvironmentjava:518)	at orgrobolectricrobolectrictestrunnerlambda$finallyaftertest$0(robolectrictestrunnerjava:349)	at orgrobolectricutilperfstatscollectormeasure(perfstatscollectorjava:75)	at orgrobolectricrobolectrictestrunnerfinallyaftertest(robolectrictestrunnerjava:347)	at orgrobolectricinternalsandboxtestrunner$2lambda$evaluate$0(sandboxtestrunnerjava:272)	at orgrobolectricinternalbytecodesandboxlambda$runonmainthread$0(sandboxjava:89)	at javabase/javautilconcurrentfuturetaskrun(futuretaskjava:264)	at javabase/javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1128)	at javabase/javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:628)	at javabase/javalangthreadrun(threadjava:834)```robolectric uses an instrumenting classloader that transforms android classes to use real implementations: is a fork of robolectric that has a test that captures the issue: can see the failure using the following command:`/gradlew   mockito-experimental:test`any tips/help debugging would be greatly appreciated it would be nice to figure out what robolectric is doing to prevent this from working";are you moving `orgmockitointernalcreationbytebuddyinjectmockmethoddispatcher` to another class loader? normally mockito injects this class into the bootstrap class loader and then initializes this dispatcher with a random identifier all inline mocks call this class with the very same identifier to communicate with mockito the bootstrap loader is used to avoid any issues with class loader hierarchiesthe null pointer exception suggests that the class `orgmockitointernalcreationbytebuddyinjectmockmethoddispatcher` exists on multiple class loaders and that the initialization hit another class loader then the dispatcher the easiest would be to build something into robolectric that makes sure that the class loader tricks you apply never targets the `mockmethoddispatcher` it must only exist in the boot loader at all times || this is indeed the problem the loader of `mockmethoddispatcher` if resolved from the mock type is `orgrobolectricinternalandroidsandbox$sdksandboxclassloader` the dispatcher must always be loaded by the bootstrap class loader you need to exclude it from your class loader shadowing for it to work with boot classes otherwise the boot classes cannot communicate with mockito || can you try again with the release from just now? i defined the window of intercpting construction as narrowly as possible || thanks for taking a look! im excited to give this a shot seems like [354]( hasnt been pushed completely to the maven repo so i may do a local build if it doesnt show uprobolectric does indeed instrument the `orgmockito*` classes so ill make sure that orgmockitointernalcreationbytebuddyinjectmockmethoddispatcher is not being instrumented do any other mockito classes have to be excluded from instrumentation? i tried to exclude all mockito classes from being instrumented but then it became impossible to use mockito to mock android classes which is another use case that we would like to support if we do not instrument orgmockitointernalcreationbytebuddyinjectmockmethoddispatcher do you see any issues with using mockito to mock classes instrumented in the robolectric class loader? || that seemed to work! thanks!! || we struggled with bintray for a while and releases got brokenits all about the mock being able to communicate with mockito a class on the bootstrap loader can only communicate with classes on the boot loader i assume your class loaders are child-first? even those should be parent first for the boot loader normally  this way frameworks dispatching via the bootloader would generally function with robolectric ||;1;0;only enable mocking of types right before instantiation to avoid circular interception of constructor creation;
2020;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;constructor dispatch;adds error message to class loader setups that do not work with the inline mock maker.;;0;i suggest adding generators to comgooglecommoncollectiterators;i suggest adding (possibly infinite) generators to the iterators class the idea is to have an iterator presenting a possibly infinite sequence of values generated on the fly a generator function so you dont have to keep all of that in memory at once two use cases are provided as unit tests: a) some kind of endless computation b) iterating over possibly infinite input;  ive signed it nowon wed apr 1 2015 at 12:27 am googlebot notifications@githubcom wrote:> thanks for your pull request> > it looks like this may be your first contribution to a google open source> project in which case youll need to sign a contributor license agreement> (cla) at  > if youve already signed a cla its possible we dont have your github> username or youre using a different email address check the information> on your cla  or see this help> article on setting the email on your git commits>  > once youve done that please reply here to let us know if you signed the> cla as a corporation please let us know the companys name> > —> reply to this email directly or view it on github>  ||   found it at last there was a wrong email address in the commits iauthored everything myselfon wed apr 1 2015 at 12:30 am googlebot notifications@githubcom wrote:> we found a contributor license agreement for you (the sender of this pull> request) but were unable to find agreements for the commit author(s) if> you authored these maybe you used a different email address in the git> commits than was used to sign the cla (login here>  to double check)? if these were> authored by someone else then they will need to sign a cla as well and> confirm that theyre okay with these being contributed to google> > —> reply to this email directly or view it on github>  ||  ||;;;;0;1;;
2020;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;constructor dispatch;adds error message to class loader setups that do not work with the inline mock maker.;;0;constructor dispatch;adds error message to class loader setups that do not work with the inline mock maker;;;;;1;1;add validation to mockmethoddispatcher that this class is only ever loaded by the bootstrap class loaderthis is normally assured by mockito but other testing frameworks that work with instrumentation can interfer with this this might be difficult to discover for those frameworks as seen with robolectric this explicit error should help to discover such discrepencies;
2020;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;constructor dispatch;adds error message to class loader setups that do not work with the inline mock maker.;;0;"implement ""pick any"" aggregation function";"we need an aggregation function to pick an arbitrary value from the group this can be commonly done with min or max but those only work for comparable typespossible names are: ""arbitrary"" ""choose_any""";;;;;0;1;;
2021;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;constructor dispatch;fixes recursive constructor invocation.;;0;mapsfromproperties() throws npe if a value is null;"maybe is intentiali have that:``` java    properties properties  new properties()    propertiesput( ""key""  null )     // i know its impossible it should show the problem    // by me it happens because a sytemproperty value is null (with the time)    // i´m not sure why?        map propertiesmap  mapsfromproperties( properties )```actual impl:``` java@gwtincompatible(""javautilproperties"")  public static immutablemap<string string> fromproperties    properties properties) {    immutablemapbuilder<string string> builder  immutablemapbuilder()    for (enumeration<?> e  propertiespropertynames() ehasmoreelements()) {      string key  (string) enextelement()      builderput(key propertiesgetproperty(key))    }    return builderbuild()  }```the `propertiespropertynames()` is the problem it throws a npethe `propertiesstringpropertynames()` would be return a empty keyset() ";`mapsfromproperties` returns an `immutablemap` and `immutablemap`s arent allowed to contain `null` ||;;;;0;1;;
2021;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;constructor dispatch;fixes recursive constructor invocation.;;0;constructor dispatch;fixes recursive constructor invocationavoids reflective access warning when using instrumentation-based member accessor;i think something has gone wrong with this pr travis is quite red after this pr:  example broken build:  like this pr was merged but travis hadnt finished yet? ||;;;;1;1;refine module openness check;
2021;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;1;constructor dispatch;fixes recursive constructor invocation.;;0;add full support for window functions;; also check that frames print correctly in the sql formatter ||;;;;0;1;;
2023;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;revert deprecation;following the discussion at #1913  that pr should be reverted.  this pr reverts the  @deprecations   but tries to keep the other improvements.  i m not sure whether  bibentry.getresolvedfield  should be kept.;;0;allow use of longstobytearray without allocation;request for longstobytearray and intstobytearray (maybe others?) to add overload accepting a byte argument to avoid the new byte[8] allocation;i think this gets into the territory that bytebuffer is already there for || agreed this is what `bytebufferputlong(long)` is for || ah yep thanks!on mon apr 6 2015 at 9:20 am colin decker notifications@githubcomwrote:> agreed this is what bytebufferputlong(long) is for> > —> reply to this email directly or view it on github>  ||;;;;0;1;;
2023;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;revert deprecation;following the discussion at #1913  that pr should be reverted.  this pr reverts the  @deprecations   but tries to keep the other improvements.  i m not sure whether  bibentry.getresolvedfield  should be kept.;;0;update reference to floatingdecimal in docs;;;;;;0;1;;
2023;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;revert deprecation;following the discussion at #1913  that pr should be reverted.  this pr reverts the  @deprecations   but tries to keep the other improvements.  i m not sure whether  bibentry.getresolvedfield  should be kept.;;2011.0;initializes classes prior to instrumentation to avoid uncontrolled code execution;2011 - triggeres initializers explicitly; merging 2023 ;stackoverflow error when upgrading to v352;"i tried to upgrade from mockito v346 to v352 and im getting a stackoverflow error (same error with v350) when running some tests (not all of them just a few  even in the same class : some tests pass and others dont)stacktrace :```javalangstackoverflowerror	at javabase/javalangthreadlocalget(threadlocaljava:163)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakerlambda$new$3(inlinebytebuddymockmakerjava:260)	at orgmockitointernalcreationbytebuddymockmethodadvicehandleconstruction(mockmethodadvicejava:176)	at orgmockitointernalcreationbytebuddyinjectmockmethoddispatcherhandleconstruction(mockmethoddispatcherjava:53)	at javabase/javalangthrowable<init>(throwablejava)	at javabase/javalangexception<init>(exceptionjava:66)	at javabase/javalangruntimeexception<init>(runtimeexceptionjava:62)	at javabase/javalangclasscastexception<init>(classcastexceptionjava:58)	at javabase/javalangthrowable<init>(throwablejava)	at javabase/javalangexception<init>(exceptionjava:66)	at javabase/javalangruntimeexception<init>(runtimeexceptionjava:62)	at javabase/javalangclasscastexception<init>(classcastexceptionjava:58)	at javabase/javalangthrowable<init>(throwablejava)	at javabase/javalangexception<init>(exceptionjava:66)        ```i didnt succeed in reproduce the error in a small project but ill spend more time to try and post the sources here when/if i have a reproducible caseenvironment :- mockito v352- junit v562- java :> openjdk version ""1108"" 2020-07-14> openjdk runtime environment (build 1108+10-post-ubuntu-0ubuntu118041)> openjdk 64-bit server vm (build 1108+10-post-ubuntu-0ubuntu118041 mixed mode sharing)- maven : v360 (tests are run by the maven-surefire plugin)";"i just discovered that the error happens when i launch all my unit tests in the maven module but its fine if i run the test or the test class only```sh$ cd myproject/my-mvn-module-1$ mvn test## [error]   mybeantesttest1 » stackoverflow#$ mvn -dtestmybeantest test# # tests run: 7 failures: 0 errors: 0 skipped: 0#$ mvn -dtestmybeantest#test1 test# # tests run: 1 failures: 0 errors: 0 skipped: 0#```maven configuration (in the root pomxml) :```xml<plugin>    <groupid>orgapachemavenplugins</groupid>    <artifactid>maven-surefire-plugin</artifactid>    <version>2222</version>    <configuration>        <skiptests>${skipunittests}</skiptests>        <includes>            <include>**/*testjava</include>        </includes>        <argline>-dnetbytebuddyexperimentaltrue @{argline} -dfileencoding${projectreportingoutputencoding}</argline>        <trimstacktrace>false</trimstacktrace>    </configuration></plugin>``` || thanks for reporting can you supply an example test case? it looks like an exception is supposed to be thrown but the constructor mocking intercepts its creation where something causes another exception which is again passed to the handlerdo you mock exceptions somewhere?also could you share the bottom of the stack trace which is where the circularity is introduced || seeing the same thing myself although i dont have a stable reproduction scenario the same was observed with `350` || could you try the latest release to see if the problem still occurs? || sorry i was not clear originally i saw the problem at first on `350` but still see it with `352` || @raphw yes i mock some exceptions in other test classes but the ones who ends with stackoverflowerror i will take some time today or next week to try to reproduce the bug in a small projectthe full stacktrace :```javalangstackoverflowerror	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakerlambda$new$3(inlinebytebuddymockmakerjava)	at orgmockitointernalcreationbytebuddymockmethodadvicehandleconstruction(mockmethodadvicejava:176)	at orgmockitointernalcreationbytebuddyinjectmockmethoddispatcherhandleconstruction(mockmethoddispatcherjava:53)	at javabase/javalangthrowable<init>(throwablejava)	at javabase/javalangexception<init>(exceptionjava:66)	at javabase/javalangruntimeexception<init>(runtimeexceptionjava:62)	at javabase/javalangclasscastexception<init>(classcastexceptionjava:58)	at javabase/javalangthrowable<init>(throwablejava)	at javabase/javalangexception<init>(exceptionjava:66)	at javabase/javalangruntimeexception<init>(runtimeexceptionjava:62)	at javabase/javalangclasscastexception<init>(classcastexceptionjava:58)	at javabase/javalangthrowable<init>(throwablejava)	at javabase/javalangexception<init>(exceptionjava:66)	at javabase/javalangruntimeexception<init>(runtimeexceptionjava:62)	at javabase/javalangclasscastexception<init>(classcastexceptionjava:58)	/*  */	at javabase/javalangthrowable<init>(throwablejava)	at javabase/javalangexception<init>(exceptionjava:66)	at javabase/javalangruntimeexception<init>(runtimeexceptionjava:62)	at javabase/javalangclasscastexception<init>(classcastexceptionjava:58)	at javabase/javalangthrowable<init>(throwablejava)	at javabase/javalangexception<init>(exceptionjava:66)	at javabase/javalangruntimeexception<init>(runtimeexceptionjava:62)	at javabase/javalangclasscastexception<init>(classcastexceptionjava:58)	at javabase/javalangthrowable<init>(throwablejava)	/* end of stacktrace */``` || this cant be the full stack trace since it needs to origin somewhere maybe its cut off in the print?i think i know the problem and tried to fix it unfortunately we have some release issues but you could build *release/3x* locally and try if the problem still occurs || im seeing the same error when trying to go from 346 to 350```javalangstackoverflowerror	at orgmockitointernalcreationbytebuddyinjectmockmethoddispatcherisconstructormock(mockmethoddispatcherjava:57)	at javabase/javalangexception<init>(exceptionjava)	at javabase/javalangruntimeexception<init>(runtimeexceptionjava:62)	at orgmockitoexceptionsbasemockitoexception<init>(mockitoexceptionjava:34)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakerlambda$new$3(inlinebytebuddymockmakerjava:273)	at orgmockitointernalcreationbytebuddymockmethodadvicehandleconstruction(mockmethodadvicejava:176)	at orgmockitointernalcreationbytebuddyinjectmockmethoddispatcherhandleconstruction(mockmethoddispatcherjava:69)	at javabase/javalangthrowable<init>(throwablejava)	at javabase/javalangexception<init>(exceptionjava)	at javabase/javalangruntimeexception<init>(runtimeexceptionjava:62)	at orgmockitoexceptionsbasemockitoexception<init>(mockitoexceptionjava:34) ```seems to be related to using a @spy in the test class when i change the @spy to an @mock the error goes away  what seems odd in my case is everything is ok until there are more than 15 tests in the class  15 tests will pass and any additional tests will failthe message of the first exception is `unexpected spy for javautilabstractmap on instance of javautilconcurrentconcurrenthashmap`    || @raphw same issue with v355stacktrace :```javalangstackoverflowerror	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakerlambda$new$3(inlinebytebuddymockmakerjava:273)	at orgmockitointernalcreationbytebuddymockmethodadvicehandleconstruction(mockmethodadvicejava:176)	at orgmockitointernalcreationbytebuddyinjectmockmethoddispatcherhandleconstruction(mockmethoddispatcherjava:69)	at javabase/javalangthrowable<init>(throwablejava)	at javabase/javalangexception<init>(exceptionjava:66)	at javabase/javalangruntimeexception<init>(runtimeexceptionjava:62)	at orgmockitoexceptionsbasemockitoexception<init>(mockitoexceptionjava:34)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakerlambda$new$3(inlinebytebuddymockmakerjava:273)	at orgmockitointernalcreationbytebuddymockmethodadvicehandleconstruction(mockmethodadvicejava:176)	at orgmockitointernalcreationbytebuddyinjectmockmethoddispatcherhandleconstruction(mockmethoddispatcherjava:69)	at javabase/javalangthrowable<init>(throwablejava)	at javabase/javalangexception<init>(exceptionjava:66)	at javabase/javalangruntimeexception<init>(runtimeexceptionjava:62)	at orgmockitoexceptionsbasemockitoexception<init>(mockitoexceptionjava:34)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakerlambda$new$3(inlinebytebuddymockmakerjava:273)	at orgmockitointernalcreationbytebuddymockmethodadvicehandleconstruction(mockmethodadvicejava:176)	at orgmockitointernalcreationbytebuddyinjectmockmethoddispatcherhandleconstruction(mockmethoddispatcherjava:69)        	at javabase/javalangthrowable<init>(throwablejava)	at javabase/javalangexception<init>(exceptionjava:66)	at javabase/javalangruntimeexception<init>(runtimeexceptionjava:62)	at orgmockitoexceptionsbasemockitoexception<init>(mockitoexceptionjava:34)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakerlambda$new$3(inlinebytebuddymockmakerjava:273)	at orgmockitointernalcreationbytebuddymockmethodadvicehandleconstruction(mockmethodadvicejava:176)	at orgmockitointernalcreationbytebuddyinjectmockmethoddispatcherhandleconstruction(mockmethoddispatcherjava:69)	at javabase/javalangthrowable<init>(throwablejava)	at javabase/javalangexception<init>(exceptionjava:66)	at javabase/javalangruntimeexception<init>(runtimeexceptionjava:62)	at orgmockitoexceptionsbasemockitoexception<init>(mockitoexceptionjava:34)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakerlambda$new$3(inlinebytebuddymockmakerjava:273)	at orgmockitointernalcreationbytebuddymockmethodadvicehandleconstruction(mockmethodadvicejava:176)	at orgmockitointernalcreationbytebuddyinjectmockmethoddispatcherhandleconstruction(mockmethoddispatcherjava:69)	at javabase/javalangthrowable<init>(throwablejava)	at javabase/javalangexception<init>(exceptionjava:66)	at javabase/javalangruntimeexception<init>(runtimeexceptionjava:62)	at orgmockitoexceptionsbasemockitoexception<init>(mockitoexceptionjava:34)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakerlambda$new$3(inlinebytebuddymockmakerjava:273)	at orgmockitointernalcreationbytebuddymockmethodadvicehandleconstruction(mockmethodadvicejava:176)``` || @jdussouillez that gets us one step closer but i needed to add an exception for when the error is thrown could you build the *constructor-dispatch* branch locally and see what exception you get in your setup? || @raphw i installed v356 from the *constructor-dispatch* branch : no more errors all the tests were executed and passed so i guess commit  fixes the issuefeel free to ask if you want me to do more tests || thats strange since the exception indicates a scenario that should not occur i merely  the recursioncan you set a breakppint to see why this happens? what instance is created during spy construction?  || @raphw i didnt succeed in setting breakpoints but i added some logs (before [this line]( : ```diffdiff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/inlinebytebuddymockmakerjava b/src/main/java/org/mockito/internal/creation/bytebuddy/inlinebytebuddymockmakerjavaindex 96477f4776b37ea09e 100644--- a/src/main/java/org/mockito/internal/creation/bytebuddy/inlinebytebuddymockmakerjava+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/inlinebytebuddymockmakerjava@@ -2656 +2659 @@ public class inlinebytebuddymockmaker                         } else if (typeisinstance(spy)) {                             return spy                         } else {+                            systemoutprintln(""type  "" + typegetname())+                            systemoutprintln(""object  "" + object)+                            systemoutprintln(""spy  "" + spygetclass()getname())                             issuspendedset(true)                             try {                                 // unexpected construction of non-spied object```logs (type is always `javautilabstractmap`):```type  javautilabstractmapobject  {}spy  commyprojectbeanmybean1type  javautilabstractmapobject  {}spy  commyprojectbeanmybean2type  javautilabstractmapobject  {}spy  commyprojectbeanmybean3``` || could you also add a stack trace at the same spot? (`threaddump()`) || code snippet to dump : ```javatry {    threaddumpstack()} catch (throwable t) {    systemoutprintln(""error while dumping stack: "" + tgetmessage())}```1 logs using [`threaddumpstack()`]( **after** `issuspendedset(true)````type  javautilabstractmapobject  {}spy  commyprojectbeanmybeantest$testclass<dump>javalangexception: stack trace	at javabase/javalangthreaddumpstack(threadjava:1388)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakerlambda$new$3(inlinebytebuddymockmakerjava:272)	at orgmockitointernalcreationbytebuddymockmethodadvicehandleconstruction(mockmethodadvicejava:176)	at orgmockitointernalcreationbytebuddyinjectmockmethoddispatcherhandleconstruction(mockmethoddispatcherjava:69)	at javabase/javautilabstractmap<init>(abstractmapjava)	at javabase/javautilconcurrentconcurrenthashmap<init>(concurrenthashmapjava:828)	at javabase/javalangclassloader<init>(classloaderjava:333)	at javabase/javalangclassloader<init>(classloaderjava:457)	at javabase/jdkinternalreflectdelegatingclassloader<init>(classdefinerjava:72)	at javabase/jdkinternalreflectclassdefiner$1run(classdefinerjava:60)	at javabase/jdkinternalreflectclassdefiner$1run(classdefinerjava:58)	at javabase/javasecurityaccesscontrollerdoprivileged(native method)	at javabase/jdkinternalreflectclassdefinerdefineclass(classdefinerjava:57)	at javabase/jdkinternalreflectmethodaccessorgenerator$1run(methodaccessorgeneratorjava:400)	at javabase/jdkinternalreflectmethodaccessorgenerator$1run(methodaccessorgeneratorjava:394)	at javabase/javasecurityaccesscontrollerdoprivileged(native method)	at javabase/jdkinternalreflectmethodaccessorgeneratorgenerate(methodaccessorgeneratorjava:393)	at javabase/jdkinternalreflectmethodaccessorgeneratorgenerateconstructor(methodaccessorgeneratorjava:92)	at javabase/jdkinternalreflectnativeconstructoraccessorimplnewinstance(nativeconstructoraccessorimpljava:55)	at javabase/jdkinternalreflectdelegatingconstructoraccessorimplnewinstance(delegatingconstructoraccessorimpljava:45)	at javabase/javalangreflectconstructornewinstance(constructorjava:490)	at orgmockitointernalutilreflectionreflectionmemberaccessorlambda$newinstance$0(reflectionmemberaccessorjava:26)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakerlambda$newinstance$4(inlinebytebuddymockmakerjava:631)	at orgmockitointernalutilreflectionreflectionmemberaccessornewinstance(reflectionmemberaccessorjava:26)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakernewinstance(inlinebytebuddymockmakerjava:626)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakerdocreatemock(inlinebytebuddymockmakerjava:373)	at orgmockitointernalcreationbytebuddyinlinebytebuddymockmakercreatespy(inlinebytebuddymockmakerjava:349)	at orgmockitointernalutilmockutilcreatemock(mockutiljava:44)	at orgmockitointernalmockitocoremock(mockitocorejava:61)	at orgmockitomockitospy(mockitojava:2033)	at commyprojectbeanmybeantesttest1(mybeantestjava:274)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javabase/javalangreflectmethodinvoke(methodjava:566)	at orgjunitplatformcommonsutilreflectionutilsinvokemethod(reflectionutilsjava:686)	at orgjunitjupiterengineexecutionmethodinvocationproceed(methodinvocationjava:60)	at orgjunitjupiterengineexecutioninvocationinterceptorchain$validatinginvocationproceed(invocationinterceptorchainjava:131)	at orgjunitjupiterengineextensiontimeoutextensionintercept(timeoutextensionjava:149)	at orgjunitjupiterengineextensiontimeoutextensionintercepttestablemethod(timeoutextensionjava:140)	at orgjunitjupiterengineextensiontimeoutextensionintercepttestmethod(timeoutextensionjava:84)	at orgjunitjupiterengineexecutionexecutableinvoker$reflectiveinterceptorcalllambda$ofvoidmethod$0(executableinvokerjava:115)	at orgjunitjupiterengineexecutionexecutableinvokerlambda$invoke$0(executableinvokerjava:105)	at orgjunitjupiterengineexecutioninvocationinterceptorchain$interceptedinvocationproceed(invocationinterceptorchainjava:106)	at orgjunitjupiterengineexecutioninvocationinterceptorchainproceed(invocationinterceptorchainjava:64)	at orgjunitjupiterengineexecutioninvocationinterceptorchainchainandinvoke(invocationinterceptorchainjava:45)	at orgjunitjupiterengineexecutioninvocationinterceptorchaininvoke(invocationinterceptorchainjava:37)	at orgjunitjupiterengineexecutionexecutableinvokerinvoke(executableinvokerjava:104)	at orgjunitjupiterengineexecutionexecutableinvokerinvoke(executableinvokerjava:98)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorlambda$invoketestmethod$6(testmethodtestdescriptorjava:212)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorinvoketestmethod(testmethodtestdescriptorjava:208)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorexecute(testmethodtestdescriptorjava:137)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorexecute(testmethodtestdescriptorjava:71)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:135)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$7(nodetesttaskjava:125)	at orgjunitplatformenginesupporthierarchicalnodearound(nodejava:135)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$8(nodetesttaskjava:123)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:122)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:80)	at javabase/javautilarraylistforeach(arraylistjava:1541)	at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorserviceinvokeall(samethreadhierarchicaltestexecutorservicejava:38)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:139)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$7(nodetesttaskjava:125)	at orgjunitplatformenginesupporthierarchicalnodearound(nodejava:135)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$8(nodetesttaskjava:123)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:122)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:80)	at javabase/javautilarraylistforeach(arraylistjava:1541)	at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorserviceinvokeall(samethreadhierarchicaltestexecutorservicejava:38)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$5(nodetesttaskjava:139)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$7(nodetesttaskjava:125)	at orgjunitplatformenginesupporthierarchicalnodearound(nodejava:135)	at orgjunitplatformenginesupporthierarchicalnodetesttasklambda$executerecursively$8(nodetesttaskjava:123)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecuterecursively(nodetesttaskjava:122)	at orgjunitplatformenginesupporthierarchicalnodetesttaskexecute(nodetesttaskjava:80)	at orgjunitplatformenginesupporthierarchicalsamethreadhierarchicaltestexecutorservicesubmit(samethreadhierarchicaltestexecutorservicejava:32)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestexecutorexecute(hierarchicaltestexecutorjava:57)	at orgjunitplatformenginesupporthierarchicalhierarchicaltestengineexecute(hierarchicaltestenginejava:51)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:220)	at orgjunitplatformlaunchercoredefaultlauncherlambda$execute$6(defaultlauncherjava:188)	at orgjunitplatformlaunchercoredefaultlauncherwithinterceptedstreams(defaultlauncherjava:202)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:181)	at orgjunitplatformlaunchercoredefaultlauncherexecute(defaultlauncherjava:128)	at orgapachemavensurefirejunitplatformjunitplatformproviderinvokealltests(junitplatformproviderjava:150)	at orgapachemavensurefirejunitplatformjunitplatformproviderinvoke(junitplatformproviderjava:124)	at orgapachemavensurefirebooterforkedbooterinvokeproviderinsameclassloader(forkedbooterjava:384)	at orgapachemavensurefirebooterforkedbooterrunsuitesinprocess(forkedbooterjava:345)	at orgapachemavensurefirebooterforkedbooterexecute(forkedbooterjava:126)	at orgapachemavensurefirebooterforkedbootermain(forkedbooterjava:418)</dump>```2 logs using [`threaddumpstack()`]( **before** `issuspendedset(true)````type  javautilabstractmapobject  {}spy  commyprojectlibrarylibrarybean1<dump>type  javalangthrowableobject  javalangexceptionspy  commyprojectlibrarylibrarybean1<dump>type  javalangthrowableobject  javalangexceptionspy  commyprojectlibrarylibrarybean1error while dumping stack: unexpected spy for javalangthrowable on instance of javalangexception</dump>error while dumping stack: unexpected spy for javalangthrowable on instance of javalangexception</dump>error while dumping stack: unexpected spy for javalangthrowable on instance of javalangexception</dump>error while dumping stack: unexpected spy for javalangthrowable on instance of javalangexception</dump>error while dumping stack: unexpected spy for javalangthrowable on instance of javalangexception</dump>``` || i thought it would be related to class loadingi am curious however how you end uo with the reflection member accessor it should be the instrumentation based one are you using the latest build?  || > are you using the latest build?i pulled the *constructor-dispatch* branch this morning before giving you the `threaddumpstack()` output i just switched to branch *release/3x* (356 next 357) applied my logs and run my tests again : same results || strange ill investigate could you make sure that you dont have a stale version? you are using *mockito-inline* or are you configuring the mock maker manually?  || > could you make sure that you dont have a stale version?i already checked using `mvn dependency:tree` but it says im using 357 (im using the *release/3x* branch)i will try to copy my project use v352 and remove code step by step until i can reproduce the bug with only a few files so i can provide you a reproducible example----> you are using mockito-inline or are you configuring the mock maker manually?im using mockito-core :```xml<dependency>    <groupid>orgmockito</groupid>    <artifactid>mockito-core</artifactid>    <version>357</version>    <scope>test</scope></dependency>```and i do not configure anything manually i just have the `src/test/resources/mockito-extensions/orgmockitopluginsmockmaker` config file which contains```mock-maker-inline``` || that explains it you can drop the config and just use the inline artifact which defines the nock maker for you the member accessor is another plugin which requires manual activation using a similar file if you dont use the other artifact  || > you can drop the config and just use the inline artifact which defines the nock maker for youi used mockito-inline v356 all tests passed but 3 the 3 that fails are new ones (not the ones who failed before) and none of them use mockito (but all of them are on enums apparently `myenumvalues()` returns an array with null values inside) but theyre executed correctly when running them manually class by class ([like i did before]( you know how can i generate the inline jar from the sources ? i cant provide you the logs i added in the source with mockito-inline because the jar is not generated  /gradlew -x check clean build` || @raphw thank you for the fix and the time spent on this it works great ! || ";1;0;initializes classes prior to instrumentation to avoid uncontrolled code executionfixes \# #2011;
2034;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fix bad web search error messages;1542  i rewrote the error messages when the fetchers fail (or added them).;;0;guava-testlib not compatible with latest version of truth;guava 18 declares a dependency on version 023 of truth the latest version is 024 when running a collection test with 024 on the classpath i get an exception like the following:```1) testretainall_countignored[observablearraylist [collection size: several]](comgooglecommoncollecttestingtesterslistretainalltester)javalangincompatibleclasschangeerror: found class comgooglecommontruthcollectionsubject$has but interface was expected        at comgooglecommoncollecttestingtesterslistretainalltestertestretainall_countignored(listretainalltesterjava:70)        at sunreflectnativemethodaccessorimplinvoke0(native method)        at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)        at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)        at javalangreflectmethodinvoke(methodjava:483)        at junitframeworktestcaseruntest(testcasejava:176)        at junitframeworktestcaserunbare(testcasejava:141)        at junitframeworktestresult$1protect(testresultjava:122)        at junitframeworktestresultrunprotected(testresultjava:142)        at junitframeworktestresultrun(testresultjava:125)        at junitframeworktestcaserun(testcasejava:129)        at junitframeworktestsuiteruntest(testsuitejava:252)        at junitframeworktestsuiterun(testsuitejava:247)        at junitframeworktestsuiteruntest(testsuitejava:252)        at junitframeworktestsuiterun(testsuitejava:247)        at junitframeworktestsuiteruntest(testsuitejava:252)        at junitframeworktestsuiterun(testsuitejava:247)        at orgjunitinternalrunnersjunit38classrunnerrun(junit38classrunnerjava:86)        at orgjunitrunnerssuiterunchild(suitejava:128)        at orgjunitrunnerssuiterunchild(suitejava:27)        at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)        at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)        at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)        at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)        at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)        at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)        at orgjunitrunnerssuiterunchild(suitejava:128)        at orgjunitrunnerssuiterunchild(suitejava:27)        at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)        at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)        at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)        at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)        at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)        at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)        at orgjunitrunnerjunitcorerun(junitcorejava:137)        at orgjunitrunnerjunitcorerun(junitcorejava:115)        at orgjunitrunnerjunitcorerunmain(junitcorejava:77)        at orgjunitrunnerjunitcoremain(junitcorejava:36)```downgrading to 023 fixes the problem;it looks like cgdecker  this with e9a23fe5ef043723c428a47ca96049306fcf813d ||;;;;0;1;;
2034;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fix bad web search error messages;1542  i rewrote the error messages when the fetchers fail (or added them).;;0;require java 8;;you should also update `comfacebookprestoserverprestojvmrequirements` || also update the readme || is there a minimum required version of java 8? || 8u40 which is not out yet were using one of the snapshots (8u40-b15) and it seems to work well so far id say in practice 8u20 and up are probably ok the bug we see in 8u20 happens very rarely ||  woohoo! ||;;;;0;1;;
2034;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;fix bad web search error messages;1542  i rewrote the error messages when the fetchers fail (or added them).;;1802.0;escape mock during method dispatch on mock to avoid premature garbage collection;under heavy optimization mocks might get garbage collected during the dispatching of a mocked method if the mock instance is not used after this method dispatch to avoid this we escape the mock instance during the dispatch to make sure that the gc cannot collect the object1802;indeed force pushed a new version just nowlets hope the jit stays dumb enough to avoid this error in the future - i was really certain that the stack allocation of the mock object would avoid the allocation but if the entire mockito call stack gets inlined that does no longer apply worst case we need to make the mockito call stack deeper then the inlining heuristic ) ||;"exception ""the mock object was garbage collected""";"we received the following exception while running tests using mockito either version 300 or 310 and im filing this bug as requested:```exception in thread ""main"" javalangillegalstateexception: the mock object was garbage collected this should not happen in normal circumstances when using public api typically the test class keeps strong reference to the mock object and it prevents getting the mock collected mockito internally needs to keep weak references to mock objects to avoid memory leaks for certain types of mockmaker implementations if you see this exception using mockito public api please file a bug for more information see issue #1313	at orgmockitointernalinvocationmockrefmockweakreferenceget(mockweakreferencejava:32)	at orgmockitointernalinvocationinterceptedinvocationgetmock(interceptedinvocationjava:106)	at orgmockitointernalstubbinginvocationcontainerimplinvokedmock(invocationcontainerimpljava:157)	at orgmockitointernalstubbingongoingstubbingimpl<init>(ongoingstubbingimpljava:22)	at orgmockitointernalhandlermockhandlerimplhandle(mockhandlerimpljava:83)	at orgmockitointernalhandlernullresultguardianhandle(nullresultguardianjava:29)	at orgmockitointernalhandlerinvocationnotifierhandlerhandle(invocationnotifierhandlerjava:35)	at orgmockitointernalcreationbytebuddymockmethodinterceptordointercept(mockmethodinterceptorjava:61)	at orgmockitointernalcreationbytebuddymockmethodinterceptordointercept(mockmethodinterceptorjava:49)	at orgmockitointernalcreationbytebuddymockmethodinterceptor$dispatcherdefaultingtorealmethodinterceptabstract(mockmethodinterceptorjava:126)	at orgmockitocodegenrunnable$mockitomock$1840149894run(unknown source)	at mockitotestruntest(mockitotestjava:13)	at mockitotestmain(mockitotestjava:6)```ive reduced the problem to the following test program:```javaimport orgmockito*public class mockitotest {  public static void main(string args) {    while (true) runtest()  }  private static void runtest() {    node list  createlist()    while (list ! null) {      node next  listnext      listobjectrun()      list  next    }  }  private static node createlist() {    node node  null    for (int i  0 i < 1000 ++i) {      node next  new node()      nextnext  node      node  next    }    return node  }  private static class node {    final runnable object  mockitomock(runnableclass)    node next  }}```whether the problem occurs depends on what exactly the jvm does with the code it looks like the mock object can be garbage collected between the call to the mocked method and mockito trying to use the weak reference to it im using adoptopenjdk 11037-hotspot on windows my test program more often than not reproduces the exception within a few seconds but occasionally it can run forever without failing";"i tried bisecting this issue happens after this pr || that makes sence if the `basestubbing` instance wraps the mocks and the latter instance is referenced via a weak reference then that latter instance can be gc-ed even if the actual mock instance is still in usethanks for the test since we both have a test for the ""too weak"" and the ""not sufficiently weak"" mock applications i hope that i can come up with a scenario that satisfies both conditions || this issue just came up as we tried to upgrade from 333 to either 346 or 359 a large chunk of our unit tests became flaky as a result holding onto a strong reference of `mockitoannotationsopenmocks()` does not seem to have any impact the only thing that seemed to rectify the issue was creating and retaining a `mockitosession` like via `mockitojunitrule()` (using the `mockspressojunitrunner` shows the same flakiness as no session is initialized in it) considering that `mockitomockitosession()` is labeled as optional and `@incubating` and considering that the junit rule & testrunner have always been optional historically this seems like a legitimate bug that will block mockito upgrades in many large codebases (especially those relying on mockito-kotlins inline `mock()` method) || yes this needs to be addressed the alternatives right now are unfortunately a leak or premature discarding i think a leak is the better alternative though since you can explicitly clear mockitos mock storethe updates within 3 should not have an impact but can have one as a result of changed gc cyclesi will try to solve this one the next time i find some free time to work on mockito || awesome! thanks so much for addressing this! || ";1;0;escape mock during method dispatch on mock to avoid premature garbage collection1802;
2042;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;mock resolver plugin;adds a plugin to allow for adding one or multiple mock resolvers. this way  instances that are provided to mockito s dsl do no longer require to be the actual mocks but can also be proxies of mocks what is something already being applied by frameworks such as spring.;;0;whats the point about cycledetectinglockfactory (@beta i know);"hi thereim trying to understand the cycledetectinglockfactory class and how it can be usefuli checked the unit tests and found one scenario with a false positive i did another scenario with a real deadlock (involving two threads) which is not recognizedso im wondering what is the benefit of the current class implementation? (if those two basic scenarios are not working?)as far as i can guess the only meaningful point about this implementation is that the rule `all threads acquire the locks in the same order`( is enforced is that right? after reading the javadoc again i find this as `checking for cycles in lock acquisition order` so a better name for the class could be `illegallockaquisitionorderdetectinglockfactory` thanks for your feedback and best regards from switzerland peti```package comgooglecommonutilconcurrentimport comgooglecommonutilconcurrentcycledetectinglockfactorypoliciesimport junitframeworktestcaseimport javautilconcurrentcountdownlatchimport javautilconcurrentlocksreentrantlockpublic class cycledetectinglockfactorytest extends testcase {    private reentrantlock locka    private reentrantlock lockb    @override    protected void setup() throws exception {        cycledetectinglockfactory factory                 cycledetectinglockfactorynewinstance(policiesthrow)        lockb  factorynewreentrantlock(""lockb"")        locka  factorynewreentrantlock(""locka"")    }    //------    // false positive?    //-----    public void testdeadlock_twolocks_falsepositive() {        // establish an acquisition order of locka -> lockb        lockalock()        lockblock()        lockaunlock()        lockbunlock()        // the opposite order fails afterwards although there is no deadlock anywhere        lockblock()        lockalock()    }    //------    // real deadlock not recognized?    //-----    public void testdeadlock_twothreads_realdeadlock_notdetectedorprevented() throws interruptedexception {        final countdownlatch t1haslocka  new countdownlatch(1)        final countdownlatch t2haslockb  new countdownlatch(1)        final countdownlatch allthreadsfinished  new countdownlatch(2)        thread t1  new thread(new runnable() {            @override            public void run() {                try {                    //prepare                    lockalock()                    t1haslockacountdown()                    t2haslockbawait()                    // now deadlock                    lockblock()                } catch (exception ignored) {                    // expected due to the use of cycledetectinglockfactory                    ignoredprintstacktrace()                } finally {                    lockaunlock()                    lockbunlock() // just in case                    allthreadsfinishedcountdown()                }            }        })        t1setdaemon(true)        t1start()        thread t2  new thread(new runnable() {            @override            public void run() {                try {                    // prepare                    t1haslockaawait()                    lockblock()                    t2haslockbcountdown()                    // now deadlock                    lockalock()                } catch (exception ignored) {                    // expected due to the use of cycledetectinglockfactory                    ignoredprintstacktrace()                } finally {                    lockbunlock()                    lockaunlock() // just in case                    allthreadsfinishedcountdown()                }            }        })        t2setdaemon(true)        t2start()        t1haslockaawait()        systemoutprintln(""thread 1 has lock a"")        t2haslockbawait()        systemoutprintln(""thread 2 has lock a"")        allthreadsfinishedawait()    }}```";"hi petikochthank you for your questions and observations!the cycledetectinglockfactory does not detect deadlocks per se it detects _potential_ deadlocks by noticing when an applications lock acquisition patterns can form a cycleit is true that a cycle will not necessarily lead to a deadlock lockathenb() and lockbthena() will never deadlock if the application only runs one thread or if the two methods execution is guarded by another lock however this type of serialization invariant is not enforceable by the compiler and in large systems its often easy to break such invariants and not notice until a deadlock happens (for example the ""testdeadlock_twolocks_falsepositive()"" method can indeed deadlock if run concurrently in multiple threads)the philosophy of the cycledetectinglockfactory is to prevent deadlocks by enforcing that for any pair of locks the application always acquires them in the same order at the expense of potential false positives this eliminates the reliance on higher-level invariants that are otherwise hard to verifythat said youre absolutely right that it does not catch everything! testdeadlock_twothreads_realdeadlock_notdetectedorprevented() identifies a deficiency thats noted in an implementation comment:   void checkacquiredlock() {        // note that there is a race condition here which can result in missing    // a cyclic edge: its possible for two threads to simultaneous find    // ""safe"" edges which together form a cycle preventing this race    // condition efficiently without _introducing_ deadlock is probably    // tricky for now just accept the race condition---missing a warning    // now and then is still better than having no deadlock detection   }```if you have an idea of how to handle this race condition please do submit a fix!thanks again for your thoughts contributions!darick || dear @daricktong thank you very much for your explanations i think i really understand now the ""prevention""-approach using **enforcing lock acquisition order** and the difference to a ""detection""-approach (finding out that there _is  now_ a deadlock)i wrote down my thoughts here:  try to summarize this further  ""enforcing lock acquisition order""good- prevents 100% of the deadlock situations (if you have 100% test-coverage of the relevant code sections)bad- false positives- introduces a potential central bottleneck because all the lock acquisition threads must pass hereapproach: ""hooking into the lock acquisition / lock releasing process and analyzing current lock-holding situation"" good- no false positivesbad- doesnt prevent 100% of the deadlock situations because in practice you are unable to cover all possible scenarios with tests- introduces a potential central bottleneck because all the lock acquisition / lock releasing threads must pass hereregarding the implementation issue with the race-condition: ill give it a try -)best regards from switzerlandpeti || close for now i open a new issue for the race-condition bug || opend  || ";;;;0;1;;
2042;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;mock resolver plugin;adds a plugin to allow for adding one or multiple mock resolvers. this way  instances that are provided to mockito s dsl do no longer require to be the actual mocks but can also be proxies of mocks what is something already being applied by frameworks such as spring.;;0;convert accumulator to take a blockbuilder;make `evaluateintermediate()` and `evaluatefinal()` take a `blockbuilder` rather than producing a `block` just like `groupedaccumulator`;;;;;0;1;;
2042;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;mock resolver plugin;adds a plugin to allow for adding one or multiple mock resolvers. this way  instances that are provided to mockito s dsl do no longer require to be the actual mocks but can also be proxies of mocks what is something already being applied by frameworks such as spring.;;198.0;mock resolver plugin;adds a plugin to allow for adding one or multiple mock resolvers this way instances that are provided to mockitos dsl do no longer require to be the actual mocks but can also be proxies of mocks what is something already being applied by frameworks such as springthis works today with the subclass mock maker by accident as we read the mock state from the mock instance via a method which gets proxied if we ever find a more private appraoch this would however break springs mockito use and it is already broken with the inline mock makerby this spi spring could add an unproxy resolver to its mockito build-up and make its proxied mocks compatible with mockito other frameworks could use the same approach if desired as this spi is genericcloses #1980; merging 2042 ;add matchers for scala value classes containing primitives;the complete details are herehttps://groupsgooglecom/d/msg/mockito/m_ptz8evh58/ws2czeaad-oj;hiactually that will probably never happen as these classes are in the scala library which we cannot depend upon if this lib is not there then the class wont even load instead id rather suggest that it should be mockito sugar to declare them || i think that there is possibility i know that npe in any[somevalueclass] happens because of trying to assign null to value that looks like object but is primitive  maybe there is possibility to add some reflection checks in runtime instead of null just try to assign default primitive value as in handyreturnvaluesjavathe same could be applied to other matchers as matcherequal  there could be introduced some reflection check if given class has method equals() in runtime if not the comparison should be done as for primitivesthats why the hack anyobject()asinstanceof[somevalueclasswithstringvalue] works the string is simply not a primitive but has equals || i do not think we will put scala specific inside mockito as we just dont add groovy / android / jee specific stuffs because wed like to keep the working set as simple and focused as possible also theres the reason that we are not able to maintain stuff that we dont use in the team in our daily job this is especially true for scala / groovy and androidwhat you are asking certainly could be implemented in the mockito sugar library by changing the default answer of a mock at creation time (if not overridden by a user)as for matchers these would probably have to be handled by mockito sugar as well i just google and found that it is part of scalatest and that their project is host on gh too you should report to them imho :  || i understand that thank you || @ppiotrow thx to you for the interest in mockito ) ||;1;0;"fixing ""best"" constructor choice";
2046;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;do not exclude synthetic constructors from instrumentation. 2040.;byte buddy does exclude synthetic members by default as they normally provide necessary infrastructure outside of business logic (e.g. bridge methods). for constructor instrumentation  it is however crucial that no code is called during mock creation and that fields are copied during spy creation.;;0;removed unnecessary null check from iobaseencodingencode(bytes);the check is done on line 166 so the first check is redundant;  thanks josh! we dont have a good mechanism for merging patches so im going to submit a change internally and it should get mirrored out shortlythere were actually a handful of unnecessary checknotnulls in this filei think i got em allthanks again! ||;;;;0;1;;
2046;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;do not exclude synthetic constructors from instrumentation. 2040.;byte buddy does exclude synthetic members by default as they normally provide necessary infrastructure outside of business logic (e.g. bridge methods). for constructor instrumentation  it is however crucial that no code is called during mock creation and that fields are copied during spy creation.;;0;fix caching of row type;;looks good some tests would be good too ||;;;;0;1;;
2046;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;do not exclude synthetic constructors from instrumentation. 2040.;byte buddy does exclude synthetic members by default as they normally provide necessary infrastructure outside of business logic (e.g. bridge methods). for constructor instrumentation  it is however crucial that no code is called during mock creation and that fields are copied during spy creation.;;2040.0;do not exclude synthetic constructors from instrumentation 2040;byte buddy does exclude synthetic members by default as they normally provide necessary infrastructure outside of business logic (eg bridge methods) for constructor instrumentation it is however crucial that no code is called during mock creation and that fields are copied during spy creation; merging 2046 ;mockitospy(activity)getbasecontext() returns null on robolectric 44 and java8;### descriptionsince robolectric 44 mockitospy(activity)getbasecontext() returns null### steps to reproduce```$ git clone -b mockito_spy_robolectric_4_4  demo$ cd demo// switch to robolectric 431$ git checkout head~1$ /gradlew  testdevelopdebugunittestbuild successful in 14s28 actionable tasks: 28 executed// switch to robolectric 44$ git checkout mockito_spy_robolectric_4_4$ /gradlew  testdevelopdebugunittest> task  testdevelopdebugunittest failedfailure: build failed with an exception* what went wrong:execution failed for task  testdevelopdebugunittest```failed unittest result :  robolectric & android version- compile sdk : 29- target sdk : 28- robolectric : 44 - mockito : 3510- jvm : openjdk 8### link to a public git repo demonstrating the problem: issue is copied from https://githubcom/robolectric/robolectric/issues/5916;"this seems to work with slightly older versions of mockito-inline eg 342 ill try a bisect and see what commit may have broken it || i did a bisect and this seems to have started failing in 47ef05814784183cd5c1d297078e2ad7e31cce34 `adds support for creating spies from within a mock instances constructor thus avoiding reflection on final fields`the workaround is to use mockito-inline < 350 i believe || i just had a look and the problem is likely with robolectric maybe they can have a look at the problem?mockito simply invokes the constructor chain and per class and within the constructor it copies all values field by field i am wondering if robolectric does some explicit initialization where this approach now failsi am to foreign to both android and robolectric to really understand why this no longer works but it likely is related to the timing of the field copyworst case we need to offer a switch to create spies using reflection if required but if we can get a hint why this timing is a problem we might be able to address this || thanks for the initial investigation @raphw i am one of the robolectric maintainers and can try investigating this its odd that on java 11 this occasionally works (but it is flaky according to robolectric/robolectric#5916) but on java 8 it seems to always fail || id like to understand in what field value the two objects differ to produce this result they should be identical unless some field is not discoverableif you could check what state difference is responsible i can probably find out how it occurred  || out of curiosity is there some kind of helper/debug util in mockito to dump an object to a string? in the meantime ill try to just serialize it to a json-type format || no we can dump class files but you could likely use a serializer such as jackson for this? || weird out of 269 fields the only difference is a field called mbase on the spy object it is null```diff132c132< class androidcontentcontextwrapper  androidappcontextimpl@6d340ec8---> class androidcontentcontextwrapper  null269a270>```mainactivity:    there a way to turn on debug logs during this field copy to see how mbase is being copied? || this is the class that contains the mbase field: its a long class hierarchy `mainactivity > appcompatactivity > fragmentactivity > componentactivity > activity > contextthemewrapper > contextwrapper > context` || i just noticed [contextthemewrapper]( which is the parent of contextwrapper calls the contextwrapper(null) constructor which could be setting mbase to null in contextwrapper:```    public contextthemewrapper() {        super(null)    }``````    public contextwrapper(context base) {        mbase  base    }```could this be causing `mbase` to be set to null? || how does one dump the class bytecode of the transient spy class created? i am curious what that looks like || -dnetbytebuddydump/some/folder || > mockito simply invokes the constructor chain and per class and within the constructor it copies all values field by fieldfor some reason when i do `spy(object)` i am not seeing the constructors being invoked what constructors does mockito invoke? are there some new/hidden constructors being generated? || no the constructors are pre and then the original chain is shortcut basically:```javapublic myclass { myclass() {  // some code} }```is turned into:```javapublic myclass { myclass() {  if (mockitoismockconstruction()) {    // mockito stuff basically copy all fields of the spied at object    return  }  // some code} }```as a consequence you cannot set a constructor breakpoint i had a look at the field state and for both *activity* and *mockactivity* `contextwrappermbase` is set to the same instance but only *activity* returns the fields value || out of curiosity how do you inject print statements to the field copy bytebuddy logic? i wanted to add some print statements to verify that the mbase before/after values are the same> i had a look at the field state and for both activity and mockactivity contextwrappermbase is set to the same instance but only activity returns the fields valuehow can you tell that? from what i see it seems like mbase is null for the spy activity:( you think its initially non-null and then gets set to null? || you are right i did not debug properly (intellij refuses to run the sample project for me i am back on the command line)when i inspect the transformed `contextwrapper` constructor i do however see that the field is copied within it:```        69: getfield      #40                 // field mbase:landroid/content/context        72: aload_0        73: dup_x1        74: pop        75: putfield      #40                 // field mbase:landroid/content/context```when is the `mbase` field populated? is this something done after object construction? || i created a special debug build (*println-constructor* you can run it by using your local maven repo and the *publishtomavenlocal* task of mockito) which shows what is happening by printing all field assignments it follows the pattern```<class name> // for each in hierarchy<mock object><field name> // for each field<spied field value><mock field value after setting>```this verifies that the field is actually set its very strange that the field is null again once it is used since this problem occurs only with robolectric there must be some mechanism where the value disappearsi also added a statement for the spy when it is constructed in its entirety and the field seems to be set correctly:```    debug robolectics: androidappcontextimpl@51ad277e - original androidappcontextimpl@51ad277e``````    class androidcontentcontext    comexamplemyapplicationmainactivity@6219c42b    public javalangobject androidcontentcontext__robo_data__    null    null    class androidcontentcontextwrapper    comexamplemyapplicationmainactivity@6219c42b    public javalangobject androidcontentcontextwrapper__robo_data__    null    null    androidcontentcontext androidcontentcontextwrappermbase    androidappcontextimpl@51ad277e    androidappcontextimpl@51ad277e    ``` || its very strange i optimized the example for output now and the fields seem to be set now that i changed the code:```java        field field  classforname(""androidcontentcontextwrapper"")getdeclaredfield(""mbase"")        fieldsetaccessible(true)        mainactivity activity  robolectricbuildactivity(mainactivityclass)setup()get()        object fieldbefore  fieldget(activity)        object methodbefore  activitygetbasecontext()        mainactivity spyactivity  mockitospy(activity)        throw new assertionerror(""activity field: "" + fieldget(activity)                        + "" - mock activity field: "" + fieldget(spyactivity)                        + "" - activity getter: "" + activitygetbasecontext()                        + "" - mock activity getter: "" + spyactivitygetbasecontext()                        + "" - activity field before: "" + fieldbefore                        + "" - activity getter before: "" + methodbefore                        + "" - original: "" + activity                        + "" - mock: "" + spyactivity)```my gutt fealing is that thats some sort of initialization issue for the original object that is triggered later then mockito expects it || maybe i turned blind but simply running:```javamainactivity activity  robolectricbuildactivity(mainactivityclass)setup()get()mainactivity spyactivity  mockitospy(activity)throw new assertionerror(activitygetbasecontext() + "" - "" + spyactivitygetbasecontext())```of the current *release/3x* branch yields both fields being set correctly maybe this is something we already fixed in mockito by accident? || okay i verified that mockito creates the spy correctly in any case but something happens to the object if passed through robolecticss runner logicthis test will function correctly:```@testpublic void test1() {  mainactivity activity  robolectricbuildactivity(mainactivityclass)setup()get()  mainactivity mockactivity  spy(activity)  assertequals(""compare base context between activity and mockactivity""     activitygetbasecontext()     mockactivitygetbasecontext())    }```while this test will yield yield an empty spy:```javaprivate mainactivity activityprivate mainactivity mockactivity@beforepublic void setup() {   activity  robolectricbuildactivity(mainactivityclass)setup()get()   mockactivity  spy(activity)}@testpublic void test1() { assertequals(""compare base context between activity and mockactivity""   activitygetbasecontext()       mockactivitygetbasecontext())}```how can that be? || comparing the output of the println branch: if the mock is created in the `@before` method the `contextwrapper` constructor is never invoked what seems dubious something must be done differently here || i added a simpler test case to the robolectric tree (currently `@ignored`) is very strange ive also seen situations where the test starts passing randomly and i usually have to do a `clean` to get it to start failing again it seems to fail more consistently when running through gradle vs running through intellij this sometimes indicates a classpath issuethanks for all your investigation and putting up that println branch ill try some print debugging as well || after adding some additional debug statements it seems like the mockito instrumentation for `contextwrapper` constructor is skipped so `contextthemewrapper` tries to call the  `contextwrapper` constructor but it calls a non-instrumented one maybe the default empty constructor is private?```start of constructor for class androidappactivityinvoking super constructor class androidappactivity -> android/view/contextthemewrapperstart of constructor for class androidviewcontextthemewrapperinvoking super constructor class androidviewcontextthemewrapper -> android/content/contextwrapperstart of constructor for class androidcontentcontextinvoking super constructor class androidcontentcontext -> java/lang/object``` || from looking at the bytecode i see that contextthemewrapper calls contextwrapper():```  public androidviewcontextthemewrapper()            31: invokespecial #317                // method android/content/contextwrapper""<init>"":()v```however in contextwrapper the no-arg constructor is not insrumented:```  public androidcontentcontextwrapper()    code:       0: aload_0       1: invokespecial #816                // method android/content/context""<init>"":()v       4: aload_0       5: invokevirtual #819                // method $$robo$init:()v       8: return```the one-arg contextwrapper constructor is instrumented though:```  public androidcontentcontextwrapper(androidcontentcontext)``` || this seems to be a simpler repro of the issue (non-robolectric):** edit **nvm still looking into a non-robolectric repro: || the issue seems to be that mockito is not instrumenting the no-arg `public androidcontentcontextwrapper()` constructor yet it is the one being selected to be called from the base class `contextthemewrapper` the one-arg `public androidcontentcontextwrapper(context)` does get instrumented but the no-arg one is preferred as the one to be called from the base classdo you know what might cause mockito to skip over the no-arg `public androidcontentcontextwrapper()` constructor? || is that constructor added later by robolectrics? maybe theres some confusion around the creation order it instruments the constructors in-flight but takes basis on the reflective model you can set a breakpoint in the `constructorshortcut`s `wrap` method  does the no-arg constructor ever arrive here? if not walk a bit down the stack into byte buddy to see if byte buddy was able to resolve this constructor to begin with || yes it does seem like robolectric adds the no-arg constructor: does it do this? i cannot say exactly that code was added many years ago) || its certainly related to that byte buddy uses the reflection api to process the members how is it even possible that the reflection api is unaware of a constructor? a class cannot add members after its loaded the jvm does not allow it i assume this also explains why it makes a difference where the mock is created does robolectrics transform classes from one class loader into another? i have a feeling this is somewhat related to parallel versions of the same class  || as a workaround mockito could prefer non-synthetic constructors for the time being  || another possible solution: could mockito only select super-constructors to call that are known to be instrumented? it should be possible to keep track of that || `constructorshortcutwrap` never hits the no-arg `contextwrapper()` constructor i am not sure how to check if bytebuddy ever resolved it but i do not believe it did || > i have a feeling this is somewhat related to parallel versions of the same classyes i believe this is happening when an android test is run initially the android sdk stubs are on the classpath which contains a small subset of the real android framework jar that are all no-ops robolectric during runtime pulls in the real android framework jars and instruments the android classes to use the real android code (plus mixes in the shadows which override the framework method implementations) || btw i think preferring non-synthetic constructors seems like a fine workaround for now i will attempt to stop adding the no-arg constructor to android objects im not sure to what extent it is still being used || actually bytebuddy does seem to find the no-arg contextwrapper constructor but `methoddescription` is null so the `wrap` method does not get invoked:![image]( || yes its in the changed class file but i wonder why the reflection api does not contain those constructors thats why byte buddy cannot map them i assume that the class is reloaded somehow into another class loader what then causes this mismatchthe problem in short is that contectwrapper classgetdeclaredconstructors() does not add the added no argument constructor  || thanks for all your hard work @raphw! i am glad this is fixed || right back at you! thanks for your patient debugging help!  || ";1;0;do not exclude synthetic constructors from instrumentation 2040;
2051;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;create sensible default settings for  enable save actions  and  cleanup  dialogs;sensible default settings for  enable save actions  field of database properties dialog and  run field formatter  field of cleanup eintries dialog are now identical 🐨 please take a look for merge. thx 🐰  - change the default setting - by click on  reset  button:  ![2016-10-15_23h31_31](  ![2016-10-15_23h31_45]( - change the default setting - by click on  recommend for bibtex  button:  ![2016-10-15_23h35_28](  ![2016-10-15_23h36_12]( - change the default setting - by click on  recommend for biblatex  button:  ![2016-10-15_23h38_27](  ![2016-10-15_23h38_40](  for further information have a look at:  😄  -   -   () -  -  internal qs;;0;immutablemapbuilder should have a public constructor which takes an initial capacity;when i use the builder and put multiple entries into the map the capacity keeps getting resized i know the desired capacity before hand so should be able to construct an immutable map of the correct size and avoid this performance taxthe builder already has a package private capacity constructor i can not find documentation as to why this is not public ( may have explained but it is no longer available);thumbs on this suggestion yeah by defining the initial size cosf of adding the each entry in a map will be reduced in time complexity in expanding the bucket || this would be really useful and same thing goes for all other immutable\* classes || having the ability to to specify the capacity for builders when known a priori would be very beneficial for us || dupe of  || verified #196 is a duplicate of my request closing this issue ||;;;;0;1;;
2051;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;create sensible default settings for  enable save actions  and  cleanup  dialogs;sensible default settings for  enable save actions  field of database properties dialog and  run field formatter  field of cleanup eintries dialog are now identical 🐨 please take a look for merge. thx 🐰  - change the default setting - by click on  reset  button:  ![2016-10-15_23h31_31](  ![2016-10-15_23h31_45]( - change the default setting - by click on  recommend for bibtex  button:  ![2016-10-15_23h35_28](  ![2016-10-15_23h36_12]( - change the default setting - by click on  recommend for biblatex  button:  ![2016-10-15_23h38_27](  ![2016-10-15_23h38_40](  for further information have a look at:  😄  -   -   () -  -  internal qs;;0;update to openjdk 15;use java 15 in builds for most recent java version;"seems like we got some test failures :( || needed to update jacoco works now || strangely enough it builds locally will investigate some more!  || its weird if i build locally with the same command and java version (build and major) i cannot reproduce this error || i dont think i have java 15 installed on any of my machines and not sure if i can get a hold of them looking at the test failures many of them seem related to how we handle `null` with primitive matchers is there some way to check the changelog to see if we see any suspicious changes? || i ran the exact build version locally and it works on a fresh clone even also on linux  || i am seeing these failures for jdk 15 (build 15+36-1562) as well but on windowsit looks like the cause for this is [jdk-8233014]( which enables ""helpful nullpointerexceptions"" by defaultthe tests which are failing apparently make assumptions about how nullpointerexceptions look like which are now not true anymore:*  now mentions the name of the method which returned `null`:  > javalangnullpointerexception: cannot invoke ""javalangbytebytevalue()"" because the return value of ""orgmockitousageimethodsbyteobjectreturningmethod()"" is null*  that nullpointerexception has no message*  that nullpointerexceptions has no message || thanks for the great investigation @marcono1234 do you mind creating a pr with the necessary fixes to make it work on jdk 15? || i fear that i am not familiar enough with mockito to perform these changes while still keeping the intended functionality for the testsfor `stubbingwithdelegatetest` it looks like this could be simplified to checking whether the returned `byte` is `null` instead of provoking the `nullpointerexception` is that correct? i assume for `deepstubsserializabletest` it is similar it might already suffice to check whether `next()` returned `null`but for `invaliduseofmatcherstest` maybe the only solution would be to drop the requirement that the message must be `null` || the requirement does not seem meaningful to me at least i just  the tests to not require an empty message ||   good point i just adjusted the tests || ";;;;1;1;adjust build to support java 15;
2051;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;create sensible default settings for  enable save actions  and  cleanup  dialogs;sensible default settings for  enable save actions  field of database properties dialog and  run field formatter  field of cleanup eintries dialog are now identical 🐨 please take a look for merge. thx 🐰  - change the default setting - by click on  reset  button:  ![2016-10-15_23h31_31](  ![2016-10-15_23h31_45]( - change the default setting - by click on  recommend for bibtex  button:  ![2016-10-15_23h35_28](  ![2016-10-15_23h36_12]( - change the default setting - by click on  recommend for biblatex  button:  ![2016-10-15_23h38_27](  ![2016-10-15_23h38_40](  for further information have a look at:  😄  -   -   () -  -  internal qs;;0;add aggregation functions including corr covarregr-slope regr-interce;add aggregation functions including corr covarregr-slope regr-intercept and unit tests;"please add these to the documentation || should i write the documentation now or wait till the change is reviewed and accepted? || add it to this pull request so that we can review it as a single unit the docs should go in presto-docs/src/main/sphinx/functions/aggregaterst || ok will do that!  the code formatting does not match the rest of presto please reformat using our code style for intellij:  || title the commit ""add statistical aggregation functions"" || address david and martins comment || let me know when youve addressed those comments and ill take another look || id like to review this again after the requested changes have been made || assign to @electrum once youve addressed his comments || @haozhun discussed with @linfb and shes not going to work on this anymore could you take this over and address the comments when you have time? || will do || ";;;;0;1;;
2071;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;tooltips now working in the main table;fixes:   tool tips in the main table now work as expected.  if the content of the cell is too big to be rendered in the cell itself it will be shown as a tool tip. what is more important  the original tool tip or the content?;;0;cleanup;remove getter/predicate functions and replace them with method references or lambdas;;;;;0;1;;
2071;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;tooltips now working in the main table;fixes:   tool tips in the main table now work as expected.  if the content of the cell is too big to be rendered in the cell itself it will be shown as a tool tip. what is more important  the original tool tip or the content?;;206.0;2061: argumentmatcher error messages use lambda class names;2061; merging 2071 ;nojunitdependenciestest is failing on windows machine;i found nojunitdependenciestest unit test is the only unit test that fails when you run the build on windows machine (i have also ubuntu and it is fine for some reason on unix platform)root cause: caused by: javalangnoclassdeffounderror: org\mockito\internal\invocation\invocationmarker (wrong name: org/mockito/internal/invocation/invocationmarker)full stacktrace  org\mockito\internal\invocation\invocationmarker has some dependency to junit    at orgmockitointegrationnojunitdependenciestestcheckdependency(nojunitdependenciestestjava:36)    at orgmockitointegrationnojunitdependenciestestpure_mockito_should_not_depend_junit(nojunitdependenciestestjava:28)    at sunreflectnativemethodaccessorimplinvoke0(native method)    at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:57)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javalangreflectmethodinvoke(methodjava:601)    at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:45)    at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:15)    at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:42)    at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:20)    at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:263)    at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:68)    at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:47)    at orgjunitrunnersparentrunner$3run(parentrunnerjava:231)    at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:60)    at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:229)    at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:50)    at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:222)    at orgjunitrunnersparentrunnerrun(parentrunnerjava:300)    at orggradleapiinternaltaskstestingjunitjunittestclassexecuterruntestclass(junittestclassexecuterjava:86)    at orggradleapiinternaltaskstestingjunitjunittestclassexecuterexecute(junittestclassexecuterjava:49)    at orggradleapiinternaltaskstestingjunitjunittestclassprocessorprocesstestclass(junittestclassprocessorjava:69)    at orggradleapiinternaltaskstestingsuitetestclassprocessorprocesstestclass(suitetestclassprocessorjava:48)    at sunreflectgeneratedmethodaccessor37invoke(unknown source)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javalangreflectmethodinvoke(methodjava:601)    at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:35)    at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:24)    at orggradlemessagingdispatchcontextclassloaderdispatchdispatch(contextclassloaderdispatchjava:32)    at orggradlemessagingdispatchproxydispatchadapter$dispatchinginvocationhandlerinvoke(proxydispatchadapterjava:93)    at comsunproxy$proxy2processtestclass(unknown source)    at orggradleapiinternaltaskstestingworkertestworkerprocesstestclass(testworkerjava:105)    at sunreflectgeneratedmethodaccessor36invoke(unknown source)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javalangreflectmethodinvoke(methodjava:601)    at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:35)    at orggradlemessagingdispatchreflectiondispatchdispatch(reflectiondispatchjava:24)    at orggradlemessagingremoteinternalhubmessagehub$handlerrun(messagehubjava:360)    at orggradleinternalconcurrentdefaultexecutorfactory$stoppableexecutorimpl$1run(defaultexecutorfactoryjava:64)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1145)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:615)    at javalangthreadrun(threadjava:722)caused by: javalangnoclassdeffounderror: org\mockito\internal\invocation\invocationmarker (wrong name: org/mockito/internal/invocation/invocationmarker)    at javalangclassloaderdefineclass1(native method)    at javalangclassloaderdefineclass(classloaderjava:791)    at javasecuritysecureclassloaderdefineclass(secureclassloaderjava:142)    at javaneturlclassloaderdefineclass(urlclassloaderjava:449)    at javaneturlclassloaderaccess$100(urlclassloaderjava:71)    at javaneturlclassloader$1run(urlclassloaderjava:361)    at javaneturlclassloader$1run(urlclassloaderjava:355)    at javasecurityaccesscontrollerdoprivileged(native method)    at javaneturlclassloaderfindclass(urlclassloaderjava:354)    at orgmockitoutilclassloaders$localexcludingurlclassloaderfindclass(classloadersjava:156)    at javalangclassloaderloadclass(classloaderjava:423)    at javalangclassloaderloadclass(classloaderjava:356)    at javalangclassforname0(native method)    at javalangclassforname(classjava:266)    at orgmockitointegrationnojunitdependenciestestcheckdependency(nojunitdependenciestestjava:34)     41 more;hithanks for reporting i dont own a windows box so i dont know if i will fix this one asapthis has probably something to do with the path thats the only thing that come to me at that time || i reproduced problem and found solution - in a sec i will create pr ||;1;0;2061: argumentmatcher error messages use lambda class names;
2071;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;tooltips now working in the main table;fixes:   tool tips in the main table now work as expected.  if the content of the cell is too big to be rendered in the cell itself it will be shown as a tool tip. what is more important  the original tool tip or the content?;;2061.0;2061: argumentmatcher error messages use lambda class names;2061; merging 2071 ;lambda used as argumentmatcher causes decamelized lambda name to appear in error message;"### versionmockito version: 3513### descriptionrelates to #1932when using a lambda or method reference expression as `argumentmatcher` and the matcher fails the error message contains the lambda / method reference class name in ""decamelized"" form which is rather irritating eg:> myinterfacedosomething(    <mockito test$$ lambda$ 4 8/ 0x 0 0 0 0 0 0 0 8 0 0c 8f 4 4 0>)expected would be that similar to anonymous classes the error output says ""\<custom argument matcher\>"" this could probably be achieved by testing for `classissynthetic()` in `orgmockitointernalmatcherstextmatchertostringtostring(argumentmatcher<?>)` before calling `decamelizematcher` there### test case```javapublic class mockitotest {    interface myinterface {        void dosomething(string s)    }        private static boolean matches(string s) {        return false    }        public static void main(string args) {        myinterface mock  mock(myinterfaceclass)        try {            verify(mock)dosomething(argthat(arg -> false))        } catch (error e) {            eprintstacktrace()        }        try {            verify(mock)dosomething(argthat(mockitotest::matches))        } catch (error e) {            eprintstacktrace()        }                // when an anonymous class is used the output is <custom argument matcher>        // (as expected)        verify(mock)dosomething(argthat(new argumentmatcher<>() {            @override            public boolean matches(string argument) {                return false            }        }))    }}```";> this could probably be achieved by testing for classissynthetic() insounds like a good idea do you want to submit a pr?  sorry for the delay have submitted the pull request: #2071feedback is appreciated! ||;1;0;2061: argumentmatcher error messages use lambda class names;
2098;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;improve error message if initializer fails.;non-initializable classes can never be mocked  an error message should help guide on these issues.;;0;"bloom filter use ""final long data"" memorize bit data cause outofmemoryerror when a huge number of expected insertions";"bloom filter apply to filter big data usually maybe billions of records when the number of expected insertions is 10 billion and the false positive probability is 00001 it will take about 22g ram it not appropriate memorize by long array i changed the type to ""hashmap&ltinteger long&gt"" ensure long array less than 20m does this feather useful to somebody others ?";im afraid this is not a use case that guavas bloomfilter support will be addressing most of our users by far have far less extreme requirements ||;;;;0;1;;
2098;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;improve error message if initializer fails.;non-initializable classes can never be mocked  an error message should help guide on these issues.;;0;improve error message if initializer fails;non-initializable classes can never be mocked an error message should help guide on these issues;indeed just updated the pr ||  merging 2098 ;;;;1;1;update src/main/java/org/mockito/internal/creation/bytebuddy/inlinebytecodegeneratorjavaco-authored-by: marcono1234 <marcono1234@usersnoreplygithubcom>;
2098;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;improve error message if initializer fails.;non-initializable classes can never be mocked  an error message should help guide on these issues.;;0;fix for row number window function optimization;;2095 || ;;;;0;1;;
2135;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add void static method mocking example;signed-off-by: gábor lipták <gliptak@gmail.com>;;0;exhume the enumerator -> iterable idea?;"hi folks im hessitant to raise a suggestion already discussed and closed but since last time java 8 has come along which might give the idea merit again(?)it seems that the ""impossible"" `iterables` equivalant of `iteratorsforenumeration` could be implemented by taking a `supplier<enumeration<t>>` with lambdas & method references this can yeild uses which arent even too horrible such as:```for (mytreenode node : iterablesforenumerationsupplier(tree::preorderenumeration)) {  //}```and which also save a bit of memory churn cf `collectionslist` if youre reaching for the duplicate button already the tickets youre looking for are: #1399 and #796 -)  still i think the supplier makes this well-defined and hence different from the ""single-use iterator as an iterable"" graveyard-suggestion made within those tickets";if youre presuming java 8 then im not sure why it wouldnt be easiest to do this yourself:  `(iterable<t>) () -> iteratorsforenumeration(treepreorderenumeration())` _is_ the `iterable` youre looking for || oh thats nice and i agree this isnt _too_ horrible:```iterable<mytreenode> nodes  () -> iteratorsforenumeration(treepreorderenumeration())for (mytreenode node : nodes) { ```yet since java cant infer that the type needs to be `iterable<t>` on the right-side of a for-each id still be tempted to write my own utility to avoid either the cast or variable declaration simply extracting this line leads to the dangerous api:```public final class enumerations {  public static <t> iterable<t> asiterable(enumeration<t> en) {    return () -> iteratorsforenumeration(en)  }```which might encourage the accident of using an exhausted enumeration so i think ill still end up with this utility when rolling my own:```public static <t> iterable<t> asiterable(supplier<enumeration<t>> factory) {  checknotnull(factory)  return new iterable<t>() {    public unmodifiableiterator<t> iterator() {      return iteratorsforenumeration(factoryget())    }  }}```it would also allow this:```    iterablesforenumerationsupplier(this::preorderenumeration)        foreach(node -> nodedosomething())```which has a lot less punctuation than:```    ((iterable<mytreenode>) () -> iteratorsforenumeration(treepreorderenumeration()))        foreach(node -> nodedosomething())``` || without saying yes or no yet some thoughts:a) its not clear where a supplier<enumeration<t>> would come from that couldnt be changed to provide an iterable in the first placeb) ```((iterable<mytreenode>) () -> iteratorsforenumeration(treepreorderenumeration()))    foreach(node -> nodedosomething())```can also be written```iteratorsforenumeration(treepreorderenumeration()))    foreachremaining(node -> nodedosomething())```without bringing `iterable` into it at all || (a) my motivating case was `defaultmutabletreenode` which has a few different methods returning enumerations and in some scenarios we may not be able to use a derived class anyway(b) is nice: both concise and efficient between that and `collectionsaslist` (for traditional loops) im happy to drop the request while it might add a little symmetry its hard to argue for much utility given this good alternative in java 8 (the requested method could probably only be used concisely in java 8);;;;0;1;;
2135;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add void static method mocking example;signed-off-by: gábor lipták <gliptak@gmail.com>;;0;add void static method mocking example;signed-off-by: gábor lipták <gliptak@gmailcom>https://githubcom/mockito/mockito/issues/2027;;;;;1;1;add void static method mocking examplesigned-off-by: gábor lipták <gliptak@gmailcom>;
2135;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;add void static method mocking example;signed-off-by: gábor lipták <gliptak@gmail.com>;;0;inconsistent results with joins when parent stage does not get slot in any nodes to assign splits;we use smaller value(20) in comparison to default(1000) for max-splits-per-node which makes it easier to hit this bugbasically in a race between parent stage and its substage of join task parent stage was not able to schedule some splits in first iteration leading to waitforfreenodes() call which does not add bufferid for the tasks it creates later on parent stage scheduled some splits on the nodes for whomthere were no bufferids with substage tasks leading to incomplete join and wrong results;;;;;0;1;;
2140;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;endorsed mockitotestnglistener in the documentation;after the latest changes in mockitotestnglistener i sure that can be used without worry.;;0;add transform/filters shortcuts for common data types to fluentiterables or a new fluent class;hifluentiterable is very useful but lacks some shortcuts for transform/filtering of primitives and common data types (string date calendar)suggestion for transform shortcuts:- asint() aslong() asstring() asshort() asbyte() aschar() asdouble() asfloat() asdate(timezone) asdate(timezone format)suggestion for filter shortcuts:- all: isnotnull() isnull()- string: isempty() isnotempty()- numbers: isnotzero() iszero() ispositive() isnegative()- dates: istoday() isthisweek() isthismonth() isthisyear() isweekend() isnotweekend()the shortcuts could be clever enough to do the conversion before filtering eg if i use isempty() as filter then asstring() is executed firstin case is too specific for fluentiterable a new fluent class can be createdi can contribute with this change but i prefer to talk about it first i have some draft implementationssome examples of combinations:- given a list of dates in numeric string format get a filtered set of dates which are today``` javafrom(list)aslong()ispositive()asdate(timezone)istoday()toset()```- given a list of text numbers get a filtered list with the positive values as integer:``` javafrom(list)isnotnull()asint()ispositive()tolist()```;the value of adding these specializations of `fluentiterable` (particularly for jdk types like `date` and `calendar` which people really shouldnt be using) would be extremely minor and the added complexity would be huge we wont be doing this ||;;;;0;1;;
2140;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;endorsed mockitotestnglistener in the documentation;after the latest changes in mockitotestnglistener i sure that can be used without worry.;;0;endorsed mockitotestnglistener in the documentation;after the latest changes in mockitotestnglistener i sure that can be used without worrycheck list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_; merging 2140 ;;;;1;1;a little mockitotestnglistener promotion;
2140;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;endorsed mockitotestnglistener in the documentation;after the latest changes in mockitotestnglistener i sure that can be used without worry.;;0;fail task when local planning fails;;;;;;0;1;;
2145;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;change download url to downloads.jabref.org;we want to get back control of the download site we offer. thus  we created  ( with a redirection to fosshub.  refs #1670;;0;add direct support for java 8 versions of predicate function etc;im thinking about adding support for all the java 8 [`javautilfunction`]( classes to the methods that use similar guava classesfor example there would be both (type parameters removed for brevity):- `multimapsfilterentries(multimap map googlecommonbasepredicatepredicate predicate)`-  `multimapsfilterentries(multimap map javautilfunctionpredicate predicate)`this would allow guava to have the more convenient syntax of java 8 lambdas without breaking backwards compatibilitythis has the obvious drawback of guava having java 8 as a compile time dependency however now that we are past java 7 end of life it is time to at least consider doing that anywayim proposing that i do some/most/all the work for this but i wanted to run it by the guava team before i began the process;hiwe already have extensive plans for java 8 support but this feature in particular would actively hurt not help  lambdas can already be used with cgcbasefunction and every other single-method interface anywhere  if we added overloads for two different interfaces -- eg our predicate and jufpredicate -- that would actively break lambdas you would have to explicitly cast the lambda to the desired type which would make the code significantly less readable for everyone  you would _have_ to write```multimapsfilterentries(multimap    (javautilfunctionbipredicate<k v>) (key value) -> test(key value))```which would be very badeven if you do have a javautilfunctionfunction stored as a constant or returned from a method somewhere and you want to pass it to a method expecting a comgooglecommonbasefunction all you have to write is myfunction::apply   || oh goodness this stemmed from me not understanding how lambdas work specifically that java is smart enough to figure out whether to use `cgcbasefunction` vs `juffunction` based on the method signature i had put the lambda in a local variable in my test and it didnt work (obviously) my mistake thanks for the clarification! ||;;;;0;1;;
2145;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;change download url to downloads.jabref.org;we want to get back control of the download site we offer. thus  we created  ( with a redirection to fosshub.  refs #1670;;0;"fix in the doc for ""mocking object construction""";"this is a suggestion for changing the documentation for ""mocking objectconstruction""  previously the documentation has suggested that`mockedconstruction` can define mock behavior and to verify static methodinvocations  however it is meant for defining mock behavior and verifyingnon-static method invocations -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_"; merging 2145 ;;;;1;1;"fix in the javadoc for ""mocking object construction""this is a suggestion for changing the documentation for ""mocking objectconstruction""  previously the documentation has suggested thatmockedconstruction can define mock behavior and to verify static methodinvocations  however it is meant for defining mock behavior and verifyingnon-static method invocations";
2145;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;change download url to downloads.jabref.org;we want to get back control of the download site we offer. thus  we created  ( with a redirection to fosshub.  refs #1670;;0;add release note for join bug;;;;;;0;1;;
2158;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;add field type in @mock example;javadoc-only change;;0;typevisitorvisitclass in typeresolverpopulatetypemappings should report the to type as well as the from type;"the visitclass implementation in typeresolverpopulatetypemappings has the following body:```  @override void visitclass(class<?> fromclass) {    // cant map from a raw class to anything other than itself    // you cant say ""assuming string is integer""    // and we dont support ""assuming string is t"" user has to say ""assuming t is string""     throw new illegalargumentexception(""no type mapping from "" + fromclass)  }```it would be great if the illegalargumentexception message reported the type its trying to convert to as well as the one its converting from for easier debugging should this exception be thrown";;;;;0;1;;
2158;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;add field type in @mock example;javadoc-only change;;0;add field type in @mock example;javadoc-only change<sup>(imo not worth separate issue nor rn mentioning)</sup>;nice thanks for fixing! ||;;;;1;1;add field type in @mock example;
2158;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;add field type in @mock example;javadoc-only change;;0;convert raptor to javautiloptional;;;;;;0;1;;
2175;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix memory leak in entry editor;this is to 2166.  list of changes - - updated microba to latest version - unregister entryeditor as a listener to entry  - implement searchqueryhighlightobservable using entrybus - make entryeditor unregister all fields that are listening on the global search bar.;;0;"documentation on rangesexplained ""encloses"" appears to be wrong";" statement needs review:""[36] does not enclose (11] even though it contains every value contained by the latter range""since the second part of the statement is not accurate";this is one of those things that is technically absolutely correct but still confusing || oh im sorry  you are correct the second statement is a vacuous truth specifically since the range (11] does not contain _any_ elements the range [36] _vacuously_ contains _all_ elements in (11] ||;;;;0;1;;
2175;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix memory leak in entry editor;this is to 2166.  list of changes - - updated microba to latest version - unregister entryeditor as a listener to entry  - implement searchqueryhighlightobservable using entrybus - make entryeditor unregister all fields that are listening on the global search bar.;;0;argumentmatches: fix javadoc typo/grammar;"i started out with noticing the ""safer that it was"" part which felt like a typo then i realized there were perhaps more errors in this sentence (which was duplicated in multiple places in this file) please verify that i understood the intent of this comment correctly but my hope is that this is now the more correct way to express thisagain thanks for a great framework!   ";;;;;1;1;argumentmatches: fix javadoc typo/grammar;
2175;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix memory leak in entry editor;this is to 2166.  list of changes - - updated microba to latest version - unregister entryeditor as a listener to entry  - implement searchqueryhighlightobservable using entrybus - make entryeditor unregister all fields that are listening on the global search bar.;;0;query tree cleanups;;;;;;0;1;;
2176;0;1;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;bump versions.errorprone from 2.4.0 to 2.5.1;bumps  versions.errorprone  from 2.4.0 to 2.5.1. updates  error_prone_core  from 2.4.0 to 2.5.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_core s releases</a>.</em></p> <blockquote> <h2>error prone 2.5.1</h2> <p>changes</p> <p>nosuchmethoderror:  com.sun.tools.javac.util.list com.sun.tools.javac.code.symbol$typesymbol.getenclosedelements</p> <ul> <li>fixed <code>nosuchmethoderror</code> crash in <code>hidingfield</code> (<a href=  >#2092</a>)</li> <li>fixed <code>nosuchelementexception</code> crash in <code>restrictedapichecker</code> (<a href=  >#2099</a>)</li> <li>false positive in <code>differentnamebutsame</code> (<a href=  >#2094</a>)</li> <li>false positive in <code>unnecessaryoptionalget</code> (<a href=  >#2101</a>)</li> <li>false positive in <code>unnecessarymethodreference</code> (<a href=  >#2102</a>)</li> <li>fixed a regression in jdk 16-ea support (<a href=  >#2105</a>)</li> </ul> <h2>error prone 2.5.0</h2> <p>new checks:</p> <ul> <li><a href=  >banserializableread</a></li> <li><a href=  >catchingunchecked</a></li> <li><a href=  >computeifabsentambiguousreference</a></li> <li><a href=  >dangerousliteralnull</a></li> <li><a href=  >datechecker</a></li> <li><a href=  >differentnamebutsame</a></li> <li><a href=  >donotcallsuggester</a></li> <li><a href=  >donotclaimannotations</a></li> <li><a href=  >donotmockautovalue</a></li> <li><a href=  >floggerformatstring</a></li> <li><a href=  >floggerlogvarargs</a></li> <li><a href=  >floggerlogwithcause</a></li> <li><a href=  >floggermessageformat</a></li> <li><a href=  >floggerpassedaround</a></li> <li><a href=  >floggerredundantisenabled</a></li> <li><a href=  >floggerrequiredmodifiers</a></li> <li><a href=  >floggersplitlogstatement</a></li> <li><a href=  >floggerwithcause</a></li> <li><a href=  >floggerwithoutcause</a></li> <li><a href=  >hashcodetostring</a></li> <li><a href=  >identityhashmapusage</a></li> <li><a href=  >immutablemembercollection</a></li> <li><a href=  >immutablesetforcontains</a></li> <li><a href=  >initializeinline</a></li> <li><a href=  >invalidthrowslink</a></li> <li><a href=  >isinstanceincompatibletype</a></li> <li><a href=  >javautildate</a></li> <li><a href=  >jodaconstructors</a></li> <li><a href=  >jodadatetimeconstants</a></li> <li><a href=  >longfloatconversion</a></li> <li><a href=  >membername</a></li> <li><a href=  >misplacedscopeannotations</a></li> <li><a href=  >objectequalsforprimitives</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >returnsnullcollection</a></li> </ul> <!-- raw html omitted --> </blockquote> <p> (truncated)</p> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>5e733ac</code></a> release error prone 2.5.1</li> <li><a href=  ><code>4f69766</code></a> support pre-jdk-8044853 early-desugaring of <code>jcnewclass</code></li> <li><a href=  ><code>6861403</code></a> don t set checks as <code>disableable = false</code> in external</li> <li><a href=  ><code>a7f3413</code></a> handle classes with explicit enclosing instances in <code>differentnamebutsame</code></li> <li><a href=  ><code>7a65117</code></a> <code>symbol.islocal</code> was renamed in jdk 16</li> <li><a href=  ><code>fb6d049</code></a> don t suggest private constructors for abstract classes</li> <li><a href=  ><code>7d93df4</code></a> fix handling of <code>super::</code> method references in <code>unnecessarymethodreference</code></li> <li><a href=  ><code>b1eaa17</code></a> only report <code>unnecessaryoptionalget</code> findings if the receivers are identical</li> <li><a href=  ><code>144c760</code></a> address a <code>visiblefortestingused</code> finding</li> <li><a href=  ><code>0951985</code></a> generate javadoc in ci pipeline</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />  updates  error_prone_test_helpers  from 2.4.0 to 2.5.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_test_helpers s releases</a>.</em></p> <blockquote> <h2>error prone 2.5.1</h2> <p>changes</p> <p>nosuchmethoderror:  com.sun.tools.javac.util.list com.sun.tools.javac.code.symbol$typesymbol.getenclosedelements</p> <ul> <li>fixed <code>nosuchmethoderror</code> crash in <code>hidingfield</code> (<a href=  >#2092</a>)</li> <li>fixed <code>nosuchelementexception</code> crash in <code>restrictedapichecker</code> (<a href=  >#2099</a>)</li> <li>false positive in <code>differentnamebutsame</code> (<a href=  >#2094</a>)</li> <li>false positive in <code>unnecessaryoptionalget</code> (<a href=  >#2101</a>)</li> <li>false positive in <code>unnecessarymethodreference</code> (<a href=  >#2102</a>)</li> <li>fixed a regression in jdk 16-ea support (<a href=  >#2105</a>)</li> </ul> <h2>error prone 2.5.0</h2> <p>new checks:</p> <ul> <li><a href=  >banserializableread</a></li> <li><a href=  >catchingunchecked</a></li> <li><a href=  >computeifabsentambiguousreference</a></li> <li><a href=  >dangerousliteralnull</a></li> <li><a href=  >datechecker</a></li> <li><a href=  >differentnamebutsame</a></li> <li><a href=  >donotcallsuggester</a></li> <li><a href=  >donotclaimannotations</a></li> <li><a href=  >donotmockautovalue</a></li> <li><a href=  >floggerformatstring</a></li> <li><a href=  >floggerlogvarargs</a></li> <li><a href=  >floggerlogwithcause</a></li> <li><a href=  >floggermessageformat</a></li> <li><a href=  >floggerpassedaround</a></li> <li><a href=  >floggerredundantisenabled</a></li> <li><a href=  >floggerrequiredmodifiers</a></li> <li><a href=  >floggersplitlogstatement</a></li> <li><a href=  >floggerwithcause</a></li> <li><a href=  >floggerwithoutcause</a></li> <li><a href=  >hashcodetostring</a></li> <li><a href=  >identityhashmapusage</a></li> <li><a href=  >immutablemembercollection</a></li> <li><a href=  >immutablesetforcontains</a></li> <li><a href=  >initializeinline</a></li> <li><a href=  >invalidthrowslink</a></li> <li><a href=  >isinstanceincompatibletype</a></li> <li><a href=  >javautildate</a></li> <li><a href=  >jodaconstructors</a></li> <li><a href=  >jodadatetimeconstants</a></li> <li><a href=  >longfloatconversion</a></li> <li><a href=  >membername</a></li> <li><a href=  >misplacedscopeannotations</a></li> <li><a href=  >objectequalsforprimitives</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >returnsnullcollection</a></li> </ul> <!-- raw html omitted --> </blockquote> <p>... (truncated)</p> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>5e733ac</code></a> release error prone 2.5.1</li> <li><a href=  ><code>4f69766</code></a> support pre-jdk-8044853 early-desugaring of <code>jcnewclass</code></li> <li><a href=  ><code>6861403</code></a> don t set checks as <code>disableable = false</code> in external</li> <li><a href=  ><code>a7f3413</code></a> handle classes with explicit enclosing instances in <code>differentnamebutsame</code></li> <li><a href=  ><code>7a65117</code></a> <code>symbol.islocal</code> was renamed in jdk 16</li> <li><a href=  ><code>fb6d049</code></a> don t suggest private constructors for abstract classes</li> <li><a href=  ><code>7d93df4</code></a> fix handling of <code>super::</code> method references in <code>unnecessarymethodreference</code></li> <li><a href=  ><code>b1eaa17</code></a> only report <code>unnecessaryoptionalget</code> findings if the receivers are identical</li> <li><a href=  ><code>144c760</code></a> address a <code>visiblefortestingused</code> finding</li> <li><a href=  ><code>0951985</code></a> generate javadoc in ci pipeline</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />   dependabot will resolve any conflicts with this pr as long as you don t alter it yourself. you can also trigger a rebase manually by commenting  @dependabot rebase .  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---  <details> <summary>dependabot commands and options</summary> <br />  you can trigger dependabot actions by commenting on this pr: -  @dependabot rebase  will rebase this pr -  @dependabot recreate  will recreate this pr  overwriting any edits that have been made to it -  @dependabot merge  will merge this pr after your ci passes on it -  @dependabot squash and merge  will squash and merge this pr after your ci passes on it -  @dependabot cancel merge  will cancel a previously requested merge and block automerging -  @dependabot reopen  will reopen this pr if it is closed -  @dependabot close  will close this pr and stop dependabot recreating it. you can achieve the same result by closing it manually -  @dependabot ignore this major version  will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this minor version  will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this dependency  will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)   </details>;;0;minor code cleanup for raptor;;looks good  ||;;;;0;1;;
2176;0;1;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;bump versions.errorprone from 2.4.0 to 2.5.1;bumps  versions.errorprone  from 2.4.0 to 2.5.1. updates  error_prone_core  from 2.4.0 to 2.5.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_core s releases</a>.</em></p> <blockquote> <h2>error prone 2.5.1</h2> <p>changes</p> <p>nosuchmethoderror:  com.sun.tools.javac.util.list com.sun.tools.javac.code.symbol$typesymbol.getenclosedelements</p> <ul> <li>fixed <code>nosuchmethoderror</code> crash in <code>hidingfield</code> (<a href=  >#2092</a>)</li> <li>fixed <code>nosuchelementexception</code> crash in <code>restrictedapichecker</code> (<a href=  >#2099</a>)</li> <li>false positive in <code>differentnamebutsame</code> (<a href=  >#2094</a>)</li> <li>false positive in <code>unnecessaryoptionalget</code> (<a href=  >#2101</a>)</li> <li>false positive in <code>unnecessarymethodreference</code> (<a href=  >#2102</a>)</li> <li>fixed a regression in jdk 16-ea support (<a href=  >#2105</a>)</li> </ul> <h2>error prone 2.5.0</h2> <p>new checks:</p> <ul> <li><a href=  >banserializableread</a></li> <li><a href=  >catchingunchecked</a></li> <li><a href=  >computeifabsentambiguousreference</a></li> <li><a href=  >dangerousliteralnull</a></li> <li><a href=  >datechecker</a></li> <li><a href=  >differentnamebutsame</a></li> <li><a href=  >donotcallsuggester</a></li> <li><a href=  >donotclaimannotations</a></li> <li><a href=  >donotmockautovalue</a></li> <li><a href=  >floggerformatstring</a></li> <li><a href=  >floggerlogvarargs</a></li> <li><a href=  >floggerlogwithcause</a></li> <li><a href=  >floggermessageformat</a></li> <li><a href=  >floggerpassedaround</a></li> <li><a href=  >floggerredundantisenabled</a></li> <li><a href=  >floggerrequiredmodifiers</a></li> <li><a href=  >floggersplitlogstatement</a></li> <li><a href=  >floggerwithcause</a></li> <li><a href=  >floggerwithoutcause</a></li> <li><a href=  >hashcodetostring</a></li> <li><a href=  >identityhashmapusage</a></li> <li><a href=  >immutablemembercollection</a></li> <li><a href=  >immutablesetforcontains</a></li> <li><a href=  >initializeinline</a></li> <li><a href=  >invalidthrowslink</a></li> <li><a href=  >isinstanceincompatibletype</a></li> <li><a href=  >javautildate</a></li> <li><a href=  >jodaconstructors</a></li> <li><a href=  >jodadatetimeconstants</a></li> <li><a href=  >longfloatconversion</a></li> <li><a href=  >membername</a></li> <li><a href=  >misplacedscopeannotations</a></li> <li><a href=  >objectequalsforprimitives</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >returnsnullcollection</a></li> </ul> <!-- raw html omitted --> </blockquote> <p> (truncated)</p> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>5e733ac</code></a> release error prone 2.5.1</li> <li><a href=  ><code>4f69766</code></a> support pre-jdk-8044853 early-desugaring of <code>jcnewclass</code></li> <li><a href=  ><code>6861403</code></a> don t set checks as <code>disableable = false</code> in external</li> <li><a href=  ><code>a7f3413</code></a> handle classes with explicit enclosing instances in <code>differentnamebutsame</code></li> <li><a href=  ><code>7a65117</code></a> <code>symbol.islocal</code> was renamed in jdk 16</li> <li><a href=  ><code>fb6d049</code></a> don t suggest private constructors for abstract classes</li> <li><a href=  ><code>7d93df4</code></a> fix handling of <code>super::</code> method references in <code>unnecessarymethodreference</code></li> <li><a href=  ><code>b1eaa17</code></a> only report <code>unnecessaryoptionalget</code> findings if the receivers are identical</li> <li><a href=  ><code>144c760</code></a> address a <code>visiblefortestingused</code> finding</li> <li><a href=  ><code>0951985</code></a> generate javadoc in ci pipeline</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />  updates  error_prone_test_helpers  from 2.4.0 to 2.5.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_test_helpers s releases</a>.</em></p> <blockquote> <h2>error prone 2.5.1</h2> <p>changes</p> <p>nosuchmethoderror:  com.sun.tools.javac.util.list com.sun.tools.javac.code.symbol$typesymbol.getenclosedelements</p> <ul> <li>fixed <code>nosuchmethoderror</code> crash in <code>hidingfield</code> (<a href=  >#2092</a>)</li> <li>fixed <code>nosuchelementexception</code> crash in <code>restrictedapichecker</code> (<a href=  >#2099</a>)</li> <li>false positive in <code>differentnamebutsame</code> (<a href=  >#2094</a>)</li> <li>false positive in <code>unnecessaryoptionalget</code> (<a href=  >#2101</a>)</li> <li>false positive in <code>unnecessarymethodreference</code> (<a href=  >#2102</a>)</li> <li>fixed a regression in jdk 16-ea support (<a href=  >#2105</a>)</li> </ul> <h2>error prone 2.5.0</h2> <p>new checks:</p> <ul> <li><a href=  >banserializableread</a></li> <li><a href=  >catchingunchecked</a></li> <li><a href=  >computeifabsentambiguousreference</a></li> <li><a href=  >dangerousliteralnull</a></li> <li><a href=  >datechecker</a></li> <li><a href=  >differentnamebutsame</a></li> <li><a href=  >donotcallsuggester</a></li> <li><a href=  >donotclaimannotations</a></li> <li><a href=  >donotmockautovalue</a></li> <li><a href=  >floggerformatstring</a></li> <li><a href=  >floggerlogvarargs</a></li> <li><a href=  >floggerlogwithcause</a></li> <li><a href=  >floggermessageformat</a></li> <li><a href=  >floggerpassedaround</a></li> <li><a href=  >floggerredundantisenabled</a></li> <li><a href=  >floggerrequiredmodifiers</a></li> <li><a href=  >floggersplitlogstatement</a></li> <li><a href=  >floggerwithcause</a></li> <li><a href=  >floggerwithoutcause</a></li> <li><a href=  >hashcodetostring</a></li> <li><a href=  >identityhashmapusage</a></li> <li><a href=  >immutablemembercollection</a></li> <li><a href=  >immutablesetforcontains</a></li> <li><a href=  >initializeinline</a></li> <li><a href=  >invalidthrowslink</a></li> <li><a href=  >isinstanceincompatibletype</a></li> <li><a href=  >javautildate</a></li> <li><a href=  >jodaconstructors</a></li> <li><a href=  >jodadatetimeconstants</a></li> <li><a href=  >longfloatconversion</a></li> <li><a href=  >membername</a></li> <li><a href=  >misplacedscopeannotations</a></li> <li><a href=  >objectequalsforprimitives</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >returnsnullcollection</a></li> </ul> <!-- raw html omitted --> </blockquote> <p>... (truncated)</p> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>5e733ac</code></a> release error prone 2.5.1</li> <li><a href=  ><code>4f69766</code></a> support pre-jdk-8044853 early-desugaring of <code>jcnewclass</code></li> <li><a href=  ><code>6861403</code></a> don t set checks as <code>disableable = false</code> in external</li> <li><a href=  ><code>a7f3413</code></a> handle classes with explicit enclosing instances in <code>differentnamebutsame</code></li> <li><a href=  ><code>7a65117</code></a> <code>symbol.islocal</code> was renamed in jdk 16</li> <li><a href=  ><code>fb6d049</code></a> don t suggest private constructors for abstract classes</li> <li><a href=  ><code>7d93df4</code></a> fix handling of <code>super::</code> method references in <code>unnecessarymethodreference</code></li> <li><a href=  ><code>b1eaa17</code></a> only report <code>unnecessaryoptionalget</code> findings if the receivers are identical</li> <li><a href=  ><code>144c760</code></a> address a <code>visiblefortestingused</code> finding</li> <li><a href=  ><code>0951985</code></a> generate javadoc in ci pipeline</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />   dependabot will resolve any conflicts with this pr as long as you don t alter it yourself. you can also trigger a rebase manually by commenting  @dependabot rebase .  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---  <details> <summary>dependabot commands and options</summary> <br />  you can trigger dependabot actions by commenting on this pr: -  @dependabot rebase  will rebase this pr -  @dependabot recreate  will recreate this pr  overwriting any edits that have been made to it -  @dependabot merge  will merge this pr after your ci passes on it -  @dependabot squash and merge  will squash and merge this pr after your ci passes on it -  @dependabot cancel merge  will cancel a previously requested merge and block automerging -  @dependabot reopen  will reopen this pr if it is closed -  @dependabot close  will close this pr and stop dependabot recreating it. you can achieve the same result by closing it manually -  @dependabot ignore this major version  will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this minor version  will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this dependency  will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)   </details>;;2092.0;bump versionserrorprone from 240 to 251;"bumps `versionserrorprone` from 240 to 251updates `error_prone_core` from 240 to 251<details><summary>release notes</summary><p><em>sourced from <a href"" releases</a></em></p><blockquote><h2>error prone 251</h2><p>changes</p><p>nosuchmethoderror: comsuntoolsjavacutillist comsuntoolsjavaccodesymbol$typesymbolgetenclosedelements</p><ul><li> <code>nosuchmethoderror</code> crash in <code>hidingfield</code> (<a href"" <code>nosuchelementexception</code> crash in <code>restrictedapichecker</code> (<a href"" positive in <code>differentnamebutsame</code> (<a href"" positive in <code>unnecessaryoptionalget</code> (<a href"" positive in <code>unnecessarymethodreference</code> (<a href"" a regression in jdk 16-ea support (<a href"" prone 250</h2><p>new checks:</p><ul><li><a href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" raw html omitted --></blockquote><p> (truncated)</p></details><details><summary>commits</summary><ul><li><a href"" release error prone 251</li><li><a href"" support pre-jdk-8044853 early-desugaring of <code>jcnewclass</code></li><li><a href"" dont set checks as <code>disableable  false</code> in external</li><li><a href"" handle classes with explicit enclosing instances in <code>differentnamebutsame</code></li><li><a href"" <code>symbolislocal</code> was renamed in jdk 16</li><li><a href"" dont suggest private constructors for abstract classes</li><li><a href"" fix handling of <code>super::</code> method references in <code>unnecessarymethodreference</code></li><li><a href"" only report <code>unnecessaryoptionalget</code> findings if the receivers are identical</li><li><a href"" address a <code>visiblefortestingused</code> finding</li><li><a href"" generate javadoc in ci pipeline</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />updates `error_prone_test_helpers` from 240 to 251<details><summary>release notes</summary><p><em>sourced from <a href"" releases</a></em></p><blockquote><h2>error prone 251</h2><p>changes</p><p>nosuchmethoderror: comsuntoolsjavacutillist comsuntoolsjavaccodesymbol$typesymbolgetenclosedelements</p><ul><li>fixed <code>nosuchmethoderror</code> crash in <code>hidingfield</code> (<a href"" <code>nosuchelementexception</code> crash in <code>restrictedapichecker</code> (<a href"" positive in <code>differentnamebutsame</code> (<a href"" positive in <code>unnecessaryoptionalget</code> (<a href"" positive in <code>unnecessarymethodreference</code> (<a href"" a regression in jdk 16-ea support (<a href"" prone 250</h2><p>new checks:</p><ul><li><a href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" raw html omitted --></blockquote><p> (truncated)</p></details><details><summary>commits</summary><ul><li><a href"" release error prone 251</li><li><a href"" support pre-jdk-8044853 early-desugaring of <code>jcnewclass</code></li><li><a href"" dont set checks as <code>disableable  false</code> in external</li><li><a href"" handle classes with explicit enclosing instances in <code>differentnamebutsame</code></li><li><a href"" <code>symbolislocal</code> was renamed in jdk 16</li><li><a href"" dont suggest private constructors for abstract classes</li><li><a href"" fix handling of <code>super::</code> method references in <code>unnecessarymethodreference</code></li><li><a href"" only report <code>unnecessaryoptionalget</code> findings if the receivers are identical</li><li><a href"" address a <code>visiblefortestingused</code> finding</li><li><a href"" generate javadoc in ci pipeline</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />dependabot will resolve any conflicts with this pr as long as you dont alter it yourself you can also trigger a rebase manually by commenting `@dependabot rebase`[//]: # (dependabot-automerge-start)[//]: # (dependabot-automerge-end)---<details><summary>dependabot commands and options</summary><br />you can trigger dependabot actions by commenting on this pr:- `@dependabot rebase` will rebase this pr- `@dependabot recreate` will recreate this pr overwriting any edits that have been made to it- `@dependabot merge` will merge this pr after your ci passes on it- `@dependabot squash and merge` will squash and merge this pr after your ci passes on it- `@dependabot cancel merge` will cancel a previously requested merge and block automerging- `@dependabot reopen` will reopen this pr if it is closed- `@dependabot close` will close this pr and stop dependabot recreating it you can achieve the same result by closing it manually- `@dependabot ignore this major version` will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this minor version` will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this dependency` will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)</details>";errorprone is catching actual issues i will work through them ||;the target server failed to respond ci issue;find solution to this problem on ci:```execution failed for task  bintrayupload133 actionable tasks: 117 executed 16 up-to-date> orgapache the target server failed to respond```build failure: https://githubcom/mockito/mockito/pull/2089/checks?check_run_id1370793325;i think we were able to resolve this issue in the mean time ||;1;0;fix errorprone compilation errors;
2176;0;1;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;bump versions.errorprone from 2.4.0 to 2.5.1;bumps  versions.errorprone  from 2.4.0 to 2.5.1. updates  error_prone_core  from 2.4.0 to 2.5.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_core s releases</a>.</em></p> <blockquote> <h2>error prone 2.5.1</h2> <p>changes</p> <p>nosuchmethoderror:  com.sun.tools.javac.util.list com.sun.tools.javac.code.symbol$typesymbol.getenclosedelements</p> <ul> <li>fixed <code>nosuchmethoderror</code> crash in <code>hidingfield</code> (<a href=  >#2092</a>)</li> <li>fixed <code>nosuchelementexception</code> crash in <code>restrictedapichecker</code> (<a href=  >#2099</a>)</li> <li>false positive in <code>differentnamebutsame</code> (<a href=  >#2094</a>)</li> <li>false positive in <code>unnecessaryoptionalget</code> (<a href=  >#2101</a>)</li> <li>false positive in <code>unnecessarymethodreference</code> (<a href=  >#2102</a>)</li> <li>fixed a regression in jdk 16-ea support (<a href=  >#2105</a>)</li> </ul> <h2>error prone 2.5.0</h2> <p>new checks:</p> <ul> <li><a href=  >banserializableread</a></li> <li><a href=  >catchingunchecked</a></li> <li><a href=  >computeifabsentambiguousreference</a></li> <li><a href=  >dangerousliteralnull</a></li> <li><a href=  >datechecker</a></li> <li><a href=  >differentnamebutsame</a></li> <li><a href=  >donotcallsuggester</a></li> <li><a href=  >donotclaimannotations</a></li> <li><a href=  >donotmockautovalue</a></li> <li><a href=  >floggerformatstring</a></li> <li><a href=  >floggerlogvarargs</a></li> <li><a href=  >floggerlogwithcause</a></li> <li><a href=  >floggermessageformat</a></li> <li><a href=  >floggerpassedaround</a></li> <li><a href=  >floggerredundantisenabled</a></li> <li><a href=  >floggerrequiredmodifiers</a></li> <li><a href=  >floggersplitlogstatement</a></li> <li><a href=  >floggerwithcause</a></li> <li><a href=  >floggerwithoutcause</a></li> <li><a href=  >hashcodetostring</a></li> <li><a href=  >identityhashmapusage</a></li> <li><a href=  >immutablemembercollection</a></li> <li><a href=  >immutablesetforcontains</a></li> <li><a href=  >initializeinline</a></li> <li><a href=  >invalidthrowslink</a></li> <li><a href=  >isinstanceincompatibletype</a></li> <li><a href=  >javautildate</a></li> <li><a href=  >jodaconstructors</a></li> <li><a href=  >jodadatetimeconstants</a></li> <li><a href=  >longfloatconversion</a></li> <li><a href=  >membername</a></li> <li><a href=  >misplacedscopeannotations</a></li> <li><a href=  >objectequalsforprimitives</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >returnsnullcollection</a></li> </ul> <!-- raw html omitted --> </blockquote> <p> (truncated)</p> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>5e733ac</code></a> release error prone 2.5.1</li> <li><a href=  ><code>4f69766</code></a> support pre-jdk-8044853 early-desugaring of <code>jcnewclass</code></li> <li><a href=  ><code>6861403</code></a> don t set checks as <code>disableable = false</code> in external</li> <li><a href=  ><code>a7f3413</code></a> handle classes with explicit enclosing instances in <code>differentnamebutsame</code></li> <li><a href=  ><code>7a65117</code></a> <code>symbol.islocal</code> was renamed in jdk 16</li> <li><a href=  ><code>fb6d049</code></a> don t suggest private constructors for abstract classes</li> <li><a href=  ><code>7d93df4</code></a> fix handling of <code>super::</code> method references in <code>unnecessarymethodreference</code></li> <li><a href=  ><code>b1eaa17</code></a> only report <code>unnecessaryoptionalget</code> findings if the receivers are identical</li> <li><a href=  ><code>144c760</code></a> address a <code>visiblefortestingused</code> finding</li> <li><a href=  ><code>0951985</code></a> generate javadoc in ci pipeline</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />  updates  error_prone_test_helpers  from 2.4.0 to 2.5.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_test_helpers s releases</a>.</em></p> <blockquote> <h2>error prone 2.5.1</h2> <p>changes</p> <p>nosuchmethoderror:  com.sun.tools.javac.util.list com.sun.tools.javac.code.symbol$typesymbol.getenclosedelements</p> <ul> <li>fixed <code>nosuchmethoderror</code> crash in <code>hidingfield</code> (<a href=  >#2092</a>)</li> <li>fixed <code>nosuchelementexception</code> crash in <code>restrictedapichecker</code> (<a href=  >#2099</a>)</li> <li>false positive in <code>differentnamebutsame</code> (<a href=  >#2094</a>)</li> <li>false positive in <code>unnecessaryoptionalget</code> (<a href=  >#2101</a>)</li> <li>false positive in <code>unnecessarymethodreference</code> (<a href=  >#2102</a>)</li> <li>fixed a regression in jdk 16-ea support (<a href=  >#2105</a>)</li> </ul> <h2>error prone 2.5.0</h2> <p>new checks:</p> <ul> <li><a href=  >banserializableread</a></li> <li><a href=  >catchingunchecked</a></li> <li><a href=  >computeifabsentambiguousreference</a></li> <li><a href=  >dangerousliteralnull</a></li> <li><a href=  >datechecker</a></li> <li><a href=  >differentnamebutsame</a></li> <li><a href=  >donotcallsuggester</a></li> <li><a href=  >donotclaimannotations</a></li> <li><a href=  >donotmockautovalue</a></li> <li><a href=  >floggerformatstring</a></li> <li><a href=  >floggerlogvarargs</a></li> <li><a href=  >floggerlogwithcause</a></li> <li><a href=  >floggermessageformat</a></li> <li><a href=  >floggerpassedaround</a></li> <li><a href=  >floggerredundantisenabled</a></li> <li><a href=  >floggerrequiredmodifiers</a></li> <li><a href=  >floggersplitlogstatement</a></li> <li><a href=  >floggerwithcause</a></li> <li><a href=  >floggerwithoutcause</a></li> <li><a href=  >hashcodetostring</a></li> <li><a href=  >identityhashmapusage</a></li> <li><a href=  >immutablemembercollection</a></li> <li><a href=  >immutablesetforcontains</a></li> <li><a href=  >initializeinline</a></li> <li><a href=  >invalidthrowslink</a></li> <li><a href=  >isinstanceincompatibletype</a></li> <li><a href=  >javautildate</a></li> <li><a href=  >jodaconstructors</a></li> <li><a href=  >jodadatetimeconstants</a></li> <li><a href=  >longfloatconversion</a></li> <li><a href=  >membername</a></li> <li><a href=  >misplacedscopeannotations</a></li> <li><a href=  >objectequalsforprimitives</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >returnsnullcollection</a></li> </ul> <!-- raw html omitted --> </blockquote> <p>... (truncated)</p> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>5e733ac</code></a> release error prone 2.5.1</li> <li><a href=  ><code>4f69766</code></a> support pre-jdk-8044853 early-desugaring of <code>jcnewclass</code></li> <li><a href=  ><code>6861403</code></a> don t set checks as <code>disableable = false</code> in external</li> <li><a href=  ><code>a7f3413</code></a> handle classes with explicit enclosing instances in <code>differentnamebutsame</code></li> <li><a href=  ><code>7a65117</code></a> <code>symbol.islocal</code> was renamed in jdk 16</li> <li><a href=  ><code>fb6d049</code></a> don t suggest private constructors for abstract classes</li> <li><a href=  ><code>7d93df4</code></a> fix handling of <code>super::</code> method references in <code>unnecessarymethodreference</code></li> <li><a href=  ><code>b1eaa17</code></a> only report <code>unnecessaryoptionalget</code> findings if the receivers are identical</li> <li><a href=  ><code>144c760</code></a> address a <code>visiblefortestingused</code> finding</li> <li><a href=  ><code>0951985</code></a> generate javadoc in ci pipeline</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />   dependabot will resolve any conflicts with this pr as long as you don t alter it yourself. you can also trigger a rebase manually by commenting  @dependabot rebase .  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---  <details> <summary>dependabot commands and options</summary> <br />  you can trigger dependabot actions by commenting on this pr: -  @dependabot rebase  will rebase this pr -  @dependabot recreate  will recreate this pr  overwriting any edits that have been made to it -  @dependabot merge  will merge this pr after your ci passes on it -  @dependabot squash and merge  will squash and merge this pr after your ci passes on it -  @dependabot cancel merge  will cancel a previously requested merge and block automerging -  @dependabot reopen  will reopen this pr if it is closed -  @dependabot close  will close this pr and stop dependabot recreating it. you can achieve the same result by closing it manually -  @dependabot ignore this major version  will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this minor version  will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this dependency  will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)   </details>;;2094.0;bump versionserrorprone from 240 to 251;"bumps `versionserrorprone` from 240 to 251updates `error_prone_core` from 240 to 251<details><summary>release notes</summary><p><em>sourced from <a href"" releases</a></em></p><blockquote><h2>error prone 251</h2><p>changes</p><p>nosuchmethoderror: comsuntoolsjavacutillist comsuntoolsjavaccodesymbol$typesymbolgetenclosedelements</p><ul><li> <code>nosuchmethoderror</code> crash in <code>hidingfield</code> (<a href"" <code>nosuchelementexception</code> crash in <code>restrictedapichecker</code> (<a href"" positive in <code>differentnamebutsame</code> (<a href"" positive in <code>unnecessaryoptionalget</code> (<a href"" positive in <code>unnecessarymethodreference</code> (<a href"" a regression in jdk 16-ea support (<a href"" prone 250</h2><p>new checks:</p><ul><li><a href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" raw html omitted --></blockquote><p> (truncated)</p></details><details><summary>commits</summary><ul><li><a href"" release error prone 251</li><li><a href"" support pre-jdk-8044853 early-desugaring of <code>jcnewclass</code></li><li><a href"" dont set checks as <code>disableable  false</code> in external</li><li><a href"" handle classes with explicit enclosing instances in <code>differentnamebutsame</code></li><li><a href"" <code>symbolislocal</code> was renamed in jdk 16</li><li><a href"" dont suggest private constructors for abstract classes</li><li><a href"" fix handling of <code>super::</code> method references in <code>unnecessarymethodreference</code></li><li><a href"" only report <code>unnecessaryoptionalget</code> findings if the receivers are identical</li><li><a href"" address a <code>visiblefortestingused</code> finding</li><li><a href"" generate javadoc in ci pipeline</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />updates `error_prone_test_helpers` from 240 to 251<details><summary>release notes</summary><p><em>sourced from <a href"" releases</a></em></p><blockquote><h2>error prone 251</h2><p>changes</p><p>nosuchmethoderror: comsuntoolsjavacutillist comsuntoolsjavaccodesymbol$typesymbolgetenclosedelements</p><ul><li>fixed <code>nosuchmethoderror</code> crash in <code>hidingfield</code> (<a href"" <code>nosuchelementexception</code> crash in <code>restrictedapichecker</code> (<a href"" positive in <code>differentnamebutsame</code> (<a href"" positive in <code>unnecessaryoptionalget</code> (<a href"" positive in <code>unnecessarymethodreference</code> (<a href"" a regression in jdk 16-ea support (<a href"" prone 250</h2><p>new checks:</p><ul><li><a href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" raw html omitted --></blockquote><p> (truncated)</p></details><details><summary>commits</summary><ul><li><a href"" release error prone 251</li><li><a href"" support pre-jdk-8044853 early-desugaring of <code>jcnewclass</code></li><li><a href"" dont set checks as <code>disableable  false</code> in external</li><li><a href"" handle classes with explicit enclosing instances in <code>differentnamebutsame</code></li><li><a href"" <code>symbolislocal</code> was renamed in jdk 16</li><li><a href"" dont suggest private constructors for abstract classes</li><li><a href"" fix handling of <code>super::</code> method references in <code>unnecessarymethodreference</code></li><li><a href"" only report <code>unnecessaryoptionalget</code> findings if the receivers are identical</li><li><a href"" address a <code>visiblefortestingused</code> finding</li><li><a href"" generate javadoc in ci pipeline</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />dependabot will resolve any conflicts with this pr as long as you dont alter it yourself you can also trigger a rebase manually by commenting `@dependabot rebase`[//]: # (dependabot-automerge-start)[//]: # (dependabot-automerge-end)---<details><summary>dependabot commands and options</summary><br />you can trigger dependabot actions by commenting on this pr:- `@dependabot rebase` will rebase this pr- `@dependabot recreate` will recreate this pr overwriting any edits that have been made to it- `@dependabot merge` will merge this pr after your ci passes on it- `@dependabot squash and merge` will squash and merge this pr after your ci passes on it- `@dependabot cancel merge` will cancel a previously requested merge and block automerging- `@dependabot reopen` will reopen this pr if it is closed- `@dependabot close` will close this pr and stop dependabot recreating it you can achieve the same result by closing it manually- `@dependabot ignore this major version` will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this minor version` will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this dependency` will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)</details>";errorprone is catching actual issues i will work through them ||;refactor gradle wrapper validation workflow to ci workflow;refactor gradle wrapper validation workflow to ci workflow this way we ci feedback on prs is cleaner and easier to use;;1;0;fix errorprone compilation errors;
2176;0;1;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;bump versions.errorprone from 2.4.0 to 2.5.1;bumps  versions.errorprone  from 2.4.0 to 2.5.1. updates  error_prone_core  from 2.4.0 to 2.5.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_core s releases</a>.</em></p> <blockquote> <h2>error prone 2.5.1</h2> <p>changes</p> <p>nosuchmethoderror:  com.sun.tools.javac.util.list com.sun.tools.javac.code.symbol$typesymbol.getenclosedelements</p> <ul> <li>fixed <code>nosuchmethoderror</code> crash in <code>hidingfield</code> (<a href=  >#2092</a>)</li> <li>fixed <code>nosuchelementexception</code> crash in <code>restrictedapichecker</code> (<a href=  >#2099</a>)</li> <li>false positive in <code>differentnamebutsame</code> (<a href=  >#2094</a>)</li> <li>false positive in <code>unnecessaryoptionalget</code> (<a href=  >#2101</a>)</li> <li>false positive in <code>unnecessarymethodreference</code> (<a href=  >#2102</a>)</li> <li>fixed a regression in jdk 16-ea support (<a href=  >#2105</a>)</li> </ul> <h2>error prone 2.5.0</h2> <p>new checks:</p> <ul> <li><a href=  >banserializableread</a></li> <li><a href=  >catchingunchecked</a></li> <li><a href=  >computeifabsentambiguousreference</a></li> <li><a href=  >dangerousliteralnull</a></li> <li><a href=  >datechecker</a></li> <li><a href=  >differentnamebutsame</a></li> <li><a href=  >donotcallsuggester</a></li> <li><a href=  >donotclaimannotations</a></li> <li><a href=  >donotmockautovalue</a></li> <li><a href=  >floggerformatstring</a></li> <li><a href=  >floggerlogvarargs</a></li> <li><a href=  >floggerlogwithcause</a></li> <li><a href=  >floggermessageformat</a></li> <li><a href=  >floggerpassedaround</a></li> <li><a href=  >floggerredundantisenabled</a></li> <li><a href=  >floggerrequiredmodifiers</a></li> <li><a href=  >floggersplitlogstatement</a></li> <li><a href=  >floggerwithcause</a></li> <li><a href=  >floggerwithoutcause</a></li> <li><a href=  >hashcodetostring</a></li> <li><a href=  >identityhashmapusage</a></li> <li><a href=  >immutablemembercollection</a></li> <li><a href=  >immutablesetforcontains</a></li> <li><a href=  >initializeinline</a></li> <li><a href=  >invalidthrowslink</a></li> <li><a href=  >isinstanceincompatibletype</a></li> <li><a href=  >javautildate</a></li> <li><a href=  >jodaconstructors</a></li> <li><a href=  >jodadatetimeconstants</a></li> <li><a href=  >longfloatconversion</a></li> <li><a href=  >membername</a></li> <li><a href=  >misplacedscopeannotations</a></li> <li><a href=  >objectequalsforprimitives</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >returnsnullcollection</a></li> </ul> <!-- raw html omitted --> </blockquote> <p> (truncated)</p> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>5e733ac</code></a> release error prone 2.5.1</li> <li><a href=  ><code>4f69766</code></a> support pre-jdk-8044853 early-desugaring of <code>jcnewclass</code></li> <li><a href=  ><code>6861403</code></a> don t set checks as <code>disableable = false</code> in external</li> <li><a href=  ><code>a7f3413</code></a> handle classes with explicit enclosing instances in <code>differentnamebutsame</code></li> <li><a href=  ><code>7a65117</code></a> <code>symbol.islocal</code> was renamed in jdk 16</li> <li><a href=  ><code>fb6d049</code></a> don t suggest private constructors for abstract classes</li> <li><a href=  ><code>7d93df4</code></a> fix handling of <code>super::</code> method references in <code>unnecessarymethodreference</code></li> <li><a href=  ><code>b1eaa17</code></a> only report <code>unnecessaryoptionalget</code> findings if the receivers are identical</li> <li><a href=  ><code>144c760</code></a> address a <code>visiblefortestingused</code> finding</li> <li><a href=  ><code>0951985</code></a> generate javadoc in ci pipeline</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />  updates  error_prone_test_helpers  from 2.4.0 to 2.5.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_test_helpers s releases</a>.</em></p> <blockquote> <h2>error prone 2.5.1</h2> <p>changes</p> <p>nosuchmethoderror:  com.sun.tools.javac.util.list com.sun.tools.javac.code.symbol$typesymbol.getenclosedelements</p> <ul> <li>fixed <code>nosuchmethoderror</code> crash in <code>hidingfield</code> (<a href=  >#2092</a>)</li> <li>fixed <code>nosuchelementexception</code> crash in <code>restrictedapichecker</code> (<a href=  >#2099</a>)</li> <li>false positive in <code>differentnamebutsame</code> (<a href=  >#2094</a>)</li> <li>false positive in <code>unnecessaryoptionalget</code> (<a href=  >#2101</a>)</li> <li>false positive in <code>unnecessarymethodreference</code> (<a href=  >#2102</a>)</li> <li>fixed a regression in jdk 16-ea support (<a href=  >#2105</a>)</li> </ul> <h2>error prone 2.5.0</h2> <p>new checks:</p> <ul> <li><a href=  >banserializableread</a></li> <li><a href=  >catchingunchecked</a></li> <li><a href=  >computeifabsentambiguousreference</a></li> <li><a href=  >dangerousliteralnull</a></li> <li><a href=  >datechecker</a></li> <li><a href=  >differentnamebutsame</a></li> <li><a href=  >donotcallsuggester</a></li> <li><a href=  >donotclaimannotations</a></li> <li><a href=  >donotmockautovalue</a></li> <li><a href=  >floggerformatstring</a></li> <li><a href=  >floggerlogvarargs</a></li> <li><a href=  >floggerlogwithcause</a></li> <li><a href=  >floggermessageformat</a></li> <li><a href=  >floggerpassedaround</a></li> <li><a href=  >floggerredundantisenabled</a></li> <li><a href=  >floggerrequiredmodifiers</a></li> <li><a href=  >floggersplitlogstatement</a></li> <li><a href=  >floggerwithcause</a></li> <li><a href=  >floggerwithoutcause</a></li> <li><a href=  >hashcodetostring</a></li> <li><a href=  >identityhashmapusage</a></li> <li><a href=  >immutablemembercollection</a></li> <li><a href=  >immutablesetforcontains</a></li> <li><a href=  >initializeinline</a></li> <li><a href=  >invalidthrowslink</a></li> <li><a href=  >isinstanceincompatibletype</a></li> <li><a href=  >javautildate</a></li> <li><a href=  >jodaconstructors</a></li> <li><a href=  >jodadatetimeconstants</a></li> <li><a href=  >longfloatconversion</a></li> <li><a href=  >membername</a></li> <li><a href=  >misplacedscopeannotations</a></li> <li><a href=  >objectequalsforprimitives</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >returnsnullcollection</a></li> </ul> <!-- raw html omitted --> </blockquote> <p>... (truncated)</p> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>5e733ac</code></a> release error prone 2.5.1</li> <li><a href=  ><code>4f69766</code></a> support pre-jdk-8044853 early-desugaring of <code>jcnewclass</code></li> <li><a href=  ><code>6861403</code></a> don t set checks as <code>disableable = false</code> in external</li> <li><a href=  ><code>a7f3413</code></a> handle classes with explicit enclosing instances in <code>differentnamebutsame</code></li> <li><a href=  ><code>7a65117</code></a> <code>symbol.islocal</code> was renamed in jdk 16</li> <li><a href=  ><code>fb6d049</code></a> don t suggest private constructors for abstract classes</li> <li><a href=  ><code>7d93df4</code></a> fix handling of <code>super::</code> method references in <code>unnecessarymethodreference</code></li> <li><a href=  ><code>b1eaa17</code></a> only report <code>unnecessaryoptionalget</code> findings if the receivers are identical</li> <li><a href=  ><code>144c760</code></a> address a <code>visiblefortestingused</code> finding</li> <li><a href=  ><code>0951985</code></a> generate javadoc in ci pipeline</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />   dependabot will resolve any conflicts with this pr as long as you don t alter it yourself. you can also trigger a rebase manually by commenting  @dependabot rebase .  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---  <details> <summary>dependabot commands and options</summary> <br />  you can trigger dependabot actions by commenting on this pr: -  @dependabot rebase  will rebase this pr -  @dependabot recreate  will recreate this pr  overwriting any edits that have been made to it -  @dependabot merge  will merge this pr after your ci passes on it -  @dependabot squash and merge  will squash and merge this pr after your ci passes on it -  @dependabot cancel merge  will cancel a previously requested merge and block automerging -  @dependabot reopen  will reopen this pr if it is closed -  @dependabot close  will close this pr and stop dependabot recreating it. you can achieve the same result by closing it manually -  @dependabot ignore this major version  will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this minor version  will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this dependency  will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)   </details>;;2105.0;bump versionserrorprone from 240 to 251;"bumps `versionserrorprone` from 240 to 251updates `error_prone_core` from 240 to 251<details><summary>release notes</summary><p><em>sourced from <a href"" releases</a></em></p><blockquote><h2>error prone 251</h2><p>changes</p><p>nosuchmethoderror: comsuntoolsjavacutillist comsuntoolsjavaccodesymbol$typesymbolgetenclosedelements</p><ul><li> <code>nosuchmethoderror</code> crash in <code>hidingfield</code> (<a href"" <code>nosuchelementexception</code> crash in <code>restrictedapichecker</code> (<a href"" positive in <code>differentnamebutsame</code> (<a href"" positive in <code>unnecessaryoptionalget</code> (<a href"" positive in <code>unnecessarymethodreference</code> (<a href"" a regression in jdk 16-ea support (<a href"" prone 250</h2><p>new checks:</p><ul><li><a href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" raw html omitted --></blockquote><p> (truncated)</p></details><details><summary>commits</summary><ul><li><a href"" release error prone 251</li><li><a href"" support pre-jdk-8044853 early-desugaring of <code>jcnewclass</code></li><li><a href"" dont set checks as <code>disableable  false</code> in external</li><li><a href"" handle classes with explicit enclosing instances in <code>differentnamebutsame</code></li><li><a href"" <code>symbolislocal</code> was renamed in jdk 16</li><li><a href"" dont suggest private constructors for abstract classes</li><li><a href"" fix handling of <code>super::</code> method references in <code>unnecessarymethodreference</code></li><li><a href"" only report <code>unnecessaryoptionalget</code> findings if the receivers are identical</li><li><a href"" address a <code>visiblefortestingused</code> finding</li><li><a href"" generate javadoc in ci pipeline</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />updates `error_prone_test_helpers` from 240 to 251<details><summary>release notes</summary><p><em>sourced from <a href"" releases</a></em></p><blockquote><h2>error prone 251</h2><p>changes</p><p>nosuchmethoderror: comsuntoolsjavacutillist comsuntoolsjavaccodesymbol$typesymbolgetenclosedelements</p><ul><li>fixed <code>nosuchmethoderror</code> crash in <code>hidingfield</code> (<a href"" <code>nosuchelementexception</code> crash in <code>restrictedapichecker</code> (<a href"" positive in <code>differentnamebutsame</code> (<a href"" positive in <code>unnecessaryoptionalget</code> (<a href"" positive in <code>unnecessarymethodreference</code> (<a href"" a regression in jdk 16-ea support (<a href"" prone 250</h2><p>new checks:</p><ul><li><a href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" href"" raw html omitted --></blockquote><p> (truncated)</p></details><details><summary>commits</summary><ul><li><a href"" release error prone 251</li><li><a href"" support pre-jdk-8044853 early-desugaring of <code>jcnewclass</code></li><li><a href"" dont set checks as <code>disableable  false</code> in external</li><li><a href"" handle classes with explicit enclosing instances in <code>differentnamebutsame</code></li><li><a href"" <code>symbolislocal</code> was renamed in jdk 16</li><li><a href"" dont suggest private constructors for abstract classes</li><li><a href"" fix handling of <code>super::</code> method references in <code>unnecessarymethodreference</code></li><li><a href"" only report <code>unnecessaryoptionalget</code> findings if the receivers are identical</li><li><a href"" address a <code>visiblefortestingused</code> finding</li><li><a href"" generate javadoc in ci pipeline</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />dependabot will resolve any conflicts with this pr as long as you dont alter it yourself you can also trigger a rebase manually by commenting `@dependabot rebase`[//]: # (dependabot-automerge-start)[//]: # (dependabot-automerge-end)---<details><summary>dependabot commands and options</summary><br />you can trigger dependabot actions by commenting on this pr:- `@dependabot rebase` will rebase this pr- `@dependabot recreate` will recreate this pr overwriting any edits that have been made to it- `@dependabot merge` will merge this pr after your ci passes on it- `@dependabot squash and merge` will squash and merge this pr after your ci passes on it- `@dependabot cancel merge` will cancel a previously requested merge and block automerging- `@dependabot reopen` will reopen this pr if it is closed- `@dependabot close` will close this pr and stop dependabot recreating it you can achieve the same result by closing it manually- `@dependabot ignore this major version` will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this minor version` will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this dependency` will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)</details>";errorprone is catching actual issues i will work through them ||;stackoverflow trying mock javalangmath;"<img width""741"" alt""captura de tela 2020-11-20 às 19 59 15"" src"" this point seems we get a loop in calls that causes stackoverflow when trying to static mock javalangmath";please do not mock `javalang*` classes as mockito us built on top of these please use the real method/class ||;1;0;fix errorprone compilation errors;
2179;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;clear bibtexkey exception;2177. nullpointerexception caused by clearing bibtexkey field in entry editor. -   -   -   () -  -   ( []( -  if you changed the localization: did you run  gradle ate ?;;0;make iterables#tocollection public;i was searching for a way to convert an iterable to a collection and guava already has it sadly its not publicuse case: i am creating a class where the api uses iterable (because its the right thing to do there) but have to call a 3rd party component that requires a collection;"what about `listsnewarraylist(iterable)` or `immutablelistcopyof(iterable)`? || works but always creates a copy iterablestocollections does not if it is passed a collection || this method is quite possibly the right thing for your use case but i would predict that it would be hard to add to guava without encouraging misusemost users who want a `collection` are going to want a specific type of `collection`: a `set` that has a fast `contains()` implementation a `list` that has fast random access or whatever the main exception of course is exactly your use case: someone wrote an api that should have accepted `iterable` but doesntthere are a couple things to watch out for even in that case first will the method mutate or store the given `collection`? if so do you want mutations it makes to be reflected in your original `iterable`? do you want changes to your original `iterable` to affect the `collection` you passed in? again for some use cases you wont need to care but for a general-purpose api we need to nail this down and under the current api the answer is ""it depends"" to reflect this wed probably have to rename the method to ""castorcopytocollection""but what about the case where the method youre calling really does just iterate over the input not modify or store it? in that case the distinction i make above doesnt matter but now someone is going to tell us that we should just provide a `collection` _view_ of the underlying `iterable` since theres no need to copy it so if we restrict ourselves to that use case we probably want `iterablesascollection()` but then will users get bit when someone calls its an o(n) `size()` implementation in a loop?a final irony in all this is that `iterablestocollection()` is not actually an ideal tool for how we use it either: we use it only to implement `iterablestoarray()` but that means that we end up making an extra copy that we dont need thats not a big deal but we would get better performance if we just wrote the array-expansion logic ourselves || ";;;;0;1;;
2179;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;clear bibtexkey exception;2177. nullpointerexception caused by clearing bibtexkey field in entry editor. -   -   -   () -  -   ( []( -  if you changed the localization: did you run  gradle ate ?;;0;categorize errors for string functions;;;;;;0;1;;
2179;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;clear bibtexkey exception;2177. nullpointerexception caused by clearing bibtexkey field in entry editor. -   -   -   () -  -   ( []( -  if you changed the localization: did you run  gradle ate ?;;2173.0;fix reversed order of verify parameters;for consistency the parameters of the methodmockedstaticverify(verificationmode verification)have been swapped tomockedstaticverify(verification verificationmode)as this order is already used inmockitoverify(t verificationmode)fixes: #2173check list -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_; merging 2179 ;feature request: unify order of parameters;helloi just stumbled accross the switched order of the verificationmode parameter    orgmockitomockitoverify(t verificationmode)vs    orgmockitomockedstaticverify(verificationmode verification)is there a reason the verificationmode from mockitostatic is at first position?;no this might be a simple oversight @raphw i think we can reverse the order? we would need to add an overload and then deprecate the existing one which we can delete in mockito 400 || no i dont think i had an intention with the order possibly to have the lambda last what often works better with languages like kotlin but i think consistency is the better goal  || @bohni do you mind sending us a pr with the added method + deprecation? || ok i will take a look ||;1;0;fix reversed order of verify parametersfor consistency the parameters of the methodmockedstaticverify(verificationmode verification)have been swapped tomockedstaticverify(verification verificationmode)as this order is already used inmockitoverify(t verificationmode)fixes: #2173;
2180;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo in javadocs of mockedconstruction;hi 🖐;;0;fix typo in javadocs of mockedconstruction;hi 🖐i noted this while reading the javadocs of mockedconstructionthey were referring to static method and out of scope variable it isnt quite easy to grasp in this context i think its just a copy-paste mistake; merging 2180 ;;;;1;1;fix typo in javadocs of mockedconstruction;
2180;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;fix typo in javadocs of mockedconstruction;hi 🖐;;0;create table fails with array type;edit: edited original issue turns out it didnt have anything with unnest```presto:default> create table foo as select array[12] xquery 20150105_120821_00007_rk8ib failed 1 node 3 total 1 done (3333%)cpu time: 00s total     0 rows/s     0b/s 33% activeper node: 00 parallelism     0 rows/s     0b/sparallelism: 000:09 [0 rows 0b] [0 rows/s 0b/s]query 20150105_120821_00007_rk8ib failed: javalangstring cannot be cast to [ljavalangobjectjavalangclasscastexception: javalangstring cannot be cast to [ljavalangobject    at orgapachehadoophiveserde2objectinspectorstandardlistobjectinspectorgetlistlength(standardlistobjectinspectorjava:86)    at orgapachehadoophiveqlioorcwriterimpl$listtreewriterwrite(writerimpljava:1441)    at orgapachehadoophiveqlioorcwriterimpl$structtreewriterwrite(writerimpljava:1390)    at orgapachehadoophiveqlioorcwriterimpladdrow(writerimpljava:2018)    at orgapachehadoophiveqlioorcorcoutputformat$orcrecordwriterwrite(orcoutputformatjava:85)    at comfacebookprestohivehiverecordsinkfinishrecord(hiverecordsinkjava:337)    at comfacebookprestospirecordpagesinkappendpage(recordpagesinkjava:56)    at comfacebookprestooperatortablewriteroperatoraddinput(tablewriteroperatorjava:145)    at comfacebookprestooperatordriverprocessinternal(driverjava:357)    at comfacebookprestooperatordriverprocessfor(driverjava:283)    at comfacebookprestoexecutionsqltaskexecution$driversplitrunnerprocessfor(sqltaskexecutionjava:563)    at comfacebookprestoexecutiontaskexecutor$prioritizedsplitrunnerprocess(taskexecutorjava:443)    at comfacebookprestoexecutiontaskexecutor$runnerrun(taskexecutorjava:577)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)    at javalangthreadrun(threadjava:745)```recordsink spi doesnt support array type and tries to write a string hives object inspector complains about mismatch in types;that query works now:```presto:default> create table foo as select array[12] xcreate table: 1 rowquery 20150729_030057_00020_knw79 finished 3 nodessplits: 8 total 8 done (10000%)0:01 [0 rows 0b] [0 rows/s 0b/s]presto:default> select * from foo   x    -------- [1 2] (1 row)query 20150729_030103_00021_knw79 finished 3 nodessplits: 4 total 4 done (10000%)0:00 [1 rows 77b] [4 rows/s 332b/s]``` || thanks for going through all these @cawallin !  ||;;;;0;1;;
2193;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;google scholar: add better error message for reached traffic limit; title already explains the purpose.  as proposed by @tobiasdiez in  a more specific error is now shown if the fetching is failing due to a redirect. - ~~ ~~ - ~~ ~~ - ~~  ()~~ -  -   ( []( - updated text directly in the  gh-pages  branch:  -  if you changed the localization: did you run  gradle ate ?;;0;invalid filter node is produced when casting constant values into double within where clause;"with presto-088 the following query produces an incorrect filter plan:```presto:default> explain select * from (values(1000)) t(a) where a * 01 > 10                     query plan----------------------------------------------------- - output[a]         a : field     - filter[((""field"" * 0) > 1)] > [field:bigint]         - values > [field:bigint]                 1000```the constant 01 (and 10) is truncated to 0 (and 1) in the filter conditionif the double value is referenced from a column it produces the correct plan:```presto:default> explain select * from (values(1000 01)) t(a b) where a * b > 10                                          query plan----------------------------------------------------------------------------------------------- - output[a b]         a : field         b : field_0     - filter[((cast(""field"" as double) * ""field_0"") > 10)] > [field:bigint field_0:double]         - values > [field:bigint field_0:double]                 1000 01```";"this seems to work fine in 089:```presto> explain select * from (values(1000)) t(a) where a * 01 > 10                               query plan                                ------------------------------------------------------------------------- - output[a]                                                                      a : field                                                           - filter[((cast(""field"" as double) * 01) > 10)] > [field:bigint]          - values > [field:bigint]                                                       (1000)                                                  (1 row)```im not sure which commit introduced the problem and which one  it though ill try to track it down later to understand what happened || thanks ill try 089 || this problem might be related to the query plan optimizer implemented in our connectorsorry for bothering but knowing 089 has no problem is enough for now  note: an optimizer we implemented analyzes where conditions and evaluates deterministic functions including our custom udfs for example we have a function called `td_time_range(time int start_time varchar end_time varchar)` the optimizer converts the function call to ""start_time_in_unix_time < time and time < end_time_in_unix_time` so that connector plugin can get pushdown-ed condition || ";;;;0;1;;
2193;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;google scholar: add better error message for reached traffic limit; title already explains the purpose.  as proposed by @tobiasdiez in  a more specific error is now shown if the fetching is failing due to a redirect. - ~~ ~~ - ~~ ~~ - ~~  ()~~ -  -   ( []( - updated text directly in the  gh-pages  branch:  -  if you changed the localization: did you run  gradle ate ?;;2154.0;2154 : javalangobject is now instrumented again;seems like ```// the object type does not ever need instrumentationtargetsremove(objectclass)```in `orgmockitointernalcreationbytebuddyinlinebytecodegeneratortriggerretransformation(set<class<?>> boolean)` was a bit over the top i e it does seem to break mocking of `tostring` when inherited from `javalangobject`i added a test for this which should have been there in the first place due to this i am still not sure if removing the line is safe even if the whole test suite is green please review carefully;yeah good point i dont know why i ever added that ||;`tostring()` seems to be broken on 3628;"hi guys i think the `tostring()` method was broken recently i have a test for mockito-scala that checks a mock `tostring` invocation returns its name but if i try to update to said version it returns the standard `object` implementation of `tostring`i tried with the ""pure"" java api of mockito and the same thing happensthanks!";"the release diff ( points to #2098 most likely can you do a bisect to figure out if that is indeed the problematic pr? || possibly related and maybe helpful in diagnosing is that attempting to work around this issue by adding an explicit stub for `tostring` (eg `when(somemocktostring())thenreturn(""somemock"")`) will cause a `missingmethodinvocationexception`:```textorgmockitoexceptionsmisusingmissingmethodinvocationexception: when() requires an argument which has to be a method call on a mockfor example:    when(mockgetarticles())thenreturn(articles)also this error might show up because:1 you stub either of: final/private/equals()/hashcode() methods   those methods *cannot* be stubbed/verified   mocking methods declared on non-public parent classes is not supported2 inside when() you dont call method on mock but on some other object``` || could you try downgrading bytebuddy to 11015 and see if that resolves the issue? || i can confirm i am facing the same issue when upgrading from 320 to 377 || hi therei came across this bug and decided to have a look i cannot reproduce it maybe ive got something wrong here anyway i provided a test repository with a test build which we may use to get behind things here me know how things go 👋 || hi @janmosigitemis i was able to reproduce the issue with your test repository just replace ""mockito-core"" with ""mockito-inline"            <dependency>                <groupid>orgmockito</groupid>                <artifactid>mockito-core</artifactid>                <version>${mockitoversion}</version>                <scope>test</scope>            </dependency>``````            <dependency>                <groupid>orgmockito</groupid>                <artifactid>mockito-inline</artifactid>                <version>${mockitoversion}</version>                <scope>test</scope>            </dependency>```you should get:```[info] -------------------------------------------------------[info]  t e s t s[info] -------------------------------------------------------[info] running deitemisjmomockitoissue2154mockitoissue2154junit5test[error] tests run: 2 failures: 0 errors: 1 skipped: 0 time elapsed: 1526 s <<< failure! - in deitemisjmomockitoissue2154mockitoissue2154junit5test[error] test_stubbed_to_string_works  time elapsed: 0054 s  <<< error!orgmockitoexceptionsmisusingmissingmethodinvocationexception: when() requires an argument which has to be a method call on a mockfor example:    when(mockgetarticles())thenreturn(articles)also this error might show up because:1 you stub either of: final/private/equals()/hashcode() methods   those methods *cannot* be stubbed/verified   mocking methods declared on non-public parent classes is not supported2 inside when() you dont call method on mock but on some other object	at deitemisjmomockitoissue2154mockitoissue2154junit5testtest_stubbed_to_string_works(mockitoissue2154junit5testjava:26)[info] running deitemisjmomockitoissue2154mockitoissue2154junit4test[error] tests run: 2 failures: 0 errors: 1 skipped: 0 time elapsed: 0041 s <<< failure! - in deitemisjmomockitoissue2154mockitoissue2154junit4test[error] test_stubbed_to_string_works  time elapsed: 0018 s  <<< error!orgmockitoexceptionsmisusingmissingmethodinvocationexception: when() requires an argument which has to be a method call on a mockfor example:    when(mockgetarticles())thenreturn(articles)also this error might show up because:1 you stub either of: final/private/equals()/hashcode() methods   those methods *cannot* be stubbed/verified   mocking methods declared on non-public parent classes is not supported2 inside when() you dont call method on mock but on some other object	at deitemisjmomockitoissue2154mockitoissue2154junit4testtest_stubbed_to_string_works(mockitoissue2154junit4testjava:26)[info] [info] results:[info] [error] errors: [error]   mockitoissue2154junit4testtest_stubbed_to_string_works:26 missingmethodinvocation[error]   mockitoissue2154junit5testtest_stubbed_to_string_works:26 missingmethodinvocation[info] [error] tests run: 4 failures: 0 errors: 2 skipped: 0```let me know if this info is enough for you or if i should fork your repo || thx @pitschr i can reproduce now the problem is also present in the latest mockito-inline release 377 || @timvdlippe i downgraded to byte buddy 11015 via maven exclusion and got the same result || i had a hunch that in  the line `targetsremove(objectclass)` could be the culprit i removed it on my local machine build mockito-inline 379 and used it in my test repo works like a charm now ive got too few internal mockito knowledge in order to come up with a decent pr on this bc i dont know exactly why this line has been introduced and if it would be safe to simply remove it any thoughts on this? || thanks for the investigation @janmosigitemis ! in general if our full test suite passes with that line removed it should be safe to do so please add a regression test to our test suite as well and then feel free to open a pr for it! || ok ill try || ";1;0;2154 : made changes spotless;
2194;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;improve autosave and backup feature;applies the remaining feedback from  and fixes  -  -   ( []( -  if you changed the localization: did you run  gradle ate ?;;0;add isnullorempty method in collections2;the method isnullorempty is null-safe to check a collection;  i signed it ||  ||;;;;0;1;;
2194;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;improve autosave and backup feature;applies the remaining feedback from  and fixes  -  -   ( []( -  if you changed the localization: did you run  gradle ate ?;;0;add api for clearing mocks;by clearing mocks caches are emptied and instrumentations are reversed;;;;;1;1;add api for clearing mocksby clearing mocks caches are emptied and instrumentations are reversed;
2194;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;1;0;0;0;0;1;0;0;1;improve autosave and backup feature;applies the remaining feedback from  and fixes  -  -   ( []( -  if you changed the localization: did you run  gradle ate ?;;0;add year_of_week() function;this function should accept a `date` return the year corresponding to the iso week of that date;claiming this task || done merged to master ||;;;;0;1;;
2227;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;add missing deprecated annotation;discovered while trying to sync mockito internally at google.;;0;why cachegetifpresent(object key) is not java generic?;hi folksas we can see the methods of cache interface most of them are generic except `getifpresent(object key)`:``` javapublic interface cache<k v> {  @nullable  v getifpresent(object key)  v get(k key callable<? extends v> valueloader) throws executionexception  void put(k key v value)```is it intended? why not `v getifpresent(k key)` to be consistent?thanks;"its consistent with the rest of guava and all of the jdk collections: anobject that might be _stored_ is of type k otherwise its objecton sun nov 15 2015 at 10:11 pm nick tan notifications@githubcom wrote:> hi folks> > as we can see the methods of cache interface most of them are generic> except getifpresent(object key):> > public interface cache<k v> {>   @nullable>   v getifpresent(object key)> >   v get(k key callable<? extends v> valueloader) throws executionexception>   void put(k key v value)> > is it intended? why not v getifpresent(k key) to be consistent?> > thanks> > —> reply to this email directly or view it on github>  kevin bourrillion | java librarian | google inc | googlecom || 你在说什么 xd2015-11-16 14:12 gmt+08:00 nick tan notifications@githubcom:> hi folks> > as we can see the methods of cache interface most of them are generic> except getifpresent(object key):> > public interface cache<k v> {>   @nullable>   v getifpresent(object key)> >   v get(k key callable<? extends v> valueloader) throws executionexception>   void put(k key v value)> > is it intended? why not v getifpresent(k key) to be consistent?> > thanks> > —> reply to this email directly or view it on github>  _达则兼济天下 穷则独善其身_ || its the [robustness principle]( consider the following case:```interface foo { }interface bar { }class key implements foo bar { }key key  new key()foo foo  keybar bar  keycache<foostring> cache  cacheput(foo ""key"")string str  cachegetifpresent(bar)assertnotnull(str)```its certain that i can retrieve `""key""` using `foo` as key but since `foo  bar` why shouldnt i be able to retrieve `""key""` using `bar` as key? || this is deliberately consistent with the rest of java which made this design decision deliberately  there have been some explanations above  has some moremarking wai || ";;;;0;1;;
2227;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;add missing deprecated annotation;discovered while trying to sync mockito internally at google.;;0;add missing deprecated annotation;discovered while trying to sync mockito internally at google;;;;;1;1;add missing deprecated annotationdiscovered while trying to sync mockito internally at google;
2227;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;add missing deprecated annotation;discovered while trying to sync mockito internally at google.;;0;fix the issue:prestodb get the wrong result with round(x d) function #2223;when i use the math function: round(x d)  i found that :this funtion has a bug like the follows default> select round(2470000000000000314)_col02470000000000001 (1 row)but the right result should be:247soi modified the round function using bigdecimal;thank you for your pull request and welcome to our community we require contributors to sign our contributor license agreement and we dont seem to have you on file in order for us to review and merge your code please sign up at  - and if you have received this in error or have any questions please drop us a line at cla@fbcom  `double` is approximate we will support `decimal` in the future which can provide you the precision you needif you have the expertise to implement `round` more accurately without incurring excessive cost wed be excited to have it ||;;;;0;1;;
2236;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;biblatex mode: add month and year field to deprecated tab;issue #2233: in biblatex the  date  field is recommended. for backward compatibility the bibtex fields  month  and  year  are also accepted. i ve added both fields to the deprecated fields tab  although the year field is present in the required fields tab too.;;0;jdk5 backport sync;;   ||;;;;0;1;;
2236;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;biblatex mode: add month and year field to deprecated tab;issue #2233: in biblatex the  date  field is recommended. for backward compatibility the bibtex fields  month  and  year  are also accepted. i ve added both fields to the deprecated fields tab  although the year field is present in the required fields tab too.;;0;add api to close a writer sink;;document that this is called after commit or on failure || ;;;;0;1;;
2236;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;biblatex mode: add month and year field to deprecated tab;issue #2233: in biblatex the  date  field is recommended. for backward compatibility the bibtex fields  month  and  year  are also accepted. i ve added both fields to the deprecated fields tab  although the year field is present in the required fields tab too.;;2235.0;bugfix/2235 verify on a wrapped mock fails;pr for #2235: verify() on a wrapped mock fails with unfinishedverificationexception;;verify() on a wrapped mock fails with unfinishedverificationexception;i am currently using the mock resolver plugin feature (#2042) in my projects but verify() on a wrapped mock does not work as expected and throws a unfinishedverificationexceptiona junit5 test case to reproduce this bug is already in the exttest module: [mockresolvertest]( but it is not executed by default adding the junitjupiterengine as test runtime the mockresolvertest is executed but fails with following message:<pre>missing method call for verify(mock) here:-> at orgmockitousagepluginsresolvermockresolvertest$mockwrapperdoit(mockresolvertestjava:47)example of correct verification:    verify(mock)dosomething()also this error might show up because you verify either of: final/private/equals()/hashcode() methodsthose methods *cannot* be stubbed/verifiedmocking methods declared on non-public parent classes is not supportedorgmockitoexceptionsmisusingunfinishedverificationexception: missing method call for verify(mock) here:-> at orgmockitousagepluginsresolvermockresolvertest$mockwrapperdoit(mockresolvertestjava:47)example of correct verification:    verify(mock)dosomething()also this error might show up because you verify either of: final/private/equals()/hashcode() methodsthose methods *cannot* be stubbed/verifiedmocking methods declared on non-public parent classes is not supported	at orgmockitointernalexceptionsreporterunfinishedverificationexception(reporterjava:115)	at orgmockitointernalprogressmockingprogressimplvalidatemoststuff(mockingprogressimpljava:124)	at orgmockitointernalprogressmockingprogressimplvalidatestate(mockingprogressimpljava:105)	at orgmockitointernalmockitocorevalidatemockitousage(mockitocorejava:248)	at orgmockitomockitovalidatemockitousage(mockitojava:3248)	at orgmockitointernalframeworkdefaultmockitosessionfinishmocking(defaultmockitosessionjava:93)	at orgmockitojunitjupitermockitoextensionaftereach(mockitoextensionjava:186)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorlambda$invokeaftereachcallbacks$11(testmethodtestdescriptorjava:253)	at orgjunitjupiterenginedescriptortestmethodtestdescriptorlambda$invokeallaftermethodsorcallbacks$12(testmethodtestdescriptorjava:269)	at orgjunitplatformenginesupporthierarchicalthrowablecollectorexecute(throwablecollectorjava:73)</pre>the reason why failing is a missing mockutilresolve() before the identity check here: will provide a pr to fix this issue;;1;0;spotlessapply;
2241;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;2238: do not omit stack frames of causing class;this pr will fix this problems described in #2238.;;0;add examples to regular expression documentation;each regular expression function should have a concise example  the docs are here //rawentcom/cberner/presto/extract_all/presto-docs/src/main/sphinx/functions/regexprst;hi i want to have a look at this issue but the link appears to be broken any updates on this? || the current docs as listed on the website are here:  the source code is here:  ||  in #4477  ||;;;;0;1;;
2241;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;2238: do not omit stack frames of causing class;this pr will fix this problems described in #2238.;;2238.0;2238: do not omit stack frames of causing class;this pr will fix this problems described in #2238 the main cause wasnt the `hiderecursivecall` method but `tryinvoke` methodin `tryinvoke` the original stacktrace will be passed through the configured filter after it has been modified  hiderecursivecall`when calling `hiderecursivecall` the second argument (`current`) is set the the length of the stack trace of the causing exceptionthis will omit too much stack frames ultimately skipping the lines containing of the root exception causein this patch `tryinvoke` will try to find a better starting frame when an exception is caughtit will do this by investigating the created stack trace and look for the first entry matching the class name of the `instance` object given to `tryinvoke` this offset will then be given to `hiderecursivecall` as `current` argument instead of using the stack trace lengthif there is no `instance` object (`null`) the length of the stack trace is used (like before);;stacktraces of exceptions are trimmed too much;"hiim not sure if this is a bug or an intended behaviourwhen testing a method which throws an exception (checked or unchecked) the causing line is suppressed in the stack coming from mockitosimple example:```javapackage testimport javaioioexceptionimport orgmockitomockitopublic class testspy {    public static void main(string args) throws ioexception {        foo spy  mockitospy(new foo())        spymessage()    }    public static class foo {        public void message() throws ioexception {            systemoutprintln(""hello 1!"") // line 15            systemoutprintln(""hello 2!"")            throw new ioexception(""fatal"") // line 17        }    }}```when calling message() on the spy (same happens on a full mock as well) i would expect to see line 17 in the exception causeinstead i see this:```exception in thread ""main"" javaioioexception: fatal	at testtestspy$foomessage(testspyjava:15)	at testtestspymain(testspyjava:10)```line 15 contains systemoutprintln which is not causing the exception but is the first expression inside of the method message()i debugged this behaviour and came to `orgmockitointernalcreationbytebuddymockmethodadvicehiderecursivecall(throwable int class<?>)` which seems to be the root cause for this the stack trace given to that method includes the correct line (line 17 in this case) my stack trace in this case has 18 entries in total:```javaioioexception: fatal	at testtestspy$foomessage(testspyjava:17)	at javabase/javalanginvokemethodhandleinvokewitharguments(methodhandlejava:710)	at orgmockitointernalutilreflectioninstrumentationmemberaccessor$dispatcher$bytebuddy$2kmhnfkdinvokewitharguments(unknown source)	at orgmockitointernalutilreflectioninstrumentationmemberaccessorinvoke(instrumentationmemberaccessorjava:230)	at orgmockitointernalutilreflectionmodulememberaccessorinvoke(modulememberaccessorjava:43)	at orgmockitointernalcreationbytebuddymockmethodadvicetryinvoke(mockmethodadvicejava:329)	at orgmockitointernalcreationbytebuddymockmethodadviceaccess$500(mockmethodadvicejava:56)	at orgmockitointernalcreationbytebuddymockmethodadvice$realmethodcallinvoke(mockmethodadvicejava:249)	at orgmockitointernalinvocationinterceptedinvocationcallrealmethod(interceptedinvocationjava:141)	at orgmockitointernalstubbinganswerscallsrealmethodsanswer(callsrealmethodsjava:44)	at orgmockitoanswersanswer(answersjava:98)	at orgmockitointernalhandlermockhandlerimplhandle(mockhandlerimpljava:106)	at orgmockitointernalhandlernullresultguardianhandle(nullresultguardianjava:29)	at orgmockitointernalhandlerinvocationnotifierhandlerhandle(invocationnotifierhandlerjava:33)	at orgmockitointernalcreationbytebuddymockmethodinterceptordointercept(mockmethodinterceptorjava:82)	at orgmockitointernalcreationbytebuddymockmethodadvicehandle(mockmethodadvicejava:147)	at testtestspy$foomessage(testspyjava:15)	at testtestspymain(testspyjava:10)```when the method is finished 13 entries are left and the most important entry is missing:```javaioioexception: fatal	at orgmockitointernalcreationbytebuddymockmethodadvicetryinvoke(mockmethodadvicejava:329)	at orgmockitointernalcreationbytebuddymockmethodadviceaccess$500(mockmethodadvicejava:56)	at orgmockitointernalcreationbytebuddymockmethodadvice$realmethodcallinvoke(mockmethodadvicejava:249)	at orgmockitointernalinvocationinterceptedinvocationcallrealmethod(interceptedinvocationjava:141)	at orgmockitointernalstubbinganswerscallsrealmethodsanswer(callsrealmethodsjava:44)	at orgmockitoanswersanswer(answersjava:98)	at orgmockitointernalhandlermockhandlerimplhandle(mockhandlerimpljava:106)	at orgmockitointernalhandlernullresultguardianhandle(nullresultguardianjava:29)	at orgmockitointernalhandlerinvocationnotifierhandlerhandle(invocationnotifierhandlerjava:33)	at orgmockitointernalcreationbytebuddymockmethodinterceptordointercept(mockmethodinterceptorjava:82)	at orgmockitointernalcreationbytebuddymockmethodadvicehandle(mockmethodadvicejava:147)	at testtestspy$foomessage(testspyjava:15)	at testtestspymain(testspyjava:10)```disabling ""cleansstacktrace"" using mockitoconfiguration does not help - hiderecursivecall is always calledthis bug/feature is very annoying when testing methods which may throw the same type of exception at different locationseg in my case i know that the exception was thrown in that very method but i dont know if it happens in eg line 20 or 85same thing happens to `runtimeexception`s which is also annoying seeing a nullpointerexception without knowing where it happens is not helpfulis there any (configuration) option to disable the cleaning of the stack trace completely?any chance of getting this ?**tested mockito versions:** 360 and 380**os:** linux/ubuntu 2004 64-bit**jdk:** openjdk runtime environment adoptopenjdk (build 1109+11)";thanks for reporting this issue! we would welcome a patch + regression test for this issue || thanks for your great work on mockito and the contribution to open source it continues to makeive come across the very same behavior under a similar setupi must agree with the op this appears to be a bug and it would be great to see it  ||;1;0; formatting issues;
2248;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;moved return out of for-loop;i found some time to look into the code. it seems  only the last conditional statement was accidentally placed inside the for loop.;;0;modify testcheckargument_simplemessage_failure to clean code;"verifysimplemessage(expected)  change to assertthat(expected)hasmessage(""a message"") so that the  compared target(""a message"") can be saw straightway";  i signed it!this is my first contribute in open sourceexciting and hope to be accepted ||  sorry that we sat on this (and so many pull requests) for so longif ""a message"" appeared inline in the setup for the test i would agree that theres a clear benefit to including it inline in the assertion but its already defined elsewhere so this test already fails to be readable on its own :( you could probably fine a way to move all the information inline if you want but id encourage you to look for something more substantial maybe  if youre still interested || ";;;;0;1;;
2248;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;moved return out of for-loop;i found some time to look into the code. it seems  only the last conditional statement was accidentally placed inside the for loop.;;0;fix thread race condition;discovered internally at google the culprit was a thread race conditionaround the usage of usedat which could race between setting the fieldand retrieving it;reviewed internally at google assuming no objections on this pr so merging ||;;;;1;1;fix serialization issue;
2248;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;0;moved return out of for-loop;i found some time to look into the code. it seems  only the last conditional statement was accidentally placed inside the for loop.;;0;[draft] started to added parsing support for creating functions and stored procedures;;thanks for all the work @tomdz! changes are integrated into #2702 ||;;;;0;1;;
2250;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;bump versions.errorprone from 2.5.1 to 2.6.0;bumps  versions.errorprone  from 2.5.1 to 2.6.0. updates  error_prone_core  from 2.5.1 to 2.6.0 <details> <summary>commits</summary> <ul> <li><a href=  ><code>86f8e23</code></a> add <code>timeunit</code> apis to <code>returnvalueignored</code>.</li> <li><a href=  ><code>c5e1687</code></a> disable <code>banserializableread</code> by default</li> <li><a href=  ><code>3d64250</code></a> improve <code>constantpatterncompile</code> fixes</li> <li><a href=  ><code>553603f</code></a> add a missing <code>@nullable</code> annotation.</li> <li><a href=  ><code>3e14f54</code></a> generalize <code>constantpatterncompile</code></li> <li><a href=  ><code>456dcf0</code></a> rename <code>isnull</code> and <code>isnonnull</code> matchers to make it</li> <li><a href=  ><code>ed55201</code></a> inet4address and inet6address are immutable</li> <li><a href=  ><code>91951e3</code></a> remove deprecated attributes from <code>@restrictedapi</code></li> <li><a href=  ><code>2b10575</code></a> rethrow reflectiveoperationexception as linkageerror instead of assertionerror.</li> <li><a href=  ><code>fc7cca8</code></a> expand immutablemembercollection to convert <code>private final</code> member collection</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />  updates  error_prone_test_helpers  from 2.5.1 to 2.6.0 <details> <summary>commits</summary> <ul> <li><a href=  ><code>86f8e23</code></a> add <code>timeunit</code> apis to <code>returnvalueignored</code>.</li> <li><a href=  ><code>c5e1687</code></a> disable <code>banserializableread</code> by default</li> <li><a href=  ><code>3d64250</code></a> improve <code>constantpatterncompile</code> fixes</li> <li><a href=  ><code>553603f</code></a> add a missing <code>@nullable</code> annotation.</li> <li><a href=  ><code>3e14f54</code></a> generalize <code>constantpatterncompile</code></li> <li><a href=  ><code>456dcf0</code></a> rename <code>isnull</code> and <code>isnonnull</code> matchers to make it</li> <li><a href=  ><code>ed55201</code></a> inet4address and inet6address are immutable</li> <li><a href=  ><code>91951e3</code></a> remove deprecated attributes from <code>@restrictedapi</code></li> <li><a href=  ><code>2b10575</code></a> rethrow reflectiveoperationexception as linkageerror instead of assertionerror.</li> <li><a href=  ><code>fc7cca8</code></a> expand immutablemembercollection to convert <code>private final</code> member collection...</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />   dependabot will resolve any conflicts with this pr as long as you don t alter it yourself. you can also trigger a rebase manually by commenting  @dependabot rebase .  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---  <details> <summary>dependabot commands and options</summary> <br />  you can trigger dependabot actions by commenting on this pr: -  @dependabot rebase  will rebase this pr -  @dependabot recreate  will recreate this pr  overwriting any edits that have been made to it -  @dependabot merge  will merge this pr after your ci passes on it -  @dependabot squash and merge  will squash and merge this pr after your ci passes on it -  @dependabot cancel merge  will cancel a previously requested merge and block automerging -  @dependabot reopen  will reopen this pr if it is closed -  @dependabot close  will close this pr and stop dependabot recreating it. you can achieve the same result by closing it manually -  @dependabot ignore this major version  will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this minor version  will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this dependency  will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)   </details>;;0;bump versionserrorprone from 251 to 260;"bumps `versionserrorprone` from 251 to 260updates `error_prone_core` from 251 to 260<details><summary>commits</summary><ul><li><a href"" add <code>timeunit</code> apis to <code>returnvalueignored</code></li><li><a href"" disable <code>banserializableread</code> by default</li><li><a href"" improve <code>constantpatterncompile</code> fixes</li><li><a href"" add a missing <code>@nullable</code> annotation</li><li><a href"" generalize <code>constantpatterncompile</code></li><li><a href"" rename <code>isnull</code> and <code>isnonnull</code> matchers to make it</li><li><a href"" inet4address and inet6address are immutable</li><li><a href"" remove deprecated attributes from <code>@restrictedapi</code></li><li><a href"" rethrow reflectiveoperationexception as linkageerror instead of assertionerror</li><li><a href"" expand immutablemembercollection to convert <code>private final</code> member collection</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />updates `error_prone_test_helpers` from 251 to 260<details><summary>commits</summary><ul><li><a href"" add <code>timeunit</code> apis to <code>returnvalueignored</code></li><li><a href"" disable <code>banserializableread</code> by default</li><li><a href"" improve <code>constantpatterncompile</code> fixes</li><li><a href"" add a missing <code>@nullable</code> annotation</li><li><a href"" generalize <code>constantpatterncompile</code></li><li><a href"" rename <code>isnull</code> and <code>isnonnull</code> matchers to make it</li><li><a href"" inet4address and inet6address are immutable</li><li><a href"" remove deprecated attributes from <code>@restrictedapi</code></li><li><a href"" rethrow reflectiveoperationexception as linkageerror instead of assertionerror</li><li><a href"" expand immutablemembercollection to convert <code>private final</code> member collection</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />dependabot will resolve any conflicts with this pr as long as you dont alter it yourself you can also trigger a rebase manually by commenting `@dependabot rebase`[//]: # (dependabot-automerge-start)[//]: # (dependabot-automerge-end)---<details><summary>dependabot commands and options</summary><br />you can trigger dependabot actions by commenting on this pr:- `@dependabot rebase` will rebase this pr- `@dependabot recreate` will recreate this pr overwriting any edits that have been made to it- `@dependabot merge` will merge this pr after your ci passes on it- `@dependabot squash and merge` will squash and merge this pr after your ci passes on it- `@dependabot cancel merge` will cancel a previously requested merge and block automerging- `@dependabot reopen` will reopen this pr if it is closed- `@dependabot close` will close this pr and stop dependabot recreating it you can achieve the same result by closing it manually- `@dependabot ignore this major version` will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this minor version` will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this dependency` will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)</details>"; merging 2250 ;;;;1;1;fix errorprone errors;
2250;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;bump versions.errorprone from 2.5.1 to 2.6.0;bumps  versions.errorprone  from 2.5.1 to 2.6.0. updates  error_prone_core  from 2.5.1 to 2.6.0 <details> <summary>commits</summary> <ul> <li><a href=  ><code>86f8e23</code></a> add <code>timeunit</code> apis to <code>returnvalueignored</code>.</li> <li><a href=  ><code>c5e1687</code></a> disable <code>banserializableread</code> by default</li> <li><a href=  ><code>3d64250</code></a> improve <code>constantpatterncompile</code> fixes</li> <li><a href=  ><code>553603f</code></a> add a missing <code>@nullable</code> annotation.</li> <li><a href=  ><code>3e14f54</code></a> generalize <code>constantpatterncompile</code></li> <li><a href=  ><code>456dcf0</code></a> rename <code>isnull</code> and <code>isnonnull</code> matchers to make it</li> <li><a href=  ><code>ed55201</code></a> inet4address and inet6address are immutable</li> <li><a href=  ><code>91951e3</code></a> remove deprecated attributes from <code>@restrictedapi</code></li> <li><a href=  ><code>2b10575</code></a> rethrow reflectiveoperationexception as linkageerror instead of assertionerror.</li> <li><a href=  ><code>fc7cca8</code></a> expand immutablemembercollection to convert <code>private final</code> member collection</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />  updates  error_prone_test_helpers  from 2.5.1 to 2.6.0 <details> <summary>commits</summary> <ul> <li><a href=  ><code>86f8e23</code></a> add <code>timeunit</code> apis to <code>returnvalueignored</code>.</li> <li><a href=  ><code>c5e1687</code></a> disable <code>banserializableread</code> by default</li> <li><a href=  ><code>3d64250</code></a> improve <code>constantpatterncompile</code> fixes</li> <li><a href=  ><code>553603f</code></a> add a missing <code>@nullable</code> annotation.</li> <li><a href=  ><code>3e14f54</code></a> generalize <code>constantpatterncompile</code></li> <li><a href=  ><code>456dcf0</code></a> rename <code>isnull</code> and <code>isnonnull</code> matchers to make it</li> <li><a href=  ><code>ed55201</code></a> inet4address and inet6address are immutable</li> <li><a href=  ><code>91951e3</code></a> remove deprecated attributes from <code>@restrictedapi</code></li> <li><a href=  ><code>2b10575</code></a> rethrow reflectiveoperationexception as linkageerror instead of assertionerror.</li> <li><a href=  ><code>fc7cca8</code></a> expand immutablemembercollection to convert <code>private final</code> member collection...</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />   dependabot will resolve any conflicts with this pr as long as you don t alter it yourself. you can also trigger a rebase manually by commenting  @dependabot rebase .  [//]: # (dependabot-automerge-start) [//]: # (dependabot-automerge-end)  ---  <details> <summary>dependabot commands and options</summary> <br />  you can trigger dependabot actions by commenting on this pr: -  @dependabot rebase  will rebase this pr -  @dependabot recreate  will recreate this pr  overwriting any edits that have been made to it -  @dependabot merge  will merge this pr after your ci passes on it -  @dependabot squash and merge  will squash and merge this pr after your ci passes on it -  @dependabot cancel merge  will cancel a previously requested merge and block automerging -  @dependabot reopen  will reopen this pr if it is closed -  @dependabot close  will close this pr and stop dependabot recreating it. you can achieve the same result by closing it manually -  @dependabot ignore this major version  will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this minor version  will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this dependency  will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)   </details>;;0;fix compiler error exception handling;;2211  || ;;;;0;1;;
2259;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;but invoked here  lists the invocation parameters;supersedes and closes #2188;;0;200-snapshot missing from google-snapshots;our project ( cannot build with gwt 280-beta1 and guava 190 release the travis ci has been broken for a week can we expect a 200-snapshot to be published to google-snapshots soon?;hmm are you looking [here]( as far as i know guava has hasnt used that `google-snapshots` repositoryi would expect for the guava snapshot to be [here]( our continuous build [seems to think that its uploaded it]( and your maven build works for me if i switch `pom-gwtxml` to `200-snapshot` || why use a snapshot at all?  just use 190 better yet inherit the version from the parent pomi had to hack the release process for v20151216 because gwt was broken in multiple places ||  thanks i was looking at the wrong place@lindner the 190 release does not work with gwt 280-beta1 at least for closure compiler  ||;;;;0;1;;
2259;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;but invoked here  lists the invocation parameters;supersedes and closes #2188;;0;update 090 release notes;;;;;;0;1;;
2259;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;but invoked here  lists the invocation parameters;supersedes and closes #2188;;218.0;"""but invoked here"" lists the invocation parameters";supersedes and closes #2188;;regression when mocking a type in a signed package;"i just tried to upgrade from 208-beta to 209-beta (and then 2010-beta) one of our tests started failing:```orgmockitoexceptionsbasemockitoexception: mockito cannot mock this class: interface commicrosoftwindowsazureservicesservicebusservicebuscontractmockito can only mock visible & non-final classesif youre not sure why youre getting this error please report to the mailing list    at javalangclassloadercheckcerts(classloaderjava:895)    at javalangclassloaderpredefineclass(classloaderjava:665)    at javalangclassloaderdefineclass(classloaderjava:758)    at sunreflectnativemethodaccessorimplinvoke0(native method)    at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)    at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)    at javalangreflectmethodinvoke(methodjava:497)    at netbytebuddydynamicloadingclassinjector$usingreflection$classloadingactionrun(classinjectorjava:336)    at netbytebuddydynamicloadingclassinjector$usingreflection$classloadingactionrun(classinjectorjava:306)    at javasecurityaccesscontrollerdoprivileged(native method)    at netbytebuddydynamicloadingclassinjector$usingreflectioninject(classinjectorjava:122)    at netbytebuddydynamicloadingclassloadingstrategy$default$5load(classloadingstrategyjava:144)    at netbytebuddydynamicdynamictype$default$unloadedload(dynamictypejava:3380)    at orgmockitointernalcreationbytebuddymockbytecodegeneratorgeneratemockclass(mockbytecodegeneratorjava:55)    at orgmockitointernalcreationbytebuddycachingmockbytecodegenerator$cachedbytecodegeneratorgenerate(cachingmockbytecodegeneratorjava:72)    at orgmockitointernalcreationbytebuddycachingmockbytecodegenerator$cachedbytecodegeneratorgetorgeneratemockclass(cachingmockbytecodegeneratorjava:64)    at orgmockitointernalcreationbytebuddycachingmockbytecodegeneratorget(cachingmockbytecodegeneratorjava:27)    at orgmockitointernalcreationbytebuddybytebuddymockmakercreateproxyclass(bytebuddymockmakerjava:49)    at orgmockitointernalcreationbytebuddybytebuddymockmakercreatemock(bytebuddymockmakerjava:22)    at orgmockitointernalutilmockutilcreatemock(mockutiljava:33)    at orgmockitointernalmockitocoremock(mockitocorejava:59)    at orgmockitomockitomock(mockitojava:1378)    at orgmockitomockitomock(mockitojava:1256)```i thought this was odd since the mentioned type (`servicebuscontract`) is a public interface so i put a breakpoint at `orgmockitointernalcreationbytebuddycachingmockbytecodegenerator:85` the underlying error turns out to be:```javalangsecurityexception: class ""commicrosoftwindowsazureservicesservicebusmodelsbrokeredmessage$mockitomock$931493758$auxiliary$gvjxoe2i""s signer information does not match signer information of other classes in the same package```if i understand correctly mockito just switched from gclib to byte buddy perhaps this is an edge case that the new library doesnt cover yet?";"that is possible or more probable we missed something thank you for testing this builds so early )id like some integration tests for ""uncommon"" stuff like signed package osgi stuff etc || this was indeed something i missed i pushed a possible fix ci should generate a new beta that should be propagated first on bintray then maven (sync takes 1 days or so) || awesome  should be in 2011-beta let me know if that works for your environment || just upgraded to 2011-beta verified  thanks again :) || cool thanks again for the feedback fixed by cb645cfd157eaaed61436dda012d95f2fd7ec7fe || by the way since youre an early beta user id like to warn you that at some point along the 20x beta development there will be breaking changes in the matcher api in 20 well see how to mitigate impact along the way too || ";1;0;add a test and refactor code;
2263;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;2242 : make exceptions for inorder.verify more standard / spec…;…ific;;0;maps document page has two uniqueindex descriptions;im watching here: [mapsuniqueindex]( think those two are equivalent :);are you referring to the uniqueindex overloads taking an iterable in onecase and an iterator in the other?  i couldnt follow your linkon mon dec 21 2015 11:11 pm honeyandsw notifications@githubcomwrote:> im watching here: mapsuniqueindex>  i think those two are equivalent :)> > —> reply to this email directly or view it on github>  ||  oops i didnt notice that one is for iterator and the other one is for iterable will close this issue! ;;;;0;1;;
2263;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;2242 : make exceptions for inorder.verify more standard / spec…;…ific;;0;add support for hash-partitioned semijoins;semijoin queries (see example below) currently execute using broadcast strategy even if distributed joins are enabled``` sqlselect * from t where a in (select b from u)```see https://githubcom/facebook/presto/blob/master/presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/addexchangesjava#l338;@martint did you implement this already? ||;;;;0;1;;
2263;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;2242 : make exceptions for inorder.verify more standard / spec…;…ific;;2242.0;2242 : make exceptions for inorderverify more standard / spec…;…ific*adds nullinsteadofmockexception and notamockexception checks to inorderverify() *before* checking if mocks were passed in during creation of inordersee  for a description of the issueinorderverify(mock) now first checks if the passed argument is null and if the mock is in fact a mock and gives appropriate exception messages before checking if the passed in argument was passed during creation of inorder object and therefore giving a less specific error message<!-- hey thanks for the contribution this is awesomeas you may have read project members have somehow an opinionated view on what and how should bemockito eg we dont want mockito to be a feature bloatthere may be a thorough review with feedback -> code change loop--><!--which branch : - on mockito 3x make your pull request target `release/3x`- on mockito 2x make your pull request target `release/2x` (2x is in maintenance mode)--><!--if you have a suggestion for this template you can fix it in the github/pull_request_templatemd file-->## checklist -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_;indeed ;inorderverify with non-mock should perhaps give standard non-mock warning;"minor but i noticed today when i accidentally passed in a non-mock to an `inorderverify` call that it warned me that it can only verify mocks that were passed in during creation of `inorder`  while correct it seems like perhaps using the standard ""non-mock"" warning would be more helpful as it has better hinting for this situation  in particular this seems like it would be useful to newer users of the api who might have a hard time figuring out what they did wrong## mockitoverify```javalist<?> mock  mockitomock(listclass)mockitoverify(mockitomockget(5))```### output```textargument passed to verify() should be a mock but is null!examples of correct verifications:    verify(mock)somemethod()    verify(mock times(10))somemethod()    verify(mock atleastonce())somemethod()    not: verify(mocksomemethod())also if you use @mock annotation dont miss initmocks()```## inorderverify```javalist<?> mock  mockitomock(listclass)inorder inorder  mockitoinorder(mock)inorderverify(mockget(5))```### output```textinorder can only verify mocks that were passed in during creation of inorderfor example:    inorder inorder  inorder(mockone)    inorderverify(mockone)dostuff()```## desired behaviornote that the current `inorder` message does not give the hint of how to fix the non-mock that was passed in  using the standard non-mock warning in this case seems like a more helpful response  alternatively that the hinting could be included in the `inorder` output when a non-mock is used";prs welcome 😄  ||;1;0;fixing spotless java;
2267;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;include cause when fieldreader fails to access field;2266;;0;restore min/max aggregations for booleans;;;;;;0;1;;
2267;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;include cause when fieldreader fails to access field;2266;;2266.0;include cause when fieldreader fails to access field;2266simply passes the exception cause to the thrown mockitoexception; merging 2267 ;swallowed illegal access exceptions make it harder to debug modularity-related issues;### issue summaryin fieldreader and reflectionmemberaccessor if an illegalaccessexception is thrown it will be suppressedat the very least mockito should include the original exception when testing a modular application it is common to have packages encapsulated by default### stacktracein fieldreader the illegalaccessexception is caught the exception is re-thrown but the cause is lost a debugger the illegalaccessexception can be observed:  problematic code1 use `module-info` in the project and dont open the package under test to mockito2 use the `mockitoextension` for junit:```java@extendwith(mockitoextensionclass)public class myclasstest {  private final mytype mock  public myclasstest(@mock mytype mock) {    thismock  mock  }}```### environmentmockito-junit-jupiter 390zulu1628+11-ca (build 16+36);;1;0;include cause when fieldreader fails to access field* 2266* add regression test in module-test;
2274;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;2273 : add missing parenthesis to javadoc example;adds the missing parenthesis to the argumentmatcher javadoc example;;0;add benchmark for structured types;;looks good  ||;;;;0;1;;
2274;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;2273 : add missing parenthesis to javadoc example;adds the missing parenthesis to the argumentmatcher javadoc example;;2273.0;2273 : add missing parenthesis to javadoc example;adds the missing parenthesis to the argumentmatcher javadoc example## checklist -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_; merging 2274 ;example in javadoc of argumentmatcher has missing parenthesis;check that -  the problematic code (if thats possible) is copied here       note that some configuration are impossible to mock via mockito -  read the [contributing guide]( javadoc for argumentmatcher contains some example code which misses a pair of parenthesis in one case at https://githubcom/mockito/mockito/blob/c86fe047d557bd2ec364d59a99430792f3920e96/src/main/java/org/mockito/argumentmatcherjava#l64;;1;0;2273 : add missing parenthesis to javadoc example;
2277;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;apply automated errorprone fixes;this is the result of running errorprone on the codebase. most notably;;0;apply automated errorprone fixes;this is the result of running errorprone on the codebase most notablyit adds missing override annotations adds private constructors forclasses that should not be subclassed removes redundant generic typespecified and fixes handling of casts/instance checks;@raphw not sure if it is worth to review as it is a mechanical change that passes all tests so feel free to rubberstamp || i am assuming no objections on this mechanical pr and will therefore merge it let me know if you do have any objections and am happy to resolve them ||;;;;1;1;apply automated errorprone fixesthis is the result of running errorprone on the codebase most notablyit adds missing override annotations adds private constructors forclasses that should not be subclassed removes redundant generic typespecified and fixes handling of casts/instance checks;
2277;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;apply automated errorprone fixes;this is the result of running errorprone on the codebase. most notably;;0;refactor raptor storagemanager interfaces;;minor comments looks good otherwise  ||;;;;0;1;;
2279;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;remove asm dependency;mockito depends on byte-buddy to make most of its bytecode fiddling but asm is still needed for the tests. we can remove this dependency by relying on the already shaded version included on asm  that we we won t get unaligned between both dependencies and we will remove the need for the explicit asm library.;;0;remove asm dependency;mockito depends on byte-buddy to make most of its bytecode fiddling but asm is still needed for the tests we can remove this dependency by relying on the already shaded version included on asm that we we wont get unaligned between both dependencies and we will remove the need for the explicit asm libraryr: @raphw<!-- hey thanks for the contribution this is awesomeas you may have read project members have somehow an opinionated view on what and how should bemockito eg we dont want mockito to be a feature bloatthere may be a thorough review with feedback -> code change loop--><!--which branch : - on mockito 3x make your pull request target `release/3x`- on mockito 2x make your pull request target `release/2x` (2x is in maintenance mode)--><!--if you have a suggestion for this template you can fix it in the github/pull_request_templatemd file-->## checklist -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_;id go as far as to say we should rather eliminate asm altogether and use byte buddys api to create the interface thats a one-liner more or less:```javanew bytebuddy()            makeinterface(qualifiedname)            make()```this avoids handling the technicalities ||   oh i only took a look at the imports :) thanks for the suggestion @raphw ptal again ||;;;;1;1;remove asm dependency;
2279;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;remove asm dependency;mockito depends on byte-buddy to make most of its bytecode fiddling but asm is still needed for the tests. we can remove this dependency by relying on the already shaded version included on asm  that we we won t get unaligned between both dependencies and we will remove the need for the explicit asm library.;;0;fix memory leak from aborted and failed tasks;;;;;;0;1;;
2280;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;support mocking of function with kotlin inline classes;despite functions with inline class parameters being already supported;;0;support mocking of function with kotlin inline classes;despite functions with inline class parameters being already supportedthere were not tests for it thus add themthe other part is functions returning inline classes there can be severalkinds of inline classes - with primitive underlying type (nullable or not-null)and reference types (nullable or not-null) also a function can return eithernullable of not-null inline class if a function returns nullable inline classwe do not do anything special - the functions signature contains inline classhowever if the function returns not-null inline class its signature containsunderlying type thus we need to unbox the inline class (ie get underlyingtypes value) to mock the return valuefor example if we have the following inline class  inline class ic(val i: int)and we want to mock return value of a function returning the inline class  fun returnsic(): iclike  `when`(mockreturnsic())thenreturn(ic(1))then if we do not unbox the argument of `thenreturn` function we get errorabout incompatible typesthe only issue however is that we cannot check whether the function indeedreturns `ic` unless we use kotlinreflect so the following code will work  fun returnsint(): int  `when`(mockreturnsint())thenreturn(ic(1))fixes issue #1930<!-- hey thanks for the contribution this is awesomeas you may have read project members have somehow an opinionated view on what and how should bemockito eg we dont want mockito to be a feature bloatthere may be a thorough review with feedback -> code change loop--><!--which branch : - on mockito 3x make your pull request target `release/3x`- on mockito 2x make your pull request target `release/2x` (2x is in maintenance mode)--><!--if you have a suggestion for this template you can fix it in the github/pull_request_templatemd file-->## checklist -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_; merging 2280 ;;;;1;1;throw an exception when inline class does not have unbox-impl;
2280;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;support mocking of function with kotlin inline classes;despite functions with inline class parameters being already supported;;0;improve error message including comparable orderable info;add typeparameter info(comparable orderable) into error messagefix https://githubcom/facebook/presto/issues/2181;;;;;0;1;;
2283;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;implement #1359: collect telemetry;in this pr  [microsoft azure application insights]( is used to record the following information about how jabref is used:;;0;improve error messages in case of missing dependency on byte buddy and avoid hard dependency on byte buddy in member accessor;this improves error messages in case the dependency is not set up correctly this should rarely happen but especially with the module system gaining traction this might trigger a few bugs that we can better explain this way;i do not quite understand why the ci is failing this does not seem related to my changes at all || @raphw since we moved the classes to a new name i think we need to update these two string references to the new class name:  || good catch about the initialization ill give it another try ||  merging 2283 ;;;;1;1;improve error messages in case of missing dependency on byte buddy and avoid hard dependency on byte buddy in member accessor;
2283;0;0;0;0;0;0;1;1;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;implement #1359: collect telemetry;in this pr  [microsoft azure application insights]( is used to record the following information about how jabref is used:;;0;add optimizer for limit 0;currently the plan a query with `limit 0` includes all nodes under the limit  this causes presto to start scheduling the query and then tear down the query  instead the plan nodes under a `limit 0` node should be replaced with an empty `values` node which will cause the query to complete instantly;may i claim this one? || sure ||  ||;;;;0;1;;
2292;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix stackoverflow in argumentsaredifferent reporting;when using mockito without opentest4j  reporting an;;0;fix stackoverflow in argumentsaredifferent reporting;when using mockito without opentest4j reporting anargumentsaredifferent exception would throw a stackoverflowerror whenattempting to obtain the message from the exceptionthe root problem was that supertostring() would call its owngetmessage() instead we should obtain the message from the super toavoid the circular call;note that i tried to create a regression test for this but sadly was unable to to make the integration test work we would need to exclude both opentest4j and junit4 while that would technically be possible gradle wouldnt be able to pick up a test that is *not* annotated with `@test` i also tried using junit5 but they have a transitive dependency on opentest4j any attempt to exclude the transitive dependency causes the gradle task to crash i have manually verified that removing  and running `basicverificationtest` would reproduce the issue and that the fix is making the test pass as expected || are all of our implementations are doing this:  and  am not sure what the effect of the removal is can we separate that change out to unblock non-opentest4j users and figure out what the impact of removing `removefirstline` will be? || ok lets move on if all tests pass with your change we should be good to go ||;;;;1;1;fix stackoverflow in argumentsaredifferent reportingwhen using mockito without opentest4j reporting anargumentsaredifferent exception would throw a stackoverflowerror whenattempting to obtain the message from the exceptionthe root problem was that supertostring() would call its owngetmessage() instead we should obtain the message from the super toavoid the circular call;
2292;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;fix stackoverflow in argumentsaredifferent reporting;when using mockito without opentest4j  reporting an;;0;remove duplicate license header in hiverecordsink;remove duplicate license header in hiverecordsink;;;;;0;1;;
2298;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;bump versions.errorprone from 2.6.0 to 2.7.1;bumps  versions.errorprone  from 2.6.0 to 2.7.1. updates  error_prone_core  from 2.6.0 to 2.7.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_core s releases</a>.</em></p> <blockquote> <h2>error prone 2.7.1</h2> <p>everything in <a href=  >error prone 2.7.0</a>  plus an <a href=  >additional fix for jdk 17</a>.</p> <h2>error prone 2.7.0</h2> <p>changes</p> <ul> <li>initial support for running on jdk 17 ea builds. supports for java 17 languages features is incomplete  <a href=  >bug reports</a> for issues with java 17 are welcome.</li> <li><a href=  ><code>@​inlineme</code></a>  is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href=  > </ul> <p>new checks:</p> <ul> <li><a href=  >equalsnull</a></li> <li><a href=  >missingbraces</a></li> <li><a href=  >nullableprimitivearray</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >testparametersnotinitialized</a></li> </ul> <p>closed issues: <a href=  >#2257</a>  <a href=  >#2260</a>  <a href=  >#2282</a>  <a href=  >#2301</a>  <a href=  >#2322</a>  <a href=  >#2323</a>  <a href=  >#2324</a></p> </blockquote> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>09262b8</code></a> release error prone 2.7.1</li> <li><a href=  ><code>ff07935</code></a> improve jdk 17 support</li> <li><a href=  ><code>65a75c9</code></a> enable <code>returnvalueignored</code>-checking of <code>collection</code>  <code>iterable</code>  and  iterat</li> <li><a href=  ><code>0c6a76d</code></a> fix a jdk 17 incompatibility</li> <li><a href=  ><code>1846d94</code></a> add tests for method invocation bug with the <code>inliner</code>.</li> <li><a href=  ><code>8c6f73c</code></a> fix a jdk 16-only test</li> <li><a href=  ><code>62d1bf7</code></a> internal refactoring.</li> <li><a href=  ><code>5913d86</code></a> update error prone ci to use jdk 16 as latest  and add 17-ea</li> <li><a href=  ><code>f6761ee</code></a> fix a jdk 16 incompatibility</li> <li><a href=  ><code>51b5c4d</code></a> fix some crashes involving records</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />  updates  error_prone_test_helpers  from 2.6.0 to 2.7.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_test_helpers s releases</a>.</em></p> <blockquote> <h2>error prone 2.7.1</h2> <p>everything in <a href=  >error prone 2.7.0</a>  plus an <a href=  >additional fix for jdk 17</a>.</p> <h2>error prone 2.7.0</h2> <p>changes</p> <ul> <li>initial support for running on jdk 17 ea builds. supports for java 17 languages features is incomplete  <a href=  >bug reports</a> for issues with java 17 are welcome.</li> <li><a href=  ><code>@​inlineme</code></a>  is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href=  > </ul> <p>new checks:</p> <ul> <li><a href=  >equalsnull</a></li> <li><a href=  >missingbraces</a></li> <li><a href=  >nullableprimitivearray</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >testparametersnotinitialized</a></li> </ul> <p>closed issues: <a href=  >#2257</a>  <a href=  >#2260</a>  <a href=  >#2282</a>  <a href=  >#2301</a>  <a href=  >#2322</a>  <a href=  >#2323</a>  <a href=  >#2324</a></p> </blockquote> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>09262b8</code></a> release error prone 2.7.1</li> <li><a href=  ><code>ff07935</code></a> improve jdk 17 support</li> <li><a href=  ><code>65a75c9</code></a> enable <code>returnvalueignored</code>-checking of <code>collection</code>  <code>iterable</code>  and  iterat...</li> <li><a href=  ><code>0c6a76d</code></a> fix a jdk 17 incompatibility</li> <li><a href=  ><code>1846d94</code></a> add tests for method invocation bug with the <code>inliner</code>.</li> <li><a href=  ><code>8c6f73c</code></a> fix a jdk 16-only test</li> <li><a href=  ><code>62d1bf7</code></a> internal refactoring.</li> <li><a href=  ><code>5913d86</code></a> update error prone ci to use jdk 16 as latest  and add 17-ea</li> <li><a href=  ><code>f6761ee</code></a> fix a jdk 16 incompatibility</li> <li><a href=  ><code>51b5c4d</code></a> fix some crashes involving records</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />   dependabot will resolve any conflicts with this pr as long as you don t alter it yourself. you can also trigger a rebase manually by commenting  @dependabot rebase .  [//]: # (dependabot-automerge-start) dependabot will merge this pr once ci passes on it  as requested by @timvdlippe.  [//]: # (dependabot-automerge-end)  ---  <details> <summary>dependabot commands and options</summary> <br />  you can trigger dependabot actions by commenting on this pr: -  @dependabot rebase  will rebase this pr -  @dependabot recreate  will recreate this pr  overwriting any edits that have been made to it -  @dependabot merge  will merge this pr after your ci passes on it -  @dependabot squash and merge  will squash and merge this pr after your ci passes on it -  @dependabot cancel merge  will cancel a previously requested merge and block automerging -  @dependabot reopen  will reopen this pr if it is closed -  @dependabot close  will close this pr and stop dependabot recreating it. you can achieve the same result by closing it manually -  @dependabot ignore this major version  will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this minor version  will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this dependency  will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)   </details>;;2282.0;bump versionserrorprone from 260 to 271;"bumps `versionserrorprone` from 260 to 271updates `error_prone_core` from 260 to 271<details><summary>release notes</summary><p><em>sourced from <a href"" releases</a></em></p><blockquote><h2>error prone 271</h2><p>everything in <a href"" prone 270</a> plus an <a href"" fix for jdk 17</a></p><h2>error prone 270</h2><p>changes</p><ul><li>initial support for running on jdk 17 ea builds supports for java 17 languages features is incomplete <a href"" reports</a> for issues with java 17 are welcome</li><li><a href"" is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href"" checks:</p><ul><li><a href"" href"" href"" href"" href"" issues: <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" href"" release error prone 271</li><li><a href"" improve jdk 17 support</li><li><a href"" enable <code>returnvalueignored</code>-checking of <code>collection</code> <code>iterable</code> and `iterat</li><li><a href"" fix a jdk 17 incompatibility</li><li><a href"" add tests for method invocation bug with the <code>inliner</code></li><li><a href"" fix a jdk 16-only test</li><li><a href"" internal refactoring</li><li><a href"" update error prone ci to use jdk 16 as latest and add 17-ea</li><li><a href"" fix a jdk 16 incompatibility</li><li><a href"" fix some crashes involving records</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />updates `error_prone_test_helpers` from 260 to 271<details><summary>release notes</summary><p><em>sourced from <a href"" releases</a></em></p><blockquote><h2>error prone 271</h2><p>everything in <a href"" prone 270</a> plus an <a href"" fix for jdk 17</a></p><h2>error prone 270</h2><p>changes</p><ul><li>initial support for running on jdk 17 ea builds supports for java 17 languages features is incomplete <a href"" reports</a> for issues with java 17 are welcome</li><li><a href"" is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href"" checks:</p><ul><li><a href"" href"" href"" href"" href"" issues: <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" href"" release error prone 271</li><li><a href"" improve jdk 17 support</li><li><a href"" enable <code>returnvalueignored</code>-checking of <code>collection</code> <code>iterable</code> and `iterat</li><li><a href"" fix a jdk 17 incompatibility</li><li><a href"" add tests for method invocation bug with the <code>inliner</code></li><li><a href"" fix a jdk 16-only test</li><li><a href"" internal refactoring</li><li><a href"" update error prone ci to use jdk 16 as latest and add 17-ea</li><li><a href"" fix a jdk 16 incompatibility</li><li><a href"" fix some crashes involving records</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />dependabot will resolve any conflicts with this pr as long as you dont alter it yourself you can also trigger a rebase manually by commenting `@dependabot rebase`[//]: # (dependabot-automerge-start)dependabot will merge this pr once ci passes on it as requested by @timvdlippe[//]: # (dependabot-automerge-end)---<details><summary>dependabot commands and options</summary><br />you can trigger dependabot actions by commenting on this pr:- `@dependabot rebase` will rebase this pr- `@dependabot recreate` will recreate this pr overwriting any edits that have been made to it- `@dependabot merge` will merge this pr after your ci passes on it- `@dependabot squash and merge` will squash and merge this pr after your ci passes on it- `@dependabot cancel merge` will cancel a previously requested merge and block automerging- `@dependabot reopen` will reopen this pr if it is closed- `@dependabot close` will close this pr and stop dependabot recreating it you can achieve the same result by closing it manually- `@dependabot ignore this major version` will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this minor version` will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this dependency` will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)</details>"; ;mockito fails to work in java 11 with jpms modules;"i am migrating log4j 2 to fully support jpms in doing that the unit tests that use mockito are all failing with    javalangillegalstateexception: could not initialize plugin: interface orgmockitopluginsmockmaker (alternate: null)    caused by: javalangillegalstateexception: internal problem occurred please report it mockito is unable to load the default implementation of class that is a part of mockito distribution failed to load interface orgmockitopluginsmockmaker    caused by: javalangreflectinvocationtargetexception    caused by: javalangnoclassdeffounderror: net/bytebuddy/dynamic/loading/classinjector$usingreflection    caused by: javalangclassnotfoundexception: netbytebuddydynamicloadingclassinjector$usingreflectionif is set system property ""orgmockitointernalnounsafeinjection"" to true then it fails the same way trying to access $usinglookup note that this worked fine with the same versions of mockito and byte-buddy when a module-infojava wasnt presentdo i need to add an --add-opens for something?";are you using mockito-inline? otherwise youd need to open your module to mockito  || no log4j does not use mockito-inline im not really sure what that is to be honest i didnt write any of the stuff that uses mockito in log4j i dont understand how opening the module to mockito will help resolve a class not found exception in byte buddy? wouulnt mockito have to open something? || mockito cannot open anything modules are fully encapsulated try replacing mockito-core with mockito-inline in your dependencies and make sure to use the latest version alternatively do you have a reproducing branch?  || i have checked the code into the jpms-mockito-fails branch of   clone the repo checkout that branch and then run mvn clean install you will need java 11  and i believe you will need at least maven 361 ||  has the full diff since this diff is quite large would it be possible to separate the directory rename? that would hopefully make it a bit easier for us to digest what the diff is and what the potential culprit could be  no it wouldnt be possible prior to this change log4j-core was an automatic module and the tests were not modules at all to convert to a jpms module the tests also had to be converted to comply with jpms the tests were being passed downstream for other modules to use in tests but they shared the same package name as the main module so the tests being passed on had to be split plus some of the test classes were using the log4j-api package namespace the diff is that log4j-core used to have an automatic module name which meant while it had a name it really wasnt a jpms module it didnt have all the restrictions placed on it that named modules do so everything was open because of the change all the tests now run on the module path instead of the class path which means everything has to conform to jpms   || the reason is pretty obvious: byte buddy is missing from the class path i do not know how the module path is assembled but i assume that the tool you are using does not know how to process an automatic module such as mockito that requires a dependency i set a breakpoint in the test and class in question and the *netbytebuddy* module is not on the module path while the class path is emptywell see how to improve the error message in such a case i assume the tooling around the module system is still lacking a few details so this might just pay offif i for example add the line:    requires transitive netbytebuddyto *logging-log4j2/log4j-core/src/test/java9/module-infojava* the problem seems to be solved for the `consoleappendertest` that yielded the error message that you described || thanks that is interesting since the class shows up with mvn dependency:tree and clearly is there since just adding the requires for it fixes the problem im not sure why that didnt occur to me id guess it is the surefire plugin setting up the class path and module path or something it delegates to it sure would have been nice to have had some kind of warning message that dependencies were being ignored anyway i will close this issue ||;1;0;fix errorprone warnings;
2298;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;bump versions.errorprone from 2.6.0 to 2.7.1;bumps  versions.errorprone  from 2.6.0 to 2.7.1. updates  error_prone_core  from 2.6.0 to 2.7.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_core s releases</a>.</em></p> <blockquote> <h2>error prone 2.7.1</h2> <p>everything in <a href=  >error prone 2.7.0</a>  plus an <a href=  >additional fix for jdk 17</a>.</p> <h2>error prone 2.7.0</h2> <p>changes</p> <ul> <li>initial support for running on jdk 17 ea builds. supports for java 17 languages features is incomplete  <a href=  >bug reports</a> for issues with java 17 are welcome.</li> <li><a href=  ><code>@​inlineme</code></a>  is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href=  > </ul> <p>new checks:</p> <ul> <li><a href=  >equalsnull</a></li> <li><a href=  >missingbraces</a></li> <li><a href=  >nullableprimitivearray</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >testparametersnotinitialized</a></li> </ul> <p>closed issues: <a href=  >#2257</a>  <a href=  >#2260</a>  <a href=  >#2282</a>  <a href=  >#2301</a>  <a href=  >#2322</a>  <a href=  >#2323</a>  <a href=  >#2324</a></p> </blockquote> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>09262b8</code></a> release error prone 2.7.1</li> <li><a href=  ><code>ff07935</code></a> improve jdk 17 support</li> <li><a href=  ><code>65a75c9</code></a> enable <code>returnvalueignored</code>-checking of <code>collection</code>  <code>iterable</code>  and  iterat</li> <li><a href=  ><code>0c6a76d</code></a> fix a jdk 17 incompatibility</li> <li><a href=  ><code>1846d94</code></a> add tests for method invocation bug with the <code>inliner</code>.</li> <li><a href=  ><code>8c6f73c</code></a> fix a jdk 16-only test</li> <li><a href=  ><code>62d1bf7</code></a> internal refactoring.</li> <li><a href=  ><code>5913d86</code></a> update error prone ci to use jdk 16 as latest  and add 17-ea</li> <li><a href=  ><code>f6761ee</code></a> fix a jdk 16 incompatibility</li> <li><a href=  ><code>51b5c4d</code></a> fix some crashes involving records</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />  updates  error_prone_test_helpers  from 2.6.0 to 2.7.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_test_helpers s releases</a>.</em></p> <blockquote> <h2>error prone 2.7.1</h2> <p>everything in <a href=  >error prone 2.7.0</a>  plus an <a href=  >additional fix for jdk 17</a>.</p> <h2>error prone 2.7.0</h2> <p>changes</p> <ul> <li>initial support for running on jdk 17 ea builds. supports for java 17 languages features is incomplete  <a href=  >bug reports</a> for issues with java 17 are welcome.</li> <li><a href=  ><code>@​inlineme</code></a>  is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href=  > </ul> <p>new checks:</p> <ul> <li><a href=  >equalsnull</a></li> <li><a href=  >missingbraces</a></li> <li><a href=  >nullableprimitivearray</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >testparametersnotinitialized</a></li> </ul> <p>closed issues: <a href=  >#2257</a>  <a href=  >#2260</a>  <a href=  >#2282</a>  <a href=  >#2301</a>  <a href=  >#2322</a>  <a href=  >#2323</a>  <a href=  >#2324</a></p> </blockquote> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>09262b8</code></a> release error prone 2.7.1</li> <li><a href=  ><code>ff07935</code></a> improve jdk 17 support</li> <li><a href=  ><code>65a75c9</code></a> enable <code>returnvalueignored</code>-checking of <code>collection</code>  <code>iterable</code>  and  iterat...</li> <li><a href=  ><code>0c6a76d</code></a> fix a jdk 17 incompatibility</li> <li><a href=  ><code>1846d94</code></a> add tests for method invocation bug with the <code>inliner</code>.</li> <li><a href=  ><code>8c6f73c</code></a> fix a jdk 16-only test</li> <li><a href=  ><code>62d1bf7</code></a> internal refactoring.</li> <li><a href=  ><code>5913d86</code></a> update error prone ci to use jdk 16 as latest  and add 17-ea</li> <li><a href=  ><code>f6761ee</code></a> fix a jdk 16 incompatibility</li> <li><a href=  ><code>51b5c4d</code></a> fix some crashes involving records</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />   dependabot will resolve any conflicts with this pr as long as you don t alter it yourself. you can also trigger a rebase manually by commenting  @dependabot rebase .  [//]: # (dependabot-automerge-start) dependabot will merge this pr once ci passes on it  as requested by @timvdlippe.  [//]: # (dependabot-automerge-end)  ---  <details> <summary>dependabot commands and options</summary> <br />  you can trigger dependabot actions by commenting on this pr: -  @dependabot rebase  will rebase this pr -  @dependabot recreate  will recreate this pr  overwriting any edits that have been made to it -  @dependabot merge  will merge this pr after your ci passes on it -  @dependabot squash and merge  will squash and merge this pr after your ci passes on it -  @dependabot cancel merge  will cancel a previously requested merge and block automerging -  @dependabot reopen  will reopen this pr if it is closed -  @dependabot close  will close this pr and stop dependabot recreating it. you can achieve the same result by closing it manually -  @dependabot ignore this major version  will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this minor version  will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this dependency  will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)   </details>;;2257.0;bump versionserrorprone from 260 to 271;"bumps `versionserrorprone` from 260 to 271updates `error_prone_core` from 260 to 271<details><summary>release notes</summary><p><em>sourced from <a href"" releases</a></em></p><blockquote><h2>error prone 271</h2><p>everything in <a href"" prone 270</a> plus an <a href"" fix for jdk 17</a></p><h2>error prone 270</h2><p>changes</p><ul><li>initial support for running on jdk 17 ea builds supports for java 17 languages features is incomplete <a href"" reports</a> for issues with java 17 are welcome</li><li><a href"" is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href"" checks:</p><ul><li><a href"" href"" href"" href"" href"" issues: <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" href"" release error prone 271</li><li><a href"" improve jdk 17 support</li><li><a href"" enable <code>returnvalueignored</code>-checking of <code>collection</code> <code>iterable</code> and `iterat</li><li><a href"" fix a jdk 17 incompatibility</li><li><a href"" add tests for method invocation bug with the <code>inliner</code></li><li><a href"" fix a jdk 16-only test</li><li><a href"" internal refactoring</li><li><a href"" update error prone ci to use jdk 16 as latest and add 17-ea</li><li><a href"" fix a jdk 16 incompatibility</li><li><a href"" fix some crashes involving records</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />updates `error_prone_test_helpers` from 260 to 271<details><summary>release notes</summary><p><em>sourced from <a href"" releases</a></em></p><blockquote><h2>error prone 271</h2><p>everything in <a href"" prone 270</a> plus an <a href"" fix for jdk 17</a></p><h2>error prone 270</h2><p>changes</p><ul><li>initial support for running on jdk 17 ea builds supports for java 17 languages features is incomplete <a href"" reports</a> for issues with java 17 are welcome</li><li><a href"" is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href"" checks:</p><ul><li><a href"" href"" href"" href"" href"" issues: <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" href"" release error prone 271</li><li><a href"" improve jdk 17 support</li><li><a href"" enable <code>returnvalueignored</code>-checking of <code>collection</code> <code>iterable</code> and `iterat</li><li><a href"" fix a jdk 17 incompatibility</li><li><a href"" add tests for method invocation bug with the <code>inliner</code></li><li><a href"" fix a jdk 16-only test</li><li><a href"" internal refactoring</li><li><a href"" update error prone ci to use jdk 16 as latest and add 17-ea</li><li><a href"" fix a jdk 16 incompatibility</li><li><a href"" fix some crashes involving records</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />dependabot will resolve any conflicts with this pr as long as you dont alter it yourself you can also trigger a rebase manually by commenting `@dependabot rebase`[//]: # (dependabot-automerge-start)dependabot will merge this pr once ci passes on it as requested by @timvdlippe[//]: # (dependabot-automerge-end)---<details><summary>dependabot commands and options</summary><br />you can trigger dependabot actions by commenting on this pr:- `@dependabot rebase` will rebase this pr- `@dependabot recreate` will recreate this pr overwriting any edits that have been made to it- `@dependabot merge` will merge this pr after your ci passes on it- `@dependabot squash and merge` will squash and merge this pr after your ci passes on it- `@dependabot cancel merge` will cancel a previously requested merge and block automerging- `@dependabot reopen` will reopen this pr if it is closed- `@dependabot close` will close this pr and stop dependabot recreating it you can achieve the same result by closing it manually- `@dependabot ignore this major version` will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this minor version` will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this dependency` will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)</details>"; ;reinstate codecov reporting;with the migration to github actions it seems that we have lost the codecov reporting on github pull requests i am assumign thats happening because we are no longer reporting to codecov after a successful github action completion;i just discovered that we do run the coverage reporting as expected but it is not reporting back on the pr status || seems like they are back in action ||;1;0;fix errorprone warnings;
2298;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;bump versions.errorprone from 2.6.0 to 2.7.1;bumps  versions.errorprone  from 2.6.0 to 2.7.1. updates  error_prone_core  from 2.6.0 to 2.7.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_core s releases</a>.</em></p> <blockquote> <h2>error prone 2.7.1</h2> <p>everything in <a href=  >error prone 2.7.0</a>  plus an <a href=  >additional fix for jdk 17</a>.</p> <h2>error prone 2.7.0</h2> <p>changes</p> <ul> <li>initial support for running on jdk 17 ea builds. supports for java 17 languages features is incomplete  <a href=  >bug reports</a> for issues with java 17 are welcome.</li> <li><a href=  ><code>@​inlineme</code></a>  is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href=  > </ul> <p>new checks:</p> <ul> <li><a href=  >equalsnull</a></li> <li><a href=  >missingbraces</a></li> <li><a href=  >nullableprimitivearray</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >testparametersnotinitialized</a></li> </ul> <p>closed issues: <a href=  >#2257</a>  <a href=  >#2260</a>  <a href=  >#2282</a>  <a href=  >#2301</a>  <a href=  >#2322</a>  <a href=  >#2323</a>  <a href=  >#2324</a></p> </blockquote> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>09262b8</code></a> release error prone 2.7.1</li> <li><a href=  ><code>ff07935</code></a> improve jdk 17 support</li> <li><a href=  ><code>65a75c9</code></a> enable <code>returnvalueignored</code>-checking of <code>collection</code>  <code>iterable</code>  and  iterat</li> <li><a href=  ><code>0c6a76d</code></a> fix a jdk 17 incompatibility</li> <li><a href=  ><code>1846d94</code></a> add tests for method invocation bug with the <code>inliner</code>.</li> <li><a href=  ><code>8c6f73c</code></a> fix a jdk 16-only test</li> <li><a href=  ><code>62d1bf7</code></a> internal refactoring.</li> <li><a href=  ><code>5913d86</code></a> update error prone ci to use jdk 16 as latest  and add 17-ea</li> <li><a href=  ><code>f6761ee</code></a> fix a jdk 16 incompatibility</li> <li><a href=  ><code>51b5c4d</code></a> fix some crashes involving records</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />  updates  error_prone_test_helpers  from 2.6.0 to 2.7.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_test_helpers s releases</a>.</em></p> <blockquote> <h2>error prone 2.7.1</h2> <p>everything in <a href=  >error prone 2.7.0</a>  plus an <a href=  >additional fix for jdk 17</a>.</p> <h2>error prone 2.7.0</h2> <p>changes</p> <ul> <li>initial support for running on jdk 17 ea builds. supports for java 17 languages features is incomplete  <a href=  >bug reports</a> for issues with java 17 are welcome.</li> <li><a href=  ><code>@​inlineme</code></a>  is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href=  > </ul> <p>new checks:</p> <ul> <li><a href=  >equalsnull</a></li> <li><a href=  >missingbraces</a></li> <li><a href=  >nullableprimitivearray</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >testparametersnotinitialized</a></li> </ul> <p>closed issues: <a href=  >#2257</a>  <a href=  >#2260</a>  <a href=  >#2282</a>  <a href=  >#2301</a>  <a href=  >#2322</a>  <a href=  >#2323</a>  <a href=  >#2324</a></p> </blockquote> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>09262b8</code></a> release error prone 2.7.1</li> <li><a href=  ><code>ff07935</code></a> improve jdk 17 support</li> <li><a href=  ><code>65a75c9</code></a> enable <code>returnvalueignored</code>-checking of <code>collection</code>  <code>iterable</code>  and  iterat...</li> <li><a href=  ><code>0c6a76d</code></a> fix a jdk 17 incompatibility</li> <li><a href=  ><code>1846d94</code></a> add tests for method invocation bug with the <code>inliner</code>.</li> <li><a href=  ><code>8c6f73c</code></a> fix a jdk 16-only test</li> <li><a href=  ><code>62d1bf7</code></a> internal refactoring.</li> <li><a href=  ><code>5913d86</code></a> update error prone ci to use jdk 16 as latest  and add 17-ea</li> <li><a href=  ><code>f6761ee</code></a> fix a jdk 16 incompatibility</li> <li><a href=  ><code>51b5c4d</code></a> fix some crashes involving records</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />   dependabot will resolve any conflicts with this pr as long as you don t alter it yourself. you can also trigger a rebase manually by commenting  @dependabot rebase .  [//]: # (dependabot-automerge-start) dependabot will merge this pr once ci passes on it  as requested by @timvdlippe.  [//]: # (dependabot-automerge-end)  ---  <details> <summary>dependabot commands and options</summary> <br />  you can trigger dependabot actions by commenting on this pr: -  @dependabot rebase  will rebase this pr -  @dependabot recreate  will recreate this pr  overwriting any edits that have been made to it -  @dependabot merge  will merge this pr after your ci passes on it -  @dependabot squash and merge  will squash and merge this pr after your ci passes on it -  @dependabot cancel merge  will cancel a previously requested merge and block automerging -  @dependabot reopen  will reopen this pr if it is closed -  @dependabot close  will close this pr and stop dependabot recreating it. you can achieve the same result by closing it manually -  @dependabot ignore this major version  will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this minor version  will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this dependency  will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)   </details>;;2260.0;bump versionserrorprone from 260 to 271;"bumps `versionserrorprone` from 260 to 271updates `error_prone_core` from 260 to 271<details><summary>release notes</summary><p><em>sourced from <a href"" releases</a></em></p><blockquote><h2>error prone 271</h2><p>everything in <a href"" prone 270</a> plus an <a href"" fix for jdk 17</a></p><h2>error prone 270</h2><p>changes</p><ul><li>initial support for running on jdk 17 ea builds supports for java 17 languages features is incomplete <a href"" reports</a> for issues with java 17 are welcome</li><li><a href"" is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href"" checks:</p><ul><li><a href"" href"" href"" href"" href"" issues: <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" href"" release error prone 271</li><li><a href"" improve jdk 17 support</li><li><a href"" enable <code>returnvalueignored</code>-checking of <code>collection</code> <code>iterable</code> and `iterat</li><li><a href"" fix a jdk 17 incompatibility</li><li><a href"" add tests for method invocation bug with the <code>inliner</code></li><li><a href"" fix a jdk 16-only test</li><li><a href"" internal refactoring</li><li><a href"" update error prone ci to use jdk 16 as latest and add 17-ea</li><li><a href"" fix a jdk 16 incompatibility</li><li><a href"" fix some crashes involving records</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />updates `error_prone_test_helpers` from 260 to 271<details><summary>release notes</summary><p><em>sourced from <a href"" releases</a></em></p><blockquote><h2>error prone 271</h2><p>everything in <a href"" prone 270</a> plus an <a href"" fix for jdk 17</a></p><h2>error prone 270</h2><p>changes</p><ul><li>initial support for running on jdk 17 ea builds supports for java 17 languages features is incomplete <a href"" reports</a> for issues with java 17 are welcome</li><li><a href"" is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href"" checks:</p><ul><li><a href"" href"" href"" href"" href"" issues: <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" href"" release error prone 271</li><li><a href"" improve jdk 17 support</li><li><a href"" enable <code>returnvalueignored</code>-checking of <code>collection</code> <code>iterable</code> and `iterat</li><li><a href"" fix a jdk 17 incompatibility</li><li><a href"" add tests for method invocation bug with the <code>inliner</code></li><li><a href"" fix a jdk 16-only test</li><li><a href"" internal refactoring</li><li><a href"" update error prone ci to use jdk 16 as latest and add 17-ea</li><li><a href"" fix a jdk 16 incompatibility</li><li><a href"" fix some crashes involving records</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />dependabot will resolve any conflicts with this pr as long as you dont alter it yourself you can also trigger a rebase manually by commenting `@dependabot rebase`[//]: # (dependabot-automerge-start)dependabot will merge this pr once ci passes on it as requested by @timvdlippe[//]: # (dependabot-automerge-end)---<details><summary>dependabot commands and options</summary><br />you can trigger dependabot actions by commenting on this pr:- `@dependabot rebase` will rebase this pr- `@dependabot recreate` will recreate this pr overwriting any edits that have been made to it- `@dependabot merge` will merge this pr after your ci passes on it- `@dependabot squash and merge` will squash and merge this pr after your ci passes on it- `@dependabot cancel merge` will cancel a previously requested merge and block automerging- `@dependabot reopen` will reopen this pr if it is closed- `@dependabot close` will close this pr and stop dependabot recreating it you can achieve the same result by closing it manually- `@dependabot ignore this major version` will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this minor version` will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this dependency` will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)</details>"; ;fix deprecation label of verifyzerointeractions;documentation change only im pretty sure this is the correct method to move to<!-- hey thanks for the contribution this is awesomeas you may have read project members have somehow an opinionated view on what and how should bemockito eg we dont want mockito to be a feature bloatthere may be a thorough review with feedback -> code change loop--><!--which branch : - on mockito 3x make your pull request target `release/3x`- on mockito 2x make your pull request target `release/2x` (2x is in maintenance mode)--><!--if you have a suggestion for this template you can fix it in the github/pull_request_templatemd file-->## checklist -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_;duplicate of #2240 || thanks that makes sense i might open a pr to put that context in the description since right now it is confusing and looks very much like a typo ||;1;0;fix errorprone warnings;
2298;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;bump versions.errorprone from 2.6.0 to 2.7.1;bumps  versions.errorprone  from 2.6.0 to 2.7.1. updates  error_prone_core  from 2.6.0 to 2.7.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_core s releases</a>.</em></p> <blockquote> <h2>error prone 2.7.1</h2> <p>everything in <a href=  >error prone 2.7.0</a>  plus an <a href=  >additional fix for jdk 17</a>.</p> <h2>error prone 2.7.0</h2> <p>changes</p> <ul> <li>initial support for running on jdk 17 ea builds. supports for java 17 languages features is incomplete  <a href=  >bug reports</a> for issues with java 17 are welcome.</li> <li><a href=  ><code>@​inlineme</code></a>  is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href=  > </ul> <p>new checks:</p> <ul> <li><a href=  >equalsnull</a></li> <li><a href=  >missingbraces</a></li> <li><a href=  >nullableprimitivearray</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >testparametersnotinitialized</a></li> </ul> <p>closed issues: <a href=  >#2257</a>  <a href=  >#2260</a>  <a href=  >#2282</a>  <a href=  >#2301</a>  <a href=  >#2322</a>  <a href=  >#2323</a>  <a href=  >#2324</a></p> </blockquote> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>09262b8</code></a> release error prone 2.7.1</li> <li><a href=  ><code>ff07935</code></a> improve jdk 17 support</li> <li><a href=  ><code>65a75c9</code></a> enable <code>returnvalueignored</code>-checking of <code>collection</code>  <code>iterable</code>  and  iterat</li> <li><a href=  ><code>0c6a76d</code></a> fix a jdk 17 incompatibility</li> <li><a href=  ><code>1846d94</code></a> add tests for method invocation bug with the <code>inliner</code>.</li> <li><a href=  ><code>8c6f73c</code></a> fix a jdk 16-only test</li> <li><a href=  ><code>62d1bf7</code></a> internal refactoring.</li> <li><a href=  ><code>5913d86</code></a> update error prone ci to use jdk 16 as latest  and add 17-ea</li> <li><a href=  ><code>f6761ee</code></a> fix a jdk 16 incompatibility</li> <li><a href=  ><code>51b5c4d</code></a> fix some crashes involving records</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />  updates  error_prone_test_helpers  from 2.6.0 to 2.7.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_test_helpers s releases</a>.</em></p> <blockquote> <h2>error prone 2.7.1</h2> <p>everything in <a href=  >error prone 2.7.0</a>  plus an <a href=  >additional fix for jdk 17</a>.</p> <h2>error prone 2.7.0</h2> <p>changes</p> <ul> <li>initial support for running on jdk 17 ea builds. supports for java 17 languages features is incomplete  <a href=  >bug reports</a> for issues with java 17 are welcome.</li> <li><a href=  ><code>@​inlineme</code></a>  is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href=  > </ul> <p>new checks:</p> <ul> <li><a href=  >equalsnull</a></li> <li><a href=  >missingbraces</a></li> <li><a href=  >nullableprimitivearray</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >testparametersnotinitialized</a></li> </ul> <p>closed issues: <a href=  >#2257</a>  <a href=  >#2260</a>  <a href=  >#2282</a>  <a href=  >#2301</a>  <a href=  >#2322</a>  <a href=  >#2323</a>  <a href=  >#2324</a></p> </blockquote> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>09262b8</code></a> release error prone 2.7.1</li> <li><a href=  ><code>ff07935</code></a> improve jdk 17 support</li> <li><a href=  ><code>65a75c9</code></a> enable <code>returnvalueignored</code>-checking of <code>collection</code>  <code>iterable</code>  and  iterat...</li> <li><a href=  ><code>0c6a76d</code></a> fix a jdk 17 incompatibility</li> <li><a href=  ><code>1846d94</code></a> add tests for method invocation bug with the <code>inliner</code>.</li> <li><a href=  ><code>8c6f73c</code></a> fix a jdk 16-only test</li> <li><a href=  ><code>62d1bf7</code></a> internal refactoring.</li> <li><a href=  ><code>5913d86</code></a> update error prone ci to use jdk 16 as latest  and add 17-ea</li> <li><a href=  ><code>f6761ee</code></a> fix a jdk 16 incompatibility</li> <li><a href=  ><code>51b5c4d</code></a> fix some crashes involving records</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />   dependabot will resolve any conflicts with this pr as long as you don t alter it yourself. you can also trigger a rebase manually by commenting  @dependabot rebase .  [//]: # (dependabot-automerge-start) dependabot will merge this pr once ci passes on it  as requested by @timvdlippe.  [//]: # (dependabot-automerge-end)  ---  <details> <summary>dependabot commands and options</summary> <br />  you can trigger dependabot actions by commenting on this pr: -  @dependabot rebase  will rebase this pr -  @dependabot recreate  will recreate this pr  overwriting any edits that have been made to it -  @dependabot merge  will merge this pr after your ci passes on it -  @dependabot squash and merge  will squash and merge this pr after your ci passes on it -  @dependabot cancel merge  will cancel a previously requested merge and block automerging -  @dependabot reopen  will reopen this pr if it is closed -  @dependabot close  will close this pr and stop dependabot recreating it. you can achieve the same result by closing it manually -  @dependabot ignore this major version  will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this minor version  will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this dependency  will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)   </details>;;2324.0;bump versionserrorprone from 260 to 271;"bumps `versionserrorprone` from 260 to 271updates `error_prone_core` from 260 to 271<details><summary>release notes</summary><p><em>sourced from <a href"" releases</a></em></p><blockquote><h2>error prone 271</h2><p>everything in <a href"" prone 270</a> plus an <a href"" fix for jdk 17</a></p><h2>error prone 270</h2><p>changes</p><ul><li>initial support for running on jdk 17 ea builds supports for java 17 languages features is incomplete <a href"" reports</a> for issues with java 17 are welcome</li><li><a href"" is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href"" checks:</p><ul><li><a href"" href"" href"" href"" href"" issues: <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" href"" release error prone 271</li><li><a href"" improve jdk 17 support</li><li><a href"" enable <code>returnvalueignored</code>-checking of <code>collection</code> <code>iterable</code> and `iterat</li><li><a href"" fix a jdk 17 incompatibility</li><li><a href"" add tests for method invocation bug with the <code>inliner</code></li><li><a href"" fix a jdk 16-only test</li><li><a href"" internal refactoring</li><li><a href"" update error prone ci to use jdk 16 as latest and add 17-ea</li><li><a href"" fix a jdk 16 incompatibility</li><li><a href"" fix some crashes involving records</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />updates `error_prone_test_helpers` from 260 to 271<details><summary>release notes</summary><p><em>sourced from <a href"" releases</a></em></p><blockquote><h2>error prone 271</h2><p>everything in <a href"" prone 270</a> plus an <a href"" fix for jdk 17</a></p><h2>error prone 270</h2><p>changes</p><ul><li>initial support for running on jdk 17 ea builds supports for java 17 languages features is incomplete <a href"" reports</a> for issues with java 17 are welcome</li><li><a href"" is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href"" checks:</p><ul><li><a href"" href"" href"" href"" href"" issues: <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" <a href"" href"" release error prone 271</li><li><a href"" improve jdk 17 support</li><li><a href"" enable <code>returnvalueignored</code>-checking of <code>collection</code> <code>iterable</code> and `iterat</li><li><a href"" fix a jdk 17 incompatibility</li><li><a href"" add tests for method invocation bug with the <code>inliner</code></li><li><a href"" fix a jdk 16-only test</li><li><a href"" internal refactoring</li><li><a href"" update error prone ci to use jdk 16 as latest and add 17-ea</li><li><a href"" fix a jdk 16 incompatibility</li><li><a href"" fix some crashes involving records</li><li>additional commits viewable in <a href"" view</a></li></ul></details><br />dependabot will resolve any conflicts with this pr as long as you dont alter it yourself you can also trigger a rebase manually by commenting `@dependabot rebase`[//]: # (dependabot-automerge-start)dependabot will merge this pr once ci passes on it as requested by @timvdlippe[//]: # (dependabot-automerge-end)---<details><summary>dependabot commands and options</summary><br />you can trigger dependabot actions by commenting on this pr:- `@dependabot rebase` will rebase this pr- `@dependabot recreate` will recreate this pr overwriting any edits that have been made to it- `@dependabot merge` will merge this pr after your ci passes on it- `@dependabot squash and merge` will squash and merge this pr after your ci passes on it- `@dependabot cancel merge` will cancel a previously requested merge and block automerging- `@dependabot reopen` will reopen this pr if it is closed- `@dependabot close` will close this pr and stop dependabot recreating it you can achieve the same result by closing it manually- `@dependabot ignore this major version` will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this minor version` will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself)- `@dependabot ignore this dependency` will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)</details>"; ;release/3x;<!-- heythanks for the contribution this is awesomeas you may have read project members have somehow an opinionated view on what and how should bemockito eg we dont want mockito to be a feature bloatthere may be a thorough review with feedback -> code change loop--><!--if you have a suggestion for this template you can fix it in the github/pull_request_templatemd file-->## checklist -  read the [contributing guide]( -  pr should be motivated ie what does it fix why and if relevant how -  if possible / relevant include an example in the description that could help all readers       including project members to get a better picture of the change -  avoid other runtime dependencies -  meaningful commit history  intention is important please rebase your commit history so that each       commit is meaningful and help the people that will explore a change in 2 years -  the pull request follows coding style -  mention `<issue number>` in the description _if relevant_ -  at least one commit should mention `fixes #<issue number>` _if relevant_;;1;0;fix errorprone warnings;
2298;0;0;0;0;0;0;1;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;bump versions.errorprone from 2.6.0 to 2.7.1;bumps  versions.errorprone  from 2.6.0 to 2.7.1. updates  error_prone_core  from 2.6.0 to 2.7.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_core s releases</a>.</em></p> <blockquote> <h2>error prone 2.7.1</h2> <p>everything in <a href=  >error prone 2.7.0</a>  plus an <a href=  >additional fix for jdk 17</a>.</p> <h2>error prone 2.7.0</h2> <p>changes</p> <ul> <li>initial support for running on jdk 17 ea builds. supports for java 17 languages features is incomplete  <a href=  >bug reports</a> for issues with java 17 are welcome.</li> <li><a href=  ><code>@​inlineme</code></a>  is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href=  > </ul> <p>new checks:</p> <ul> <li><a href=  >equalsnull</a></li> <li><a href=  >missingbraces</a></li> <li><a href=  >nullableprimitivearray</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >testparametersnotinitialized</a></li> </ul> <p>closed issues: <a href=  >#2257</a>  <a href=  >#2260</a>  <a href=  >#2282</a>  <a href=  >#2301</a>  <a href=  >#2322</a>  <a href=  >#2323</a>  <a href=  >#2324</a></p> </blockquote> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>09262b8</code></a> release error prone 2.7.1</li> <li><a href=  ><code>ff07935</code></a> improve jdk 17 support</li> <li><a href=  ><code>65a75c9</code></a> enable <code>returnvalueignored</code>-checking of <code>collection</code>  <code>iterable</code>  and  iterat</li> <li><a href=  ><code>0c6a76d</code></a> fix a jdk 17 incompatibility</li> <li><a href=  ><code>1846d94</code></a> add tests for method invocation bug with the <code>inliner</code>.</li> <li><a href=  ><code>8c6f73c</code></a> fix a jdk 16-only test</li> <li><a href=  ><code>62d1bf7</code></a> internal refactoring.</li> <li><a href=  ><code>5913d86</code></a> update error prone ci to use jdk 16 as latest  and add 17-ea</li> <li><a href=  ><code>f6761ee</code></a> fix a jdk 16 incompatibility</li> <li><a href=  ><code>51b5c4d</code></a> fix some crashes involving records</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />  updates  error_prone_test_helpers  from 2.6.0 to 2.7.1 <details> <summary>release notes</summary> <p><em>sourced from <a href=  >error_prone_test_helpers s releases</a>.</em></p> <blockquote> <h2>error prone 2.7.1</h2> <p>everything in <a href=  >error prone 2.7.0</a>  plus an <a href=  >additional fix for jdk 17</a>.</p> <h2>error prone 2.7.0</h2> <p>changes</p> <ul> <li>initial support for running on jdk 17 ea builds. supports for java 17 languages features is incomplete  <a href=  >bug reports</a> for issues with java 17 are welcome.</li> <li><a href=  ><code>@​inlineme</code></a>  is a deprecation mechanism that allows automated tools to cleanup existing callers: <a href=  > </ul> <p>new checks:</p> <ul> <li><a href=  >equalsnull</a></li> <li><a href=  >missingbraces</a></li> <li><a href=  >nullableprimitivearray</a></li> <li><a href=  >optionalmapunusedvalue</a></li> <li><a href=  >testparametersnotinitialized</a></li> </ul> <p>closed issues: <a href=  >#2257</a>  <a href=  >#2260</a>  <a href=  >#2282</a>  <a href=  >#2301</a>  <a href=  >#2322</a>  <a href=  >#2323</a>  <a href=  >#2324</a></p> </blockquote> </details> <details> <summary>commits</summary> <ul> <li><a href=  ><code>09262b8</code></a> release error prone 2.7.1</li> <li><a href=  ><code>ff07935</code></a> improve jdk 17 support</li> <li><a href=  ><code>65a75c9</code></a> enable <code>returnvalueignored</code>-checking of <code>collection</code>  <code>iterable</code>  and  iterat...</li> <li><a href=  ><code>0c6a76d</code></a> fix a jdk 17 incompatibility</li> <li><a href=  ><code>1846d94</code></a> add tests for method invocation bug with the <code>inliner</code>.</li> <li><a href=  ><code>8c6f73c</code></a> fix a jdk 16-only test</li> <li><a href=  ><code>62d1bf7</code></a> internal refactoring.</li> <li><a href=  ><code>5913d86</code></a> update error prone ci to use jdk 16 as latest  and add 17-ea</li> <li><a href=  ><code>f6761ee</code></a> fix a jdk 16 incompatibility</li> <li><a href=  ><code>51b5c4d</code></a> fix some crashes involving records</li> <li>additional commits viewable in <a href=  >compare view</a></li> </ul> </details> <br />   dependabot will resolve any conflicts with this pr as long as you don t alter it yourself. you can also trigger a rebase manually by commenting  @dependabot rebase .  [//]: # (dependabot-automerge-start) dependabot will merge this pr once ci passes on it  as requested by @timvdlippe.  [//]: # (dependabot-automerge-end)  ---  <details> <summary>dependabot commands and options</summary> <br />  you can trigger dependabot actions by commenting on this pr: -  @dependabot rebase  will rebase this pr -  @dependabot recreate  will recreate this pr  overwriting any edits that have been made to it -  @dependabot merge  will merge this pr after your ci passes on it -  @dependabot squash and merge  will squash and merge this pr after your ci passes on it -  @dependabot cancel merge  will cancel a previously requested merge and block automerging -  @dependabot reopen  will reopen this pr if it is closed -  @dependabot close  will close this pr and stop dependabot recreating it. you can achieve the same result by closing it manually -  @dependabot ignore this major version  will close this pr and stop dependabot creating any more for this major version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this minor version  will close this pr and stop dependabot creating any more for this minor version (unless you reopen the pr or upgrade to it yourself) -  @dependabot ignore this dependency  will close this pr and stop dependabot creating any more for this dependency (unless you reopen the pr or upgrade to it yourself)   </details>;;0;modify cli client to use jvm socks proxy flags - solves #2289;;closing and re-opening to link to issue ||;;;;0;1;;
2306;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;adapt csl tests to crlf and lf;the discussion at  revealed that  \r  does not appear as line separator alone. thus  our tests should be adapted accordingly.;;0;allow coordinator only plan fragment to remain for the source;this occurs when the localqueryrunner executes a query with a tablecommit;;;;;0;1;;
2306;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;adapt csl tests to crlf and lf;the discussion at  revealed that  \r  does not appear as line separator alone. thus  our tests should be adapted accordingly.;;230.0;use the parent classloader if the context classloader is a child of it;this should only affect cases that previously would have thrown anexception2303;there are some formatting issues that should be automatically  if you run `/gradlew spotlessapply` locally || formatting issues fixed ||  merging 2306 ;null pointer when invoking whiteboxinvokemethod() with null one of the params null;"getting below exceptions when trying to invoke whiteboxinvokemethod(erxprovidermanager ""setcommand"" provider nullretait mail)version used 162failed: testsetenrollmentcommandwithunenrollmentwithnulljavalangnullpointerexception    at javalangclassisassignablefrom(native method)    at orgpowermockreflectinternalwhiteboximplcheckifparametertypesaresame(whiteboximpljava:2257)    at orgpowermockreflectinternalwhiteboximplgetmethods(whiteboximpljava:1800)    at orgpowermockreflectinternalwhiteboximplgetbestmethodcandidate(whiteboximpljava:955)    at orgpowermockreflectinternalwhiteboximplfindmethodorthrowexception(whiteboximpljava:832)    at orgpowermockreflectinternalwhiteboximpldoinvokemethod(whiteboximpljava:770)    at orgpowermockreflectinternalwhiteboximplinvokemethod(whiteboximpljava:638)    at orgpowermockreflectwhiteboxinvokemethod(whiteboxjava:401)";its powermock api )also the code youre mentioning use an **internal** api which is not thought for use outside the library ||;1;0;address review comments;
2312;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;undo parent for multipleparentsclassloader;66998ea7f81c6adf49983cea081586e19760b7a0 inadvertently undid a change from 9bc9be6d0fb1809346dcd02b22ced477816e0fc1  which breaks behavior under some classloaders that special-case mockito classes. use of an explicit parent with  multipleparentsclassloader  appears to be discouraged in the documentation also.;;0;synchronize on-disk data for raptor;;;;;;0;1;;
2312;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;undo parent for multipleparentsclassloader;66998ea7f81c6adf49983cea081586e19760b7a0 inadvertently undid a change from 9bc9be6d0fb1809346dcd02b22ced477816e0fc1  which breaks behavior under some classloaders that special-case mockito classes. use of an explicit parent with  multipleparentsclassloader  appears to be discouraged in the documentation also.;;2303.0;undo parent for multipleparentsclassloader;66998ea7f81c6adf49983cea081586e19760b7a0 inadvertently undid a change from 9bc9be6d0fb1809346dcd02b22ced477816e0fc1 which breaks behavior under some classloaders that special-case mockito classes use of an explicit parent with `multipleparentsclassloader` appears to be discouraged in the documentation alsofollowup for #2303; merging 2312 ;"""the type is not public and its mock class is loaded by a different class loader"" with a context classloader that delegates";repro case:```javapackage comgoogleclmmockitobugimport static orgmockitomockitomockimport orgjunittestimport orgjunitrunnerrunwithimport orgjunitrunnersjunit4/** * my goal is to create a context classloader that is identical in every way to the existing one * except that it has a different object identity and possibly some extra fields however even a * basic classloader that always delegates causes problems for mockito */@runwith(junit4class)public final class classloadertest {  @test  public void mockpackageprivateinterface() {    classloader old  threadcurrentthread()getcontextclassloader()    threadcurrentthread()setcontextclassloader(new classloader(old) {})    // fails    object unused  mock(packageprivateclass)  }  @test  public void mockpublicinterface() {    classloader old  threadcurrentthread()getcontextclassloader()    threadcurrentthread()setcontextclassloader(new classloader(old) {})    // succeeds    object unused  mock(publicclass)  }  interface packageprivate {}  public interface public {}}```error:```orgmockitoexceptionsbasemockitoexception: mockito cannot mock this class: interface comgoogleclmmockitobugclassloadertest$packageprivatemockito can only mock non-private & non-final classesif youre not sure why youre getting this error please report to the mailing listjava               : 11jvm vendor name    : google incjvm vendor version : 11010+9-google-release-371350251jvm name           : openjdk 64-bit server vmjvm version        : 11010+9-google-release-371350251jvm info           : mixed mode sharingos name            : linuxos version         : 4150-smp-9122300underlying exception : orgmockitoexceptionsbasemockitoexception: cannot create mock for interface comgoogleclmmockitobugclassloadertest$packageprivatethe type is not public and its mock class is loaded by a different class loaderthis can have multiple reasons: - you are mocking a class with additional interfaces of another class loader - mockito is loaded by a different class loader than the mocked type (eg with osgi) - the threads context class loader is different than the mocks class loader	at comgoogleclmmockitobugclassloadertestmockpackageprivateinterface(classloadertestjava:21)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javabase/javalangreflectmethodinvoke(methodjava:566)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:57)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:59)	at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)	at orgjunitrunnersblockjunit4classrunner$1evaluate(blockjunit4classrunnerjava:81)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:327)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:84)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:292)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:73)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:290)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:60)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:270)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:370)	at comgoogletestingjunitrunnerinternaljunit4cancellablerequestfactory$cancellablerunnerrun(cancellablerequestfactoryjava:108)	at orgjunitrunnerjunitcorerun(junitcorejava:137)	at orgjunitrunnerjunitcorerun(junitcorejava:115)	at comgoogletestingjunitrunnerjunit4junit4runnerrun(junit4runnerjava:104)	at comgoogletestingjunitrunnerrunnershell$2run(runnershelljava:34)	at comgoogletestingjunitrunnergoogletestrunnerruntestsinsuite(googletestrunnerjava:200)	at comgoogletestingjunitrunnergoogletestrunnerruntestsinsuite(googletestrunnerjava:184)	at comgoogletestingjunitrunnergoogletestrunnermain(googletestrunnerjava:137)caused by: orgmockitoexceptionsbasemockitoexception: cannot create mock for interface comgoogleclmmockitobugclassloadertest$packageprivatethe type is not public and its mock class is loaded by a different class loaderthis can have multiple reasons: - you are mocking a class with additional interfaces of another class loader - mockito is loaded by a different class loader than the mocked type (eg with osgi) - the threads context class loader is different than the mocks class loader	at netbytebuddytypecachefindorinsert(typecachejava:153)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:366)	at netbytebuddytypecachefindorinsert(typecachejava:175)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:377)	 27 more```if mockito actually tried to use the classloader i think it would work since we dont see an interesting exception deep in the stack my guess is that mockito is doing some extra validation to avoid generating bytecode it thinks would fail;rafael i took a look at this code and it wasnt completely clear to my why we are failing here the reason that is probably happening is that mockito first adds the mocked type ( in this case `packageprivate` before adding the current classloader:  it looks up the classloader for the mocked type which is the old classloader then it looks up the current classloader (which you changed) and then determines that they dont match thus `localmock  false`this code landed as part of supporting java 9+ modules:  it wouldnt surprise me if there is an edge case we are missingsince the new classloader delegates to the former i would have expected the classes to match and thus pass the checks but they dont presumably because of the classloader equality check can we be lenient here and allow for child classloaders to be valid as well? || the reason we fail is that a package-private type is not visible outside of its own class loader even if we defined the subclass in the same nominal package if it was loaded by a different class loader it could not see its superclass to avoid this visibility issue we fail before even attempting to create the mockwe could consider to drop the context class loader if a mocked class is package-private i am not sure why we need the context class loader to begin with but i assume its related to serialization what tends to be an edge case || i can think of a few options:1 ignore the context classloader if the type is package-private it could have failed anyway so if it succeeds might as well reap the benefit2 ignore the package-private restriction for classloaders that are not participating in the java module system by checking issealed on the classs package3 check to see if the context classloader is a child of the originating classloader although if a classloader is declaring a parent but not following the delegation patter this might cause a false negative or positive4 just load the stuff as you would and check each relevant class you load and error if the defining classloader doesnt match || ill mess around a bit more and report back if i figure out what the issue is || ok i have a the minimal fix (as in it will only affect cases that would have broken before):if the mocked type is a non-interface or non-public or any of the extra interfaces are non-public dont include the context classloader in multipleparentsclassloader iff the context classloader is a child of the classloader wed use if it wasnt includedthis fixes my issue and in general likely fixes cases where a context classloader is set that follows the parent-first delegation pattern i thought about simply removing the context loader entirely but test authors who hit this can set and unset it in a try-finally block around their mock calls if necessary and since theres no comments about why its included id be wary of breaking somebody depending on the existing behaviori am going to run this fix through googles internal suite of tests to see if it breaks anything  || 1 the problem is that it might fail delayed upon deserialization this might be non-trivial to understand and we should document this restriction somewhere 2 that wont work sealing only affects jars on the same class loader that are defining the same package this wont work with modules anymore anyways and is taken care of package-private classes are however never visible on other class loaders therefore we must retain the class loader3 is already done to some extend4 this is implicit by the multiple parent loaderi think the right approach is to exclude the context loader for package-private classes by default since it will never work and to fail if serialization is enabled in addition  || > i think the right approach is to exclude the context loader for package-private classes by default since it will never work and to fail if serialization is enabled in additionits not just package-private classes - mocking a public non-final-non-interface class also poses problems since that will break stubbing/verification of package-private methods (#796)my proposed fix:```javaprivate static boolean needssamepackageclassloader(mockfeatures<?> features) {  if (!modifierispublic(featuresmockedtypegetmodifiers())                              || !featuresmockedtypeisinterface()) {    // the mocked type is package private or is not an interface and thus may contain package    // private methods    return true  }  for (class<?> iface : featuresinterfaces) {    if (!modifierispublic(ifacegetmodifiers())) {      return true    }  }  return false}multipleparentclassloaderbuilder loaderbuilder  new multipleparentclassloaderbuilder()                  appendmostspecific(getalltypes(featuresmockedtype))                  appendmostspecific(featuresinterfaces)                  appendmostspecific(mockaccessclass)classloader contextloader  currentthread()getcontextclassloader()boolean shouldincludecontextloader  trueif (needssamepackageclassloader(features)) {    // for the generated class to access package-private methods it must be defined by the    // same classloader as its type all the other added classloaders are required to load    // the type if the context classloader is a child of the mocked types defining    // classloader it will break a mock that would have worked check if the context class    // loader is a child of the classloader wed otherwise use and possibly skip it    classloader candidateloader  loaderbuilderbuild()    for (classloader parent  contextloader parent ! null parent  parentgetparent()) {      if (parent  candidateloader) {        shouldincludecontextloader  false        break      }    }}if (shouldincludecontextloader) {  loaderbuilder  loaderbuilderappendmostspecific(contextloader)}classloader classloader  loaderbuilderbuild()```the focus was on only changing behavior for cases that failed before since we verify that the classloader we define in is a parent of the context classloader we shouldnt see any problems with serialization right? or at least no new problems as the existing `multipleparentsclassloader` relies on `getparent()` to infer the delegation order || @charlesmunger do you mind opening a pr that includes your proposed fix and adds a regression test for your use case? if all tests pass i am inclined to merge as-is if we end up breaking anybody else we should add regression tests for their use cases and modify the implementation accordingly ||;1;0;refactor test to branch on orgmockitousage package;
2318;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;check package-privacy of method params;this patch handles methods where an interface uses a package-private type as a param or return value - without it  the generated mock class will produce abstractmethoderror  since its methods do not actually override the methods of the interfaces.;;0;how to execute query in plan optimizing phase;im trying to write a query plan optimizer but i need to query the row count of a tablescannode how can i execute a query with the existing (plannode plan session session map<symbol type> types symbolallocator symbolallocator plannodeidallocator idallocator) param?;;;;;0;1;;
2318;0;0;0;0;0;0;1;0;0;0;1;0;1;0;0;0;0;0;0;0;1;0;0;1;check package-privacy of method params;this patch handles methods where an interface uses a package-private type as a param or return value - without it  the generated mock class will produce abstractmethoderror  since its methods do not actually override the methods of the interfaces.;;2303.0;check package-privacy of method params;this patch handles methods where an interface uses a package-private type as a param or return value - without it the generated mock class will produce abstractmethoderror since its methods do not actually override the methods of the interfacesfollowup on #2303;i have run this through googles internal tests and it doesnt break anything ||;"""the type is not public and its mock class is loaded by a different class loader"" with a context classloader that delegates";repro case:```javapackage comgoogleclmmockitobugimport static orgmockitomockitomockimport orgjunittestimport orgjunitrunnerrunwithimport orgjunitrunnersjunit4/** * my goal is to create a context classloader that is identical in every way to the existing one * except that it has a different object identity and possibly some extra fields however even a * basic classloader that always delegates causes problems for mockito */@runwith(junit4class)public final class classloadertest {  @test  public void mockpackageprivateinterface() {    classloader old  threadcurrentthread()getcontextclassloader()    threadcurrentthread()setcontextclassloader(new classloader(old) {})    // fails    object unused  mock(packageprivateclass)  }  @test  public void mockpublicinterface() {    classloader old  threadcurrentthread()getcontextclassloader()    threadcurrentthread()setcontextclassloader(new classloader(old) {})    // succeeds    object unused  mock(publicclass)  }  interface packageprivate {}  public interface public {}}```error:```orgmockitoexceptionsbasemockitoexception: mockito cannot mock this class: interface comgoogleclmmockitobugclassloadertest$packageprivatemockito can only mock non-private & non-final classesif youre not sure why youre getting this error please report to the mailing listjava               : 11jvm vendor name    : google incjvm vendor version : 11010+9-google-release-371350251jvm name           : openjdk 64-bit server vmjvm version        : 11010+9-google-release-371350251jvm info           : mixed mode sharingos name            : linuxos version         : 4150-smp-9122300underlying exception : orgmockitoexceptionsbasemockitoexception: cannot create mock for interface comgoogleclmmockitobugclassloadertest$packageprivatethe type is not public and its mock class is loaded by a different class loaderthis can have multiple reasons: - you are mocking a class with additional interfaces of another class loader - mockito is loaded by a different class loader than the mocked type (eg with osgi) - the threads context class loader is different than the mocks class loader	at comgoogleclmmockitobugclassloadertestmockpackageprivateinterface(classloadertestjava:21)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke0(native method)	at javabase/jdkinternalreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at javabase/jdkinternalreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javabase/javalangreflectmethodinvoke(methodjava:566)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:57)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:59)	at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)	at orgjunitrunnersblockjunit4classrunner$1evaluate(blockjunit4classrunnerjava:81)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:327)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:84)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:292)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:73)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:290)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:60)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:270)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:370)	at comgoogletestingjunitrunnerinternaljunit4cancellablerequestfactory$cancellablerunnerrun(cancellablerequestfactoryjava:108)	at orgjunitrunnerjunitcorerun(junitcorejava:137)	at orgjunitrunnerjunitcorerun(junitcorejava:115)	at comgoogletestingjunitrunnerjunit4junit4runnerrun(junit4runnerjava:104)	at comgoogletestingjunitrunnerrunnershell$2run(runnershelljava:34)	at comgoogletestingjunitrunnergoogletestrunnerruntestsinsuite(googletestrunnerjava:200)	at comgoogletestingjunitrunnergoogletestrunnerruntestsinsuite(googletestrunnerjava:184)	at comgoogletestingjunitrunnergoogletestrunnermain(googletestrunnerjava:137)caused by: orgmockitoexceptionsbasemockitoexception: cannot create mock for interface comgoogleclmmockitobugclassloadertest$packageprivatethe type is not public and its mock class is loaded by a different class loaderthis can have multiple reasons: - you are mocking a class with additional interfaces of another class loader - mockito is loaded by a different class loader than the mocked type (eg with osgi) - the threads context class loader is different than the mocks class loader	at netbytebuddytypecachefindorinsert(typecachejava:153)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:366)	at netbytebuddytypecachefindorinsert(typecachejava:175)	at netbytebuddytypecache$withinlineexpunctionfindorinsert(typecachejava:377)	 27 more```if mockito actually tried to use the classloader i think it would work since we dont see an interesting exception deep in the stack my guess is that mockito is doing some extra validation to avoid generating bytecode it thinks would fail;rafael i took a look at this code and it wasnt completely clear to my why we are failing here the reason that is probably happening is that mockito first adds the mocked type ( in this case `packageprivate` before adding the current classloader:  it looks up the classloader for the mocked type which is the old classloader then it looks up the current classloader (which you changed) and then determines that they dont match thus `localmock  false`this code landed as part of supporting java 9+ modules:  it wouldnt surprise me if there is an edge case we are missingsince the new classloader delegates to the former i would have expected the classes to match and thus pass the checks but they dont presumably because of the classloader equality check can we be lenient here and allow for child classloaders to be valid as well? || the reason we fail is that a package-private type is not visible outside of its own class loader even if we defined the subclass in the same nominal package if it was loaded by a different class loader it could not see its superclass to avoid this visibility issue we fail before even attempting to create the mockwe could consider to drop the context class loader if a mocked class is package-private i am not sure why we need the context class loader to begin with but i assume its related to serialization what tends to be an edge case || i can think of a few options:1 ignore the context classloader if the type is package-private it could have failed anyway so if it succeeds might as well reap the benefit2 ignore the package-private restriction for classloaders that are not participating in the java module system by checking issealed on the classs package3 check to see if the context classloader is a child of the originating classloader although if a classloader is declaring a parent but not following the delegation patter this might cause a false negative or positive4 just load the stuff as you would and check each relevant class you load and error if the defining classloader doesnt match || ill mess around a bit more and report back if i figure out what the issue is || ok i have a the minimal fix (as in it will only affect cases that would have broken before):if the mocked type is a non-interface or non-public or any of the extra interfaces are non-public dont include the context classloader in multipleparentsclassloader iff the context classloader is a child of the classloader wed use if it wasnt includedthis fixes my issue and in general likely fixes cases where a context classloader is set that follows the parent-first delegation pattern i thought about simply removing the context loader entirely but test authors who hit this can set and unset it in a try-finally block around their mock calls if necessary and since theres no comments about why its included id be wary of breaking somebody depending on the existing behaviori am going to run this fix through googles internal suite of tests to see if it breaks anything  || 1 the problem is that it might fail delayed upon deserialization this might be non-trivial to understand and we should document this restriction somewhere 2 that wont work sealing only affects jars on the same class loader that are defining the same package this wont work with modules anymore anyways and is taken care of package-private classes are however never visible on other class loaders therefore we must retain the class loader3 is already done to some extend4 this is implicit by the multiple parent loaderi think the right approach is to exclude the context loader for package-private classes by default since it will never work and to fail if serialization is enabled in addition  || > i think the right approach is to exclude the context loader for package-private classes by default since it will never work and to fail if serialization is enabled in additionits not just package-private classes - mocking a public non-final-non-interface class also poses problems since that will break stubbing/verification of package-private methods (#796)my proposed fix:```javaprivate static boolean needssamepackageclassloader(mockfeatures<?> features) {  if (!modifierispublic(featuresmockedtypegetmodifiers())                              || !featuresmockedtypeisinterface()) {    // the mocked type is package private or is not an interface and thus may contain package    // private methods    return true  }  for (class<?> iface : featuresinterfaces) {    if (!modifierispublic(ifacegetmodifiers())) {      return true    }  }  return false}multipleparentclassloaderbuilder loaderbuilder  new multipleparentclassloaderbuilder()                  appendmostspecific(getalltypes(featuresmockedtype))                  appendmostspecific(featuresinterfaces)                  appendmostspecific(mockaccessclass)classloader contextloader  currentthread()getcontextclassloader()boolean shouldincludecontextloader  trueif (needssamepackageclassloader(features)) {    // for the generated class to access package-private methods it must be defined by the    // same classloader as its type all the other added classloaders are required to load    // the type if the context classloader is a child of the mocked types defining    // classloader it will break a mock that would have worked check if the context class    // loader is a child of the classloader wed otherwise use and possibly skip it    classloader candidateloader  loaderbuilderbuild()    for (classloader parent  contextloader parent ! null parent  parentgetparent()) {      if (parent  candidateloader) {        shouldincludecontextloader  false        break      }    }}if (shouldincludecontextloader) {  loaderbuilder  loaderbuilderappendmostspecific(contextloader)}classloader classloader  loaderbuilderbuild()```the focus was on only changing behavior for cases that failed before since we verify that the classloader we define in is a parent of the context classloader we shouldnt see any problems with serialization right? or at least no new problems as the existing `multipleparentsclassloader` relies on `getparent()` to infer the delegation order || @charlesmunger do you mind opening a pr that includes your proposed fix and adds a regression test for your use case? if all tests pass i am inclined to merge as-is if we end up breaking anybody else we should add regression tests for their use cases and modify the implementation accordingly ||;1;0;rename helper method;
